// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc 30.2
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `api/apps/v1/generated.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.ControllerRevision)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ControllerRevision {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.ControllerRevision.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.ControllerRevision.data)
    pub data: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::runtime::RawExtension>,
    // @@protoc_insertion_point(field:api.apps.v1.ControllerRevision.revision)
    pub revision: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.ControllerRevision.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ControllerRevision {
    fn default() -> &'a ControllerRevision {
        <ControllerRevision as ::protobuf::Message>::default_instance()
    }
}

impl ControllerRevision {
    pub fn new() -> ControllerRevision {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .apimachinery.pkg.runtime.RawExtension data = 2;

    pub fn data(&self) -> &crate::v1_33::apimachinery::pkg::runtime::RawExtension {
        self.data.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::runtime::RawExtension as ::protobuf::Message>::default_instance())
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: crate::v1_33::apimachinery::pkg::runtime::RawExtension) {
        self.data = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut crate::v1_33::apimachinery::pkg::runtime::RawExtension {
        self.data.mut_or_insert_default()
    }

    // Take field
    pub fn take_data(&mut self) -> crate::v1_33::apimachinery::pkg::runtime::RawExtension {
        self.data.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::runtime::RawExtension::new())
    }

    // optional int64 revision = 3;

    pub fn revision(&self) -> i64 {
        self.revision.unwrap_or(0)
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: i64) {
        self.revision = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ControllerRevision| { &m.metadata },
            |m: &mut ControllerRevision| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::runtime::RawExtension>(
            "data",
            |m: &ControllerRevision| { &m.data },
            |m: &mut ControllerRevision| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revision",
            |m: &ControllerRevision| { &m.revision },
            |m: &mut ControllerRevision| { &mut m.revision },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ControllerRevision>(
            "ControllerRevision",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ControllerRevision {
    const NAME: &'static str = "ControllerRevision";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                24 => {
                    self.revision = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.revision {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.revision {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ControllerRevision {
        ControllerRevision::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.data.clear();
        self.revision = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ControllerRevision {
        static instance: ControllerRevision = ControllerRevision {
            metadata: ::protobuf::MessageField::none(),
            data: ::protobuf::MessageField::none(),
            revision: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ControllerRevision {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ControllerRevision").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ControllerRevision {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControllerRevision {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.ControllerRevisionList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ControllerRevisionList {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.ControllerRevisionList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.ControllerRevisionList.items)
    pub items: ::std::vec::Vec<ControllerRevision>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.ControllerRevisionList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ControllerRevisionList {
    fn default() -> &'a ControllerRevisionList {
        <ControllerRevisionList as ::protobuf::Message>::default_instance()
    }
}

impl ControllerRevisionList {
    pub fn new() -> ControllerRevisionList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.apps.v1.ControllerRevision items = 2;

    pub fn items(&self) -> &[ControllerRevision] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ControllerRevision>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ControllerRevision> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ControllerRevision> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ControllerRevisionList| { &m.metadata },
            |m: &mut ControllerRevisionList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ControllerRevisionList| { &m.items },
            |m: &mut ControllerRevisionList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ControllerRevisionList>(
            "ControllerRevisionList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ControllerRevisionList {
    const NAME: &'static str = "ControllerRevisionList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ControllerRevisionList {
        ControllerRevisionList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ControllerRevisionList {
        static instance: ControllerRevisionList = ControllerRevisionList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ControllerRevisionList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ControllerRevisionList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ControllerRevisionList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControllerRevisionList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.DaemonSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DaemonSet {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSet.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSet.spec)
    pub spec: ::protobuf::MessageField<DaemonSetSpec>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSet.status)
    pub status: ::protobuf::MessageField<DaemonSetStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.DaemonSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DaemonSet {
    fn default() -> &'a DaemonSet {
        <DaemonSet as ::protobuf::Message>::default_instance()
    }
}

impl DaemonSet {
    pub fn new() -> DaemonSet {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.apps.v1.DaemonSetSpec spec = 2;

    pub fn spec(&self) -> &DaemonSetSpec {
        self.spec.as_ref().unwrap_or_else(|| <DaemonSetSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: DaemonSetSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut DaemonSetSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> DaemonSetSpec {
        self.spec.take().unwrap_or_else(|| DaemonSetSpec::new())
    }

    // optional .api.apps.v1.DaemonSetStatus status = 3;

    pub fn status(&self) -> &DaemonSetStatus {
        self.status.as_ref().unwrap_or_else(|| <DaemonSetStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: DaemonSetStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut DaemonSetStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> DaemonSetStatus {
        self.status.take().unwrap_or_else(|| DaemonSetStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &DaemonSet| { &m.metadata },
            |m: &mut DaemonSet| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DaemonSetSpec>(
            "spec",
            |m: &DaemonSet| { &m.spec },
            |m: &mut DaemonSet| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DaemonSetStatus>(
            "status",
            |m: &DaemonSet| { &m.status },
            |m: &mut DaemonSet| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DaemonSet>(
            "DaemonSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DaemonSet {
    const NAME: &'static str = "DaemonSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DaemonSet {
        DaemonSet::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DaemonSet {
        static instance: DaemonSet = DaemonSet {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DaemonSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DaemonSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DaemonSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaemonSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.DaemonSetCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DaemonSetCondition {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSetCondition.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSetCondition.status)
    pub status: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSetCondition.lastTransitionTime)
    pub lastTransitionTime: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSetCondition.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSetCondition.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.DaemonSetCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DaemonSetCondition {
    fn default() -> &'a DaemonSetCondition {
        <DaemonSetCondition as ::protobuf::Message>::default_instance()
    }
}

impl DaemonSetCondition {
    pub fn new() -> DaemonSetCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

    pub fn lastTransitionTime(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastTransitionTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional string reason = 4;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 5;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &DaemonSetCondition| { &m.type_ },
            |m: &mut DaemonSetCondition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &DaemonSetCondition| { &m.status },
            |m: &mut DaemonSetCondition| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::Time>(
            "lastTransitionTime",
            |m: &DaemonSetCondition| { &m.lastTransitionTime },
            |m: &mut DaemonSetCondition| { &mut m.lastTransitionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &DaemonSetCondition| { &m.reason },
            |m: &mut DaemonSetCondition| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &DaemonSetCondition| { &m.message },
            |m: &mut DaemonSetCondition| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DaemonSetCondition>(
            "DaemonSetCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DaemonSetCondition {
    const NAME: &'static str = "DaemonSetCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTransitionTime)?;
                },
                34 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DaemonSetCondition {
        DaemonSetCondition::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.lastTransitionTime.clear();
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DaemonSetCondition {
        static instance: DaemonSetCondition = DaemonSetCondition {
            type_: ::std::option::Option::None,
            status: ::std::option::Option::None,
            lastTransitionTime: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DaemonSetCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DaemonSetCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DaemonSetCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaemonSetCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.DaemonSetList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DaemonSetList {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSetList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSetList.items)
    pub items: ::std::vec::Vec<DaemonSet>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.DaemonSetList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DaemonSetList {
    fn default() -> &'a DaemonSetList {
        <DaemonSetList as ::protobuf::Message>::default_instance()
    }
}

impl DaemonSetList {
    pub fn new() -> DaemonSetList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.apps.v1.DaemonSet items = 2;

    pub fn items(&self) -> &[DaemonSet] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<DaemonSet>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<DaemonSet> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<DaemonSet> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &DaemonSetList| { &m.metadata },
            |m: &mut DaemonSetList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &DaemonSetList| { &m.items },
            |m: &mut DaemonSetList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DaemonSetList>(
            "DaemonSetList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DaemonSetList {
    const NAME: &'static str = "DaemonSetList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DaemonSetList {
        DaemonSetList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DaemonSetList {
        static instance: DaemonSetList = DaemonSetList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DaemonSetList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DaemonSetList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DaemonSetList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaemonSetList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.DaemonSetSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DaemonSetSpec {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSetSpec.selector)
    pub selector: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSetSpec.template)
    pub template: ::protobuf::MessageField<crate::v1_33::api::core::v1::PodTemplateSpec>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSetSpec.updateStrategy)
    pub updateStrategy: ::protobuf::MessageField<DaemonSetUpdateStrategy>,
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSetSpec.minReadySeconds)
    pub minReadySeconds: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSetSpec.revisionHistoryLimit)
    pub revisionHistoryLimit: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.DaemonSetSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DaemonSetSpec {
    fn default() -> &'a DaemonSetSpec {
        <DaemonSetSpec as ::protobuf::Message>::default_instance()
    }
}

impl DaemonSetSpec {
    pub fn new() -> DaemonSetSpec {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;

    pub fn selector(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    pub fn has_selector(&self) -> bool {
        self.selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.selector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selector(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.mut_or_insert_default()
    }

    // Take field
    pub fn take_selector(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional .api.core.v1.PodTemplateSpec template = 2;

    pub fn template(&self) -> &crate::v1_33::api::core::v1::PodTemplateSpec {
        self.template.as_ref().unwrap_or_else(|| <crate::v1_33::api::core::v1::PodTemplateSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_template(&mut self) {
        self.template.clear();
    }

    pub fn has_template(&self) -> bool {
        self.template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template(&mut self, v: crate::v1_33::api::core::v1::PodTemplateSpec) {
        self.template = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template(&mut self) -> &mut crate::v1_33::api::core::v1::PodTemplateSpec {
        self.template.mut_or_insert_default()
    }

    // Take field
    pub fn take_template(&mut self) -> crate::v1_33::api::core::v1::PodTemplateSpec {
        self.template.take().unwrap_or_else(|| crate::v1_33::api::core::v1::PodTemplateSpec::new())
    }

    // optional .api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;

    pub fn updateStrategy(&self) -> &DaemonSetUpdateStrategy {
        self.updateStrategy.as_ref().unwrap_or_else(|| <DaemonSetUpdateStrategy as ::protobuf::Message>::default_instance())
    }

    pub fn clear_updateStrategy(&mut self) {
        self.updateStrategy.clear();
    }

    pub fn has_updateStrategy(&self) -> bool {
        self.updateStrategy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updateStrategy(&mut self, v: DaemonSetUpdateStrategy) {
        self.updateStrategy = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updateStrategy(&mut self) -> &mut DaemonSetUpdateStrategy {
        self.updateStrategy.mut_or_insert_default()
    }

    // Take field
    pub fn take_updateStrategy(&mut self) -> DaemonSetUpdateStrategy {
        self.updateStrategy.take().unwrap_or_else(|| DaemonSetUpdateStrategy::new())
    }

    // optional int32 minReadySeconds = 4;

    pub fn minReadySeconds(&self) -> i32 {
        self.minReadySeconds.unwrap_or(0)
    }

    pub fn clear_minReadySeconds(&mut self) {
        self.minReadySeconds = ::std::option::Option::None;
    }

    pub fn has_minReadySeconds(&self) -> bool {
        self.minReadySeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minReadySeconds(&mut self, v: i32) {
        self.minReadySeconds = ::std::option::Option::Some(v);
    }

    // optional int32 revisionHistoryLimit = 6;

    pub fn revisionHistoryLimit(&self) -> i32 {
        self.revisionHistoryLimit.unwrap_or(0)
    }

    pub fn clear_revisionHistoryLimit(&mut self) {
        self.revisionHistoryLimit = ::std::option::Option::None;
    }

    pub fn has_revisionHistoryLimit(&self) -> bool {
        self.revisionHistoryLimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revisionHistoryLimit(&mut self, v: i32) {
        self.revisionHistoryLimit = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "selector",
            |m: &DaemonSetSpec| { &m.selector },
            |m: &mut DaemonSetSpec| { &mut m.selector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::api::core::v1::PodTemplateSpec>(
            "template",
            |m: &DaemonSetSpec| { &m.template },
            |m: &mut DaemonSetSpec| { &mut m.template },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DaemonSetUpdateStrategy>(
            "updateStrategy",
            |m: &DaemonSetSpec| { &m.updateStrategy },
            |m: &mut DaemonSetSpec| { &mut m.updateStrategy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minReadySeconds",
            |m: &DaemonSetSpec| { &m.minReadySeconds },
            |m: &mut DaemonSetSpec| { &mut m.minReadySeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revisionHistoryLimit",
            |m: &DaemonSetSpec| { &m.revisionHistoryLimit },
            |m: &mut DaemonSetSpec| { &mut m.revisionHistoryLimit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DaemonSetSpec>(
            "DaemonSetSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DaemonSetSpec {
    const NAME: &'static str = "DaemonSetSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.selector)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.template)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.updateStrategy)?;
                },
                32 => {
                    self.minReadySeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.revisionHistoryLimit = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.updateStrategy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.minReadySeconds {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.revisionHistoryLimit {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.selector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.template.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.updateStrategy.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.minReadySeconds {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.revisionHistoryLimit {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DaemonSetSpec {
        DaemonSetSpec::new()
    }

    fn clear(&mut self) {
        self.selector.clear();
        self.template.clear();
        self.updateStrategy.clear();
        self.minReadySeconds = ::std::option::Option::None;
        self.revisionHistoryLimit = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DaemonSetSpec {
        static instance: DaemonSetSpec = DaemonSetSpec {
            selector: ::protobuf::MessageField::none(),
            template: ::protobuf::MessageField::none(),
            updateStrategy: ::protobuf::MessageField::none(),
            minReadySeconds: ::std::option::Option::None,
            revisionHistoryLimit: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DaemonSetSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DaemonSetSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DaemonSetSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaemonSetSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.DaemonSetStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DaemonSetStatus {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSetStatus.currentNumberScheduled)
    pub currentNumberScheduled: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSetStatus.numberMisscheduled)
    pub numberMisscheduled: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSetStatus.desiredNumberScheduled)
    pub desiredNumberScheduled: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSetStatus.numberReady)
    pub numberReady: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSetStatus.observedGeneration)
    pub observedGeneration: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSetStatus.updatedNumberScheduled)
    pub updatedNumberScheduled: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSetStatus.numberAvailable)
    pub numberAvailable: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSetStatus.numberUnavailable)
    pub numberUnavailable: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSetStatus.collisionCount)
    pub collisionCount: ::std::option::Option<i32>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSetStatus.conditions)
    pub conditions: ::std::vec::Vec<DaemonSetCondition>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.DaemonSetStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DaemonSetStatus {
    fn default() -> &'a DaemonSetStatus {
        <DaemonSetStatus as ::protobuf::Message>::default_instance()
    }
}

impl DaemonSetStatus {
    pub fn new() -> DaemonSetStatus {
        ::std::default::Default::default()
    }

    // optional int32 currentNumberScheduled = 1;

    pub fn currentNumberScheduled(&self) -> i32 {
        self.currentNumberScheduled.unwrap_or(0)
    }

    pub fn clear_currentNumberScheduled(&mut self) {
        self.currentNumberScheduled = ::std::option::Option::None;
    }

    pub fn has_currentNumberScheduled(&self) -> bool {
        self.currentNumberScheduled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currentNumberScheduled(&mut self, v: i32) {
        self.currentNumberScheduled = ::std::option::Option::Some(v);
    }

    // optional int32 numberMisscheduled = 2;

    pub fn numberMisscheduled(&self) -> i32 {
        self.numberMisscheduled.unwrap_or(0)
    }

    pub fn clear_numberMisscheduled(&mut self) {
        self.numberMisscheduled = ::std::option::Option::None;
    }

    pub fn has_numberMisscheduled(&self) -> bool {
        self.numberMisscheduled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numberMisscheduled(&mut self, v: i32) {
        self.numberMisscheduled = ::std::option::Option::Some(v);
    }

    // optional int32 desiredNumberScheduled = 3;

    pub fn desiredNumberScheduled(&self) -> i32 {
        self.desiredNumberScheduled.unwrap_or(0)
    }

    pub fn clear_desiredNumberScheduled(&mut self) {
        self.desiredNumberScheduled = ::std::option::Option::None;
    }

    pub fn has_desiredNumberScheduled(&self) -> bool {
        self.desiredNumberScheduled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desiredNumberScheduled(&mut self, v: i32) {
        self.desiredNumberScheduled = ::std::option::Option::Some(v);
    }

    // optional int32 numberReady = 4;

    pub fn numberReady(&self) -> i32 {
        self.numberReady.unwrap_or(0)
    }

    pub fn clear_numberReady(&mut self) {
        self.numberReady = ::std::option::Option::None;
    }

    pub fn has_numberReady(&self) -> bool {
        self.numberReady.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numberReady(&mut self, v: i32) {
        self.numberReady = ::std::option::Option::Some(v);
    }

    // optional int64 observedGeneration = 5;

    pub fn observedGeneration(&self) -> i64 {
        self.observedGeneration.unwrap_or(0)
    }

    pub fn clear_observedGeneration(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
    }

    pub fn has_observedGeneration(&self) -> bool {
        self.observedGeneration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observedGeneration(&mut self, v: i64) {
        self.observedGeneration = ::std::option::Option::Some(v);
    }

    // optional int32 updatedNumberScheduled = 6;

    pub fn updatedNumberScheduled(&self) -> i32 {
        self.updatedNumberScheduled.unwrap_or(0)
    }

    pub fn clear_updatedNumberScheduled(&mut self) {
        self.updatedNumberScheduled = ::std::option::Option::None;
    }

    pub fn has_updatedNumberScheduled(&self) -> bool {
        self.updatedNumberScheduled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updatedNumberScheduled(&mut self, v: i32) {
        self.updatedNumberScheduled = ::std::option::Option::Some(v);
    }

    // optional int32 numberAvailable = 7;

    pub fn numberAvailable(&self) -> i32 {
        self.numberAvailable.unwrap_or(0)
    }

    pub fn clear_numberAvailable(&mut self) {
        self.numberAvailable = ::std::option::Option::None;
    }

    pub fn has_numberAvailable(&self) -> bool {
        self.numberAvailable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numberAvailable(&mut self, v: i32) {
        self.numberAvailable = ::std::option::Option::Some(v);
    }

    // optional int32 numberUnavailable = 8;

    pub fn numberUnavailable(&self) -> i32 {
        self.numberUnavailable.unwrap_or(0)
    }

    pub fn clear_numberUnavailable(&mut self) {
        self.numberUnavailable = ::std::option::Option::None;
    }

    pub fn has_numberUnavailable(&self) -> bool {
        self.numberUnavailable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numberUnavailable(&mut self, v: i32) {
        self.numberUnavailable = ::std::option::Option::Some(v);
    }

    // optional int32 collisionCount = 9;

    pub fn collisionCount(&self) -> i32 {
        self.collisionCount.unwrap_or(0)
    }

    pub fn clear_collisionCount(&mut self) {
        self.collisionCount = ::std::option::Option::None;
    }

    pub fn has_collisionCount(&self) -> bool {
        self.collisionCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_collisionCount(&mut self, v: i32) {
        self.collisionCount = ::std::option::Option::Some(v);
    }

    // repeated .api.apps.v1.DaemonSetCondition conditions = 10;

    pub fn conditions(&self) -> &[DaemonSetCondition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<DaemonSetCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<DaemonSetCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<DaemonSetCondition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currentNumberScheduled",
            |m: &DaemonSetStatus| { &m.currentNumberScheduled },
            |m: &mut DaemonSetStatus| { &mut m.currentNumberScheduled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "numberMisscheduled",
            |m: &DaemonSetStatus| { &m.numberMisscheduled },
            |m: &mut DaemonSetStatus| { &mut m.numberMisscheduled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desiredNumberScheduled",
            |m: &DaemonSetStatus| { &m.desiredNumberScheduled },
            |m: &mut DaemonSetStatus| { &mut m.desiredNumberScheduled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "numberReady",
            |m: &DaemonSetStatus| { &m.numberReady },
            |m: &mut DaemonSetStatus| { &mut m.numberReady },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "observedGeneration",
            |m: &DaemonSetStatus| { &m.observedGeneration },
            |m: &mut DaemonSetStatus| { &mut m.observedGeneration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "updatedNumberScheduled",
            |m: &DaemonSetStatus| { &m.updatedNumberScheduled },
            |m: &mut DaemonSetStatus| { &mut m.updatedNumberScheduled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "numberAvailable",
            |m: &DaemonSetStatus| { &m.numberAvailable },
            |m: &mut DaemonSetStatus| { &mut m.numberAvailable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "numberUnavailable",
            |m: &DaemonSetStatus| { &m.numberUnavailable },
            |m: &mut DaemonSetStatus| { &mut m.numberUnavailable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "collisionCount",
            |m: &DaemonSetStatus| { &m.collisionCount },
            |m: &mut DaemonSetStatus| { &mut m.collisionCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &DaemonSetStatus| { &m.conditions },
            |m: &mut DaemonSetStatus| { &mut m.conditions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DaemonSetStatus>(
            "DaemonSetStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DaemonSetStatus {
    const NAME: &'static str = "DaemonSetStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.currentNumberScheduled = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.numberMisscheduled = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.desiredNumberScheduled = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.numberReady = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.observedGeneration = ::std::option::Option::Some(is.read_int64()?);
                },
                48 => {
                    self.updatedNumberScheduled = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.numberAvailable = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.numberUnavailable = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.collisionCount = ::std::option::Option::Some(is.read_int32()?);
                },
                82 => {
                    self.conditions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.currentNumberScheduled {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.numberMisscheduled {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.desiredNumberScheduled {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.numberReady {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.observedGeneration {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.updatedNumberScheduled {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.numberAvailable {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.numberUnavailable {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.collisionCount {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.currentNumberScheduled {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.numberMisscheduled {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.desiredNumberScheduled {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.numberReady {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.observedGeneration {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.updatedNumberScheduled {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.numberAvailable {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.numberUnavailable {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.collisionCount {
            os.write_int32(9, v)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DaemonSetStatus {
        DaemonSetStatus::new()
    }

    fn clear(&mut self) {
        self.currentNumberScheduled = ::std::option::Option::None;
        self.numberMisscheduled = ::std::option::Option::None;
        self.desiredNumberScheduled = ::std::option::Option::None;
        self.numberReady = ::std::option::Option::None;
        self.observedGeneration = ::std::option::Option::None;
        self.updatedNumberScheduled = ::std::option::Option::None;
        self.numberAvailable = ::std::option::Option::None;
        self.numberUnavailable = ::std::option::Option::None;
        self.collisionCount = ::std::option::Option::None;
        self.conditions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DaemonSetStatus {
        static instance: DaemonSetStatus = DaemonSetStatus {
            currentNumberScheduled: ::std::option::Option::None,
            numberMisscheduled: ::std::option::Option::None,
            desiredNumberScheduled: ::std::option::Option::None,
            numberReady: ::std::option::Option::None,
            observedGeneration: ::std::option::Option::None,
            updatedNumberScheduled: ::std::option::Option::None,
            numberAvailable: ::std::option::Option::None,
            numberUnavailable: ::std::option::Option::None,
            collisionCount: ::std::option::Option::None,
            conditions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DaemonSetStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DaemonSetStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DaemonSetStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaemonSetStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.DaemonSetUpdateStrategy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DaemonSetUpdateStrategy {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSetUpdateStrategy.type)
    pub type_: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.DaemonSetUpdateStrategy.rollingUpdate)
    pub rollingUpdate: ::protobuf::MessageField<RollingUpdateDaemonSet>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.DaemonSetUpdateStrategy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DaemonSetUpdateStrategy {
    fn default() -> &'a DaemonSetUpdateStrategy {
        <DaemonSetUpdateStrategy as ::protobuf::Message>::default_instance()
    }
}

impl DaemonSetUpdateStrategy {
    pub fn new() -> DaemonSetUpdateStrategy {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;

    pub fn rollingUpdate(&self) -> &RollingUpdateDaemonSet {
        self.rollingUpdate.as_ref().unwrap_or_else(|| <RollingUpdateDaemonSet as ::protobuf::Message>::default_instance())
    }

    pub fn clear_rollingUpdate(&mut self) {
        self.rollingUpdate.clear();
    }

    pub fn has_rollingUpdate(&self) -> bool {
        self.rollingUpdate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollingUpdate(&mut self, v: RollingUpdateDaemonSet) {
        self.rollingUpdate = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollingUpdate(&mut self) -> &mut RollingUpdateDaemonSet {
        self.rollingUpdate.mut_or_insert_default()
    }

    // Take field
    pub fn take_rollingUpdate(&mut self) -> RollingUpdateDaemonSet {
        self.rollingUpdate.take().unwrap_or_else(|| RollingUpdateDaemonSet::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &DaemonSetUpdateStrategy| { &m.type_ },
            |m: &mut DaemonSetUpdateStrategy| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RollingUpdateDaemonSet>(
            "rollingUpdate",
            |m: &DaemonSetUpdateStrategy| { &m.rollingUpdate },
            |m: &mut DaemonSetUpdateStrategy| { &mut m.rollingUpdate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DaemonSetUpdateStrategy>(
            "DaemonSetUpdateStrategy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DaemonSetUpdateStrategy {
    const NAME: &'static str = "DaemonSetUpdateStrategy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rollingUpdate)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.rollingUpdate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.rollingUpdate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DaemonSetUpdateStrategy {
        DaemonSetUpdateStrategy::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.rollingUpdate.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DaemonSetUpdateStrategy {
        static instance: DaemonSetUpdateStrategy = DaemonSetUpdateStrategy {
            type_: ::std::option::Option::None,
            rollingUpdate: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DaemonSetUpdateStrategy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DaemonSetUpdateStrategy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DaemonSetUpdateStrategy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaemonSetUpdateStrategy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.Deployment)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Deployment {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.Deployment.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.Deployment.spec)
    pub spec: ::protobuf::MessageField<DeploymentSpec>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.Deployment.status)
    pub status: ::protobuf::MessageField<DeploymentStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.Deployment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Deployment {
    fn default() -> &'a Deployment {
        <Deployment as ::protobuf::Message>::default_instance()
    }
}

impl Deployment {
    pub fn new() -> Deployment {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.apps.v1.DeploymentSpec spec = 2;

    pub fn spec(&self) -> &DeploymentSpec {
        self.spec.as_ref().unwrap_or_else(|| <DeploymentSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: DeploymentSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut DeploymentSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> DeploymentSpec {
        self.spec.take().unwrap_or_else(|| DeploymentSpec::new())
    }

    // optional .api.apps.v1.DeploymentStatus status = 3;

    pub fn status(&self) -> &DeploymentStatus {
        self.status.as_ref().unwrap_or_else(|| <DeploymentStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: DeploymentStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut DeploymentStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> DeploymentStatus {
        self.status.take().unwrap_or_else(|| DeploymentStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &Deployment| { &m.metadata },
            |m: &mut Deployment| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeploymentSpec>(
            "spec",
            |m: &Deployment| { &m.spec },
            |m: &mut Deployment| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeploymentStatus>(
            "status",
            |m: &Deployment| { &m.status },
            |m: &mut Deployment| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Deployment>(
            "Deployment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Deployment {
    const NAME: &'static str = "Deployment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Deployment {
        Deployment::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Deployment {
        static instance: Deployment = Deployment {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Deployment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Deployment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Deployment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Deployment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.DeploymentCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeploymentCondition {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentCondition.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentCondition.status)
    pub status: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentCondition.lastUpdateTime)
    pub lastUpdateTime: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::Time>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentCondition.lastTransitionTime)
    pub lastTransitionTime: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentCondition.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentCondition.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.DeploymentCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeploymentCondition {
    fn default() -> &'a DeploymentCondition {
        <DeploymentCondition as ::protobuf::Message>::default_instance()
    }
}

impl DeploymentCondition {
    pub fn new() -> DeploymentCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;

    pub fn lastUpdateTime(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::Time {
        self.lastUpdateTime.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastUpdateTime(&mut self) {
        self.lastUpdateTime.clear();
    }

    pub fn has_lastUpdateTime(&self) -> bool {
        self.lastUpdateTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastUpdateTime(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastUpdateTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastUpdateTime(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::Time {
        self.lastUpdateTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastUpdateTime(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::Time {
        self.lastUpdateTime.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;

    pub fn lastTransitionTime(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastTransitionTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional string reason = 4;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 5;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &DeploymentCondition| { &m.type_ },
            |m: &mut DeploymentCondition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &DeploymentCondition| { &m.status },
            |m: &mut DeploymentCondition| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::Time>(
            "lastUpdateTime",
            |m: &DeploymentCondition| { &m.lastUpdateTime },
            |m: &mut DeploymentCondition| { &mut m.lastUpdateTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::Time>(
            "lastTransitionTime",
            |m: &DeploymentCondition| { &m.lastTransitionTime },
            |m: &mut DeploymentCondition| { &mut m.lastTransitionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &DeploymentCondition| { &m.reason },
            |m: &mut DeploymentCondition| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &DeploymentCondition| { &m.message },
            |m: &mut DeploymentCondition| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeploymentCondition>(
            "DeploymentCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeploymentCondition {
    const NAME: &'static str = "DeploymentCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastUpdateTime)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTransitionTime)?;
                },
                34 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastUpdateTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lastUpdateTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeploymentCondition {
        DeploymentCondition::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.lastUpdateTime.clear();
        self.lastTransitionTime.clear();
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeploymentCondition {
        static instance: DeploymentCondition = DeploymentCondition {
            type_: ::std::option::Option::None,
            status: ::std::option::Option::None,
            lastUpdateTime: ::protobuf::MessageField::none(),
            lastTransitionTime: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeploymentCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeploymentCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeploymentCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeploymentCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.DeploymentList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeploymentList {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentList.items)
    pub items: ::std::vec::Vec<Deployment>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.DeploymentList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeploymentList {
    fn default() -> &'a DeploymentList {
        <DeploymentList as ::protobuf::Message>::default_instance()
    }
}

impl DeploymentList {
    pub fn new() -> DeploymentList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.apps.v1.Deployment items = 2;

    pub fn items(&self) -> &[Deployment] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<Deployment>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<Deployment> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<Deployment> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &DeploymentList| { &m.metadata },
            |m: &mut DeploymentList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &DeploymentList| { &m.items },
            |m: &mut DeploymentList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeploymentList>(
            "DeploymentList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeploymentList {
    const NAME: &'static str = "DeploymentList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeploymentList {
        DeploymentList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeploymentList {
        static instance: DeploymentList = DeploymentList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeploymentList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeploymentList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeploymentList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeploymentList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.DeploymentSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeploymentSpec {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentSpec.replicas)
    pub replicas: ::std::option::Option<i32>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentSpec.selector)
    pub selector: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentSpec.template)
    pub template: ::protobuf::MessageField<crate::v1_33::api::core::v1::PodTemplateSpec>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentSpec.strategy)
    pub strategy: ::protobuf::MessageField<DeploymentStrategy>,
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentSpec.minReadySeconds)
    pub minReadySeconds: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentSpec.revisionHistoryLimit)
    pub revisionHistoryLimit: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentSpec.paused)
    pub paused: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentSpec.progressDeadlineSeconds)
    pub progressDeadlineSeconds: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.DeploymentSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeploymentSpec {
    fn default() -> &'a DeploymentSpec {
        <DeploymentSpec as ::protobuf::Message>::default_instance()
    }
}

impl DeploymentSpec {
    pub fn new() -> DeploymentSpec {
        ::std::default::Default::default()
    }

    // optional int32 replicas = 1;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;

    pub fn selector(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    pub fn has_selector(&self) -> bool {
        self.selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.selector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selector(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.mut_or_insert_default()
    }

    // Take field
    pub fn take_selector(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional .api.core.v1.PodTemplateSpec template = 3;

    pub fn template(&self) -> &crate::v1_33::api::core::v1::PodTemplateSpec {
        self.template.as_ref().unwrap_or_else(|| <crate::v1_33::api::core::v1::PodTemplateSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_template(&mut self) {
        self.template.clear();
    }

    pub fn has_template(&self) -> bool {
        self.template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template(&mut self, v: crate::v1_33::api::core::v1::PodTemplateSpec) {
        self.template = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template(&mut self) -> &mut crate::v1_33::api::core::v1::PodTemplateSpec {
        self.template.mut_or_insert_default()
    }

    // Take field
    pub fn take_template(&mut self) -> crate::v1_33::api::core::v1::PodTemplateSpec {
        self.template.take().unwrap_or_else(|| crate::v1_33::api::core::v1::PodTemplateSpec::new())
    }

    // optional .api.apps.v1.DeploymentStrategy strategy = 4;

    pub fn strategy(&self) -> &DeploymentStrategy {
        self.strategy.as_ref().unwrap_or_else(|| <DeploymentStrategy as ::protobuf::Message>::default_instance())
    }

    pub fn clear_strategy(&mut self) {
        self.strategy.clear();
    }

    pub fn has_strategy(&self) -> bool {
        self.strategy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strategy(&mut self, v: DeploymentStrategy) {
        self.strategy = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_strategy(&mut self) -> &mut DeploymentStrategy {
        self.strategy.mut_or_insert_default()
    }

    // Take field
    pub fn take_strategy(&mut self) -> DeploymentStrategy {
        self.strategy.take().unwrap_or_else(|| DeploymentStrategy::new())
    }

    // optional int32 minReadySeconds = 5;

    pub fn minReadySeconds(&self) -> i32 {
        self.minReadySeconds.unwrap_or(0)
    }

    pub fn clear_minReadySeconds(&mut self) {
        self.minReadySeconds = ::std::option::Option::None;
    }

    pub fn has_minReadySeconds(&self) -> bool {
        self.minReadySeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minReadySeconds(&mut self, v: i32) {
        self.minReadySeconds = ::std::option::Option::Some(v);
    }

    // optional int32 revisionHistoryLimit = 6;

    pub fn revisionHistoryLimit(&self) -> i32 {
        self.revisionHistoryLimit.unwrap_or(0)
    }

    pub fn clear_revisionHistoryLimit(&mut self) {
        self.revisionHistoryLimit = ::std::option::Option::None;
    }

    pub fn has_revisionHistoryLimit(&self) -> bool {
        self.revisionHistoryLimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revisionHistoryLimit(&mut self, v: i32) {
        self.revisionHistoryLimit = ::std::option::Option::Some(v);
    }

    // optional bool paused = 7;

    pub fn paused(&self) -> bool {
        self.paused.unwrap_or(false)
    }

    pub fn clear_paused(&mut self) {
        self.paused = ::std::option::Option::None;
    }

    pub fn has_paused(&self) -> bool {
        self.paused.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paused(&mut self, v: bool) {
        self.paused = ::std::option::Option::Some(v);
    }

    // optional int32 progressDeadlineSeconds = 9;

    pub fn progressDeadlineSeconds(&self) -> i32 {
        self.progressDeadlineSeconds.unwrap_or(0)
    }

    pub fn clear_progressDeadlineSeconds(&mut self) {
        self.progressDeadlineSeconds = ::std::option::Option::None;
    }

    pub fn has_progressDeadlineSeconds(&self) -> bool {
        self.progressDeadlineSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progressDeadlineSeconds(&mut self, v: i32) {
        self.progressDeadlineSeconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &DeploymentSpec| { &m.replicas },
            |m: &mut DeploymentSpec| { &mut m.replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "selector",
            |m: &DeploymentSpec| { &m.selector },
            |m: &mut DeploymentSpec| { &mut m.selector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::api::core::v1::PodTemplateSpec>(
            "template",
            |m: &DeploymentSpec| { &m.template },
            |m: &mut DeploymentSpec| { &mut m.template },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeploymentStrategy>(
            "strategy",
            |m: &DeploymentSpec| { &m.strategy },
            |m: &mut DeploymentSpec| { &mut m.strategy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minReadySeconds",
            |m: &DeploymentSpec| { &m.minReadySeconds },
            |m: &mut DeploymentSpec| { &mut m.minReadySeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revisionHistoryLimit",
            |m: &DeploymentSpec| { &m.revisionHistoryLimit },
            |m: &mut DeploymentSpec| { &mut m.revisionHistoryLimit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "paused",
            |m: &DeploymentSpec| { &m.paused },
            |m: &mut DeploymentSpec| { &mut m.paused },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "progressDeadlineSeconds",
            |m: &DeploymentSpec| { &m.progressDeadlineSeconds },
            |m: &mut DeploymentSpec| { &mut m.progressDeadlineSeconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeploymentSpec>(
            "DeploymentSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeploymentSpec {
    const NAME: &'static str = "DeploymentSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.selector)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.template)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.strategy)?;
                },
                40 => {
                    self.minReadySeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.revisionHistoryLimit = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.paused = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.progressDeadlineSeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.strategy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.minReadySeconds {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.revisionHistoryLimit {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.paused {
            my_size += 1 + 1;
        }
        if let Some(v) = self.progressDeadlineSeconds {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.replicas {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.selector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.template.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.strategy.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.minReadySeconds {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.revisionHistoryLimit {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.paused {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.progressDeadlineSeconds {
            os.write_int32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeploymentSpec {
        DeploymentSpec::new()
    }

    fn clear(&mut self) {
        self.replicas = ::std::option::Option::None;
        self.selector.clear();
        self.template.clear();
        self.strategy.clear();
        self.minReadySeconds = ::std::option::Option::None;
        self.revisionHistoryLimit = ::std::option::Option::None;
        self.paused = ::std::option::Option::None;
        self.progressDeadlineSeconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeploymentSpec {
        static instance: DeploymentSpec = DeploymentSpec {
            replicas: ::std::option::Option::None,
            selector: ::protobuf::MessageField::none(),
            template: ::protobuf::MessageField::none(),
            strategy: ::protobuf::MessageField::none(),
            minReadySeconds: ::std::option::Option::None,
            revisionHistoryLimit: ::std::option::Option::None,
            paused: ::std::option::Option::None,
            progressDeadlineSeconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeploymentSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeploymentSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeploymentSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeploymentSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.DeploymentStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeploymentStatus {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentStatus.observedGeneration)
    pub observedGeneration: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentStatus.replicas)
    pub replicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentStatus.updatedReplicas)
    pub updatedReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentStatus.readyReplicas)
    pub readyReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentStatus.availableReplicas)
    pub availableReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentStatus.unavailableReplicas)
    pub unavailableReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentStatus.terminatingReplicas)
    pub terminatingReplicas: ::std::option::Option<i32>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentStatus.conditions)
    pub conditions: ::std::vec::Vec<DeploymentCondition>,
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentStatus.collisionCount)
    pub collisionCount: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.DeploymentStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeploymentStatus {
    fn default() -> &'a DeploymentStatus {
        <DeploymentStatus as ::protobuf::Message>::default_instance()
    }
}

impl DeploymentStatus {
    pub fn new() -> DeploymentStatus {
        ::std::default::Default::default()
    }

    // optional int64 observedGeneration = 1;

    pub fn observedGeneration(&self) -> i64 {
        self.observedGeneration.unwrap_or(0)
    }

    pub fn clear_observedGeneration(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
    }

    pub fn has_observedGeneration(&self) -> bool {
        self.observedGeneration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observedGeneration(&mut self, v: i64) {
        self.observedGeneration = ::std::option::Option::Some(v);
    }

    // optional int32 replicas = 2;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // optional int32 updatedReplicas = 3;

    pub fn updatedReplicas(&self) -> i32 {
        self.updatedReplicas.unwrap_or(0)
    }

    pub fn clear_updatedReplicas(&mut self) {
        self.updatedReplicas = ::std::option::Option::None;
    }

    pub fn has_updatedReplicas(&self) -> bool {
        self.updatedReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updatedReplicas(&mut self, v: i32) {
        self.updatedReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 readyReplicas = 7;

    pub fn readyReplicas(&self) -> i32 {
        self.readyReplicas.unwrap_or(0)
    }

    pub fn clear_readyReplicas(&mut self) {
        self.readyReplicas = ::std::option::Option::None;
    }

    pub fn has_readyReplicas(&self) -> bool {
        self.readyReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readyReplicas(&mut self, v: i32) {
        self.readyReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 availableReplicas = 4;

    pub fn availableReplicas(&self) -> i32 {
        self.availableReplicas.unwrap_or(0)
    }

    pub fn clear_availableReplicas(&mut self) {
        self.availableReplicas = ::std::option::Option::None;
    }

    pub fn has_availableReplicas(&self) -> bool {
        self.availableReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_availableReplicas(&mut self, v: i32) {
        self.availableReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 unavailableReplicas = 5;

    pub fn unavailableReplicas(&self) -> i32 {
        self.unavailableReplicas.unwrap_or(0)
    }

    pub fn clear_unavailableReplicas(&mut self) {
        self.unavailableReplicas = ::std::option::Option::None;
    }

    pub fn has_unavailableReplicas(&self) -> bool {
        self.unavailableReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unavailableReplicas(&mut self, v: i32) {
        self.unavailableReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 terminatingReplicas = 9;

    pub fn terminatingReplicas(&self) -> i32 {
        self.terminatingReplicas.unwrap_or(0)
    }

    pub fn clear_terminatingReplicas(&mut self) {
        self.terminatingReplicas = ::std::option::Option::None;
    }

    pub fn has_terminatingReplicas(&self) -> bool {
        self.terminatingReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_terminatingReplicas(&mut self, v: i32) {
        self.terminatingReplicas = ::std::option::Option::Some(v);
    }

    // repeated .api.apps.v1.DeploymentCondition conditions = 6;

    pub fn conditions(&self) -> &[DeploymentCondition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<DeploymentCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<DeploymentCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<DeploymentCondition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    // optional int32 collisionCount = 8;

    pub fn collisionCount(&self) -> i32 {
        self.collisionCount.unwrap_or(0)
    }

    pub fn clear_collisionCount(&mut self) {
        self.collisionCount = ::std::option::Option::None;
    }

    pub fn has_collisionCount(&self) -> bool {
        self.collisionCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_collisionCount(&mut self, v: i32) {
        self.collisionCount = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "observedGeneration",
            |m: &DeploymentStatus| { &m.observedGeneration },
            |m: &mut DeploymentStatus| { &mut m.observedGeneration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &DeploymentStatus| { &m.replicas },
            |m: &mut DeploymentStatus| { &mut m.replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "updatedReplicas",
            |m: &DeploymentStatus| { &m.updatedReplicas },
            |m: &mut DeploymentStatus| { &mut m.updatedReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readyReplicas",
            |m: &DeploymentStatus| { &m.readyReplicas },
            |m: &mut DeploymentStatus| { &mut m.readyReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "availableReplicas",
            |m: &DeploymentStatus| { &m.availableReplicas },
            |m: &mut DeploymentStatus| { &mut m.availableReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unavailableReplicas",
            |m: &DeploymentStatus| { &m.unavailableReplicas },
            |m: &mut DeploymentStatus| { &mut m.unavailableReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "terminatingReplicas",
            |m: &DeploymentStatus| { &m.terminatingReplicas },
            |m: &mut DeploymentStatus| { &mut m.terminatingReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &DeploymentStatus| { &m.conditions },
            |m: &mut DeploymentStatus| { &mut m.conditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "collisionCount",
            |m: &DeploymentStatus| { &m.collisionCount },
            |m: &mut DeploymentStatus| { &mut m.collisionCount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeploymentStatus>(
            "DeploymentStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeploymentStatus {
    const NAME: &'static str = "DeploymentStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.observedGeneration = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.updatedReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.readyReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.availableReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.unavailableReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.terminatingReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    self.conditions.push(is.read_message()?);
                },
                64 => {
                    self.collisionCount = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.observedGeneration {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.updatedReplicas {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.readyReplicas {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.availableReplicas {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.unavailableReplicas {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.terminatingReplicas {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.collisionCount {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.observedGeneration {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.replicas {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.updatedReplicas {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.readyReplicas {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.availableReplicas {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.unavailableReplicas {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.terminatingReplicas {
            os.write_int32(9, v)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.collisionCount {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeploymentStatus {
        DeploymentStatus::new()
    }

    fn clear(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
        self.replicas = ::std::option::Option::None;
        self.updatedReplicas = ::std::option::Option::None;
        self.readyReplicas = ::std::option::Option::None;
        self.availableReplicas = ::std::option::Option::None;
        self.unavailableReplicas = ::std::option::Option::None;
        self.terminatingReplicas = ::std::option::Option::None;
        self.conditions.clear();
        self.collisionCount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeploymentStatus {
        static instance: DeploymentStatus = DeploymentStatus {
            observedGeneration: ::std::option::Option::None,
            replicas: ::std::option::Option::None,
            updatedReplicas: ::std::option::Option::None,
            readyReplicas: ::std::option::Option::None,
            availableReplicas: ::std::option::Option::None,
            unavailableReplicas: ::std::option::Option::None,
            terminatingReplicas: ::std::option::Option::None,
            conditions: ::std::vec::Vec::new(),
            collisionCount: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeploymentStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeploymentStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeploymentStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeploymentStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.DeploymentStrategy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeploymentStrategy {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentStrategy.type)
    pub type_: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.DeploymentStrategy.rollingUpdate)
    pub rollingUpdate: ::protobuf::MessageField<RollingUpdateDeployment>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.DeploymentStrategy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeploymentStrategy {
    fn default() -> &'a DeploymentStrategy {
        <DeploymentStrategy as ::protobuf::Message>::default_instance()
    }
}

impl DeploymentStrategy {
    pub fn new() -> DeploymentStrategy {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.apps.v1.RollingUpdateDeployment rollingUpdate = 2;

    pub fn rollingUpdate(&self) -> &RollingUpdateDeployment {
        self.rollingUpdate.as_ref().unwrap_or_else(|| <RollingUpdateDeployment as ::protobuf::Message>::default_instance())
    }

    pub fn clear_rollingUpdate(&mut self) {
        self.rollingUpdate.clear();
    }

    pub fn has_rollingUpdate(&self) -> bool {
        self.rollingUpdate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollingUpdate(&mut self, v: RollingUpdateDeployment) {
        self.rollingUpdate = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollingUpdate(&mut self) -> &mut RollingUpdateDeployment {
        self.rollingUpdate.mut_or_insert_default()
    }

    // Take field
    pub fn take_rollingUpdate(&mut self) -> RollingUpdateDeployment {
        self.rollingUpdate.take().unwrap_or_else(|| RollingUpdateDeployment::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &DeploymentStrategy| { &m.type_ },
            |m: &mut DeploymentStrategy| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RollingUpdateDeployment>(
            "rollingUpdate",
            |m: &DeploymentStrategy| { &m.rollingUpdate },
            |m: &mut DeploymentStrategy| { &mut m.rollingUpdate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeploymentStrategy>(
            "DeploymentStrategy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeploymentStrategy {
    const NAME: &'static str = "DeploymentStrategy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rollingUpdate)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.rollingUpdate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.rollingUpdate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeploymentStrategy {
        DeploymentStrategy::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.rollingUpdate.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeploymentStrategy {
        static instance: DeploymentStrategy = DeploymentStrategy {
            type_: ::std::option::Option::None,
            rollingUpdate: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeploymentStrategy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeploymentStrategy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeploymentStrategy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeploymentStrategy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.ReplicaSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReplicaSet {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.ReplicaSet.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.ReplicaSet.spec)
    pub spec: ::protobuf::MessageField<ReplicaSetSpec>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.ReplicaSet.status)
    pub status: ::protobuf::MessageField<ReplicaSetStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.ReplicaSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReplicaSet {
    fn default() -> &'a ReplicaSet {
        <ReplicaSet as ::protobuf::Message>::default_instance()
    }
}

impl ReplicaSet {
    pub fn new() -> ReplicaSet {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.apps.v1.ReplicaSetSpec spec = 2;

    pub fn spec(&self) -> &ReplicaSetSpec {
        self.spec.as_ref().unwrap_or_else(|| <ReplicaSetSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ReplicaSetSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ReplicaSetSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ReplicaSetSpec {
        self.spec.take().unwrap_or_else(|| ReplicaSetSpec::new())
    }

    // optional .api.apps.v1.ReplicaSetStatus status = 3;

    pub fn status(&self) -> &ReplicaSetStatus {
        self.status.as_ref().unwrap_or_else(|| <ReplicaSetStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ReplicaSetStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ReplicaSetStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> ReplicaSetStatus {
        self.status.take().unwrap_or_else(|| ReplicaSetStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ReplicaSet| { &m.metadata },
            |m: &mut ReplicaSet| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ReplicaSetSpec>(
            "spec",
            |m: &ReplicaSet| { &m.spec },
            |m: &mut ReplicaSet| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ReplicaSetStatus>(
            "status",
            |m: &ReplicaSet| { &m.status },
            |m: &mut ReplicaSet| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplicaSet>(
            "ReplicaSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReplicaSet {
    const NAME: &'static str = "ReplicaSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReplicaSet {
        ReplicaSet::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReplicaSet {
        static instance: ReplicaSet = ReplicaSet {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReplicaSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReplicaSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReplicaSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicaSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.ReplicaSetCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReplicaSetCondition {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1.ReplicaSetCondition.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1.ReplicaSetCondition.status)
    pub status: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.ReplicaSetCondition.lastTransitionTime)
    pub lastTransitionTime: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:api.apps.v1.ReplicaSetCondition.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1.ReplicaSetCondition.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.ReplicaSetCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReplicaSetCondition {
    fn default() -> &'a ReplicaSetCondition {
        <ReplicaSetCondition as ::protobuf::Message>::default_instance()
    }
}

impl ReplicaSetCondition {
    pub fn new() -> ReplicaSetCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

    pub fn lastTransitionTime(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastTransitionTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional string reason = 4;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 5;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &ReplicaSetCondition| { &m.type_ },
            |m: &mut ReplicaSetCondition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &ReplicaSetCondition| { &m.status },
            |m: &mut ReplicaSetCondition| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::Time>(
            "lastTransitionTime",
            |m: &ReplicaSetCondition| { &m.lastTransitionTime },
            |m: &mut ReplicaSetCondition| { &mut m.lastTransitionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &ReplicaSetCondition| { &m.reason },
            |m: &mut ReplicaSetCondition| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &ReplicaSetCondition| { &m.message },
            |m: &mut ReplicaSetCondition| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplicaSetCondition>(
            "ReplicaSetCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReplicaSetCondition {
    const NAME: &'static str = "ReplicaSetCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTransitionTime)?;
                },
                34 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReplicaSetCondition {
        ReplicaSetCondition::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.lastTransitionTime.clear();
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReplicaSetCondition {
        static instance: ReplicaSetCondition = ReplicaSetCondition {
            type_: ::std::option::Option::None,
            status: ::std::option::Option::None,
            lastTransitionTime: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReplicaSetCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReplicaSetCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReplicaSetCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicaSetCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.ReplicaSetList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReplicaSetList {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.ReplicaSetList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.ReplicaSetList.items)
    pub items: ::std::vec::Vec<ReplicaSet>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.ReplicaSetList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReplicaSetList {
    fn default() -> &'a ReplicaSetList {
        <ReplicaSetList as ::protobuf::Message>::default_instance()
    }
}

impl ReplicaSetList {
    pub fn new() -> ReplicaSetList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.apps.v1.ReplicaSet items = 2;

    pub fn items(&self) -> &[ReplicaSet] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ReplicaSet>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ReplicaSet> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ReplicaSet> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ReplicaSetList| { &m.metadata },
            |m: &mut ReplicaSetList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ReplicaSetList| { &m.items },
            |m: &mut ReplicaSetList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplicaSetList>(
            "ReplicaSetList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReplicaSetList {
    const NAME: &'static str = "ReplicaSetList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReplicaSetList {
        ReplicaSetList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReplicaSetList {
        static instance: ReplicaSetList = ReplicaSetList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReplicaSetList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReplicaSetList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReplicaSetList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicaSetList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.ReplicaSetSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReplicaSetSpec {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1.ReplicaSetSpec.replicas)
    pub replicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.ReplicaSetSpec.minReadySeconds)
    pub minReadySeconds: ::std::option::Option<i32>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.ReplicaSetSpec.selector)
    pub selector: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.ReplicaSetSpec.template)
    pub template: ::protobuf::MessageField<crate::v1_33::api::core::v1::PodTemplateSpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.ReplicaSetSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReplicaSetSpec {
    fn default() -> &'a ReplicaSetSpec {
        <ReplicaSetSpec as ::protobuf::Message>::default_instance()
    }
}

impl ReplicaSetSpec {
    pub fn new() -> ReplicaSetSpec {
        ::std::default::Default::default()
    }

    // optional int32 replicas = 1;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // optional int32 minReadySeconds = 4;

    pub fn minReadySeconds(&self) -> i32 {
        self.minReadySeconds.unwrap_or(0)
    }

    pub fn clear_minReadySeconds(&mut self) {
        self.minReadySeconds = ::std::option::Option::None;
    }

    pub fn has_minReadySeconds(&self) -> bool {
        self.minReadySeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minReadySeconds(&mut self, v: i32) {
        self.minReadySeconds = ::std::option::Option::Some(v);
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;

    pub fn selector(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    pub fn has_selector(&self) -> bool {
        self.selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.selector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selector(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.mut_or_insert_default()
    }

    // Take field
    pub fn take_selector(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional .api.core.v1.PodTemplateSpec template = 3;

    pub fn template(&self) -> &crate::v1_33::api::core::v1::PodTemplateSpec {
        self.template.as_ref().unwrap_or_else(|| <crate::v1_33::api::core::v1::PodTemplateSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_template(&mut self) {
        self.template.clear();
    }

    pub fn has_template(&self) -> bool {
        self.template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template(&mut self, v: crate::v1_33::api::core::v1::PodTemplateSpec) {
        self.template = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template(&mut self) -> &mut crate::v1_33::api::core::v1::PodTemplateSpec {
        self.template.mut_or_insert_default()
    }

    // Take field
    pub fn take_template(&mut self) -> crate::v1_33::api::core::v1::PodTemplateSpec {
        self.template.take().unwrap_or_else(|| crate::v1_33::api::core::v1::PodTemplateSpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &ReplicaSetSpec| { &m.replicas },
            |m: &mut ReplicaSetSpec| { &mut m.replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minReadySeconds",
            |m: &ReplicaSetSpec| { &m.minReadySeconds },
            |m: &mut ReplicaSetSpec| { &mut m.minReadySeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "selector",
            |m: &ReplicaSetSpec| { &m.selector },
            |m: &mut ReplicaSetSpec| { &mut m.selector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::api::core::v1::PodTemplateSpec>(
            "template",
            |m: &ReplicaSetSpec| { &m.template },
            |m: &mut ReplicaSetSpec| { &mut m.template },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplicaSetSpec>(
            "ReplicaSetSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReplicaSetSpec {
    const NAME: &'static str = "ReplicaSetSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.minReadySeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.selector)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.template)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.minReadySeconds {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.replicas {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.minReadySeconds {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.selector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.template.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReplicaSetSpec {
        ReplicaSetSpec::new()
    }

    fn clear(&mut self) {
        self.replicas = ::std::option::Option::None;
        self.minReadySeconds = ::std::option::Option::None;
        self.selector.clear();
        self.template.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReplicaSetSpec {
        static instance: ReplicaSetSpec = ReplicaSetSpec {
            replicas: ::std::option::Option::None,
            minReadySeconds: ::std::option::Option::None,
            selector: ::protobuf::MessageField::none(),
            template: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReplicaSetSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReplicaSetSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReplicaSetSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicaSetSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.ReplicaSetStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReplicaSetStatus {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1.ReplicaSetStatus.replicas)
    pub replicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.ReplicaSetStatus.fullyLabeledReplicas)
    pub fullyLabeledReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.ReplicaSetStatus.readyReplicas)
    pub readyReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.ReplicaSetStatus.availableReplicas)
    pub availableReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.ReplicaSetStatus.terminatingReplicas)
    pub terminatingReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.ReplicaSetStatus.observedGeneration)
    pub observedGeneration: ::std::option::Option<i64>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.ReplicaSetStatus.conditions)
    pub conditions: ::std::vec::Vec<ReplicaSetCondition>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.ReplicaSetStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReplicaSetStatus {
    fn default() -> &'a ReplicaSetStatus {
        <ReplicaSetStatus as ::protobuf::Message>::default_instance()
    }
}

impl ReplicaSetStatus {
    pub fn new() -> ReplicaSetStatus {
        ::std::default::Default::default()
    }

    // optional int32 replicas = 1;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // optional int32 fullyLabeledReplicas = 2;

    pub fn fullyLabeledReplicas(&self) -> i32 {
        self.fullyLabeledReplicas.unwrap_or(0)
    }

    pub fn clear_fullyLabeledReplicas(&mut self) {
        self.fullyLabeledReplicas = ::std::option::Option::None;
    }

    pub fn has_fullyLabeledReplicas(&self) -> bool {
        self.fullyLabeledReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fullyLabeledReplicas(&mut self, v: i32) {
        self.fullyLabeledReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 readyReplicas = 4;

    pub fn readyReplicas(&self) -> i32 {
        self.readyReplicas.unwrap_or(0)
    }

    pub fn clear_readyReplicas(&mut self) {
        self.readyReplicas = ::std::option::Option::None;
    }

    pub fn has_readyReplicas(&self) -> bool {
        self.readyReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readyReplicas(&mut self, v: i32) {
        self.readyReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 availableReplicas = 5;

    pub fn availableReplicas(&self) -> i32 {
        self.availableReplicas.unwrap_or(0)
    }

    pub fn clear_availableReplicas(&mut self) {
        self.availableReplicas = ::std::option::Option::None;
    }

    pub fn has_availableReplicas(&self) -> bool {
        self.availableReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_availableReplicas(&mut self, v: i32) {
        self.availableReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 terminatingReplicas = 7;

    pub fn terminatingReplicas(&self) -> i32 {
        self.terminatingReplicas.unwrap_or(0)
    }

    pub fn clear_terminatingReplicas(&mut self) {
        self.terminatingReplicas = ::std::option::Option::None;
    }

    pub fn has_terminatingReplicas(&self) -> bool {
        self.terminatingReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_terminatingReplicas(&mut self, v: i32) {
        self.terminatingReplicas = ::std::option::Option::Some(v);
    }

    // optional int64 observedGeneration = 3;

    pub fn observedGeneration(&self) -> i64 {
        self.observedGeneration.unwrap_or(0)
    }

    pub fn clear_observedGeneration(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
    }

    pub fn has_observedGeneration(&self) -> bool {
        self.observedGeneration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observedGeneration(&mut self, v: i64) {
        self.observedGeneration = ::std::option::Option::Some(v);
    }

    // repeated .api.apps.v1.ReplicaSetCondition conditions = 6;

    pub fn conditions(&self) -> &[ReplicaSetCondition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<ReplicaSetCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<ReplicaSetCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<ReplicaSetCondition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &ReplicaSetStatus| { &m.replicas },
            |m: &mut ReplicaSetStatus| { &mut m.replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fullyLabeledReplicas",
            |m: &ReplicaSetStatus| { &m.fullyLabeledReplicas },
            |m: &mut ReplicaSetStatus| { &mut m.fullyLabeledReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readyReplicas",
            |m: &ReplicaSetStatus| { &m.readyReplicas },
            |m: &mut ReplicaSetStatus| { &mut m.readyReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "availableReplicas",
            |m: &ReplicaSetStatus| { &m.availableReplicas },
            |m: &mut ReplicaSetStatus| { &mut m.availableReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "terminatingReplicas",
            |m: &ReplicaSetStatus| { &m.terminatingReplicas },
            |m: &mut ReplicaSetStatus| { &mut m.terminatingReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "observedGeneration",
            |m: &ReplicaSetStatus| { &m.observedGeneration },
            |m: &mut ReplicaSetStatus| { &mut m.observedGeneration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &ReplicaSetStatus| { &m.conditions },
            |m: &mut ReplicaSetStatus| { &mut m.conditions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplicaSetStatus>(
            "ReplicaSetStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReplicaSetStatus {
    const NAME: &'static str = "ReplicaSetStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.fullyLabeledReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.readyReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.availableReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.terminatingReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.observedGeneration = ::std::option::Option::Some(is.read_int64()?);
                },
                50 => {
                    self.conditions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.fullyLabeledReplicas {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.readyReplicas {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.availableReplicas {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.terminatingReplicas {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.observedGeneration {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.replicas {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.fullyLabeledReplicas {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.readyReplicas {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.availableReplicas {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.terminatingReplicas {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.observedGeneration {
            os.write_int64(3, v)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReplicaSetStatus {
        ReplicaSetStatus::new()
    }

    fn clear(&mut self) {
        self.replicas = ::std::option::Option::None;
        self.fullyLabeledReplicas = ::std::option::Option::None;
        self.readyReplicas = ::std::option::Option::None;
        self.availableReplicas = ::std::option::Option::None;
        self.terminatingReplicas = ::std::option::Option::None;
        self.observedGeneration = ::std::option::Option::None;
        self.conditions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReplicaSetStatus {
        static instance: ReplicaSetStatus = ReplicaSetStatus {
            replicas: ::std::option::Option::None,
            fullyLabeledReplicas: ::std::option::Option::None,
            readyReplicas: ::std::option::Option::None,
            availableReplicas: ::std::option::Option::None,
            terminatingReplicas: ::std::option::Option::None,
            observedGeneration: ::std::option::Option::None,
            conditions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReplicaSetStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReplicaSetStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReplicaSetStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicaSetStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.RollingUpdateDaemonSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RollingUpdateDaemonSet {
    // message fields
    #[serde(with = "crate::v1_33::intorstr")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.RollingUpdateDaemonSet.maxUnavailable)
    pub maxUnavailable: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::util::intstr::IntOrString>,
    #[serde(with = "crate::v1_33::intorstr")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.RollingUpdateDaemonSet.maxSurge)
    pub maxSurge: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::util::intstr::IntOrString>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.RollingUpdateDaemonSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RollingUpdateDaemonSet {
    fn default() -> &'a RollingUpdateDaemonSet {
        <RollingUpdateDaemonSet as ::protobuf::Message>::default_instance()
    }
}

impl RollingUpdateDaemonSet {
    pub fn new() -> RollingUpdateDaemonSet {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;

    pub fn maxUnavailable(&self) -> &crate::v1_33::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::util::intstr::IntOrString as ::protobuf::Message>::default_instance())
    }

    pub fn clear_maxUnavailable(&mut self) {
        self.maxUnavailable.clear();
    }

    pub fn has_maxUnavailable(&self) -> bool {
        self.maxUnavailable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxUnavailable(&mut self, v: crate::v1_33::apimachinery::pkg::util::intstr::IntOrString) {
        self.maxUnavailable = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maxUnavailable(&mut self) -> &mut crate::v1_33::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.mut_or_insert_default()
    }

    // Take field
    pub fn take_maxUnavailable(&mut self) -> crate::v1_33::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::util::intstr::IntOrString::new())
    }

    // optional .apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;

    pub fn maxSurge(&self) -> &crate::v1_33::apimachinery::pkg::util::intstr::IntOrString {
        self.maxSurge.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::util::intstr::IntOrString as ::protobuf::Message>::default_instance())
    }

    pub fn clear_maxSurge(&mut self) {
        self.maxSurge.clear();
    }

    pub fn has_maxSurge(&self) -> bool {
        self.maxSurge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxSurge(&mut self, v: crate::v1_33::apimachinery::pkg::util::intstr::IntOrString) {
        self.maxSurge = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maxSurge(&mut self) -> &mut crate::v1_33::apimachinery::pkg::util::intstr::IntOrString {
        self.maxSurge.mut_or_insert_default()
    }

    // Take field
    pub fn take_maxSurge(&mut self) -> crate::v1_33::apimachinery::pkg::util::intstr::IntOrString {
        self.maxSurge.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::util::intstr::IntOrString::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::util::intstr::IntOrString>(
            "maxUnavailable",
            |m: &RollingUpdateDaemonSet| { &m.maxUnavailable },
            |m: &mut RollingUpdateDaemonSet| { &mut m.maxUnavailable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::util::intstr::IntOrString>(
            "maxSurge",
            |m: &RollingUpdateDaemonSet| { &m.maxSurge },
            |m: &mut RollingUpdateDaemonSet| { &mut m.maxSurge },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RollingUpdateDaemonSet>(
            "RollingUpdateDaemonSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RollingUpdateDaemonSet {
    const NAME: &'static str = "RollingUpdateDaemonSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.maxUnavailable)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.maxSurge)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.maxUnavailable.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.maxSurge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.maxUnavailable.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.maxSurge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RollingUpdateDaemonSet {
        RollingUpdateDaemonSet::new()
    }

    fn clear(&mut self) {
        self.maxUnavailable.clear();
        self.maxSurge.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RollingUpdateDaemonSet {
        static instance: RollingUpdateDaemonSet = RollingUpdateDaemonSet {
            maxUnavailable: ::protobuf::MessageField::none(),
            maxSurge: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RollingUpdateDaemonSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RollingUpdateDaemonSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RollingUpdateDaemonSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpdateDaemonSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.RollingUpdateDeployment)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RollingUpdateDeployment {
    // message fields
    #[serde(with = "crate::v1_33::intorstr")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.RollingUpdateDeployment.maxUnavailable)
    pub maxUnavailable: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::util::intstr::IntOrString>,
    #[serde(with = "crate::v1_33::intorstr")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.RollingUpdateDeployment.maxSurge)
    pub maxSurge: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::util::intstr::IntOrString>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.RollingUpdateDeployment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RollingUpdateDeployment {
    fn default() -> &'a RollingUpdateDeployment {
        <RollingUpdateDeployment as ::protobuf::Message>::default_instance()
    }
}

impl RollingUpdateDeployment {
    pub fn new() -> RollingUpdateDeployment {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;

    pub fn maxUnavailable(&self) -> &crate::v1_33::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::util::intstr::IntOrString as ::protobuf::Message>::default_instance())
    }

    pub fn clear_maxUnavailable(&mut self) {
        self.maxUnavailable.clear();
    }

    pub fn has_maxUnavailable(&self) -> bool {
        self.maxUnavailable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxUnavailable(&mut self, v: crate::v1_33::apimachinery::pkg::util::intstr::IntOrString) {
        self.maxUnavailable = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maxUnavailable(&mut self) -> &mut crate::v1_33::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.mut_or_insert_default()
    }

    // Take field
    pub fn take_maxUnavailable(&mut self) -> crate::v1_33::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::util::intstr::IntOrString::new())
    }

    // optional .apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;

    pub fn maxSurge(&self) -> &crate::v1_33::apimachinery::pkg::util::intstr::IntOrString {
        self.maxSurge.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::util::intstr::IntOrString as ::protobuf::Message>::default_instance())
    }

    pub fn clear_maxSurge(&mut self) {
        self.maxSurge.clear();
    }

    pub fn has_maxSurge(&self) -> bool {
        self.maxSurge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxSurge(&mut self, v: crate::v1_33::apimachinery::pkg::util::intstr::IntOrString) {
        self.maxSurge = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maxSurge(&mut self) -> &mut crate::v1_33::apimachinery::pkg::util::intstr::IntOrString {
        self.maxSurge.mut_or_insert_default()
    }

    // Take field
    pub fn take_maxSurge(&mut self) -> crate::v1_33::apimachinery::pkg::util::intstr::IntOrString {
        self.maxSurge.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::util::intstr::IntOrString::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::util::intstr::IntOrString>(
            "maxUnavailable",
            |m: &RollingUpdateDeployment| { &m.maxUnavailable },
            |m: &mut RollingUpdateDeployment| { &mut m.maxUnavailable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::util::intstr::IntOrString>(
            "maxSurge",
            |m: &RollingUpdateDeployment| { &m.maxSurge },
            |m: &mut RollingUpdateDeployment| { &mut m.maxSurge },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RollingUpdateDeployment>(
            "RollingUpdateDeployment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RollingUpdateDeployment {
    const NAME: &'static str = "RollingUpdateDeployment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.maxUnavailable)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.maxSurge)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.maxUnavailable.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.maxSurge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.maxUnavailable.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.maxSurge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RollingUpdateDeployment {
        RollingUpdateDeployment::new()
    }

    fn clear(&mut self) {
        self.maxUnavailable.clear();
        self.maxSurge.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RollingUpdateDeployment {
        static instance: RollingUpdateDeployment = RollingUpdateDeployment {
            maxUnavailable: ::protobuf::MessageField::none(),
            maxSurge: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RollingUpdateDeployment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RollingUpdateDeployment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RollingUpdateDeployment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpdateDeployment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.RollingUpdateStatefulSetStrategy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RollingUpdateStatefulSetStrategy {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1.RollingUpdateStatefulSetStrategy.partition)
    pub partition: ::std::option::Option<i32>,
    #[serde(with = "crate::v1_33::intorstr")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.RollingUpdateStatefulSetStrategy.maxUnavailable)
    pub maxUnavailable: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::util::intstr::IntOrString>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.RollingUpdateStatefulSetStrategy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RollingUpdateStatefulSetStrategy {
    fn default() -> &'a RollingUpdateStatefulSetStrategy {
        <RollingUpdateStatefulSetStrategy as ::protobuf::Message>::default_instance()
    }
}

impl RollingUpdateStatefulSetStrategy {
    pub fn new() -> RollingUpdateStatefulSetStrategy {
        ::std::default::Default::default()
    }

    // optional int32 partition = 1;

    pub fn partition(&self) -> i32 {
        self.partition.unwrap_or(0)
    }

    pub fn clear_partition(&mut self) {
        self.partition = ::std::option::Option::None;
    }

    pub fn has_partition(&self) -> bool {
        self.partition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partition(&mut self, v: i32) {
        self.partition = ::std::option::Option::Some(v);
    }

    // optional .apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 2;

    pub fn maxUnavailable(&self) -> &crate::v1_33::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::util::intstr::IntOrString as ::protobuf::Message>::default_instance())
    }

    pub fn clear_maxUnavailable(&mut self) {
        self.maxUnavailable.clear();
    }

    pub fn has_maxUnavailable(&self) -> bool {
        self.maxUnavailable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxUnavailable(&mut self, v: crate::v1_33::apimachinery::pkg::util::intstr::IntOrString) {
        self.maxUnavailable = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maxUnavailable(&mut self) -> &mut crate::v1_33::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.mut_or_insert_default()
    }

    // Take field
    pub fn take_maxUnavailable(&mut self) -> crate::v1_33::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::util::intstr::IntOrString::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "partition",
            |m: &RollingUpdateStatefulSetStrategy| { &m.partition },
            |m: &mut RollingUpdateStatefulSetStrategy| { &mut m.partition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::util::intstr::IntOrString>(
            "maxUnavailable",
            |m: &RollingUpdateStatefulSetStrategy| { &m.maxUnavailable },
            |m: &mut RollingUpdateStatefulSetStrategy| { &mut m.maxUnavailable },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RollingUpdateStatefulSetStrategy>(
            "RollingUpdateStatefulSetStrategy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RollingUpdateStatefulSetStrategy {
    const NAME: &'static str = "RollingUpdateStatefulSetStrategy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.partition = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.maxUnavailable)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.partition {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.maxUnavailable.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.partition {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.maxUnavailable.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RollingUpdateStatefulSetStrategy {
        RollingUpdateStatefulSetStrategy::new()
    }

    fn clear(&mut self) {
        self.partition = ::std::option::Option::None;
        self.maxUnavailable.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RollingUpdateStatefulSetStrategy {
        static instance: RollingUpdateStatefulSetStrategy = RollingUpdateStatefulSetStrategy {
            partition: ::std::option::Option::None,
            maxUnavailable: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RollingUpdateStatefulSetStrategy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RollingUpdateStatefulSetStrategy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RollingUpdateStatefulSetStrategy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpdateStatefulSetStrategy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.StatefulSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatefulSet {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSet.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSet.spec)
    pub spec: ::protobuf::MessageField<StatefulSetSpec>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSet.status)
    pub status: ::protobuf::MessageField<StatefulSetStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.StatefulSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatefulSet {
    fn default() -> &'a StatefulSet {
        <StatefulSet as ::protobuf::Message>::default_instance()
    }
}

impl StatefulSet {
    pub fn new() -> StatefulSet {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.apps.v1.StatefulSetSpec spec = 2;

    pub fn spec(&self) -> &StatefulSetSpec {
        self.spec.as_ref().unwrap_or_else(|| <StatefulSetSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: StatefulSetSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut StatefulSetSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> StatefulSetSpec {
        self.spec.take().unwrap_or_else(|| StatefulSetSpec::new())
    }

    // optional .api.apps.v1.StatefulSetStatus status = 3;

    pub fn status(&self) -> &StatefulSetStatus {
        self.status.as_ref().unwrap_or_else(|| <StatefulSetStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: StatefulSetStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut StatefulSetStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> StatefulSetStatus {
        self.status.take().unwrap_or_else(|| StatefulSetStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &StatefulSet| { &m.metadata },
            |m: &mut StatefulSet| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StatefulSetSpec>(
            "spec",
            |m: &StatefulSet| { &m.spec },
            |m: &mut StatefulSet| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StatefulSetStatus>(
            "status",
            |m: &StatefulSet| { &m.status },
            |m: &mut StatefulSet| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatefulSet>(
            "StatefulSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatefulSet {
    const NAME: &'static str = "StatefulSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatefulSet {
        StatefulSet::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatefulSet {
        static instance: StatefulSet = StatefulSet {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatefulSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatefulSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatefulSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatefulSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.StatefulSetCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatefulSetCondition {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetCondition.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetCondition.status)
    pub status: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetCondition.lastTransitionTime)
    pub lastTransitionTime: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetCondition.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetCondition.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.StatefulSetCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatefulSetCondition {
    fn default() -> &'a StatefulSetCondition {
        <StatefulSetCondition as ::protobuf::Message>::default_instance()
    }
}

impl StatefulSetCondition {
    pub fn new() -> StatefulSetCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

    pub fn lastTransitionTime(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastTransitionTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional string reason = 4;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 5;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &StatefulSetCondition| { &m.type_ },
            |m: &mut StatefulSetCondition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &StatefulSetCondition| { &m.status },
            |m: &mut StatefulSetCondition| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::Time>(
            "lastTransitionTime",
            |m: &StatefulSetCondition| { &m.lastTransitionTime },
            |m: &mut StatefulSetCondition| { &mut m.lastTransitionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &StatefulSetCondition| { &m.reason },
            |m: &mut StatefulSetCondition| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &StatefulSetCondition| { &m.message },
            |m: &mut StatefulSetCondition| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatefulSetCondition>(
            "StatefulSetCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatefulSetCondition {
    const NAME: &'static str = "StatefulSetCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTransitionTime)?;
                },
                34 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatefulSetCondition {
        StatefulSetCondition::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.lastTransitionTime.clear();
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatefulSetCondition {
        static instance: StatefulSetCondition = StatefulSetCondition {
            type_: ::std::option::Option::None,
            status: ::std::option::Option::None,
            lastTransitionTime: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatefulSetCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatefulSetCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatefulSetCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatefulSetCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.StatefulSetList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatefulSetList {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetList.items)
    pub items: ::std::vec::Vec<StatefulSet>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.StatefulSetList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatefulSetList {
    fn default() -> &'a StatefulSetList {
        <StatefulSetList as ::protobuf::Message>::default_instance()
    }
}

impl StatefulSetList {
    pub fn new() -> StatefulSetList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.apps.v1.StatefulSet items = 2;

    pub fn items(&self) -> &[StatefulSet] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<StatefulSet>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<StatefulSet> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<StatefulSet> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &StatefulSetList| { &m.metadata },
            |m: &mut StatefulSetList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &StatefulSetList| { &m.items },
            |m: &mut StatefulSetList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatefulSetList>(
            "StatefulSetList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatefulSetList {
    const NAME: &'static str = "StatefulSetList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatefulSetList {
        StatefulSetList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatefulSetList {
        static instance: StatefulSetList = StatefulSetList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatefulSetList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatefulSetList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatefulSetList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatefulSetList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.StatefulSetOrdinals)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatefulSetOrdinals {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetOrdinals.start)
    pub start: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.StatefulSetOrdinals.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatefulSetOrdinals {
    fn default() -> &'a StatefulSetOrdinals {
        <StatefulSetOrdinals as ::protobuf::Message>::default_instance()
    }
}

impl StatefulSetOrdinals {
    pub fn new() -> StatefulSetOrdinals {
        ::std::default::Default::default()
    }

    // optional int32 start = 1;

    pub fn start(&self) -> i32 {
        self.start.unwrap_or(0)
    }

    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: i32) {
        self.start = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start",
            |m: &StatefulSetOrdinals| { &m.start },
            |m: &mut StatefulSetOrdinals| { &mut m.start },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatefulSetOrdinals>(
            "StatefulSetOrdinals",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatefulSetOrdinals {
    const NAME: &'static str = "StatefulSetOrdinals";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.start = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatefulSetOrdinals {
        StatefulSetOrdinals::new()
    }

    fn clear(&mut self) {
        self.start = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatefulSetOrdinals {
        static instance: StatefulSetOrdinals = StatefulSetOrdinals {
            start: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatefulSetOrdinals {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatefulSetOrdinals").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatefulSetOrdinals {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatefulSetOrdinals {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatefulSetPersistentVolumeClaimRetentionPolicy {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy.whenDeleted)
    pub whenDeleted: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy.whenScaled)
    pub whenScaled: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatefulSetPersistentVolumeClaimRetentionPolicy {
    fn default() -> &'a StatefulSetPersistentVolumeClaimRetentionPolicy {
        <StatefulSetPersistentVolumeClaimRetentionPolicy as ::protobuf::Message>::default_instance()
    }
}

impl StatefulSetPersistentVolumeClaimRetentionPolicy {
    pub fn new() -> StatefulSetPersistentVolumeClaimRetentionPolicy {
        ::std::default::Default::default()
    }

    // optional string whenDeleted = 1;

    pub fn whenDeleted(&self) -> &str {
        match self.whenDeleted.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_whenDeleted(&mut self) {
        self.whenDeleted = ::std::option::Option::None;
    }

    pub fn has_whenDeleted(&self) -> bool {
        self.whenDeleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_whenDeleted(&mut self, v: ::std::string::String) {
        self.whenDeleted = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_whenDeleted(&mut self) -> &mut ::std::string::String {
        if self.whenDeleted.is_none() {
            self.whenDeleted = ::std::option::Option::Some(::std::string::String::new());
        }
        self.whenDeleted.as_mut().unwrap()
    }

    // Take field
    pub fn take_whenDeleted(&mut self) -> ::std::string::String {
        self.whenDeleted.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string whenScaled = 2;

    pub fn whenScaled(&self) -> &str {
        match self.whenScaled.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_whenScaled(&mut self) {
        self.whenScaled = ::std::option::Option::None;
    }

    pub fn has_whenScaled(&self) -> bool {
        self.whenScaled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_whenScaled(&mut self, v: ::std::string::String) {
        self.whenScaled = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_whenScaled(&mut self) -> &mut ::std::string::String {
        if self.whenScaled.is_none() {
            self.whenScaled = ::std::option::Option::Some(::std::string::String::new());
        }
        self.whenScaled.as_mut().unwrap()
    }

    // Take field
    pub fn take_whenScaled(&mut self) -> ::std::string::String {
        self.whenScaled.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "whenDeleted",
            |m: &StatefulSetPersistentVolumeClaimRetentionPolicy| { &m.whenDeleted },
            |m: &mut StatefulSetPersistentVolumeClaimRetentionPolicy| { &mut m.whenDeleted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "whenScaled",
            |m: &StatefulSetPersistentVolumeClaimRetentionPolicy| { &m.whenScaled },
            |m: &mut StatefulSetPersistentVolumeClaimRetentionPolicy| { &mut m.whenScaled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatefulSetPersistentVolumeClaimRetentionPolicy>(
            "StatefulSetPersistentVolumeClaimRetentionPolicy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatefulSetPersistentVolumeClaimRetentionPolicy {
    const NAME: &'static str = "StatefulSetPersistentVolumeClaimRetentionPolicy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.whenDeleted = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.whenScaled = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.whenDeleted.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.whenScaled.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.whenDeleted.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.whenScaled.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatefulSetPersistentVolumeClaimRetentionPolicy {
        StatefulSetPersistentVolumeClaimRetentionPolicy::new()
    }

    fn clear(&mut self) {
        self.whenDeleted = ::std::option::Option::None;
        self.whenScaled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatefulSetPersistentVolumeClaimRetentionPolicy {
        static instance: StatefulSetPersistentVolumeClaimRetentionPolicy = StatefulSetPersistentVolumeClaimRetentionPolicy {
            whenDeleted: ::std::option::Option::None,
            whenScaled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatefulSetPersistentVolumeClaimRetentionPolicy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatefulSetPersistentVolumeClaimRetentionPolicy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatefulSetPersistentVolumeClaimRetentionPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatefulSetPersistentVolumeClaimRetentionPolicy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.StatefulSetSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatefulSetSpec {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetSpec.replicas)
    pub replicas: ::std::option::Option<i32>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetSpec.selector)
    pub selector: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetSpec.template)
    pub template: ::protobuf::MessageField<crate::v1_33::api::core::v1::PodTemplateSpec>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetSpec.volumeClaimTemplates)
    pub volumeClaimTemplates: ::std::vec::Vec<crate::v1_33::api::core::v1::PersistentVolumeClaim>,
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetSpec.serviceName)
    pub serviceName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetSpec.podManagementPolicy)
    pub podManagementPolicy: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetSpec.updateStrategy)
    pub updateStrategy: ::protobuf::MessageField<StatefulSetUpdateStrategy>,
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetSpec.revisionHistoryLimit)
    pub revisionHistoryLimit: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetSpec.minReadySeconds)
    pub minReadySeconds: ::std::option::Option<i32>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetSpec.persistentVolumeClaimRetentionPolicy)
    pub persistentVolumeClaimRetentionPolicy: ::protobuf::MessageField<StatefulSetPersistentVolumeClaimRetentionPolicy>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetSpec.ordinals)
    pub ordinals: ::protobuf::MessageField<StatefulSetOrdinals>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.StatefulSetSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatefulSetSpec {
    fn default() -> &'a StatefulSetSpec {
        <StatefulSetSpec as ::protobuf::Message>::default_instance()
    }
}

impl StatefulSetSpec {
    pub fn new() -> StatefulSetSpec {
        ::std::default::Default::default()
    }

    // optional int32 replicas = 1;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;

    pub fn selector(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    pub fn has_selector(&self) -> bool {
        self.selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.selector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selector(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.mut_or_insert_default()
    }

    // Take field
    pub fn take_selector(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional .api.core.v1.PodTemplateSpec template = 3;

    pub fn template(&self) -> &crate::v1_33::api::core::v1::PodTemplateSpec {
        self.template.as_ref().unwrap_or_else(|| <crate::v1_33::api::core::v1::PodTemplateSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_template(&mut self) {
        self.template.clear();
    }

    pub fn has_template(&self) -> bool {
        self.template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template(&mut self, v: crate::v1_33::api::core::v1::PodTemplateSpec) {
        self.template = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template(&mut self) -> &mut crate::v1_33::api::core::v1::PodTemplateSpec {
        self.template.mut_or_insert_default()
    }

    // Take field
    pub fn take_template(&mut self) -> crate::v1_33::api::core::v1::PodTemplateSpec {
        self.template.take().unwrap_or_else(|| crate::v1_33::api::core::v1::PodTemplateSpec::new())
    }

    // repeated .api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;

    pub fn volumeClaimTemplates(&self) -> &[crate::v1_33::api::core::v1::PersistentVolumeClaim] {
        &self.volumeClaimTemplates
    }

    pub fn clear_volumeClaimTemplates(&mut self) {
        self.volumeClaimTemplates.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumeClaimTemplates(&mut self, v: ::std::vec::Vec<crate::v1_33::api::core::v1::PersistentVolumeClaim>) {
        self.volumeClaimTemplates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumeClaimTemplates(&mut self) -> &mut ::std::vec::Vec<crate::v1_33::api::core::v1::PersistentVolumeClaim> {
        &mut self.volumeClaimTemplates
    }

    // Take field
    pub fn take_volumeClaimTemplates(&mut self) -> ::std::vec::Vec<crate::v1_33::api::core::v1::PersistentVolumeClaim> {
        ::std::mem::replace(&mut self.volumeClaimTemplates, ::std::vec::Vec::new())
    }

    // optional string serviceName = 5;

    pub fn serviceName(&self) -> &str {
        match self.serviceName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_serviceName(&mut self) {
        self.serviceName = ::std::option::Option::None;
    }

    pub fn has_serviceName(&self) -> bool {
        self.serviceName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serviceName(&mut self, v: ::std::string::String) {
        self.serviceName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serviceName(&mut self) -> &mut ::std::string::String {
        if self.serviceName.is_none() {
            self.serviceName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.serviceName.as_mut().unwrap()
    }

    // Take field
    pub fn take_serviceName(&mut self) -> ::std::string::String {
        self.serviceName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string podManagementPolicy = 6;

    pub fn podManagementPolicy(&self) -> &str {
        match self.podManagementPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_podManagementPolicy(&mut self) {
        self.podManagementPolicy = ::std::option::Option::None;
    }

    pub fn has_podManagementPolicy(&self) -> bool {
        self.podManagementPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podManagementPolicy(&mut self, v: ::std::string::String) {
        self.podManagementPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podManagementPolicy(&mut self) -> &mut ::std::string::String {
        if self.podManagementPolicy.is_none() {
            self.podManagementPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.podManagementPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_podManagementPolicy(&mut self) -> ::std::string::String {
        self.podManagementPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.apps.v1.StatefulSetUpdateStrategy updateStrategy = 7;

    pub fn updateStrategy(&self) -> &StatefulSetUpdateStrategy {
        self.updateStrategy.as_ref().unwrap_or_else(|| <StatefulSetUpdateStrategy as ::protobuf::Message>::default_instance())
    }

    pub fn clear_updateStrategy(&mut self) {
        self.updateStrategy.clear();
    }

    pub fn has_updateStrategy(&self) -> bool {
        self.updateStrategy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updateStrategy(&mut self, v: StatefulSetUpdateStrategy) {
        self.updateStrategy = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updateStrategy(&mut self) -> &mut StatefulSetUpdateStrategy {
        self.updateStrategy.mut_or_insert_default()
    }

    // Take field
    pub fn take_updateStrategy(&mut self) -> StatefulSetUpdateStrategy {
        self.updateStrategy.take().unwrap_or_else(|| StatefulSetUpdateStrategy::new())
    }

    // optional int32 revisionHistoryLimit = 8;

    pub fn revisionHistoryLimit(&self) -> i32 {
        self.revisionHistoryLimit.unwrap_or(0)
    }

    pub fn clear_revisionHistoryLimit(&mut self) {
        self.revisionHistoryLimit = ::std::option::Option::None;
    }

    pub fn has_revisionHistoryLimit(&self) -> bool {
        self.revisionHistoryLimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revisionHistoryLimit(&mut self, v: i32) {
        self.revisionHistoryLimit = ::std::option::Option::Some(v);
    }

    // optional int32 minReadySeconds = 9;

    pub fn minReadySeconds(&self) -> i32 {
        self.minReadySeconds.unwrap_or(0)
    }

    pub fn clear_minReadySeconds(&mut self) {
        self.minReadySeconds = ::std::option::Option::None;
    }

    pub fn has_minReadySeconds(&self) -> bool {
        self.minReadySeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minReadySeconds(&mut self, v: i32) {
        self.minReadySeconds = ::std::option::Option::Some(v);
    }

    // optional .api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy persistentVolumeClaimRetentionPolicy = 10;

    pub fn persistentVolumeClaimRetentionPolicy(&self) -> &StatefulSetPersistentVolumeClaimRetentionPolicy {
        self.persistentVolumeClaimRetentionPolicy.as_ref().unwrap_or_else(|| <StatefulSetPersistentVolumeClaimRetentionPolicy as ::protobuf::Message>::default_instance())
    }

    pub fn clear_persistentVolumeClaimRetentionPolicy(&mut self) {
        self.persistentVolumeClaimRetentionPolicy.clear();
    }

    pub fn has_persistentVolumeClaimRetentionPolicy(&self) -> bool {
        self.persistentVolumeClaimRetentionPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persistentVolumeClaimRetentionPolicy(&mut self, v: StatefulSetPersistentVolumeClaimRetentionPolicy) {
        self.persistentVolumeClaimRetentionPolicy = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persistentVolumeClaimRetentionPolicy(&mut self) -> &mut StatefulSetPersistentVolumeClaimRetentionPolicy {
        self.persistentVolumeClaimRetentionPolicy.mut_or_insert_default()
    }

    // Take field
    pub fn take_persistentVolumeClaimRetentionPolicy(&mut self) -> StatefulSetPersistentVolumeClaimRetentionPolicy {
        self.persistentVolumeClaimRetentionPolicy.take().unwrap_or_else(|| StatefulSetPersistentVolumeClaimRetentionPolicy::new())
    }

    // optional .api.apps.v1.StatefulSetOrdinals ordinals = 11;

    pub fn ordinals(&self) -> &StatefulSetOrdinals {
        self.ordinals.as_ref().unwrap_or_else(|| <StatefulSetOrdinals as ::protobuf::Message>::default_instance())
    }

    pub fn clear_ordinals(&mut self) {
        self.ordinals.clear();
    }

    pub fn has_ordinals(&self) -> bool {
        self.ordinals.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinals(&mut self, v: StatefulSetOrdinals) {
        self.ordinals = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ordinals(&mut self) -> &mut StatefulSetOrdinals {
        self.ordinals.mut_or_insert_default()
    }

    // Take field
    pub fn take_ordinals(&mut self) -> StatefulSetOrdinals {
        self.ordinals.take().unwrap_or_else(|| StatefulSetOrdinals::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &StatefulSetSpec| { &m.replicas },
            |m: &mut StatefulSetSpec| { &mut m.replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "selector",
            |m: &StatefulSetSpec| { &m.selector },
            |m: &mut StatefulSetSpec| { &mut m.selector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::api::core::v1::PodTemplateSpec>(
            "template",
            |m: &StatefulSetSpec| { &m.template },
            |m: &mut StatefulSetSpec| { &mut m.template },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "volumeClaimTemplates",
            |m: &StatefulSetSpec| { &m.volumeClaimTemplates },
            |m: &mut StatefulSetSpec| { &mut m.volumeClaimTemplates },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serviceName",
            |m: &StatefulSetSpec| { &m.serviceName },
            |m: &mut StatefulSetSpec| { &mut m.serviceName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "podManagementPolicy",
            |m: &StatefulSetSpec| { &m.podManagementPolicy },
            |m: &mut StatefulSetSpec| { &mut m.podManagementPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StatefulSetUpdateStrategy>(
            "updateStrategy",
            |m: &StatefulSetSpec| { &m.updateStrategy },
            |m: &mut StatefulSetSpec| { &mut m.updateStrategy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revisionHistoryLimit",
            |m: &StatefulSetSpec| { &m.revisionHistoryLimit },
            |m: &mut StatefulSetSpec| { &mut m.revisionHistoryLimit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minReadySeconds",
            |m: &StatefulSetSpec| { &m.minReadySeconds },
            |m: &mut StatefulSetSpec| { &mut m.minReadySeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StatefulSetPersistentVolumeClaimRetentionPolicy>(
            "persistentVolumeClaimRetentionPolicy",
            |m: &StatefulSetSpec| { &m.persistentVolumeClaimRetentionPolicy },
            |m: &mut StatefulSetSpec| { &mut m.persistentVolumeClaimRetentionPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StatefulSetOrdinals>(
            "ordinals",
            |m: &StatefulSetSpec| { &m.ordinals },
            |m: &mut StatefulSetSpec| { &mut m.ordinals },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatefulSetSpec>(
            "StatefulSetSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatefulSetSpec {
    const NAME: &'static str = "StatefulSetSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.selector)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.template)?;
                },
                34 => {
                    self.volumeClaimTemplates.push(is.read_message()?);
                },
                42 => {
                    self.serviceName = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.podManagementPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.updateStrategy)?;
                },
                64 => {
                    self.revisionHistoryLimit = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.minReadySeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.persistentVolumeClaimRetentionPolicy)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ordinals)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.volumeClaimTemplates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.serviceName.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.podManagementPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.updateStrategy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.revisionHistoryLimit {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.minReadySeconds {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.persistentVolumeClaimRetentionPolicy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ordinals.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.replicas {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.selector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.template.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.volumeClaimTemplates {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.serviceName.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.podManagementPolicy.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.updateStrategy.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.revisionHistoryLimit {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.minReadySeconds {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.persistentVolumeClaimRetentionPolicy.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.ordinals.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatefulSetSpec {
        StatefulSetSpec::new()
    }

    fn clear(&mut self) {
        self.replicas = ::std::option::Option::None;
        self.selector.clear();
        self.template.clear();
        self.volumeClaimTemplates.clear();
        self.serviceName = ::std::option::Option::None;
        self.podManagementPolicy = ::std::option::Option::None;
        self.updateStrategy.clear();
        self.revisionHistoryLimit = ::std::option::Option::None;
        self.minReadySeconds = ::std::option::Option::None;
        self.persistentVolumeClaimRetentionPolicy.clear();
        self.ordinals.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatefulSetSpec {
        static instance: StatefulSetSpec = StatefulSetSpec {
            replicas: ::std::option::Option::None,
            selector: ::protobuf::MessageField::none(),
            template: ::protobuf::MessageField::none(),
            volumeClaimTemplates: ::std::vec::Vec::new(),
            serviceName: ::std::option::Option::None,
            podManagementPolicy: ::std::option::Option::None,
            updateStrategy: ::protobuf::MessageField::none(),
            revisionHistoryLimit: ::std::option::Option::None,
            minReadySeconds: ::std::option::Option::None,
            persistentVolumeClaimRetentionPolicy: ::protobuf::MessageField::none(),
            ordinals: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatefulSetSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatefulSetSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatefulSetSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatefulSetSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.StatefulSetStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatefulSetStatus {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetStatus.observedGeneration)
    pub observedGeneration: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetStatus.replicas)
    pub replicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetStatus.readyReplicas)
    pub readyReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetStatus.currentReplicas)
    pub currentReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetStatus.updatedReplicas)
    pub updatedReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetStatus.currentRevision)
    pub currentRevision: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetStatus.updateRevision)
    pub updateRevision: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetStatus.collisionCount)
    pub collisionCount: ::std::option::Option<i32>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetStatus.conditions)
    pub conditions: ::std::vec::Vec<StatefulSetCondition>,
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetStatus.availableReplicas)
    pub availableReplicas: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.StatefulSetStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatefulSetStatus {
    fn default() -> &'a StatefulSetStatus {
        <StatefulSetStatus as ::protobuf::Message>::default_instance()
    }
}

impl StatefulSetStatus {
    pub fn new() -> StatefulSetStatus {
        ::std::default::Default::default()
    }

    // optional int64 observedGeneration = 1;

    pub fn observedGeneration(&self) -> i64 {
        self.observedGeneration.unwrap_or(0)
    }

    pub fn clear_observedGeneration(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
    }

    pub fn has_observedGeneration(&self) -> bool {
        self.observedGeneration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observedGeneration(&mut self, v: i64) {
        self.observedGeneration = ::std::option::Option::Some(v);
    }

    // optional int32 replicas = 2;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // optional int32 readyReplicas = 3;

    pub fn readyReplicas(&self) -> i32 {
        self.readyReplicas.unwrap_or(0)
    }

    pub fn clear_readyReplicas(&mut self) {
        self.readyReplicas = ::std::option::Option::None;
    }

    pub fn has_readyReplicas(&self) -> bool {
        self.readyReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readyReplicas(&mut self, v: i32) {
        self.readyReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 currentReplicas = 4;

    pub fn currentReplicas(&self) -> i32 {
        self.currentReplicas.unwrap_or(0)
    }

    pub fn clear_currentReplicas(&mut self) {
        self.currentReplicas = ::std::option::Option::None;
    }

    pub fn has_currentReplicas(&self) -> bool {
        self.currentReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currentReplicas(&mut self, v: i32) {
        self.currentReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 updatedReplicas = 5;

    pub fn updatedReplicas(&self) -> i32 {
        self.updatedReplicas.unwrap_or(0)
    }

    pub fn clear_updatedReplicas(&mut self) {
        self.updatedReplicas = ::std::option::Option::None;
    }

    pub fn has_updatedReplicas(&self) -> bool {
        self.updatedReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updatedReplicas(&mut self, v: i32) {
        self.updatedReplicas = ::std::option::Option::Some(v);
    }

    // optional string currentRevision = 6;

    pub fn currentRevision(&self) -> &str {
        match self.currentRevision.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_currentRevision(&mut self) {
        self.currentRevision = ::std::option::Option::None;
    }

    pub fn has_currentRevision(&self) -> bool {
        self.currentRevision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currentRevision(&mut self, v: ::std::string::String) {
        self.currentRevision = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_currentRevision(&mut self) -> &mut ::std::string::String {
        if self.currentRevision.is_none() {
            self.currentRevision = ::std::option::Option::Some(::std::string::String::new());
        }
        self.currentRevision.as_mut().unwrap()
    }

    // Take field
    pub fn take_currentRevision(&mut self) -> ::std::string::String {
        self.currentRevision.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string updateRevision = 7;

    pub fn updateRevision(&self) -> &str {
        match self.updateRevision.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_updateRevision(&mut self) {
        self.updateRevision = ::std::option::Option::None;
    }

    pub fn has_updateRevision(&self) -> bool {
        self.updateRevision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updateRevision(&mut self, v: ::std::string::String) {
        self.updateRevision = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updateRevision(&mut self) -> &mut ::std::string::String {
        if self.updateRevision.is_none() {
            self.updateRevision = ::std::option::Option::Some(::std::string::String::new());
        }
        self.updateRevision.as_mut().unwrap()
    }

    // Take field
    pub fn take_updateRevision(&mut self) -> ::std::string::String {
        self.updateRevision.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 collisionCount = 9;

    pub fn collisionCount(&self) -> i32 {
        self.collisionCount.unwrap_or(0)
    }

    pub fn clear_collisionCount(&mut self) {
        self.collisionCount = ::std::option::Option::None;
    }

    pub fn has_collisionCount(&self) -> bool {
        self.collisionCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_collisionCount(&mut self, v: i32) {
        self.collisionCount = ::std::option::Option::Some(v);
    }

    // repeated .api.apps.v1.StatefulSetCondition conditions = 10;

    pub fn conditions(&self) -> &[StatefulSetCondition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<StatefulSetCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<StatefulSetCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<StatefulSetCondition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    // optional int32 availableReplicas = 11;

    pub fn availableReplicas(&self) -> i32 {
        self.availableReplicas.unwrap_or(0)
    }

    pub fn clear_availableReplicas(&mut self) {
        self.availableReplicas = ::std::option::Option::None;
    }

    pub fn has_availableReplicas(&self) -> bool {
        self.availableReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_availableReplicas(&mut self, v: i32) {
        self.availableReplicas = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "observedGeneration",
            |m: &StatefulSetStatus| { &m.observedGeneration },
            |m: &mut StatefulSetStatus| { &mut m.observedGeneration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &StatefulSetStatus| { &m.replicas },
            |m: &mut StatefulSetStatus| { &mut m.replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readyReplicas",
            |m: &StatefulSetStatus| { &m.readyReplicas },
            |m: &mut StatefulSetStatus| { &mut m.readyReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currentReplicas",
            |m: &StatefulSetStatus| { &m.currentReplicas },
            |m: &mut StatefulSetStatus| { &mut m.currentReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "updatedReplicas",
            |m: &StatefulSetStatus| { &m.updatedReplicas },
            |m: &mut StatefulSetStatus| { &mut m.updatedReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currentRevision",
            |m: &StatefulSetStatus| { &m.currentRevision },
            |m: &mut StatefulSetStatus| { &mut m.currentRevision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "updateRevision",
            |m: &StatefulSetStatus| { &m.updateRevision },
            |m: &mut StatefulSetStatus| { &mut m.updateRevision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "collisionCount",
            |m: &StatefulSetStatus| { &m.collisionCount },
            |m: &mut StatefulSetStatus| { &mut m.collisionCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &StatefulSetStatus| { &m.conditions },
            |m: &mut StatefulSetStatus| { &mut m.conditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "availableReplicas",
            |m: &StatefulSetStatus| { &m.availableReplicas },
            |m: &mut StatefulSetStatus| { &mut m.availableReplicas },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatefulSetStatus>(
            "StatefulSetStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatefulSetStatus {
    const NAME: &'static str = "StatefulSetStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.observedGeneration = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.readyReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.currentReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.updatedReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    self.currentRevision = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.updateRevision = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.collisionCount = ::std::option::Option::Some(is.read_int32()?);
                },
                82 => {
                    self.conditions.push(is.read_message()?);
                },
                88 => {
                    self.availableReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.observedGeneration {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.readyReplicas {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.currentReplicas {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.updatedReplicas {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.currentRevision.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.updateRevision.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.collisionCount {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.availableReplicas {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.observedGeneration {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.replicas {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.readyReplicas {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.currentReplicas {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.updatedReplicas {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.currentRevision.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.updateRevision.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.collisionCount {
            os.write_int32(9, v)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        if let Some(v) = self.availableReplicas {
            os.write_int32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatefulSetStatus {
        StatefulSetStatus::new()
    }

    fn clear(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
        self.replicas = ::std::option::Option::None;
        self.readyReplicas = ::std::option::Option::None;
        self.currentReplicas = ::std::option::Option::None;
        self.updatedReplicas = ::std::option::Option::None;
        self.currentRevision = ::std::option::Option::None;
        self.updateRevision = ::std::option::Option::None;
        self.collisionCount = ::std::option::Option::None;
        self.conditions.clear();
        self.availableReplicas = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatefulSetStatus {
        static instance: StatefulSetStatus = StatefulSetStatus {
            observedGeneration: ::std::option::Option::None,
            replicas: ::std::option::Option::None,
            readyReplicas: ::std::option::Option::None,
            currentReplicas: ::std::option::Option::None,
            updatedReplicas: ::std::option::Option::None,
            currentRevision: ::std::option::Option::None,
            updateRevision: ::std::option::Option::None,
            collisionCount: ::std::option::Option::None,
            conditions: ::std::vec::Vec::new(),
            availableReplicas: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatefulSetStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatefulSetStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatefulSetStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatefulSetStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1.StatefulSetUpdateStrategy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatefulSetUpdateStrategy {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetUpdateStrategy.type)
    pub type_: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1.StatefulSetUpdateStrategy.rollingUpdate)
    pub rollingUpdate: ::protobuf::MessageField<RollingUpdateStatefulSetStrategy>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1.StatefulSetUpdateStrategy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatefulSetUpdateStrategy {
    fn default() -> &'a StatefulSetUpdateStrategy {
        <StatefulSetUpdateStrategy as ::protobuf::Message>::default_instance()
    }
}

impl StatefulSetUpdateStrategy {
    pub fn new() -> StatefulSetUpdateStrategy {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.apps.v1.RollingUpdateStatefulSetStrategy rollingUpdate = 2;

    pub fn rollingUpdate(&self) -> &RollingUpdateStatefulSetStrategy {
        self.rollingUpdate.as_ref().unwrap_or_else(|| <RollingUpdateStatefulSetStrategy as ::protobuf::Message>::default_instance())
    }

    pub fn clear_rollingUpdate(&mut self) {
        self.rollingUpdate.clear();
    }

    pub fn has_rollingUpdate(&self) -> bool {
        self.rollingUpdate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollingUpdate(&mut self, v: RollingUpdateStatefulSetStrategy) {
        self.rollingUpdate = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollingUpdate(&mut self) -> &mut RollingUpdateStatefulSetStrategy {
        self.rollingUpdate.mut_or_insert_default()
    }

    // Take field
    pub fn take_rollingUpdate(&mut self) -> RollingUpdateStatefulSetStrategy {
        self.rollingUpdate.take().unwrap_or_else(|| RollingUpdateStatefulSetStrategy::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &StatefulSetUpdateStrategy| { &m.type_ },
            |m: &mut StatefulSetUpdateStrategy| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RollingUpdateStatefulSetStrategy>(
            "rollingUpdate",
            |m: &StatefulSetUpdateStrategy| { &m.rollingUpdate },
            |m: &mut StatefulSetUpdateStrategy| { &mut m.rollingUpdate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatefulSetUpdateStrategy>(
            "StatefulSetUpdateStrategy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatefulSetUpdateStrategy {
    const NAME: &'static str = "StatefulSetUpdateStrategy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rollingUpdate)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.rollingUpdate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.rollingUpdate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatefulSetUpdateStrategy {
        StatefulSetUpdateStrategy::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.rollingUpdate.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatefulSetUpdateStrategy {
        static instance: StatefulSetUpdateStrategy = StatefulSetUpdateStrategy {
            type_: ::std::option::Option::None,
            rollingUpdate: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatefulSetUpdateStrategy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatefulSetUpdateStrategy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatefulSetUpdateStrategy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatefulSetUpdateStrategy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1bapi/apps/v1/generated.proto\x12\x0bapi.apps.v1\x1a\x1bapi/core/v1/\
    generated.proto\x1a-apimachinery/pkg/apis/meta/v1/generated.proto\x1a(ap\
    imachinery/pkg/runtime/generated.proto\x1a/apimachinery/pkg/runtime/sche\
    ma/generated.proto\x1a,apimachinery/pkg/util/intstr/generated.proto\"\
    \xb3\x01\n\x12ControllerRevision\x12E\n\x08metadata\x18\x01\x20\x01(\x0b\
    2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12:\n\x04data\
    \x18\x02\x20\x01(\x0b2&.apimachinery.pkg.runtime.RawExtensionR\x04data\
    \x12\x1a\n\x08revision\x18\x03\x20\x01(\x03R\x08revision\"\x94\x01\n\x16\
    ControllerRevisionList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimach\
    inery.pkg.apis.meta.v1.ListMetaR\x08metadata\x125\n\x05items\x18\x02\x20\
    \x03(\x0b2\x1f.api.apps.v1.ControllerRevisionR\x05items\"\xb8\x01\n\tDae\
    monSet\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.m\
    eta.v1.ObjectMetaR\x08metadata\x12.\n\x04spec\x18\x02\x20\x01(\x0b2\x1a.\
    api.apps.v1.DaemonSetSpecR\x04spec\x124\n\x06status\x18\x03\x20\x01(\x0b\
    2\x1c.api.apps.v1.DaemonSetStatusR\x06status\"\xc7\x01\n\x12DaemonSetCon\
    dition\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12\x16\n\x06status\
    \x18\x02\x20\x01(\tR\x06status\x12S\n\x12lastTransitionTime\x18\x03\x20\
    \x01(\x0b2#.apimachinery.pkg.apis.meta.v1.TimeR\x12lastTransitionTime\
    \x12\x16\n\x06reason\x18\x04\x20\x01(\tR\x06reason\x12\x18\n\x07message\
    \x18\x05\x20\x01(\tR\x07message\"\x82\x01\n\rDaemonSetList\x12C\n\x08met\
    adata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMetaR\x08\
    metadata\x12,\n\x05items\x18\x02\x20\x03(\x0b2\x16.api.apps.v1.DaemonSet\
    R\x05items\"\xbf\x02\n\rDaemonSetSpec\x12H\n\x08selector\x18\x01\x20\x01\
    (\x0b2,.apimachinery.pkg.apis.meta.v1.LabelSelectorR\x08selector\x128\n\
    \x08template\x18\x02\x20\x01(\x0b2\x1c.api.core.v1.PodTemplateSpecR\x08t\
    emplate\x12L\n\x0eupdateStrategy\x18\x03\x20\x01(\x0b2$.api.apps.v1.Daem\
    onSetUpdateStrategyR\x0eupdateStrategy\x12(\n\x0fminReadySeconds\x18\x04\
    \x20\x01(\x05R\x0fminReadySeconds\x122\n\x14revisionHistoryLimit\x18\x06\
    \x20\x01(\x05R\x14revisionHistoryLimit\"\xfc\x03\n\x0fDaemonSetStatus\
    \x126\n\x16currentNumberScheduled\x18\x01\x20\x01(\x05R\x16currentNumber\
    Scheduled\x12.\n\x12numberMisscheduled\x18\x02\x20\x01(\x05R\x12numberMi\
    sscheduled\x126\n\x16desiredNumberScheduled\x18\x03\x20\x01(\x05R\x16des\
    iredNumberScheduled\x12\x20\n\x0bnumberReady\x18\x04\x20\x01(\x05R\x0bnu\
    mberReady\x12.\n\x12observedGeneration\x18\x05\x20\x01(\x03R\x12observed\
    Generation\x126\n\x16updatedNumberScheduled\x18\x06\x20\x01(\x05R\x16upd\
    atedNumberScheduled\x12(\n\x0fnumberAvailable\x18\x07\x20\x01(\x05R\x0fn\
    umberAvailable\x12,\n\x11numberUnavailable\x18\x08\x20\x01(\x05R\x11numb\
    erUnavailable\x12&\n\x0ecollisionCount\x18\t\x20\x01(\x05R\x0ecollisionC\
    ount\x12?\n\nconditions\x18\n\x20\x03(\x0b2\x1f.api.apps.v1.DaemonSetCon\
    ditionR\nconditions\"x\n\x17DaemonSetUpdateStrategy\x12\x12\n\x04type\
    \x18\x01\x20\x01(\tR\x04type\x12I\n\rrollingUpdate\x18\x02\x20\x01(\x0b2\
    #.api.apps.v1.RollingUpdateDaemonSetR\rrollingUpdate\"\xbb\x01\n\nDeploy\
    ment\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.met\
    a.v1.ObjectMetaR\x08metadata\x12/\n\x04spec\x18\x02\x20\x01(\x0b2\x1b.ap\
    i.apps.v1.DeploymentSpecR\x04spec\x125\n\x06status\x18\x03\x20\x01(\x0b2\
    \x1d.api.apps.v1.DeploymentStatusR\x06status\"\x95\x02\n\x13DeploymentCo\
    ndition\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12\x16\n\x06statu\
    s\x18\x02\x20\x01(\tR\x06status\x12K\n\x0elastUpdateTime\x18\x06\x20\x01\
    (\x0b2#.apimachinery.pkg.apis.meta.v1.TimeR\x0elastUpdateTime\x12S\n\x12\
    lastTransitionTime\x18\x07\x20\x01(\x0b2#.apimachinery.pkg.apis.meta.v1.\
    TimeR\x12lastTransitionTime\x12\x16\n\x06reason\x18\x04\x20\x01(\tR\x06r\
    eason\x12\x18\n\x07message\x18\x05\x20\x01(\tR\x07message\"\x84\x01\n\
    \x0eDeploymentList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachiner\
    y.pkg.apis.meta.v1.ListMetaR\x08metadata\x12-\n\x05items\x18\x02\x20\x03\
    (\x0b2\x17.api.apps.v1.DeploymentR\x05items\"\x9d\x03\n\x0eDeploymentSpe\
    c\x12\x1a\n\x08replicas\x18\x01\x20\x01(\x05R\x08replicas\x12H\n\x08sele\
    ctor\x18\x02\x20\x01(\x0b2,.apimachinery.pkg.apis.meta.v1.LabelSelectorR\
    \x08selector\x128\n\x08template\x18\x03\x20\x01(\x0b2\x1c.api.core.v1.Po\
    dTemplateSpecR\x08template\x12;\n\x08strategy\x18\x04\x20\x01(\x0b2\x1f.\
    api.apps.v1.DeploymentStrategyR\x08strategy\x12(\n\x0fminReadySeconds\
    \x18\x05\x20\x01(\x05R\x0fminReadySeconds\x122\n\x14revisionHistoryLimit\
    \x18\x06\x20\x01(\x05R\x14revisionHistoryLimit\x12\x16\n\x06paused\x18\
    \x07\x20\x01(\x08R\x06paused\x128\n\x17progressDeadlineSeconds\x18\t\x20\
    \x01(\x05R\x17progressDeadlineSeconds\"\xaa\x03\n\x10DeploymentStatus\
    \x12.\n\x12observedGeneration\x18\x01\x20\x01(\x03R\x12observedGeneratio\
    n\x12\x1a\n\x08replicas\x18\x02\x20\x01(\x05R\x08replicas\x12(\n\x0fupda\
    tedReplicas\x18\x03\x20\x01(\x05R\x0fupdatedReplicas\x12$\n\rreadyReplic\
    as\x18\x07\x20\x01(\x05R\rreadyReplicas\x12,\n\x11availableReplicas\x18\
    \x04\x20\x01(\x05R\x11availableReplicas\x120\n\x13unavailableReplicas\
    \x18\x05\x20\x01(\x05R\x13unavailableReplicas\x120\n\x13terminatingRepli\
    cas\x18\t\x20\x01(\x05R\x13terminatingReplicas\x12@\n\nconditions\x18\
    \x06\x20\x03(\x0b2\x20.api.apps.v1.DeploymentConditionR\nconditions\x12&\
    \n\x0ecollisionCount\x18\x08\x20\x01(\x05R\x0ecollisionCount\"t\n\x12Dep\
    loymentStrategy\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12J\n\rro\
    llingUpdate\x18\x02\x20\x01(\x0b2$.api.apps.v1.RollingUpdateDeploymentR\
    \rrollingUpdate\"\xbb\x01\n\nReplicaSet\x12E\n\x08metadata\x18\x01\x20\
    \x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12/\n\
    \x04spec\x18\x02\x20\x01(\x0b2\x1b.api.apps.v1.ReplicaSetSpecR\x04spec\
    \x125\n\x06status\x18\x03\x20\x01(\x0b2\x1d.api.apps.v1.ReplicaSetStatus\
    R\x06status\"\xc8\x01\n\x13ReplicaSetCondition\x12\x12\n\x04type\x18\x01\
    \x20\x01(\tR\x04type\x12\x16\n\x06status\x18\x02\x20\x01(\tR\x06status\
    \x12S\n\x12lastTransitionTime\x18\x03\x20\x01(\x0b2#.apimachinery.pkg.ap\
    is.meta.v1.TimeR\x12lastTransitionTime\x12\x16\n\x06reason\x18\x04\x20\
    \x01(\tR\x06reason\x12\x18\n\x07message\x18\x05\x20\x01(\tR\x07message\"\
    \x84\x01\n\x0eReplicaSetList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.a\
    pimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12-\n\x05items\x18\
    \x02\x20\x03(\x0b2\x17.api.apps.v1.ReplicaSetR\x05items\"\xda\x01\n\x0eR\
    eplicaSetSpec\x12\x1a\n\x08replicas\x18\x01\x20\x01(\x05R\x08replicas\
    \x12(\n\x0fminReadySeconds\x18\x04\x20\x01(\x05R\x0fminReadySeconds\x12H\
    \n\x08selector\x18\x02\x20\x01(\x0b2,.apimachinery.pkg.apis.meta.v1.Labe\
    lSelectorR\x08selector\x128\n\x08template\x18\x03\x20\x01(\x0b2\x1c.api.\
    core.v1.PodTemplateSpecR\x08template\"\xda\x02\n\x10ReplicaSetStatus\x12\
    \x1a\n\x08replicas\x18\x01\x20\x01(\x05R\x08replicas\x122\n\x14fullyLabe\
    ledReplicas\x18\x02\x20\x01(\x05R\x14fullyLabeledReplicas\x12$\n\rreadyR\
    eplicas\x18\x04\x20\x01(\x05R\rreadyReplicas\x12,\n\x11availableReplicas\
    \x18\x05\x20\x01(\x05R\x11availableReplicas\x120\n\x13terminatingReplica\
    s\x18\x07\x20\x01(\x05R\x13terminatingReplicas\x12.\n\x12observedGenerat\
    ion\x18\x03\x20\x01(\x03R\x12observedGeneration\x12@\n\nconditions\x18\
    \x06\x20\x03(\x0b2\x20.api.apps.v1.ReplicaSetConditionR\nconditions\"\
    \xb2\x01\n\x16RollingUpdateDaemonSet\x12Q\n\x0emaxUnavailable\x18\x01\
    \x20\x01(\x0b2).apimachinery.pkg.util.intstr.IntOrStringR\x0emaxUnavaila\
    ble\x12E\n\x08maxSurge\x18\x02\x20\x01(\x0b2).apimachinery.pkg.util.ints\
    tr.IntOrStringR\x08maxSurge\"\xb3\x01\n\x17RollingUpdateDeployment\x12Q\
    \n\x0emaxUnavailable\x18\x01\x20\x01(\x0b2).apimachinery.pkg.util.intstr\
    .IntOrStringR\x0emaxUnavailable\x12E\n\x08maxSurge\x18\x02\x20\x01(\x0b2\
    ).apimachinery.pkg.util.intstr.IntOrStringR\x08maxSurge\"\x93\x01\n\x20R\
    ollingUpdateStatefulSetStrategy\x12\x1c\n\tpartition\x18\x01\x20\x01(\
    \x05R\tpartition\x12Q\n\x0emaxUnavailable\x18\x02\x20\x01(\x0b2).apimach\
    inery.pkg.util.intstr.IntOrStringR\x0emaxUnavailable\"\xbe\x01\n\x0bStat\
    efulSet\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.\
    meta.v1.ObjectMetaR\x08metadata\x120\n\x04spec\x18\x02\x20\x01(\x0b2\x1c\
    .api.apps.v1.StatefulSetSpecR\x04spec\x126\n\x06status\x18\x03\x20\x01(\
    \x0b2\x1e.api.apps.v1.StatefulSetStatusR\x06status\"\xc9\x01\n\x14Statef\
    ulSetCondition\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12\x16\n\
    \x06status\x18\x02\x20\x01(\tR\x06status\x12S\n\x12lastTransitionTime\
    \x18\x03\x20\x01(\x0b2#.apimachinery.pkg.apis.meta.v1.TimeR\x12lastTrans\
    itionTime\x12\x16\n\x06reason\x18\x04\x20\x01(\tR\x06reason\x12\x18\n\
    \x07message\x18\x05\x20\x01(\tR\x07message\"\x86\x01\n\x0fStatefulSetLis\
    t\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v\
    1.ListMetaR\x08metadata\x12.\n\x05items\x18\x02\x20\x03(\x0b2\x18.api.ap\
    ps.v1.StatefulSetR\x05items\"+\n\x13StatefulSetOrdinals\x12\x14\n\x05sta\
    rt\x18\x01\x20\x01(\x05R\x05start\"s\n/StatefulSetPersistentVolumeClaimR\
    etentionPolicy\x12\x20\n\x0bwhenDeleted\x18\x01\x20\x01(\tR\x0bwhenDelet\
    ed\x12\x1e\n\nwhenScaled\x18\x02\x20\x01(\tR\nwhenScaled\"\xdc\x05\n\x0f\
    StatefulSetSpec\x12\x1a\n\x08replicas\x18\x01\x20\x01(\x05R\x08replicas\
    \x12H\n\x08selector\x18\x02\x20\x01(\x0b2,.apimachinery.pkg.apis.meta.v1\
    .LabelSelectorR\x08selector\x128\n\x08template\x18\x03\x20\x01(\x0b2\x1c\
    .api.core.v1.PodTemplateSpecR\x08template\x12V\n\x14volumeClaimTemplates\
    \x18\x04\x20\x03(\x0b2\".api.core.v1.PersistentVolumeClaimR\x14volumeCla\
    imTemplates\x12\x20\n\x0bserviceName\x18\x05\x20\x01(\tR\x0bserviceName\
    \x120\n\x13podManagementPolicy\x18\x06\x20\x01(\tR\x13podManagementPolic\
    y\x12N\n\x0eupdateStrategy\x18\x07\x20\x01(\x0b2&.api.apps.v1.StatefulSe\
    tUpdateStrategyR\x0eupdateStrategy\x122\n\x14revisionHistoryLimit\x18\
    \x08\x20\x01(\x05R\x14revisionHistoryLimit\x12(\n\x0fminReadySeconds\x18\
    \t\x20\x01(\x05R\x0fminReadySeconds\x12\x90\x01\n$persistentVolumeClaimR\
    etentionPolicy\x18\n\x20\x01(\x0b2<.api.apps.v1.StatefulSetPersistentVol\
    umeClaimRetentionPolicyR$persistentVolumeClaimRetentionPolicy\x12<\n\x08\
    ordinals\x18\x0b\x20\x01(\x0b2\x20.api.apps.v1.StatefulSetOrdinalsR\x08o\
    rdinals\"\xc4\x03\n\x11StatefulSetStatus\x12.\n\x12observedGeneration\
    \x18\x01\x20\x01(\x03R\x12observedGeneration\x12\x1a\n\x08replicas\x18\
    \x02\x20\x01(\x05R\x08replicas\x12$\n\rreadyReplicas\x18\x03\x20\x01(\
    \x05R\rreadyReplicas\x12(\n\x0fcurrentReplicas\x18\x04\x20\x01(\x05R\x0f\
    currentReplicas\x12(\n\x0fupdatedReplicas\x18\x05\x20\x01(\x05R\x0fupdat\
    edReplicas\x12(\n\x0fcurrentRevision\x18\x06\x20\x01(\tR\x0fcurrentRevis\
    ion\x12&\n\x0eupdateRevision\x18\x07\x20\x01(\tR\x0eupdateRevision\x12&\
    \n\x0ecollisionCount\x18\t\x20\x01(\x05R\x0ecollisionCount\x12A\n\ncondi\
    tions\x18\n\x20\x03(\x0b2!.api.apps.v1.StatefulSetConditionR\nconditions\
    \x12,\n\x11availableReplicas\x18\x0b\x20\x01(\x05R\x11availableReplicas\
    \"\x84\x01\n\x19StatefulSetUpdateStrategy\x12\x12\n\x04type\x18\x01\x20\
    \x01(\tR\x04type\x12S\n\rrollingUpdate\x18\x02\x20\x01(\x0b2-.api.apps.v\
    1.RollingUpdateStatefulSetStrategyR\rrollingUpdateB\x14Z\x12k8s.io/api/a\
    pps/v1\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(5);
            deps.push(super::v1::file_descriptor().clone());
            deps.push(super::v1::file_descriptor().clone());
            deps.push(super::v1::file_descriptor().clone());
            deps.push(super::v1::file_descriptor().clone());
            deps.push(super::v1::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(30);
            messages.push(ControllerRevision::generated_message_descriptor_data());
            messages.push(ControllerRevisionList::generated_message_descriptor_data());
            messages.push(DaemonSet::generated_message_descriptor_data());
            messages.push(DaemonSetCondition::generated_message_descriptor_data());
            messages.push(DaemonSetList::generated_message_descriptor_data());
            messages.push(DaemonSetSpec::generated_message_descriptor_data());
            messages.push(DaemonSetStatus::generated_message_descriptor_data());
            messages.push(DaemonSetUpdateStrategy::generated_message_descriptor_data());
            messages.push(Deployment::generated_message_descriptor_data());
            messages.push(DeploymentCondition::generated_message_descriptor_data());
            messages.push(DeploymentList::generated_message_descriptor_data());
            messages.push(DeploymentSpec::generated_message_descriptor_data());
            messages.push(DeploymentStatus::generated_message_descriptor_data());
            messages.push(DeploymentStrategy::generated_message_descriptor_data());
            messages.push(ReplicaSet::generated_message_descriptor_data());
            messages.push(ReplicaSetCondition::generated_message_descriptor_data());
            messages.push(ReplicaSetList::generated_message_descriptor_data());
            messages.push(ReplicaSetSpec::generated_message_descriptor_data());
            messages.push(ReplicaSetStatus::generated_message_descriptor_data());
            messages.push(RollingUpdateDaemonSet::generated_message_descriptor_data());
            messages.push(RollingUpdateDeployment::generated_message_descriptor_data());
            messages.push(RollingUpdateStatefulSetStrategy::generated_message_descriptor_data());
            messages.push(StatefulSet::generated_message_descriptor_data());
            messages.push(StatefulSetCondition::generated_message_descriptor_data());
            messages.push(StatefulSetList::generated_message_descriptor_data());
            messages.push(StatefulSetOrdinals::generated_message_descriptor_data());
            messages.push(StatefulSetPersistentVolumeClaimRetentionPolicy::generated_message_descriptor_data());
            messages.push(StatefulSetSpec::generated_message_descriptor_data());
            messages.push(StatefulSetStatus::generated_message_descriptor_data());
            messages.push(StatefulSetUpdateStrategy::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
