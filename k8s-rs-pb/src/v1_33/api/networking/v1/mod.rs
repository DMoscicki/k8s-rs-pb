// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc 30.2
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `api/networking/v1/generated.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.HTTPIngressPath)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HTTPIngressPath {
    // message fields
    // @@protoc_insertion_point(field:api.networking.v1.HTTPIngressPath.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.networking.v1.HTTPIngressPath.pathType)
    pub pathType: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.HTTPIngressPath.backend)
    pub backend: ::protobuf::MessageField<IngressBackend>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.HTTPIngressPath.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HTTPIngressPath {
    fn default() -> &'a HTTPIngressPath {
        <HTTPIngressPath as ::protobuf::Message>::default_instance()
    }
}

impl HTTPIngressPath {
    pub fn new() -> HTTPIngressPath {
        ::std::default::Default::default()
    }

    // optional string path = 1;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pathType = 3;

    pub fn pathType(&self) -> &str {
        match self.pathType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pathType(&mut self) {
        self.pathType = ::std::option::Option::None;
    }

    pub fn has_pathType(&self) -> bool {
        self.pathType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pathType(&mut self, v: ::std::string::String) {
        self.pathType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pathType(&mut self) -> &mut ::std::string::String {
        if self.pathType.is_none() {
            self.pathType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pathType.as_mut().unwrap()
    }

    // Take field
    pub fn take_pathType(&mut self) -> ::std::string::String {
        self.pathType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.networking.v1.IngressBackend backend = 2;

    pub fn backend(&self) -> &IngressBackend {
        self.backend.as_ref().unwrap_or_else(|| <IngressBackend as ::protobuf::Message>::default_instance())
    }

    pub fn clear_backend(&mut self) {
        self.backend.clear();
    }

    pub fn has_backend(&self) -> bool {
        self.backend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backend(&mut self, v: IngressBackend) {
        self.backend = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backend(&mut self) -> &mut IngressBackend {
        self.backend.mut_or_insert_default()
    }

    // Take field
    pub fn take_backend(&mut self) -> IngressBackend {
        self.backend.take().unwrap_or_else(|| IngressBackend::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &HTTPIngressPath| { &m.path },
            |m: &mut HTTPIngressPath| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pathType",
            |m: &HTTPIngressPath| { &m.pathType },
            |m: &mut HTTPIngressPath| { &mut m.pathType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IngressBackend>(
            "backend",
            |m: &HTTPIngressPath| { &m.backend },
            |m: &mut HTTPIngressPath| { &mut m.backend },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HTTPIngressPath>(
            "HTTPIngressPath",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HTTPIngressPath {
    const NAME: &'static str = "HTTPIngressPath";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.pathType = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.backend)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.pathType.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.backend.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.path.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.pathType.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.backend.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HTTPIngressPath {
        HTTPIngressPath::new()
    }

    fn clear(&mut self) {
        self.path = ::std::option::Option::None;
        self.pathType = ::std::option::Option::None;
        self.backend.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HTTPIngressPath {
        static instance: HTTPIngressPath = HTTPIngressPath {
            path: ::std::option::Option::None,
            pathType: ::std::option::Option::None,
            backend: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HTTPIngressPath {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HTTPIngressPath").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HTTPIngressPath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPIngressPath {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.HTTPIngressRuleValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HTTPIngressRuleValue {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.HTTPIngressRuleValue.paths)
    pub paths: ::std::vec::Vec<HTTPIngressPath>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.HTTPIngressRuleValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HTTPIngressRuleValue {
    fn default() -> &'a HTTPIngressRuleValue {
        <HTTPIngressRuleValue as ::protobuf::Message>::default_instance()
    }
}

impl HTTPIngressRuleValue {
    pub fn new() -> HTTPIngressRuleValue {
        ::std::default::Default::default()
    }

    // repeated .api.networking.v1.HTTPIngressPath paths = 1;

    pub fn paths(&self) -> &[HTTPIngressPath] {
        &self.paths
    }

    pub fn clear_paths(&mut self) {
        self.paths.clear();
    }

    // Param is passed by value, moved
    pub fn set_paths(&mut self, v: ::std::vec::Vec<HTTPIngressPath>) {
        self.paths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_paths(&mut self) -> &mut ::std::vec::Vec<HTTPIngressPath> {
        &mut self.paths
    }

    // Take field
    pub fn take_paths(&mut self) -> ::std::vec::Vec<HTTPIngressPath> {
        ::std::mem::replace(&mut self.paths, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "paths",
            |m: &HTTPIngressRuleValue| { &m.paths },
            |m: &mut HTTPIngressRuleValue| { &mut m.paths },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HTTPIngressRuleValue>(
            "HTTPIngressRuleValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HTTPIngressRuleValue {
    const NAME: &'static str = "HTTPIngressRuleValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.paths.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.paths {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.paths {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HTTPIngressRuleValue {
        HTTPIngressRuleValue::new()
    }

    fn clear(&mut self) {
        self.paths.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HTTPIngressRuleValue {
        static instance: HTTPIngressRuleValue = HTTPIngressRuleValue {
            paths: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HTTPIngressRuleValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HTTPIngressRuleValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HTTPIngressRuleValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPIngressRuleValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.IPAddress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IPAddress {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.IPAddress.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.IPAddress.spec)
    pub spec: ::protobuf::MessageField<IPAddressSpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.IPAddress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IPAddress {
    fn default() -> &'a IPAddress {
        <IPAddress as ::protobuf::Message>::default_instance()
    }
}

impl IPAddress {
    pub fn new() -> IPAddress {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.networking.v1.IPAddressSpec spec = 2;

    pub fn spec(&self) -> &IPAddressSpec {
        self.spec.as_ref().unwrap_or_else(|| <IPAddressSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: IPAddressSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut IPAddressSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> IPAddressSpec {
        self.spec.take().unwrap_or_else(|| IPAddressSpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &IPAddress| { &m.metadata },
            |m: &mut IPAddress| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IPAddressSpec>(
            "spec",
            |m: &IPAddress| { &m.spec },
            |m: &mut IPAddress| { &mut m.spec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IPAddress>(
            "IPAddress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IPAddress {
    const NAME: &'static str = "IPAddress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IPAddress {
        IPAddress::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IPAddress {
        static instance: IPAddress = IPAddress {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IPAddress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IPAddress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IPAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPAddress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.IPAddressList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IPAddressList {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.IPAddressList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.IPAddressList.items)
    pub items: ::std::vec::Vec<IPAddress>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.IPAddressList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IPAddressList {
    fn default() -> &'a IPAddressList {
        <IPAddressList as ::protobuf::Message>::default_instance()
    }
}

impl IPAddressList {
    pub fn new() -> IPAddressList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.networking.v1.IPAddress items = 2;

    pub fn items(&self) -> &[IPAddress] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<IPAddress>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<IPAddress> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<IPAddress> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &IPAddressList| { &m.metadata },
            |m: &mut IPAddressList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &IPAddressList| { &m.items },
            |m: &mut IPAddressList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IPAddressList>(
            "IPAddressList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IPAddressList {
    const NAME: &'static str = "IPAddressList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IPAddressList {
        IPAddressList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IPAddressList {
        static instance: IPAddressList = IPAddressList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IPAddressList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IPAddressList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IPAddressList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPAddressList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.IPAddressSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IPAddressSpec {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.IPAddressSpec.parentRef)
    pub parentRef: ::protobuf::MessageField<ParentReference>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.IPAddressSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IPAddressSpec {
    fn default() -> &'a IPAddressSpec {
        <IPAddressSpec as ::protobuf::Message>::default_instance()
    }
}

impl IPAddressSpec {
    pub fn new() -> IPAddressSpec {
        ::std::default::Default::default()
    }

    // optional .api.networking.v1.ParentReference parentRef = 1;

    pub fn parentRef(&self) -> &ParentReference {
        self.parentRef.as_ref().unwrap_or_else(|| <ParentReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_parentRef(&mut self) {
        self.parentRef.clear();
    }

    pub fn has_parentRef(&self) -> bool {
        self.parentRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parentRef(&mut self, v: ParentReference) {
        self.parentRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parentRef(&mut self) -> &mut ParentReference {
        self.parentRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_parentRef(&mut self) -> ParentReference {
        self.parentRef.take().unwrap_or_else(|| ParentReference::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ParentReference>(
            "parentRef",
            |m: &IPAddressSpec| { &m.parentRef },
            |m: &mut IPAddressSpec| { &mut m.parentRef },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IPAddressSpec>(
            "IPAddressSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IPAddressSpec {
    const NAME: &'static str = "IPAddressSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.parentRef)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.parentRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.parentRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IPAddressSpec {
        IPAddressSpec::new()
    }

    fn clear(&mut self) {
        self.parentRef.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IPAddressSpec {
        static instance: IPAddressSpec = IPAddressSpec {
            parentRef: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IPAddressSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IPAddressSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IPAddressSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPAddressSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.IPBlock)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IPBlock {
    // message fields
    // @@protoc_insertion_point(field:api.networking.v1.IPBlock.cidr)
    pub cidr: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.IPBlock.except)
    pub except: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.IPBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IPBlock {
    fn default() -> &'a IPBlock {
        <IPBlock as ::protobuf::Message>::default_instance()
    }
}

impl IPBlock {
    pub fn new() -> IPBlock {
        ::std::default::Default::default()
    }

    // optional string cidr = 1;

    pub fn cidr(&self) -> &str {
        match self.cidr.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cidr(&mut self) {
        self.cidr = ::std::option::Option::None;
    }

    pub fn has_cidr(&self) -> bool {
        self.cidr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cidr(&mut self, v: ::std::string::String) {
        self.cidr = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cidr(&mut self) -> &mut ::std::string::String {
        if self.cidr.is_none() {
            self.cidr = ::std::option::Option::Some(::std::string::String::new());
        }
        self.cidr.as_mut().unwrap()
    }

    // Take field
    pub fn take_cidr(&mut self) -> ::std::string::String {
        self.cidr.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string except = 2;

    pub fn except(&self) -> &[::std::string::String] {
        &self.except
    }

    pub fn clear_except(&mut self) {
        self.except.clear();
    }

    // Param is passed by value, moved
    pub fn set_except(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.except = v;
    }

    // Mutable pointer to the field.
    pub fn mut_except(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.except
    }

    // Take field
    pub fn take_except(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.except, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cidr",
            |m: &IPBlock| { &m.cidr },
            |m: &mut IPBlock| { &mut m.cidr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "except",
            |m: &IPBlock| { &m.except },
            |m: &mut IPBlock| { &mut m.except },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IPBlock>(
            "IPBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IPBlock {
    const NAME: &'static str = "IPBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cidr = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.except.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cidr.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.except {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cidr.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.except {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IPBlock {
        IPBlock::new()
    }

    fn clear(&mut self) {
        self.cidr = ::std::option::Option::None;
        self.except.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IPBlock {
        static instance: IPBlock = IPBlock {
            cidr: ::std::option::Option::None,
            except: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IPBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IPBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IPBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.Ingress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Ingress {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.Ingress.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.Ingress.spec)
    pub spec: ::protobuf::MessageField<IngressSpec>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.Ingress.status)
    pub status: ::protobuf::MessageField<IngressStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.Ingress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Ingress {
    fn default() -> &'a Ingress {
        <Ingress as ::protobuf::Message>::default_instance()
    }
}

impl Ingress {
    pub fn new() -> Ingress {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.networking.v1.IngressSpec spec = 2;

    pub fn spec(&self) -> &IngressSpec {
        self.spec.as_ref().unwrap_or_else(|| <IngressSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: IngressSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut IngressSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> IngressSpec {
        self.spec.take().unwrap_or_else(|| IngressSpec::new())
    }

    // optional .api.networking.v1.IngressStatus status = 3;

    pub fn status(&self) -> &IngressStatus {
        self.status.as_ref().unwrap_or_else(|| <IngressStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: IngressStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut IngressStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> IngressStatus {
        self.status.take().unwrap_or_else(|| IngressStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &Ingress| { &m.metadata },
            |m: &mut Ingress| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IngressSpec>(
            "spec",
            |m: &Ingress| { &m.spec },
            |m: &mut Ingress| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IngressStatus>(
            "status",
            |m: &Ingress| { &m.status },
            |m: &mut Ingress| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Ingress>(
            "Ingress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Ingress {
    const NAME: &'static str = "Ingress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Ingress {
        Ingress::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Ingress {
        static instance: Ingress = Ingress {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Ingress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Ingress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Ingress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ingress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.IngressBackend)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressBackend {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.IngressBackend.service)
    pub service: ::protobuf::MessageField<IngressServiceBackend>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.IngressBackend.resource)
    pub resource: ::protobuf::MessageField<crate::v1_33::api::core::v1::TypedLocalObjectReference>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.IngressBackend.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressBackend {
    fn default() -> &'a IngressBackend {
        <IngressBackend as ::protobuf::Message>::default_instance()
    }
}

impl IngressBackend {
    pub fn new() -> IngressBackend {
        ::std::default::Default::default()
    }

    // optional .api.networking.v1.IngressServiceBackend service = 4;

    pub fn service(&self) -> &IngressServiceBackend {
        self.service.as_ref().unwrap_or_else(|| <IngressServiceBackend as ::protobuf::Message>::default_instance())
    }

    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    pub fn has_service(&self) -> bool {
        self.service.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: IngressServiceBackend) {
        self.service = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut IngressServiceBackend {
        self.service.mut_or_insert_default()
    }

    // Take field
    pub fn take_service(&mut self) -> IngressServiceBackend {
        self.service.take().unwrap_or_else(|| IngressServiceBackend::new())
    }

    // optional .api.core.v1.TypedLocalObjectReference resource = 3;

    pub fn resource(&self) -> &crate::v1_33::api::core::v1::TypedLocalObjectReference {
        self.resource.as_ref().unwrap_or_else(|| <crate::v1_33::api::core::v1::TypedLocalObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_resource(&mut self) {
        self.resource.clear();
    }

    pub fn has_resource(&self) -> bool {
        self.resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: crate::v1_33::api::core::v1::TypedLocalObjectReference) {
        self.resource = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut crate::v1_33::api::core::v1::TypedLocalObjectReference {
        self.resource.mut_or_insert_default()
    }

    // Take field
    pub fn take_resource(&mut self) -> crate::v1_33::api::core::v1::TypedLocalObjectReference {
        self.resource.take().unwrap_or_else(|| crate::v1_33::api::core::v1::TypedLocalObjectReference::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IngressServiceBackend>(
            "service",
            |m: &IngressBackend| { &m.service },
            |m: &mut IngressBackend| { &mut m.service },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::api::core::v1::TypedLocalObjectReference>(
            "resource",
            |m: &IngressBackend| { &m.resource },
            |m: &mut IngressBackend| { &mut m.resource },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressBackend>(
            "IngressBackend",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressBackend {
    const NAME: &'static str = "IngressBackend";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.service)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resource)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.resource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.service.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.resource.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressBackend {
        IngressBackend::new()
    }

    fn clear(&mut self) {
        self.service.clear();
        self.resource.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressBackend {
        static instance: IngressBackend = IngressBackend {
            service: ::protobuf::MessageField::none(),
            resource: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressBackend {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressBackend").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressBackend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressBackend {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.IngressClass)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressClass {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.IngressClass.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.IngressClass.spec)
    pub spec: ::protobuf::MessageField<IngressClassSpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.IngressClass.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressClass {
    fn default() -> &'a IngressClass {
        <IngressClass as ::protobuf::Message>::default_instance()
    }
}

impl IngressClass {
    pub fn new() -> IngressClass {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.networking.v1.IngressClassSpec spec = 2;

    pub fn spec(&self) -> &IngressClassSpec {
        self.spec.as_ref().unwrap_or_else(|| <IngressClassSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: IngressClassSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut IngressClassSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> IngressClassSpec {
        self.spec.take().unwrap_or_else(|| IngressClassSpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &IngressClass| { &m.metadata },
            |m: &mut IngressClass| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IngressClassSpec>(
            "spec",
            |m: &IngressClass| { &m.spec },
            |m: &mut IngressClass| { &mut m.spec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressClass>(
            "IngressClass",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressClass {
    const NAME: &'static str = "IngressClass";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressClass {
        IngressClass::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressClass {
        static instance: IngressClass = IngressClass {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressClass {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressClass").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressClass {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.IngressClassList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressClassList {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.IngressClassList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.IngressClassList.items)
    pub items: ::std::vec::Vec<IngressClass>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.IngressClassList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressClassList {
    fn default() -> &'a IngressClassList {
        <IngressClassList as ::protobuf::Message>::default_instance()
    }
}

impl IngressClassList {
    pub fn new() -> IngressClassList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.networking.v1.IngressClass items = 2;

    pub fn items(&self) -> &[IngressClass] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<IngressClass>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<IngressClass> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<IngressClass> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &IngressClassList| { &m.metadata },
            |m: &mut IngressClassList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &IngressClassList| { &m.items },
            |m: &mut IngressClassList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressClassList>(
            "IngressClassList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressClassList {
    const NAME: &'static str = "IngressClassList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressClassList {
        IngressClassList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressClassList {
        static instance: IngressClassList = IngressClassList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressClassList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressClassList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressClassList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressClassList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.IngressClassParametersReference)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressClassParametersReference {
    // message fields
    // @@protoc_insertion_point(field:api.networking.v1.IngressClassParametersReference.aPIGroup)
    pub aPIGroup: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.networking.v1.IngressClassParametersReference.kind)
    pub kind: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.networking.v1.IngressClassParametersReference.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.networking.v1.IngressClassParametersReference.scope)
    pub scope: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.networking.v1.IngressClassParametersReference.namespace)
    pub namespace: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.IngressClassParametersReference.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressClassParametersReference {
    fn default() -> &'a IngressClassParametersReference {
        <IngressClassParametersReference as ::protobuf::Message>::default_instance()
    }
}

impl IngressClassParametersReference {
    pub fn new() -> IngressClassParametersReference {
        ::std::default::Default::default()
    }

    // optional string aPIGroup = 1;

    pub fn aPIGroup(&self) -> &str {
        match self.aPIGroup.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_aPIGroup(&mut self) {
        self.aPIGroup = ::std::option::Option::None;
    }

    pub fn has_aPIGroup(&self) -> bool {
        self.aPIGroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aPIGroup(&mut self, v: ::std::string::String) {
        self.aPIGroup = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aPIGroup(&mut self) -> &mut ::std::string::String {
        if self.aPIGroup.is_none() {
            self.aPIGroup = ::std::option::Option::Some(::std::string::String::new());
        }
        self.aPIGroup.as_mut().unwrap()
    }

    // Take field
    pub fn take_aPIGroup(&mut self) -> ::std::string::String {
        self.aPIGroup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kind = 2;

    pub fn kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string scope = 4;

    pub fn scope(&self) -> &str {
        match self.scope.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_scope(&mut self) {
        self.scope = ::std::option::Option::None;
    }

    pub fn has_scope(&self) -> bool {
        self.scope.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: ::std::string::String) {
        self.scope = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scope(&mut self) -> &mut ::std::string::String {
        if self.scope.is_none() {
            self.scope = ::std::option::Option::Some(::std::string::String::new());
        }
        self.scope.as_mut().unwrap()
    }

    // Take field
    pub fn take_scope(&mut self) -> ::std::string::String {
        self.scope.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string namespace = 5;

    pub fn namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_namespace(&mut self) {
        self.namespace = ::std::option::Option::None;
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "aPIGroup",
            |m: &IngressClassParametersReference| { &m.aPIGroup },
            |m: &mut IngressClassParametersReference| { &mut m.aPIGroup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &IngressClassParametersReference| { &m.kind },
            |m: &mut IngressClassParametersReference| { &mut m.kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &IngressClassParametersReference| { &m.name },
            |m: &mut IngressClassParametersReference| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scope",
            |m: &IngressClassParametersReference| { &m.scope },
            |m: &mut IngressClassParametersReference| { &mut m.scope },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "namespace",
            |m: &IngressClassParametersReference| { &m.namespace },
            |m: &mut IngressClassParametersReference| { &mut m.namespace },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressClassParametersReference>(
            "IngressClassParametersReference",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressClassParametersReference {
    const NAME: &'static str = "IngressClassParametersReference";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.aPIGroup = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.kind = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.scope = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.namespace = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.aPIGroup.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.scope.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.aPIGroup.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.kind.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.scope.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.namespace.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressClassParametersReference {
        IngressClassParametersReference::new()
    }

    fn clear(&mut self) {
        self.aPIGroup = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.scope = ::std::option::Option::None;
        self.namespace = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressClassParametersReference {
        static instance: IngressClassParametersReference = IngressClassParametersReference {
            aPIGroup: ::std::option::Option::None,
            kind: ::std::option::Option::None,
            name: ::std::option::Option::None,
            scope: ::std::option::Option::None,
            namespace: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressClassParametersReference {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressClassParametersReference").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressClassParametersReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressClassParametersReference {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.IngressClassSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressClassSpec {
    // message fields
    // @@protoc_insertion_point(field:api.networking.v1.IngressClassSpec.controller)
    pub controller: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.IngressClassSpec.parameters)
    pub parameters: ::protobuf::MessageField<IngressClassParametersReference>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.IngressClassSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressClassSpec {
    fn default() -> &'a IngressClassSpec {
        <IngressClassSpec as ::protobuf::Message>::default_instance()
    }
}

impl IngressClassSpec {
    pub fn new() -> IngressClassSpec {
        ::std::default::Default::default()
    }

    // optional string controller = 1;

    pub fn controller(&self) -> &str {
        match self.controller.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_controller(&mut self) {
        self.controller = ::std::option::Option::None;
    }

    pub fn has_controller(&self) -> bool {
        self.controller.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller(&mut self, v: ::std::string::String) {
        self.controller = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controller(&mut self) -> &mut ::std::string::String {
        if self.controller.is_none() {
            self.controller = ::std::option::Option::Some(::std::string::String::new());
        }
        self.controller.as_mut().unwrap()
    }

    // Take field
    pub fn take_controller(&mut self) -> ::std::string::String {
        self.controller.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.networking.v1.IngressClassParametersReference parameters = 2;

    pub fn parameters(&self) -> &IngressClassParametersReference {
        self.parameters.as_ref().unwrap_or_else(|| <IngressClassParametersReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_parameters(&mut self) {
        self.parameters.clear();
    }

    pub fn has_parameters(&self) -> bool {
        self.parameters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameters(&mut self, v: IngressClassParametersReference) {
        self.parameters = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parameters(&mut self) -> &mut IngressClassParametersReference {
        self.parameters.mut_or_insert_default()
    }

    // Take field
    pub fn take_parameters(&mut self) -> IngressClassParametersReference {
        self.parameters.take().unwrap_or_else(|| IngressClassParametersReference::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "controller",
            |m: &IngressClassSpec| { &m.controller },
            |m: &mut IngressClassSpec| { &mut m.controller },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IngressClassParametersReference>(
            "parameters",
            |m: &IngressClassSpec| { &m.parameters },
            |m: &mut IngressClassSpec| { &mut m.parameters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressClassSpec>(
            "IngressClassSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressClassSpec {
    const NAME: &'static str = "IngressClassSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.controller = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.parameters)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.controller.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.parameters.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.controller.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.parameters.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressClassSpec {
        IngressClassSpec::new()
    }

    fn clear(&mut self) {
        self.controller = ::std::option::Option::None;
        self.parameters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressClassSpec {
        static instance: IngressClassSpec = IngressClassSpec {
            controller: ::std::option::Option::None,
            parameters: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressClassSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressClassSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressClassSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressClassSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.IngressList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressList {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.IngressList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.IngressList.items)
    pub items: ::std::vec::Vec<Ingress>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.IngressList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressList {
    fn default() -> &'a IngressList {
        <IngressList as ::protobuf::Message>::default_instance()
    }
}

impl IngressList {
    pub fn new() -> IngressList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.networking.v1.Ingress items = 2;

    pub fn items(&self) -> &[Ingress] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<Ingress>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<Ingress> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<Ingress> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &IngressList| { &m.metadata },
            |m: &mut IngressList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &IngressList| { &m.items },
            |m: &mut IngressList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressList>(
            "IngressList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressList {
    const NAME: &'static str = "IngressList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressList {
        IngressList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressList {
        static instance: IngressList = IngressList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.IngressLoadBalancerIngress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressLoadBalancerIngress {
    // message fields
    // @@protoc_insertion_point(field:api.networking.v1.IngressLoadBalancerIngress.ip)
    pub ip: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.networking.v1.IngressLoadBalancerIngress.hostname)
    pub hostname: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.IngressLoadBalancerIngress.ports)
    pub ports: ::std::vec::Vec<IngressPortStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.IngressLoadBalancerIngress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressLoadBalancerIngress {
    fn default() -> &'a IngressLoadBalancerIngress {
        <IngressLoadBalancerIngress as ::protobuf::Message>::default_instance()
    }
}

impl IngressLoadBalancerIngress {
    pub fn new() -> IngressLoadBalancerIngress {
        ::std::default::Default::default()
    }

    // optional string ip = 1;

    pub fn ip(&self) -> &str {
        match self.ip.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        if self.ip.is_none() {
            self.ip = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        self.ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string hostname = 2;

    pub fn hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hostname(&mut self) {
        self.hostname = ::std::option::Option::None;
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.networking.v1.IngressPortStatus ports = 4;

    pub fn ports(&self) -> &[IngressPortStatus] {
        &self.ports
    }

    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::std::vec::Vec<IngressPortStatus>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::std::vec::Vec<IngressPortStatus> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::std::vec::Vec<IngressPortStatus> {
        ::std::mem::replace(&mut self.ports, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip",
            |m: &IngressLoadBalancerIngress| { &m.ip },
            |m: &mut IngressLoadBalancerIngress| { &mut m.ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hostname",
            |m: &IngressLoadBalancerIngress| { &m.hostname },
            |m: &mut IngressLoadBalancerIngress| { &mut m.hostname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ports",
            |m: &IngressLoadBalancerIngress| { &m.ports },
            |m: &mut IngressLoadBalancerIngress| { &mut m.ports },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressLoadBalancerIngress>(
            "IngressLoadBalancerIngress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressLoadBalancerIngress {
    const NAME: &'static str = "IngressLoadBalancerIngress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ip = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.hostname = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.ports.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ip.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ip.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.hostname.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.ports {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressLoadBalancerIngress {
        IngressLoadBalancerIngress::new()
    }

    fn clear(&mut self) {
        self.ip = ::std::option::Option::None;
        self.hostname = ::std::option::Option::None;
        self.ports.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressLoadBalancerIngress {
        static instance: IngressLoadBalancerIngress = IngressLoadBalancerIngress {
            ip: ::std::option::Option::None,
            hostname: ::std::option::Option::None,
            ports: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressLoadBalancerIngress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressLoadBalancerIngress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressLoadBalancerIngress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressLoadBalancerIngress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.IngressLoadBalancerStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressLoadBalancerStatus {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.IngressLoadBalancerStatus.ingress)
    pub ingress: ::std::vec::Vec<IngressLoadBalancerIngress>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.IngressLoadBalancerStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressLoadBalancerStatus {
    fn default() -> &'a IngressLoadBalancerStatus {
        <IngressLoadBalancerStatus as ::protobuf::Message>::default_instance()
    }
}

impl IngressLoadBalancerStatus {
    pub fn new() -> IngressLoadBalancerStatus {
        ::std::default::Default::default()
    }

    // repeated .api.networking.v1.IngressLoadBalancerIngress ingress = 1;

    pub fn ingress(&self) -> &[IngressLoadBalancerIngress] {
        &self.ingress
    }

    pub fn clear_ingress(&mut self) {
        self.ingress.clear();
    }

    // Param is passed by value, moved
    pub fn set_ingress(&mut self, v: ::std::vec::Vec<IngressLoadBalancerIngress>) {
        self.ingress = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ingress(&mut self) -> &mut ::std::vec::Vec<IngressLoadBalancerIngress> {
        &mut self.ingress
    }

    // Take field
    pub fn take_ingress(&mut self) -> ::std::vec::Vec<IngressLoadBalancerIngress> {
        ::std::mem::replace(&mut self.ingress, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ingress",
            |m: &IngressLoadBalancerStatus| { &m.ingress },
            |m: &mut IngressLoadBalancerStatus| { &mut m.ingress },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressLoadBalancerStatus>(
            "IngressLoadBalancerStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressLoadBalancerStatus {
    const NAME: &'static str = "IngressLoadBalancerStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ingress.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ingress {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ingress {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressLoadBalancerStatus {
        IngressLoadBalancerStatus::new()
    }

    fn clear(&mut self) {
        self.ingress.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressLoadBalancerStatus {
        static instance: IngressLoadBalancerStatus = IngressLoadBalancerStatus {
            ingress: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressLoadBalancerStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressLoadBalancerStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressLoadBalancerStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressLoadBalancerStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.IngressPortStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressPortStatus {
    // message fields
    // @@protoc_insertion_point(field:api.networking.v1.IngressPortStatus.port)
    pub port: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.networking.v1.IngressPortStatus.protocol)
    pub protocol: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.networking.v1.IngressPortStatus.error)
    pub error: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.IngressPortStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressPortStatus {
    fn default() -> &'a IngressPortStatus {
        <IngressPortStatus as ::protobuf::Message>::default_instance()
    }
}

impl IngressPortStatus {
    pub fn new() -> IngressPortStatus {
        ::std::default::Default::default()
    }

    // optional int32 port = 1;

    pub fn port(&self) -> i32 {
        self.port.unwrap_or(0)
    }

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Option::Some(v);
    }

    // optional string protocol = 2;

    pub fn protocol(&self) -> &str {
        match self.protocol.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_protocol(&mut self) {
        self.protocol = ::std::option::Option::None;
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol = ::std::option::Option::Some(::std::string::String::new());
        }
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string error = 3;

    pub fn error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "port",
            |m: &IngressPortStatus| { &m.port },
            |m: &mut IngressPortStatus| { &mut m.port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol",
            |m: &IngressPortStatus| { &m.protocol },
            |m: &mut IngressPortStatus| { &mut m.protocol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error",
            |m: &IngressPortStatus| { &m.error },
            |m: &mut IngressPortStatus| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressPortStatus>(
            "IngressPortStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressPortStatus {
    const NAME: &'static str = "IngressPortStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.port = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.protocol = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.error = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.protocol.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.port {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.protocol.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.error.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressPortStatus {
        IngressPortStatus::new()
    }

    fn clear(&mut self) {
        self.port = ::std::option::Option::None;
        self.protocol = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressPortStatus {
        static instance: IngressPortStatus = IngressPortStatus {
            port: ::std::option::Option::None,
            protocol: ::std::option::Option::None,
            error: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressPortStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressPortStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressPortStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressPortStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.IngressRule)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressRule {
    // message fields
    // @@protoc_insertion_point(field:api.networking.v1.IngressRule.host)
    pub host: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.IngressRule.ingressRuleValue)
    pub ingressRuleValue: ::protobuf::MessageField<IngressRuleValue>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.IngressRule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressRule {
    fn default() -> &'a IngressRule {
        <IngressRule as ::protobuf::Message>::default_instance()
    }
}

impl IngressRule {
    pub fn new() -> IngressRule {
        ::std::default::Default::default()
    }

    // optional string host = 1;

    pub fn host(&self) -> &str {
        match self.host.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_host(&mut self) {
        self.host = ::std::option::Option::None;
    }

    pub fn has_host(&self) -> bool {
        self.host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        if self.host.is_none() {
            self.host = ::std::option::Option::Some(::std::string::String::new());
        }
        self.host.as_mut().unwrap()
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        self.host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.networking.v1.IngressRuleValue ingressRuleValue = 2;

    pub fn ingressRuleValue(&self) -> &IngressRuleValue {
        self.ingressRuleValue.as_ref().unwrap_or_else(|| <IngressRuleValue as ::protobuf::Message>::default_instance())
    }

    pub fn clear_ingressRuleValue(&mut self) {
        self.ingressRuleValue.clear();
    }

    pub fn has_ingressRuleValue(&self) -> bool {
        self.ingressRuleValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ingressRuleValue(&mut self, v: IngressRuleValue) {
        self.ingressRuleValue = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ingressRuleValue(&mut self) -> &mut IngressRuleValue {
        self.ingressRuleValue.mut_or_insert_default()
    }

    // Take field
    pub fn take_ingressRuleValue(&mut self) -> IngressRuleValue {
        self.ingressRuleValue.take().unwrap_or_else(|| IngressRuleValue::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "host",
            |m: &IngressRule| { &m.host },
            |m: &mut IngressRule| { &mut m.host },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IngressRuleValue>(
            "ingressRuleValue",
            |m: &IngressRule| { &m.ingressRuleValue },
            |m: &mut IngressRule| { &mut m.ingressRuleValue },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressRule>(
            "IngressRule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressRule {
    const NAME: &'static str = "IngressRule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.host = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ingressRuleValue)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.host.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.ingressRuleValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.host.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.ingressRuleValue.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressRule {
        IngressRule::new()
    }

    fn clear(&mut self) {
        self.host = ::std::option::Option::None;
        self.ingressRuleValue.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressRule {
        static instance: IngressRule = IngressRule {
            host: ::std::option::Option::None,
            ingressRuleValue: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressRule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressRule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressRule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.IngressRuleValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressRuleValue {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.IngressRuleValue.http)
    pub http: ::protobuf::MessageField<HTTPIngressRuleValue>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.IngressRuleValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressRuleValue {
    fn default() -> &'a IngressRuleValue {
        <IngressRuleValue as ::protobuf::Message>::default_instance()
    }
}

impl IngressRuleValue {
    pub fn new() -> IngressRuleValue {
        ::std::default::Default::default()
    }

    // optional .api.networking.v1.HTTPIngressRuleValue http = 1;

    pub fn http(&self) -> &HTTPIngressRuleValue {
        self.http.as_ref().unwrap_or_else(|| <HTTPIngressRuleValue as ::protobuf::Message>::default_instance())
    }

    pub fn clear_http(&mut self) {
        self.http.clear();
    }

    pub fn has_http(&self) -> bool {
        self.http.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http(&mut self, v: HTTPIngressRuleValue) {
        self.http = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http(&mut self) -> &mut HTTPIngressRuleValue {
        self.http.mut_or_insert_default()
    }

    // Take field
    pub fn take_http(&mut self) -> HTTPIngressRuleValue {
        self.http.take().unwrap_or_else(|| HTTPIngressRuleValue::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HTTPIngressRuleValue>(
            "http",
            |m: &IngressRuleValue| { &m.http },
            |m: &mut IngressRuleValue| { &mut m.http },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressRuleValue>(
            "IngressRuleValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressRuleValue {
    const NAME: &'static str = "IngressRuleValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.http)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.http.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.http.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressRuleValue {
        IngressRuleValue::new()
    }

    fn clear(&mut self) {
        self.http.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressRuleValue {
        static instance: IngressRuleValue = IngressRuleValue {
            http: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressRuleValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressRuleValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressRuleValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressRuleValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.IngressServiceBackend)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressServiceBackend {
    // message fields
    // @@protoc_insertion_point(field:api.networking.v1.IngressServiceBackend.name)
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.IngressServiceBackend.port)
    pub port: ::protobuf::MessageField<ServiceBackendPort>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.IngressServiceBackend.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressServiceBackend {
    fn default() -> &'a IngressServiceBackend {
        <IngressServiceBackend as ::protobuf::Message>::default_instance()
    }
}

impl IngressServiceBackend {
    pub fn new() -> IngressServiceBackend {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.networking.v1.ServiceBackendPort port = 2;

    pub fn port(&self) -> &ServiceBackendPort {
        self.port.as_ref().unwrap_or_else(|| <ServiceBackendPort as ::protobuf::Message>::default_instance())
    }

    pub fn clear_port(&mut self) {
        self.port.clear();
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: ServiceBackendPort) {
        self.port = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_port(&mut self) -> &mut ServiceBackendPort {
        self.port.mut_or_insert_default()
    }

    // Take field
    pub fn take_port(&mut self) -> ServiceBackendPort {
        self.port.take().unwrap_or_else(|| ServiceBackendPort::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &IngressServiceBackend| { &m.name },
            |m: &mut IngressServiceBackend| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ServiceBackendPort>(
            "port",
            |m: &IngressServiceBackend| { &m.port },
            |m: &mut IngressServiceBackend| { &mut m.port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressServiceBackend>(
            "IngressServiceBackend",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressServiceBackend {
    const NAME: &'static str = "IngressServiceBackend";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.port)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.port.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.port.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressServiceBackend {
        IngressServiceBackend::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.port.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressServiceBackend {
        static instance: IngressServiceBackend = IngressServiceBackend {
            name: ::std::option::Option::None,
            port: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressServiceBackend {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressServiceBackend").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressServiceBackend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressServiceBackend {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.IngressSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressSpec {
    // message fields
    // @@protoc_insertion_point(field:api.networking.v1.IngressSpec.ingressClassName)
    pub ingressClassName: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.IngressSpec.defaultBackend)
    pub defaultBackend: ::protobuf::MessageField<IngressBackend>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.IngressSpec.tls)
    pub tls: ::std::vec::Vec<IngressTLS>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.IngressSpec.rules)
    pub rules: ::std::vec::Vec<IngressRule>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.IngressSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressSpec {
    fn default() -> &'a IngressSpec {
        <IngressSpec as ::protobuf::Message>::default_instance()
    }
}

impl IngressSpec {
    pub fn new() -> IngressSpec {
        ::std::default::Default::default()
    }

    // optional string ingressClassName = 4;

    pub fn ingressClassName(&self) -> &str {
        match self.ingressClassName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ingressClassName(&mut self) {
        self.ingressClassName = ::std::option::Option::None;
    }

    pub fn has_ingressClassName(&self) -> bool {
        self.ingressClassName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ingressClassName(&mut self, v: ::std::string::String) {
        self.ingressClassName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ingressClassName(&mut self) -> &mut ::std::string::String {
        if self.ingressClassName.is_none() {
            self.ingressClassName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ingressClassName.as_mut().unwrap()
    }

    // Take field
    pub fn take_ingressClassName(&mut self) -> ::std::string::String {
        self.ingressClassName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.networking.v1.IngressBackend defaultBackend = 1;

    pub fn defaultBackend(&self) -> &IngressBackend {
        self.defaultBackend.as_ref().unwrap_or_else(|| <IngressBackend as ::protobuf::Message>::default_instance())
    }

    pub fn clear_defaultBackend(&mut self) {
        self.defaultBackend.clear();
    }

    pub fn has_defaultBackend(&self) -> bool {
        self.defaultBackend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defaultBackend(&mut self, v: IngressBackend) {
        self.defaultBackend = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_defaultBackend(&mut self) -> &mut IngressBackend {
        self.defaultBackend.mut_or_insert_default()
    }

    // Take field
    pub fn take_defaultBackend(&mut self) -> IngressBackend {
        self.defaultBackend.take().unwrap_or_else(|| IngressBackend::new())
    }

    // repeated .api.networking.v1.IngressTLS tls = 2;

    pub fn tls(&self) -> &[IngressTLS] {
        &self.tls
    }

    pub fn clear_tls(&mut self) {
        self.tls.clear();
    }

    // Param is passed by value, moved
    pub fn set_tls(&mut self, v: ::std::vec::Vec<IngressTLS>) {
        self.tls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tls(&mut self) -> &mut ::std::vec::Vec<IngressTLS> {
        &mut self.tls
    }

    // Take field
    pub fn take_tls(&mut self) -> ::std::vec::Vec<IngressTLS> {
        ::std::mem::replace(&mut self.tls, ::std::vec::Vec::new())
    }

    // repeated .api.networking.v1.IngressRule rules = 3;

    pub fn rules(&self) -> &[IngressRule] {
        &self.rules
    }

    pub fn clear_rules(&mut self) {
        self.rules.clear();
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: ::std::vec::Vec<IngressRule>) {
        self.rules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rules(&mut self) -> &mut ::std::vec::Vec<IngressRule> {
        &mut self.rules
    }

    // Take field
    pub fn take_rules(&mut self) -> ::std::vec::Vec<IngressRule> {
        ::std::mem::replace(&mut self.rules, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ingressClassName",
            |m: &IngressSpec| { &m.ingressClassName },
            |m: &mut IngressSpec| { &mut m.ingressClassName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IngressBackend>(
            "defaultBackend",
            |m: &IngressSpec| { &m.defaultBackend },
            |m: &mut IngressSpec| { &mut m.defaultBackend },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tls",
            |m: &IngressSpec| { &m.tls },
            |m: &mut IngressSpec| { &mut m.tls },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rules",
            |m: &IngressSpec| { &m.rules },
            |m: &mut IngressSpec| { &mut m.rules },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressSpec>(
            "IngressSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressSpec {
    const NAME: &'static str = "IngressSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                34 => {
                    self.ingressClassName = ::std::option::Option::Some(is.read_string()?);
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.defaultBackend)?;
                },
                18 => {
                    self.tls.push(is.read_message()?);
                },
                26 => {
                    self.rules.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ingressClassName.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.defaultBackend.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.tls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ingressClassName.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.defaultBackend.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.tls {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.rules {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressSpec {
        IngressSpec::new()
    }

    fn clear(&mut self) {
        self.ingressClassName = ::std::option::Option::None;
        self.defaultBackend.clear();
        self.tls.clear();
        self.rules.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressSpec {
        static instance: IngressSpec = IngressSpec {
            ingressClassName: ::std::option::Option::None,
            defaultBackend: ::protobuf::MessageField::none(),
            tls: ::std::vec::Vec::new(),
            rules: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.IngressStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressStatus {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.IngressStatus.loadBalancer)
    pub loadBalancer: ::protobuf::MessageField<IngressLoadBalancerStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.IngressStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressStatus {
    fn default() -> &'a IngressStatus {
        <IngressStatus as ::protobuf::Message>::default_instance()
    }
}

impl IngressStatus {
    pub fn new() -> IngressStatus {
        ::std::default::Default::default()
    }

    // optional .api.networking.v1.IngressLoadBalancerStatus loadBalancer = 1;

    pub fn loadBalancer(&self) -> &IngressLoadBalancerStatus {
        self.loadBalancer.as_ref().unwrap_or_else(|| <IngressLoadBalancerStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_loadBalancer(&mut self) {
        self.loadBalancer.clear();
    }

    pub fn has_loadBalancer(&self) -> bool {
        self.loadBalancer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loadBalancer(&mut self, v: IngressLoadBalancerStatus) {
        self.loadBalancer = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loadBalancer(&mut self) -> &mut IngressLoadBalancerStatus {
        self.loadBalancer.mut_or_insert_default()
    }

    // Take field
    pub fn take_loadBalancer(&mut self) -> IngressLoadBalancerStatus {
        self.loadBalancer.take().unwrap_or_else(|| IngressLoadBalancerStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IngressLoadBalancerStatus>(
            "loadBalancer",
            |m: &IngressStatus| { &m.loadBalancer },
            |m: &mut IngressStatus| { &mut m.loadBalancer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressStatus>(
            "IngressStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressStatus {
    const NAME: &'static str = "IngressStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.loadBalancer)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.loadBalancer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.loadBalancer.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressStatus {
        IngressStatus::new()
    }

    fn clear(&mut self) {
        self.loadBalancer.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressStatus {
        static instance: IngressStatus = IngressStatus {
            loadBalancer: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.IngressTLS)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressTLS {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.IngressTLS.hosts)
    pub hosts: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.networking.v1.IngressTLS.secretName)
    pub secretName: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.IngressTLS.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressTLS {
    fn default() -> &'a IngressTLS {
        <IngressTLS as ::protobuf::Message>::default_instance()
    }
}

impl IngressTLS {
    pub fn new() -> IngressTLS {
        ::std::default::Default::default()
    }

    // repeated string hosts = 1;

    pub fn hosts(&self) -> &[::std::string::String] {
        &self.hosts
    }

    pub fn clear_hosts(&mut self) {
        self.hosts.clear();
    }

    // Param is passed by value, moved
    pub fn set_hosts(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.hosts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hosts(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.hosts
    }

    // Take field
    pub fn take_hosts(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.hosts, ::std::vec::Vec::new())
    }

    // optional string secretName = 2;

    pub fn secretName(&self) -> &str {
        match self.secretName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_secretName(&mut self) {
        self.secretName = ::std::option::Option::None;
    }

    pub fn has_secretName(&self) -> bool {
        self.secretName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretName(&mut self, v: ::std::string::String) {
        self.secretName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretName(&mut self) -> &mut ::std::string::String {
        if self.secretName.is_none() {
            self.secretName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.secretName.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretName(&mut self) -> ::std::string::String {
        self.secretName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hosts",
            |m: &IngressTLS| { &m.hosts },
            |m: &mut IngressTLS| { &mut m.hosts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "secretName",
            |m: &IngressTLS| { &m.secretName },
            |m: &mut IngressTLS| { &mut m.secretName },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressTLS>(
            "IngressTLS",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressTLS {
    const NAME: &'static str = "IngressTLS";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hosts.push(is.read_string()?);
                },
                18 => {
                    self.secretName = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.hosts {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.secretName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.hosts {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.secretName.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressTLS {
        IngressTLS::new()
    }

    fn clear(&mut self) {
        self.hosts.clear();
        self.secretName = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressTLS {
        static instance: IngressTLS = IngressTLS {
            hosts: ::std::vec::Vec::new(),
            secretName: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressTLS {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressTLS").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressTLS {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressTLS {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.NetworkPolicy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NetworkPolicy {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.NetworkPolicy.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.NetworkPolicy.spec)
    pub spec: ::protobuf::MessageField<NetworkPolicySpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.NetworkPolicy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NetworkPolicy {
    fn default() -> &'a NetworkPolicy {
        <NetworkPolicy as ::protobuf::Message>::default_instance()
    }
}

impl NetworkPolicy {
    pub fn new() -> NetworkPolicy {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.networking.v1.NetworkPolicySpec spec = 2;

    pub fn spec(&self) -> &NetworkPolicySpec {
        self.spec.as_ref().unwrap_or_else(|| <NetworkPolicySpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: NetworkPolicySpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut NetworkPolicySpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> NetworkPolicySpec {
        self.spec.take().unwrap_or_else(|| NetworkPolicySpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &NetworkPolicy| { &m.metadata },
            |m: &mut NetworkPolicy| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NetworkPolicySpec>(
            "spec",
            |m: &NetworkPolicy| { &m.spec },
            |m: &mut NetworkPolicy| { &mut m.spec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NetworkPolicy>(
            "NetworkPolicy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NetworkPolicy {
    const NAME: &'static str = "NetworkPolicy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NetworkPolicy {
        NetworkPolicy::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NetworkPolicy {
        static instance: NetworkPolicy = NetworkPolicy {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NetworkPolicy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NetworkPolicy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NetworkPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkPolicy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.NetworkPolicyEgressRule)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NetworkPolicyEgressRule {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.NetworkPolicyEgressRule.ports)
    pub ports: ::std::vec::Vec<NetworkPolicyPort>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.NetworkPolicyEgressRule.to)
    pub to: ::std::vec::Vec<NetworkPolicyPeer>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.NetworkPolicyEgressRule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NetworkPolicyEgressRule {
    fn default() -> &'a NetworkPolicyEgressRule {
        <NetworkPolicyEgressRule as ::protobuf::Message>::default_instance()
    }
}

impl NetworkPolicyEgressRule {
    pub fn new() -> NetworkPolicyEgressRule {
        ::std::default::Default::default()
    }

    // repeated .api.networking.v1.NetworkPolicyPort ports = 1;

    pub fn ports(&self) -> &[NetworkPolicyPort] {
        &self.ports
    }

    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::std::vec::Vec<NetworkPolicyPort>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::std::vec::Vec<NetworkPolicyPort> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::std::vec::Vec<NetworkPolicyPort> {
        ::std::mem::replace(&mut self.ports, ::std::vec::Vec::new())
    }

    // repeated .api.networking.v1.NetworkPolicyPeer to = 2;

    pub fn to(&self) -> &[NetworkPolicyPeer] {
        &self.to
    }

    pub fn clear_to(&mut self) {
        self.to.clear();
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: ::std::vec::Vec<NetworkPolicyPeer>) {
        self.to = v;
    }

    // Mutable pointer to the field.
    pub fn mut_to(&mut self) -> &mut ::std::vec::Vec<NetworkPolicyPeer> {
        &mut self.to
    }

    // Take field
    pub fn take_to(&mut self) -> ::std::vec::Vec<NetworkPolicyPeer> {
        ::std::mem::replace(&mut self.to, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ports",
            |m: &NetworkPolicyEgressRule| { &m.ports },
            |m: &mut NetworkPolicyEgressRule| { &mut m.ports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "to",
            |m: &NetworkPolicyEgressRule| { &m.to },
            |m: &mut NetworkPolicyEgressRule| { &mut m.to },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NetworkPolicyEgressRule>(
            "NetworkPolicyEgressRule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NetworkPolicyEgressRule {
    const NAME: &'static str = "NetworkPolicyEgressRule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ports.push(is.read_message()?);
                },
                18 => {
                    self.to.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.to {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ports {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.to {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NetworkPolicyEgressRule {
        NetworkPolicyEgressRule::new()
    }

    fn clear(&mut self) {
        self.ports.clear();
        self.to.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NetworkPolicyEgressRule {
        static instance: NetworkPolicyEgressRule = NetworkPolicyEgressRule {
            ports: ::std::vec::Vec::new(),
            to: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NetworkPolicyEgressRule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NetworkPolicyEgressRule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NetworkPolicyEgressRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkPolicyEgressRule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.NetworkPolicyIngressRule)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NetworkPolicyIngressRule {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.NetworkPolicyIngressRule.ports)
    pub ports: ::std::vec::Vec<NetworkPolicyPort>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.NetworkPolicyIngressRule.from)
    pub from: ::std::vec::Vec<NetworkPolicyPeer>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.NetworkPolicyIngressRule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NetworkPolicyIngressRule {
    fn default() -> &'a NetworkPolicyIngressRule {
        <NetworkPolicyIngressRule as ::protobuf::Message>::default_instance()
    }
}

impl NetworkPolicyIngressRule {
    pub fn new() -> NetworkPolicyIngressRule {
        ::std::default::Default::default()
    }

    // repeated .api.networking.v1.NetworkPolicyPort ports = 1;

    pub fn ports(&self) -> &[NetworkPolicyPort] {
        &self.ports
    }

    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::std::vec::Vec<NetworkPolicyPort>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::std::vec::Vec<NetworkPolicyPort> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::std::vec::Vec<NetworkPolicyPort> {
        ::std::mem::replace(&mut self.ports, ::std::vec::Vec::new())
    }

    // repeated .api.networking.v1.NetworkPolicyPeer from = 2;

    pub fn from(&self) -> &[NetworkPolicyPeer] {
        &self.from
    }

    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::std::vec::Vec<NetworkPolicyPeer>) {
        self.from = v;
    }

    // Mutable pointer to the field.
    pub fn mut_from(&mut self) -> &mut ::std::vec::Vec<NetworkPolicyPeer> {
        &mut self.from
    }

    // Take field
    pub fn take_from(&mut self) -> ::std::vec::Vec<NetworkPolicyPeer> {
        ::std::mem::replace(&mut self.from, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ports",
            |m: &NetworkPolicyIngressRule| { &m.ports },
            |m: &mut NetworkPolicyIngressRule| { &mut m.ports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "from",
            |m: &NetworkPolicyIngressRule| { &m.from },
            |m: &mut NetworkPolicyIngressRule| { &mut m.from },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NetworkPolicyIngressRule>(
            "NetworkPolicyIngressRule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NetworkPolicyIngressRule {
    const NAME: &'static str = "NetworkPolicyIngressRule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ports.push(is.read_message()?);
                },
                18 => {
                    self.from.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.from {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ports {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.from {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NetworkPolicyIngressRule {
        NetworkPolicyIngressRule::new()
    }

    fn clear(&mut self) {
        self.ports.clear();
        self.from.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NetworkPolicyIngressRule {
        static instance: NetworkPolicyIngressRule = NetworkPolicyIngressRule {
            ports: ::std::vec::Vec::new(),
            from: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NetworkPolicyIngressRule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NetworkPolicyIngressRule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NetworkPolicyIngressRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkPolicyIngressRule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.NetworkPolicyList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NetworkPolicyList {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.NetworkPolicyList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.NetworkPolicyList.items)
    pub items: ::std::vec::Vec<NetworkPolicy>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.NetworkPolicyList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NetworkPolicyList {
    fn default() -> &'a NetworkPolicyList {
        <NetworkPolicyList as ::protobuf::Message>::default_instance()
    }
}

impl NetworkPolicyList {
    pub fn new() -> NetworkPolicyList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.networking.v1.NetworkPolicy items = 2;

    pub fn items(&self) -> &[NetworkPolicy] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<NetworkPolicy>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<NetworkPolicy> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<NetworkPolicy> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &NetworkPolicyList| { &m.metadata },
            |m: &mut NetworkPolicyList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &NetworkPolicyList| { &m.items },
            |m: &mut NetworkPolicyList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NetworkPolicyList>(
            "NetworkPolicyList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NetworkPolicyList {
    const NAME: &'static str = "NetworkPolicyList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NetworkPolicyList {
        NetworkPolicyList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NetworkPolicyList {
        static instance: NetworkPolicyList = NetworkPolicyList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NetworkPolicyList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NetworkPolicyList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NetworkPolicyList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkPolicyList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.NetworkPolicyPeer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NetworkPolicyPeer {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.NetworkPolicyPeer.podSelector)
    pub podSelector: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.NetworkPolicyPeer.namespaceSelector)
    pub namespaceSelector: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.NetworkPolicyPeer.ipBlock)
    pub ipBlock: ::protobuf::MessageField<IPBlock>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.NetworkPolicyPeer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NetworkPolicyPeer {
    fn default() -> &'a NetworkPolicyPeer {
        <NetworkPolicyPeer as ::protobuf::Message>::default_instance()
    }
}

impl NetworkPolicyPeer {
    pub fn new() -> NetworkPolicyPeer {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;

    pub fn podSelector(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.podSelector.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_podSelector(&mut self) {
        self.podSelector.clear();
    }

    pub fn has_podSelector(&self) -> bool {
        self.podSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podSelector(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.podSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podSelector(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.podSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_podSelector(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.podSelector.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 2;

    pub fn namespaceSelector(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_namespaceSelector(&mut self) {
        self.namespaceSelector.clear();
    }

    pub fn has_namespaceSelector(&self) -> bool {
        self.namespaceSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespaceSelector(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.namespaceSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespaceSelector(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_namespaceSelector(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional .api.networking.v1.IPBlock ipBlock = 3;

    pub fn ipBlock(&self) -> &IPBlock {
        self.ipBlock.as_ref().unwrap_or_else(|| <IPBlock as ::protobuf::Message>::default_instance())
    }

    pub fn clear_ipBlock(&mut self) {
        self.ipBlock.clear();
    }

    pub fn has_ipBlock(&self) -> bool {
        self.ipBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipBlock(&mut self, v: IPBlock) {
        self.ipBlock = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipBlock(&mut self) -> &mut IPBlock {
        self.ipBlock.mut_or_insert_default()
    }

    // Take field
    pub fn take_ipBlock(&mut self) -> IPBlock {
        self.ipBlock.take().unwrap_or_else(|| IPBlock::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "podSelector",
            |m: &NetworkPolicyPeer| { &m.podSelector },
            |m: &mut NetworkPolicyPeer| { &mut m.podSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "namespaceSelector",
            |m: &NetworkPolicyPeer| { &m.namespaceSelector },
            |m: &mut NetworkPolicyPeer| { &mut m.namespaceSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IPBlock>(
            "ipBlock",
            |m: &NetworkPolicyPeer| { &m.ipBlock },
            |m: &mut NetworkPolicyPeer| { &mut m.ipBlock },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NetworkPolicyPeer>(
            "NetworkPolicyPeer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NetworkPolicyPeer {
    const NAME: &'static str = "NetworkPolicyPeer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.podSelector)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.namespaceSelector)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ipBlock)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.podSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.namespaceSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ipBlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.podSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.namespaceSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.ipBlock.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NetworkPolicyPeer {
        NetworkPolicyPeer::new()
    }

    fn clear(&mut self) {
        self.podSelector.clear();
        self.namespaceSelector.clear();
        self.ipBlock.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NetworkPolicyPeer {
        static instance: NetworkPolicyPeer = NetworkPolicyPeer {
            podSelector: ::protobuf::MessageField::none(),
            namespaceSelector: ::protobuf::MessageField::none(),
            ipBlock: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NetworkPolicyPeer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NetworkPolicyPeer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NetworkPolicyPeer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkPolicyPeer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.NetworkPolicyPort)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NetworkPolicyPort {
    // message fields
    // @@protoc_insertion_point(field:api.networking.v1.NetworkPolicyPort.protocol)
    pub protocol: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_33::intorstr")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.NetworkPolicyPort.port)
    pub port: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::util::intstr::IntOrString>,
    // @@protoc_insertion_point(field:api.networking.v1.NetworkPolicyPort.endPort)
    pub endPort: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.NetworkPolicyPort.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NetworkPolicyPort {
    fn default() -> &'a NetworkPolicyPort {
        <NetworkPolicyPort as ::protobuf::Message>::default_instance()
    }
}

impl NetworkPolicyPort {
    pub fn new() -> NetworkPolicyPort {
        ::std::default::Default::default()
    }

    // optional string protocol = 1;

    pub fn protocol(&self) -> &str {
        match self.protocol.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_protocol(&mut self) {
        self.protocol = ::std::option::Option::None;
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol = ::std::option::Option::Some(::std::string::String::new());
        }
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.util.intstr.IntOrString port = 2;

    pub fn port(&self) -> &crate::v1_33::apimachinery::pkg::util::intstr::IntOrString {
        self.port.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::util::intstr::IntOrString as ::protobuf::Message>::default_instance())
    }

    pub fn clear_port(&mut self) {
        self.port.clear();
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: crate::v1_33::apimachinery::pkg::util::intstr::IntOrString) {
        self.port = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_port(&mut self) -> &mut crate::v1_33::apimachinery::pkg::util::intstr::IntOrString {
        self.port.mut_or_insert_default()
    }

    // Take field
    pub fn take_port(&mut self) -> crate::v1_33::apimachinery::pkg::util::intstr::IntOrString {
        self.port.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::util::intstr::IntOrString::new())
    }

    // optional int32 endPort = 3;

    pub fn endPort(&self) -> i32 {
        self.endPort.unwrap_or(0)
    }

    pub fn clear_endPort(&mut self) {
        self.endPort = ::std::option::Option::None;
    }

    pub fn has_endPort(&self) -> bool {
        self.endPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endPort(&mut self, v: i32) {
        self.endPort = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol",
            |m: &NetworkPolicyPort| { &m.protocol },
            |m: &mut NetworkPolicyPort| { &mut m.protocol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::util::intstr::IntOrString>(
            "port",
            |m: &NetworkPolicyPort| { &m.port },
            |m: &mut NetworkPolicyPort| { &mut m.port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "endPort",
            |m: &NetworkPolicyPort| { &m.endPort },
            |m: &mut NetworkPolicyPort| { &mut m.endPort },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NetworkPolicyPort>(
            "NetworkPolicyPort",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NetworkPolicyPort {
    const NAME: &'static str = "NetworkPolicyPort";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.protocol = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.port)?;
                },
                24 => {
                    self.endPort = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.protocol.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.port.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.endPort {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.protocol.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.port.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.endPort {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NetworkPolicyPort {
        NetworkPolicyPort::new()
    }

    fn clear(&mut self) {
        self.protocol = ::std::option::Option::None;
        self.port.clear();
        self.endPort = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NetworkPolicyPort {
        static instance: NetworkPolicyPort = NetworkPolicyPort {
            protocol: ::std::option::Option::None,
            port: ::protobuf::MessageField::none(),
            endPort: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NetworkPolicyPort {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NetworkPolicyPort").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NetworkPolicyPort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkPolicyPort {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.NetworkPolicySpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NetworkPolicySpec {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.NetworkPolicySpec.podSelector)
    pub podSelector: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.NetworkPolicySpec.ingress)
    pub ingress: ::std::vec::Vec<NetworkPolicyIngressRule>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.NetworkPolicySpec.egress)
    pub egress: ::std::vec::Vec<NetworkPolicyEgressRule>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.NetworkPolicySpec.policyTypes)
    pub policyTypes: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.NetworkPolicySpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NetworkPolicySpec {
    fn default() -> &'a NetworkPolicySpec {
        <NetworkPolicySpec as ::protobuf::Message>::default_instance()
    }
}

impl NetworkPolicySpec {
    pub fn new() -> NetworkPolicySpec {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;

    pub fn podSelector(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.podSelector.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_podSelector(&mut self) {
        self.podSelector.clear();
    }

    pub fn has_podSelector(&self) -> bool {
        self.podSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podSelector(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.podSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podSelector(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.podSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_podSelector(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.podSelector.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // repeated .api.networking.v1.NetworkPolicyIngressRule ingress = 2;

    pub fn ingress(&self) -> &[NetworkPolicyIngressRule] {
        &self.ingress
    }

    pub fn clear_ingress(&mut self) {
        self.ingress.clear();
    }

    // Param is passed by value, moved
    pub fn set_ingress(&mut self, v: ::std::vec::Vec<NetworkPolicyIngressRule>) {
        self.ingress = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ingress(&mut self) -> &mut ::std::vec::Vec<NetworkPolicyIngressRule> {
        &mut self.ingress
    }

    // Take field
    pub fn take_ingress(&mut self) -> ::std::vec::Vec<NetworkPolicyIngressRule> {
        ::std::mem::replace(&mut self.ingress, ::std::vec::Vec::new())
    }

    // repeated .api.networking.v1.NetworkPolicyEgressRule egress = 3;

    pub fn egress(&self) -> &[NetworkPolicyEgressRule] {
        &self.egress
    }

    pub fn clear_egress(&mut self) {
        self.egress.clear();
    }

    // Param is passed by value, moved
    pub fn set_egress(&mut self, v: ::std::vec::Vec<NetworkPolicyEgressRule>) {
        self.egress = v;
    }

    // Mutable pointer to the field.
    pub fn mut_egress(&mut self) -> &mut ::std::vec::Vec<NetworkPolicyEgressRule> {
        &mut self.egress
    }

    // Take field
    pub fn take_egress(&mut self) -> ::std::vec::Vec<NetworkPolicyEgressRule> {
        ::std::mem::replace(&mut self.egress, ::std::vec::Vec::new())
    }

    // repeated string policyTypes = 4;

    pub fn policyTypes(&self) -> &[::std::string::String] {
        &self.policyTypes
    }

    pub fn clear_policyTypes(&mut self) {
        self.policyTypes.clear();
    }

    // Param is passed by value, moved
    pub fn set_policyTypes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.policyTypes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_policyTypes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.policyTypes
    }

    // Take field
    pub fn take_policyTypes(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.policyTypes, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "podSelector",
            |m: &NetworkPolicySpec| { &m.podSelector },
            |m: &mut NetworkPolicySpec| { &mut m.podSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ingress",
            |m: &NetworkPolicySpec| { &m.ingress },
            |m: &mut NetworkPolicySpec| { &mut m.ingress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "egress",
            |m: &NetworkPolicySpec| { &m.egress },
            |m: &mut NetworkPolicySpec| { &mut m.egress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "policyTypes",
            |m: &NetworkPolicySpec| { &m.policyTypes },
            |m: &mut NetworkPolicySpec| { &mut m.policyTypes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NetworkPolicySpec>(
            "NetworkPolicySpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NetworkPolicySpec {
    const NAME: &'static str = "NetworkPolicySpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.podSelector)?;
                },
                18 => {
                    self.ingress.push(is.read_message()?);
                },
                26 => {
                    self.egress.push(is.read_message()?);
                },
                34 => {
                    self.policyTypes.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.podSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ingress {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.egress {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.policyTypes {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.podSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ingress {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.egress {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.policyTypes {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NetworkPolicySpec {
        NetworkPolicySpec::new()
    }

    fn clear(&mut self) {
        self.podSelector.clear();
        self.ingress.clear();
        self.egress.clear();
        self.policyTypes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NetworkPolicySpec {
        static instance: NetworkPolicySpec = NetworkPolicySpec {
            podSelector: ::protobuf::MessageField::none(),
            ingress: ::std::vec::Vec::new(),
            egress: ::std::vec::Vec::new(),
            policyTypes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NetworkPolicySpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NetworkPolicySpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NetworkPolicySpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkPolicySpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.ParentReference)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ParentReference {
    // message fields
    // @@protoc_insertion_point(field:api.networking.v1.ParentReference.group)
    pub group: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.networking.v1.ParentReference.resource)
    pub resource: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.networking.v1.ParentReference.namespace)
    pub namespace: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.networking.v1.ParentReference.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.ParentReference.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ParentReference {
    fn default() -> &'a ParentReference {
        <ParentReference as ::protobuf::Message>::default_instance()
    }
}

impl ParentReference {
    pub fn new() -> ParentReference {
        ::std::default::Default::default()
    }

    // optional string group = 1;

    pub fn group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_group(&mut self) {
        self.group = ::std::option::Option::None;
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group = ::std::option::Option::Some(::std::string::String::new());
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resource = 2;

    pub fn resource(&self) -> &str {
        match self.resource.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resource(&mut self) {
        self.resource = ::std::option::Option::None;
    }

    pub fn has_resource(&self) -> bool {
        self.resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: ::std::string::String) {
        self.resource = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut ::std::string::String {
        if self.resource.is_none() {
            self.resource = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resource.as_mut().unwrap()
    }

    // Take field
    pub fn take_resource(&mut self) -> ::std::string::String {
        self.resource.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string namespace = 3;

    pub fn namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_namespace(&mut self) {
        self.namespace = ::std::option::Option::None;
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 4;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "group",
            |m: &ParentReference| { &m.group },
            |m: &mut ParentReference| { &mut m.group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resource",
            |m: &ParentReference| { &m.resource },
            |m: &mut ParentReference| { &mut m.resource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "namespace",
            |m: &ParentReference| { &m.namespace },
            |m: &mut ParentReference| { &mut m.namespace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ParentReference| { &m.name },
            |m: &mut ParentReference| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ParentReference>(
            "ParentReference",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ParentReference {
    const NAME: &'static str = "ParentReference";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.group = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.resource = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.namespace = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.resource.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.group.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.resource.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.namespace.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ParentReference {
        ParentReference::new()
    }

    fn clear(&mut self) {
        self.group = ::std::option::Option::None;
        self.resource = ::std::option::Option::None;
        self.namespace = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ParentReference {
        static instance: ParentReference = ParentReference {
            group: ::std::option::Option::None,
            resource: ::std::option::Option::None,
            namespace: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ParentReference {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ParentReference").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ParentReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParentReference {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.ServiceBackendPort)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServiceBackendPort {
    // message fields
    // @@protoc_insertion_point(field:api.networking.v1.ServiceBackendPort.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.networking.v1.ServiceBackendPort.number)
    pub number: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.ServiceBackendPort.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceBackendPort {
    fn default() -> &'a ServiceBackendPort {
        <ServiceBackendPort as ::protobuf::Message>::default_instance()
    }
}

impl ServiceBackendPort {
    pub fn new() -> ServiceBackendPort {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 number = 2;

    pub fn number(&self) -> i32 {
        self.number.unwrap_or(0)
    }

    pub fn clear_number(&mut self) {
        self.number = ::std::option::Option::None;
    }

    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: i32) {
        self.number = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ServiceBackendPort| { &m.name },
            |m: &mut ServiceBackendPort| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number",
            |m: &ServiceBackendPort| { &m.number },
            |m: &mut ServiceBackendPort| { &mut m.number },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServiceBackendPort>(
            "ServiceBackendPort",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServiceBackendPort {
    const NAME: &'static str = "ServiceBackendPort";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.number = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.number {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.number {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceBackendPort {
        ServiceBackendPort::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.number = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceBackendPort {
        static instance: ServiceBackendPort = ServiceBackendPort {
            name: ::std::option::Option::None,
            number: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServiceBackendPort {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceBackendPort").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceBackendPort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceBackendPort {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.ServiceCIDR)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServiceCIDR {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.ServiceCIDR.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.ServiceCIDR.spec)
    pub spec: ::protobuf::MessageField<ServiceCIDRSpec>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.ServiceCIDR.status)
    pub status: ::protobuf::MessageField<ServiceCIDRStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.ServiceCIDR.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceCIDR {
    fn default() -> &'a ServiceCIDR {
        <ServiceCIDR as ::protobuf::Message>::default_instance()
    }
}

impl ServiceCIDR {
    pub fn new() -> ServiceCIDR {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.networking.v1.ServiceCIDRSpec spec = 2;

    pub fn spec(&self) -> &ServiceCIDRSpec {
        self.spec.as_ref().unwrap_or_else(|| <ServiceCIDRSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ServiceCIDRSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ServiceCIDRSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ServiceCIDRSpec {
        self.spec.take().unwrap_or_else(|| ServiceCIDRSpec::new())
    }

    // optional .api.networking.v1.ServiceCIDRStatus status = 3;

    pub fn status(&self) -> &ServiceCIDRStatus {
        self.status.as_ref().unwrap_or_else(|| <ServiceCIDRStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ServiceCIDRStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ServiceCIDRStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> ServiceCIDRStatus {
        self.status.take().unwrap_or_else(|| ServiceCIDRStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ServiceCIDR| { &m.metadata },
            |m: &mut ServiceCIDR| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ServiceCIDRSpec>(
            "spec",
            |m: &ServiceCIDR| { &m.spec },
            |m: &mut ServiceCIDR| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ServiceCIDRStatus>(
            "status",
            |m: &ServiceCIDR| { &m.status },
            |m: &mut ServiceCIDR| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServiceCIDR>(
            "ServiceCIDR",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServiceCIDR {
    const NAME: &'static str = "ServiceCIDR";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceCIDR {
        ServiceCIDR::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceCIDR {
        static instance: ServiceCIDR = ServiceCIDR {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServiceCIDR {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceCIDR").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceCIDR {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceCIDR {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.ServiceCIDRList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServiceCIDRList {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.ServiceCIDRList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.ServiceCIDRList.items)
    pub items: ::std::vec::Vec<ServiceCIDR>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.ServiceCIDRList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceCIDRList {
    fn default() -> &'a ServiceCIDRList {
        <ServiceCIDRList as ::protobuf::Message>::default_instance()
    }
}

impl ServiceCIDRList {
    pub fn new() -> ServiceCIDRList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.networking.v1.ServiceCIDR items = 2;

    pub fn items(&self) -> &[ServiceCIDR] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ServiceCIDR>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ServiceCIDR> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ServiceCIDR> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ServiceCIDRList| { &m.metadata },
            |m: &mut ServiceCIDRList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ServiceCIDRList| { &m.items },
            |m: &mut ServiceCIDRList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServiceCIDRList>(
            "ServiceCIDRList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServiceCIDRList {
    const NAME: &'static str = "ServiceCIDRList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceCIDRList {
        ServiceCIDRList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceCIDRList {
        static instance: ServiceCIDRList = ServiceCIDRList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServiceCIDRList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceCIDRList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceCIDRList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceCIDRList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.ServiceCIDRSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServiceCIDRSpec {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.ServiceCIDRSpec.cidrs)
    pub cidrs: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.ServiceCIDRSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceCIDRSpec {
    fn default() -> &'a ServiceCIDRSpec {
        <ServiceCIDRSpec as ::protobuf::Message>::default_instance()
    }
}

impl ServiceCIDRSpec {
    pub fn new() -> ServiceCIDRSpec {
        ::std::default::Default::default()
    }

    // repeated string cidrs = 1;

    pub fn cidrs(&self) -> &[::std::string::String] {
        &self.cidrs
    }

    pub fn clear_cidrs(&mut self) {
        self.cidrs.clear();
    }

    // Param is passed by value, moved
    pub fn set_cidrs(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.cidrs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cidrs(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.cidrs
    }

    // Take field
    pub fn take_cidrs(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.cidrs, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cidrs",
            |m: &ServiceCIDRSpec| { &m.cidrs },
            |m: &mut ServiceCIDRSpec| { &mut m.cidrs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServiceCIDRSpec>(
            "ServiceCIDRSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServiceCIDRSpec {
    const NAME: &'static str = "ServiceCIDRSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cidrs.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.cidrs {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.cidrs {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceCIDRSpec {
        ServiceCIDRSpec::new()
    }

    fn clear(&mut self) {
        self.cidrs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceCIDRSpec {
        static instance: ServiceCIDRSpec = ServiceCIDRSpec {
            cidrs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServiceCIDRSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceCIDRSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceCIDRSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceCIDRSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1.ServiceCIDRStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServiceCIDRStatus {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1.ServiceCIDRStatus.conditions)
    pub conditions: ::std::vec::Vec<crate::v1_33::apimachinery::pkg::apis::meta::v1::Condition>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1.ServiceCIDRStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceCIDRStatus {
    fn default() -> &'a ServiceCIDRStatus {
        <ServiceCIDRStatus as ::protobuf::Message>::default_instance()
    }
}

impl ServiceCIDRStatus {
    pub fn new() -> ServiceCIDRStatus {
        ::std::default::Default::default()
    }

    // repeated .apimachinery.pkg.apis.meta.v1.Condition conditions = 1;

    pub fn conditions(&self) -> &[crate::v1_33::apimachinery::pkg::apis::meta::v1::Condition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<crate::v1_33::apimachinery::pkg::apis::meta::v1::Condition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<crate::v1_33::apimachinery::pkg::apis::meta::v1::Condition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<crate::v1_33::apimachinery::pkg::apis::meta::v1::Condition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &ServiceCIDRStatus| { &m.conditions },
            |m: &mut ServiceCIDRStatus| { &mut m.conditions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServiceCIDRStatus>(
            "ServiceCIDRStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServiceCIDRStatus {
    const NAME: &'static str = "ServiceCIDRStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.conditions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceCIDRStatus {
        ServiceCIDRStatus::new()
    }

    fn clear(&mut self) {
        self.conditions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceCIDRStatus {
        static instance: ServiceCIDRStatus = ServiceCIDRStatus {
            conditions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServiceCIDRStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceCIDRStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceCIDRStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceCIDRStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n!api/networking/v1/generated.proto\x12\x11api.networking.v1\x1a\x1bapi\
    /core/v1/generated.proto\x1a-apimachinery/pkg/apis/meta/v1/generated.pro\
    to\x1a(apimachinery/pkg/runtime/generated.proto\x1a/apimachinery/pkg/run\
    time/schema/generated.proto\x1a,apimachinery/pkg/util/intstr/generated.p\
    roto\"~\n\x0fHTTPIngressPath\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04pa\
    th\x12\x1a\n\x08pathType\x18\x03\x20\x01(\tR\x08pathType\x12;\n\x07backe\
    nd\x18\x02\x20\x01(\x0b2!.api.networking.v1.IngressBackendR\x07backend\"\
    P\n\x14HTTPIngressRuleValue\x128\n\x05paths\x18\x01\x20\x03(\x0b2\".api.\
    networking.v1.HTTPIngressPathR\x05paths\"\x88\x01\n\tIPAddress\x12E\n\
    \x08metadata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.Object\
    MetaR\x08metadata\x124\n\x04spec\x18\x02\x20\x01(\x0b2\x20.api.networkin\
    g.v1.IPAddressSpecR\x04spec\"\x88\x01\n\rIPAddressList\x12C\n\x08metadat\
    a\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMetaR\x08meta\
    data\x122\n\x05items\x18\x02\x20\x03(\x0b2\x1c.api.networking.v1.IPAddre\
    ssR\x05items\"Q\n\rIPAddressSpec\x12@\n\tparentRef\x18\x01\x20\x01(\x0b2\
    \".api.networking.v1.ParentReferenceR\tparentRef\"5\n\x07IPBlock\x12\x12\
    \n\x04cidr\x18\x01\x20\x01(\tR\x04cidr\x12\x16\n\x06except\x18\x02\x20\
    \x03(\tR\x06except\"\xbe\x01\n\x07Ingress\x12E\n\x08metadata\x18\x01\x20\
    \x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x122\n\
    \x04spec\x18\x02\x20\x01(\x0b2\x1e.api.networking.v1.IngressSpecR\x04spe\
    c\x128\n\x06status\x18\x03\x20\x01(\x0b2\x20.api.networking.v1.IngressSt\
    atusR\x06status\"\x98\x01\n\x0eIngressBackend\x12B\n\x07service\x18\x04\
    \x20\x01(\x0b2(.api.networking.v1.IngressServiceBackendR\x07service\x12B\
    \n\x08resource\x18\x03\x20\x01(\x0b2&.api.core.v1.TypedLocalObjectRefere\
    nceR\x08resource\"\x8e\x01\n\x0cIngressClass\x12E\n\x08metadata\x18\x01\
    \x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\
    \x127\n\x04spec\x18\x02\x20\x01(\x0b2#.api.networking.v1.IngressClassSpe\
    cR\x04spec\"\x8e\x01\n\x10IngressClassList\x12C\n\x08metadata\x18\x01\
    \x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x125\
    \n\x05items\x18\x02\x20\x03(\x0b2\x1f.api.networking.v1.IngressClassR\
    \x05items\"\x99\x01\n\x1fIngressClassParametersReference\x12\x1a\n\x08aP\
    IGroup\x18\x01\x20\x01(\tR\x08aPIGroup\x12\x12\n\x04kind\x18\x02\x20\x01\
    (\tR\x04kind\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x14\n\x05\
    scope\x18\x04\x20\x01(\tR\x05scope\x12\x1c\n\tnamespace\x18\x05\x20\x01(\
    \tR\tnamespace\"\x86\x01\n\x10IngressClassSpec\x12\x1e\n\ncontroller\x18\
    \x01\x20\x01(\tR\ncontroller\x12R\n\nparameters\x18\x02\x20\x01(\x0b22.a\
    pi.networking.v1.IngressClassParametersReferenceR\nparameters\"\x84\x01\
    \n\x0bIngressList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery\
    .pkg.apis.meta.v1.ListMetaR\x08metadata\x120\n\x05items\x18\x02\x20\x03(\
    \x0b2\x1a.api.networking.v1.IngressR\x05items\"\x84\x01\n\x1aIngressLoad\
    BalancerIngress\x12\x0e\n\x02ip\x18\x01\x20\x01(\tR\x02ip\x12\x1a\n\x08h\
    ostname\x18\x02\x20\x01(\tR\x08hostname\x12:\n\x05ports\x18\x04\x20\x03(\
    \x0b2$.api.networking.v1.IngressPortStatusR\x05ports\"d\n\x19IngressLoad\
    BalancerStatus\x12G\n\x07ingress\x18\x01\x20\x03(\x0b2-.api.networking.v\
    1.IngressLoadBalancerIngressR\x07ingress\"Y\n\x11IngressPortStatus\x12\
    \x12\n\x04port\x18\x01\x20\x01(\x05R\x04port\x12\x1a\n\x08protocol\x18\
    \x02\x20\x01(\tR\x08protocol\x12\x14\n\x05error\x18\x03\x20\x01(\tR\x05e\
    rror\"r\n\x0bIngressRule\x12\x12\n\x04host\x18\x01\x20\x01(\tR\x04host\
    \x12O\n\x10ingressRuleValue\x18\x02\x20\x01(\x0b2#.api.networking.v1.Ing\
    ressRuleValueR\x10ingressRuleValue\"O\n\x10IngressRuleValue\x12;\n\x04ht\
    tp\x18\x01\x20\x01(\x0b2'.api.networking.v1.HTTPIngressRuleValueR\x04htt\
    p\"f\n\x15IngressServiceBackend\x12\x12\n\x04name\x18\x01\x20\x01(\tR\
    \x04name\x129\n\x04port\x18\x02\x20\x01(\x0b2%.api.networking.v1.Service\
    BackendPortR\x04port\"\xeb\x01\n\x0bIngressSpec\x12*\n\x10ingressClassNa\
    me\x18\x04\x20\x01(\tR\x10ingressClassName\x12I\n\x0edefaultBackend\x18\
    \x01\x20\x01(\x0b2!.api.networking.v1.IngressBackendR\x0edefaultBackend\
    \x12/\n\x03tls\x18\x02\x20\x03(\x0b2\x1d.api.networking.v1.IngressTLSR\
    \x03tls\x124\n\x05rules\x18\x03\x20\x03(\x0b2\x1e.api.networking.v1.Ingr\
    essRuleR\x05rules\"a\n\rIngressStatus\x12P\n\x0cloadBalancer\x18\x01\x20\
    \x01(\x0b2,.api.networking.v1.IngressLoadBalancerStatusR\x0cloadBalancer\
    \"B\n\nIngressTLS\x12\x14\n\x05hosts\x18\x01\x20\x03(\tR\x05hosts\x12\
    \x1e\n\nsecretName\x18\x02\x20\x01(\tR\nsecretName\"\x90\x01\n\rNetworkP\
    olicy\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.me\
    ta.v1.ObjectMetaR\x08metadata\x128\n\x04spec\x18\x02\x20\x01(\x0b2$.api.\
    networking.v1.NetworkPolicySpecR\x04spec\"\x8b\x01\n\x17NetworkPolicyEgr\
    essRule\x12:\n\x05ports\x18\x01\x20\x03(\x0b2$.api.networking.v1.Network\
    PolicyPortR\x05ports\x124\n\x02to\x18\x02\x20\x03(\x0b2$.api.networking.\
    v1.NetworkPolicyPeerR\x02to\"\x90\x01\n\x18NetworkPolicyIngressRule\x12:\
    \n\x05ports\x18\x01\x20\x03(\x0b2$.api.networking.v1.NetworkPolicyPortR\
    \x05ports\x128\n\x04from\x18\x02\x20\x03(\x0b2$.api.networking.v1.Networ\
    kPolicyPeerR\x04from\"\x90\x01\n\x11NetworkPolicyList\x12C\n\x08metadata\
    \x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metad\
    ata\x126\n\x05items\x18\x02\x20\x03(\x0b2\x20.api.networking.v1.NetworkP\
    olicyR\x05items\"\xf5\x01\n\x11NetworkPolicyPeer\x12N\n\x0bpodSelector\
    \x18\x01\x20\x01(\x0b2,.apimachinery.pkg.apis.meta.v1.LabelSelectorR\x0b\
    podSelector\x12Z\n\x11namespaceSelector\x18\x02\x20\x01(\x0b2,.apimachin\
    ery.pkg.apis.meta.v1.LabelSelectorR\x11namespaceSelector\x124\n\x07ipBlo\
    ck\x18\x03\x20\x01(\x0b2\x1a.api.networking.v1.IPBlockR\x07ipBlock\"\x88\
    \x01\n\x11NetworkPolicyPort\x12\x1a\n\x08protocol\x18\x01\x20\x01(\tR\
    \x08protocol\x12=\n\x04port\x18\x02\x20\x01(\x0b2).apimachinery.pkg.util\
    .intstr.IntOrStringR\x04port\x12\x18\n\x07endPort\x18\x03\x20\x01(\x05R\
    \x07endPort\"\x90\x02\n\x11NetworkPolicySpec\x12N\n\x0bpodSelector\x18\
    \x01\x20\x01(\x0b2,.apimachinery.pkg.apis.meta.v1.LabelSelectorR\x0bpodS\
    elector\x12E\n\x07ingress\x18\x02\x20\x03(\x0b2+.api.networking.v1.Netwo\
    rkPolicyIngressRuleR\x07ingress\x12B\n\x06egress\x18\x03\x20\x03(\x0b2*.\
    api.networking.v1.NetworkPolicyEgressRuleR\x06egress\x12\x20\n\x0bpolicy\
    Types\x18\x04\x20\x03(\tR\x0bpolicyTypes\"u\n\x0fParentReference\x12\x14\
    \n\x05group\x18\x01\x20\x01(\tR\x05group\x12\x1a\n\x08resource\x18\x02\
    \x20\x01(\tR\x08resource\x12\x1c\n\tnamespace\x18\x03\x20\x01(\tR\tnames\
    pace\x12\x12\n\x04name\x18\x04\x20\x01(\tR\x04name\"@\n\x12ServiceBacken\
    dPort\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x16\n\x06number\
    \x18\x02\x20\x01(\x05R\x06number\"\xca\x01\n\x0bServiceCIDR\x12E\n\x08me\
    tadata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\
    \x08metadata\x126\n\x04spec\x18\x02\x20\x01(\x0b2\".api.networking.v1.Se\
    rviceCIDRSpecR\x04spec\x12<\n\x06status\x18\x03\x20\x01(\x0b2$.api.netwo\
    rking.v1.ServiceCIDRStatusR\x06status\"\x8c\x01\n\x0fServiceCIDRList\x12\
    C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.Lis\
    tMetaR\x08metadata\x124\n\x05items\x18\x02\x20\x03(\x0b2\x1e.api.network\
    ing.v1.ServiceCIDRR\x05items\"'\n\x0fServiceCIDRSpec\x12\x14\n\x05cidrs\
    \x18\x01\x20\x03(\tR\x05cidrs\"]\n\x11ServiceCIDRStatus\x12H\n\nconditio\
    ns\x18\x01\x20\x03(\x0b2(.apimachinery.pkg.apis.meta.v1.ConditionR\ncond\
    itionsB\x1aZ\x18k8s.io/api/networking/v1\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(5);
            deps.push(super::v1::file_descriptor().clone());
            deps.push(super::v1::file_descriptor().clone());
            deps.push(super::v1::file_descriptor().clone());
            deps.push(super::v1::file_descriptor().clone());
            deps.push(super::v1::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(35);
            messages.push(HTTPIngressPath::generated_message_descriptor_data());
            messages.push(HTTPIngressRuleValue::generated_message_descriptor_data());
            messages.push(IPAddress::generated_message_descriptor_data());
            messages.push(IPAddressList::generated_message_descriptor_data());
            messages.push(IPAddressSpec::generated_message_descriptor_data());
            messages.push(IPBlock::generated_message_descriptor_data());
            messages.push(Ingress::generated_message_descriptor_data());
            messages.push(IngressBackend::generated_message_descriptor_data());
            messages.push(IngressClass::generated_message_descriptor_data());
            messages.push(IngressClassList::generated_message_descriptor_data());
            messages.push(IngressClassParametersReference::generated_message_descriptor_data());
            messages.push(IngressClassSpec::generated_message_descriptor_data());
            messages.push(IngressList::generated_message_descriptor_data());
            messages.push(IngressLoadBalancerIngress::generated_message_descriptor_data());
            messages.push(IngressLoadBalancerStatus::generated_message_descriptor_data());
            messages.push(IngressPortStatus::generated_message_descriptor_data());
            messages.push(IngressRule::generated_message_descriptor_data());
            messages.push(IngressRuleValue::generated_message_descriptor_data());
            messages.push(IngressServiceBackend::generated_message_descriptor_data());
            messages.push(IngressSpec::generated_message_descriptor_data());
            messages.push(IngressStatus::generated_message_descriptor_data());
            messages.push(IngressTLS::generated_message_descriptor_data());
            messages.push(NetworkPolicy::generated_message_descriptor_data());
            messages.push(NetworkPolicyEgressRule::generated_message_descriptor_data());
            messages.push(NetworkPolicyIngressRule::generated_message_descriptor_data());
            messages.push(NetworkPolicyList::generated_message_descriptor_data());
            messages.push(NetworkPolicyPeer::generated_message_descriptor_data());
            messages.push(NetworkPolicyPort::generated_message_descriptor_data());
            messages.push(NetworkPolicySpec::generated_message_descriptor_data());
            messages.push(ParentReference::generated_message_descriptor_data());
            messages.push(ServiceBackendPort::generated_message_descriptor_data());
            messages.push(ServiceCIDR::generated_message_descriptor_data());
            messages.push(ServiceCIDRList::generated_message_descriptor_data());
            messages.push(ServiceCIDRSpec::generated_message_descriptor_data());
            messages.push(ServiceCIDRStatus::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
