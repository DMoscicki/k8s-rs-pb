// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc 30.2
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `api/resource/v1beta2/generated.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.AllocatedDeviceStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AllocatedDeviceStatus {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta2.AllocatedDeviceStatus.driver)
    pub driver: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.AllocatedDeviceStatus.pool)
    pub pool: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.AllocatedDeviceStatus.device)
    pub device: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.AllocatedDeviceStatus.conditions)
    pub conditions: ::std::vec::Vec<crate::v1_33::apimachinery::pkg::apis::meta::v1::Condition>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.AllocatedDeviceStatus.data)
    pub data: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::runtime::RawExtension>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.AllocatedDeviceStatus.networkData)
    pub networkData: ::protobuf::MessageField<NetworkDeviceData>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.AllocatedDeviceStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AllocatedDeviceStatus {
    fn default() -> &'a AllocatedDeviceStatus {
        <AllocatedDeviceStatus as ::protobuf::Message>::default_instance()
    }
}

impl AllocatedDeviceStatus {
    pub fn new() -> AllocatedDeviceStatus {
        ::std::default::Default::default()
    }

    // optional string driver = 1;

    pub fn driver(&self) -> &str {
        match self.driver.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_driver(&mut self) {
        self.driver = ::std::option::Option::None;
    }

    pub fn has_driver(&self) -> bool {
        self.driver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driver(&mut self, v: ::std::string::String) {
        self.driver = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver(&mut self) -> &mut ::std::string::String {
        if self.driver.is_none() {
            self.driver = ::std::option::Option::Some(::std::string::String::new());
        }
        self.driver.as_mut().unwrap()
    }

    // Take field
    pub fn take_driver(&mut self) -> ::std::string::String {
        self.driver.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pool = 2;

    pub fn pool(&self) -> &str {
        match self.pool.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pool(&mut self) {
        self.pool = ::std::option::Option::None;
    }

    pub fn has_pool(&self) -> bool {
        self.pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pool(&mut self, v: ::std::string::String) {
        self.pool = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pool(&mut self) -> &mut ::std::string::String {
        if self.pool.is_none() {
            self.pool = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pool.as_mut().unwrap()
    }

    // Take field
    pub fn take_pool(&mut self) -> ::std::string::String {
        self.pool.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string device = 3;

    pub fn device(&self) -> &str {
        match self.device.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device(&mut self) {
        self.device = ::std::option::Option::None;
    }

    pub fn has_device(&self) -> bool {
        self.device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: ::std::string::String) {
        self.device = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut ::std::string::String {
        if self.device.is_none() {
            self.device = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device.as_mut().unwrap()
    }

    // Take field
    pub fn take_device(&mut self) -> ::std::string::String {
        self.device.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .apimachinery.pkg.apis.meta.v1.Condition conditions = 4;

    pub fn conditions(&self) -> &[crate::v1_33::apimachinery::pkg::apis::meta::v1::Condition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<crate::v1_33::apimachinery::pkg::apis::meta::v1::Condition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<crate::v1_33::apimachinery::pkg::apis::meta::v1::Condition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<crate::v1_33::apimachinery::pkg::apis::meta::v1::Condition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    // optional .apimachinery.pkg.runtime.RawExtension data = 5;

    pub fn data(&self) -> &crate::v1_33::apimachinery::pkg::runtime::RawExtension {
        self.data.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::runtime::RawExtension as ::protobuf::Message>::default_instance())
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: crate::v1_33::apimachinery::pkg::runtime::RawExtension) {
        self.data = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut crate::v1_33::apimachinery::pkg::runtime::RawExtension {
        self.data.mut_or_insert_default()
    }

    // Take field
    pub fn take_data(&mut self) -> crate::v1_33::apimachinery::pkg::runtime::RawExtension {
        self.data.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::runtime::RawExtension::new())
    }

    // optional .api.resource.v1beta2.NetworkDeviceData networkData = 6;

    pub fn networkData(&self) -> &NetworkDeviceData {
        self.networkData.as_ref().unwrap_or_else(|| <NetworkDeviceData as ::protobuf::Message>::default_instance())
    }

    pub fn clear_networkData(&mut self) {
        self.networkData.clear();
    }

    pub fn has_networkData(&self) -> bool {
        self.networkData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_networkData(&mut self, v: NetworkDeviceData) {
        self.networkData = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_networkData(&mut self) -> &mut NetworkDeviceData {
        self.networkData.mut_or_insert_default()
    }

    // Take field
    pub fn take_networkData(&mut self) -> NetworkDeviceData {
        self.networkData.take().unwrap_or_else(|| NetworkDeviceData::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "driver",
            |m: &AllocatedDeviceStatus| { &m.driver },
            |m: &mut AllocatedDeviceStatus| { &mut m.driver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pool",
            |m: &AllocatedDeviceStatus| { &m.pool },
            |m: &mut AllocatedDeviceStatus| { &mut m.pool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "device",
            |m: &AllocatedDeviceStatus| { &m.device },
            |m: &mut AllocatedDeviceStatus| { &mut m.device },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &AllocatedDeviceStatus| { &m.conditions },
            |m: &mut AllocatedDeviceStatus| { &mut m.conditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::runtime::RawExtension>(
            "data",
            |m: &AllocatedDeviceStatus| { &m.data },
            |m: &mut AllocatedDeviceStatus| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NetworkDeviceData>(
            "networkData",
            |m: &AllocatedDeviceStatus| { &m.networkData },
            |m: &mut AllocatedDeviceStatus| { &mut m.networkData },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AllocatedDeviceStatus>(
            "AllocatedDeviceStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AllocatedDeviceStatus {
    const NAME: &'static str = "AllocatedDeviceStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.driver = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.pool = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.device = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.conditions.push(is.read_message()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.networkData)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.driver.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.pool.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.device.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.networkData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.driver.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.pool.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.device.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.networkData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AllocatedDeviceStatus {
        AllocatedDeviceStatus::new()
    }

    fn clear(&mut self) {
        self.driver = ::std::option::Option::None;
        self.pool = ::std::option::Option::None;
        self.device = ::std::option::Option::None;
        self.conditions.clear();
        self.data.clear();
        self.networkData.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AllocatedDeviceStatus {
        static instance: AllocatedDeviceStatus = AllocatedDeviceStatus {
            driver: ::std::option::Option::None,
            pool: ::std::option::Option::None,
            device: ::std::option::Option::None,
            conditions: ::std::vec::Vec::new(),
            data: ::protobuf::MessageField::none(),
            networkData: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AllocatedDeviceStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AllocatedDeviceStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AllocatedDeviceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllocatedDeviceStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.AllocationResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AllocationResult {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.AllocationResult.devices)
    pub devices: ::protobuf::MessageField<DeviceAllocationResult>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.AllocationResult.nodeSelector)
    pub nodeSelector: ::protobuf::MessageField<crate::v1_33::api::core::v1::NodeSelector>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.AllocationResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AllocationResult {
    fn default() -> &'a AllocationResult {
        <AllocationResult as ::protobuf::Message>::default_instance()
    }
}

impl AllocationResult {
    pub fn new() -> AllocationResult {
        ::std::default::Default::default()
    }

    // optional .api.resource.v1beta2.DeviceAllocationResult devices = 1;

    pub fn devices(&self) -> &DeviceAllocationResult {
        self.devices.as_ref().unwrap_or_else(|| <DeviceAllocationResult as ::protobuf::Message>::default_instance())
    }

    pub fn clear_devices(&mut self) {
        self.devices.clear();
    }

    pub fn has_devices(&self) -> bool {
        self.devices.is_some()
    }

    // Param is passed by value, moved
    pub fn set_devices(&mut self, v: DeviceAllocationResult) {
        self.devices = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_devices(&mut self) -> &mut DeviceAllocationResult {
        self.devices.mut_or_insert_default()
    }

    // Take field
    pub fn take_devices(&mut self) -> DeviceAllocationResult {
        self.devices.take().unwrap_or_else(|| DeviceAllocationResult::new())
    }

    // optional .api.core.v1.NodeSelector nodeSelector = 3;

    pub fn nodeSelector(&self) -> &crate::v1_33::api::core::v1::NodeSelector {
        self.nodeSelector.as_ref().unwrap_or_else(|| <crate::v1_33::api::core::v1::NodeSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_nodeSelector(&mut self) {
        self.nodeSelector.clear();
    }

    pub fn has_nodeSelector(&self) -> bool {
        self.nodeSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeSelector(&mut self, v: crate::v1_33::api::core::v1::NodeSelector) {
        self.nodeSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeSelector(&mut self) -> &mut crate::v1_33::api::core::v1::NodeSelector {
        self.nodeSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_nodeSelector(&mut self) -> crate::v1_33::api::core::v1::NodeSelector {
        self.nodeSelector.take().unwrap_or_else(|| crate::v1_33::api::core::v1::NodeSelector::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeviceAllocationResult>(
            "devices",
            |m: &AllocationResult| { &m.devices },
            |m: &mut AllocationResult| { &mut m.devices },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::api::core::v1::NodeSelector>(
            "nodeSelector",
            |m: &AllocationResult| { &m.nodeSelector },
            |m: &mut AllocationResult| { &mut m.nodeSelector },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AllocationResult>(
            "AllocationResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AllocationResult {
    const NAME: &'static str = "AllocationResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.devices)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.nodeSelector)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.devices.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.nodeSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.devices.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.nodeSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AllocationResult {
        AllocationResult::new()
    }

    fn clear(&mut self) {
        self.devices.clear();
        self.nodeSelector.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AllocationResult {
        static instance: AllocationResult = AllocationResult {
            devices: ::protobuf::MessageField::none(),
            nodeSelector: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AllocationResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AllocationResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AllocationResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllocationResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.CELDeviceSelector)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CELDeviceSelector {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta2.CELDeviceSelector.expression)
    pub expression: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.CELDeviceSelector.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CELDeviceSelector {
    fn default() -> &'a CELDeviceSelector {
        <CELDeviceSelector as ::protobuf::Message>::default_instance()
    }
}

impl CELDeviceSelector {
    pub fn new() -> CELDeviceSelector {
        ::std::default::Default::default()
    }

    // optional string expression = 1;

    pub fn expression(&self) -> &str {
        match self.expression.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_expression(&mut self) {
        self.expression = ::std::option::Option::None;
    }

    pub fn has_expression(&self) -> bool {
        self.expression.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expression(&mut self, v: ::std::string::String) {
        self.expression = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expression(&mut self) -> &mut ::std::string::String {
        if self.expression.is_none() {
            self.expression = ::std::option::Option::Some(::std::string::String::new());
        }
        self.expression.as_mut().unwrap()
    }

    // Take field
    pub fn take_expression(&mut self) -> ::std::string::String {
        self.expression.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expression",
            |m: &CELDeviceSelector| { &m.expression },
            |m: &mut CELDeviceSelector| { &mut m.expression },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CELDeviceSelector>(
            "CELDeviceSelector",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CELDeviceSelector {
    const NAME: &'static str = "CELDeviceSelector";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.expression = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.expression.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.expression.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CELDeviceSelector {
        CELDeviceSelector::new()
    }

    fn clear(&mut self) {
        self.expression = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CELDeviceSelector {
        static instance: CELDeviceSelector = CELDeviceSelector {
            expression: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CELDeviceSelector {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CELDeviceSelector").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CELDeviceSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CELDeviceSelector {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.Counter)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Counter {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.Counter.value)
    pub value: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::api::resource::Quantity>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.Counter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Counter {
    fn default() -> &'a Counter {
        <Counter as ::protobuf::Message>::default_instance()
    }
}

impl Counter {
    pub fn new() -> Counter {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.api.resource.Quantity value = 1;

    pub fn value(&self) -> &crate::v1_33::apimachinery::pkg::api::resource::Quantity {
        self.value.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::api::resource::Quantity as ::protobuf::Message>::default_instance())
    }

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: crate::v1_33::apimachinery::pkg::api::resource::Quantity) {
        self.value = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut crate::v1_33::apimachinery::pkg::api::resource::Quantity {
        self.value.mut_or_insert_default()
    }

    // Take field
    pub fn take_value(&mut self) -> crate::v1_33::apimachinery::pkg::api::resource::Quantity {
        self.value.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::api::resource::Quantity::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::api::resource::Quantity>(
            "value",
            |m: &Counter| { &m.value },
            |m: &mut Counter| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Counter>(
            "Counter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Counter {
    const NAME: &'static str = "Counter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Counter {
        Counter::new()
    }

    fn clear(&mut self) {
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Counter {
        static instance: Counter = Counter {
            value: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Counter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Counter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Counter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Counter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.CounterSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CounterSet {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta2.CounterSet.name)
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.CounterSet.counters)
    pub counters: ::std::collections::BTreeMap<::std::string::String, Counter>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.CounterSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CounterSet {
    fn default() -> &'a CounterSet {
        <CounterSet as ::protobuf::Message>::default_instance()
    }
}

impl CounterSet {
    pub fn new() -> CounterSet {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.resource.v1beta2.CounterSet.CountersEntry counters = 2;

    pub fn counters(&self) -> &::std::collections::BTreeMap<::std::string::String, Counter> {
        &self.counters
    }

    pub fn clear_counters(&mut self) {
        self.counters.clear();
    }

    // Param is passed by value, moved
    pub fn set_counters(&mut self, v: ::std::collections::BTreeMap<::std::string::String, Counter>) {
        self.counters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_counters(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, Counter> {
        &mut self.counters
    }

    // Take field
    pub fn take_counters(&mut self) -> ::std::collections::BTreeMap<::std::string::String, Counter> {
        ::std::mem::replace(&mut self.counters, ::std::collections::BTreeMap::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CounterSet| { &m.name },
            |m: &mut CounterSet| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "counters",
            |m: &CounterSet| { &m.counters },
            |m: &mut CounterSet| { &mut m.counters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CounterSet>(
            "CounterSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CounterSet {
    const NAME: &'static str = "CounterSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.counters.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for (k, v) in &self.counters {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for (k, v) in &self.counters {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CounterSet {
        CounterSet::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.counters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CounterSet {
        static instance: ::protobuf::rt::Lazy<CounterSet> = ::protobuf::rt::Lazy::new();
        instance.get(CounterSet::new)
    }
}

impl ::protobuf::MessageFull for CounterSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CounterSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CounterSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CounterSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.Device)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Device {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta2.Device.name)
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.Device.attributes)
    pub attributes: ::std::collections::BTreeMap<::std::string::String, DeviceAttribute>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.Device.capacity)
    pub capacity: ::std::collections::BTreeMap<::std::string::String, DeviceCapacity>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.Device.consumesCounters)
    pub consumesCounters: ::std::vec::Vec<DeviceCounterConsumption>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.Device.nodeName)
    pub nodeName: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.Device.nodeSelector)
    pub nodeSelector: ::protobuf::MessageField<crate::v1_33::api::core::v1::NodeSelector>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.Device.allNodes)
    pub allNodes: ::std::option::Option<bool>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.Device.taints)
    pub taints: ::std::vec::Vec<DeviceTaint>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.Device.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Device {
    fn default() -> &'a Device {
        <Device as ::protobuf::Message>::default_instance()
    }
}

impl Device {
    pub fn new() -> Device {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.resource.v1beta2.Device.AttributesEntry attributes = 2;

    pub fn attributes(&self) -> &::std::collections::BTreeMap<::std::string::String, DeviceAttribute> {
        &self.attributes
    }

    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::std::collections::BTreeMap<::std::string::String, DeviceAttribute>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, DeviceAttribute> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::std::collections::BTreeMap<::std::string::String, DeviceAttribute> {
        ::std::mem::replace(&mut self.attributes, ::std::collections::BTreeMap::new())
    }

    // repeated .api.resource.v1beta2.Device.CapacityEntry capacity = 3;

    pub fn capacity(&self) -> &::std::collections::BTreeMap<::std::string::String, DeviceCapacity> {
        &self.capacity
    }

    pub fn clear_capacity(&mut self) {
        self.capacity.clear();
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: ::std::collections::BTreeMap<::std::string::String, DeviceCapacity>) {
        self.capacity = v;
    }

    // Mutable pointer to the field.
    pub fn mut_capacity(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, DeviceCapacity> {
        &mut self.capacity
    }

    // Take field
    pub fn take_capacity(&mut self) -> ::std::collections::BTreeMap<::std::string::String, DeviceCapacity> {
        ::std::mem::replace(&mut self.capacity, ::std::collections::BTreeMap::new())
    }

    // repeated .api.resource.v1beta2.DeviceCounterConsumption consumesCounters = 4;

    pub fn consumesCounters(&self) -> &[DeviceCounterConsumption] {
        &self.consumesCounters
    }

    pub fn clear_consumesCounters(&mut self) {
        self.consumesCounters.clear();
    }

    // Param is passed by value, moved
    pub fn set_consumesCounters(&mut self, v: ::std::vec::Vec<DeviceCounterConsumption>) {
        self.consumesCounters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_consumesCounters(&mut self) -> &mut ::std::vec::Vec<DeviceCounterConsumption> {
        &mut self.consumesCounters
    }

    // Take field
    pub fn take_consumesCounters(&mut self) -> ::std::vec::Vec<DeviceCounterConsumption> {
        ::std::mem::replace(&mut self.consumesCounters, ::std::vec::Vec::new())
    }

    // optional string nodeName = 5;

    pub fn nodeName(&self) -> &str {
        match self.nodeName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nodeName(&mut self) {
        self.nodeName = ::std::option::Option::None;
    }

    pub fn has_nodeName(&self) -> bool {
        self.nodeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeName(&mut self, v: ::std::string::String) {
        self.nodeName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeName(&mut self) -> &mut ::std::string::String {
        if self.nodeName.is_none() {
            self.nodeName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.nodeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodeName(&mut self) -> ::std::string::String {
        self.nodeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.NodeSelector nodeSelector = 6;

    pub fn nodeSelector(&self) -> &crate::v1_33::api::core::v1::NodeSelector {
        self.nodeSelector.as_ref().unwrap_or_else(|| <crate::v1_33::api::core::v1::NodeSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_nodeSelector(&mut self) {
        self.nodeSelector.clear();
    }

    pub fn has_nodeSelector(&self) -> bool {
        self.nodeSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeSelector(&mut self, v: crate::v1_33::api::core::v1::NodeSelector) {
        self.nodeSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeSelector(&mut self) -> &mut crate::v1_33::api::core::v1::NodeSelector {
        self.nodeSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_nodeSelector(&mut self) -> crate::v1_33::api::core::v1::NodeSelector {
        self.nodeSelector.take().unwrap_or_else(|| crate::v1_33::api::core::v1::NodeSelector::new())
    }

    // optional bool allNodes = 7;

    pub fn allNodes(&self) -> bool {
        self.allNodes.unwrap_or(false)
    }

    pub fn clear_allNodes(&mut self) {
        self.allNodes = ::std::option::Option::None;
    }

    pub fn has_allNodes(&self) -> bool {
        self.allNodes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allNodes(&mut self, v: bool) {
        self.allNodes = ::std::option::Option::Some(v);
    }

    // repeated .api.resource.v1beta2.DeviceTaint taints = 8;

    pub fn taints(&self) -> &[DeviceTaint] {
        &self.taints
    }

    pub fn clear_taints(&mut self) {
        self.taints.clear();
    }

    // Param is passed by value, moved
    pub fn set_taints(&mut self, v: ::std::vec::Vec<DeviceTaint>) {
        self.taints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_taints(&mut self) -> &mut ::std::vec::Vec<DeviceTaint> {
        &mut self.taints
    }

    // Take field
    pub fn take_taints(&mut self) -> ::std::vec::Vec<DeviceTaint> {
        ::std::mem::replace(&mut self.taints, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Device| { &m.name },
            |m: &mut Device| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "attributes",
            |m: &Device| { &m.attributes },
            |m: &mut Device| { &mut m.attributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "capacity",
            |m: &Device| { &m.capacity },
            |m: &mut Device| { &mut m.capacity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "consumesCounters",
            |m: &Device| { &m.consumesCounters },
            |m: &mut Device| { &mut m.consumesCounters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nodeName",
            |m: &Device| { &m.nodeName },
            |m: &mut Device| { &mut m.nodeName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::api::core::v1::NodeSelector>(
            "nodeSelector",
            |m: &Device| { &m.nodeSelector },
            |m: &mut Device| { &mut m.nodeSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allNodes",
            |m: &Device| { &m.allNodes },
            |m: &mut Device| { &mut m.allNodes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "taints",
            |m: &Device| { &m.taints },
            |m: &mut Device| { &mut m.taints },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Device>(
            "Device",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Device {
    const NAME: &'static str = "Device";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.attributes.insert(key, value);
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.capacity.insert(key, value);
                },
                34 => {
                    self.consumesCounters.push(is.read_message()?);
                },
                42 => {
                    self.nodeName = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.nodeSelector)?;
                },
                56 => {
                    self.allNodes = ::std::option::Option::Some(is.read_bool()?);
                },
                66 => {
                    self.taints.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for (k, v) in &self.attributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.capacity {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for value in &self.consumesCounters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.nodeName.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.nodeSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.allNodes {
            my_size += 1 + 1;
        }
        for value in &self.taints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for (k, v) in &self.attributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.capacity {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.consumesCounters {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.nodeName.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.nodeSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.allNodes {
            os.write_bool(7, v)?;
        }
        for v in &self.taints {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Device {
        Device::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.attributes.clear();
        self.capacity.clear();
        self.consumesCounters.clear();
        self.nodeName = ::std::option::Option::None;
        self.nodeSelector.clear();
        self.allNodes = ::std::option::Option::None;
        self.taints.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Device {
        static instance: ::protobuf::rt::Lazy<Device> = ::protobuf::rt::Lazy::new();
        instance.get(Device::new)
    }
}

impl ::protobuf::MessageFull for Device {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Device").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Device {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Device {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.DeviceAllocationConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceAllocationConfiguration {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceAllocationConfiguration.source)
    pub source: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceAllocationConfiguration.requests)
    pub requests: ::std::vec::Vec<::std::string::String>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceAllocationConfiguration.deviceConfiguration)
    pub deviceConfiguration: ::protobuf::MessageField<DeviceConfiguration>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.DeviceAllocationConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceAllocationConfiguration {
    fn default() -> &'a DeviceAllocationConfiguration {
        <DeviceAllocationConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl DeviceAllocationConfiguration {
    pub fn new() -> DeviceAllocationConfiguration {
        ::std::default::Default::default()
    }

    // optional string source = 1;

    pub fn source(&self) -> &str {
        match self.source.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_source(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::string::String {
        if self.source.is_none() {
            self.source = ::std::option::Option::Some(::std::string::String::new());
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        self.source.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string requests = 2;

    pub fn requests(&self) -> &[::std::string::String] {
        &self.requests
    }

    pub fn clear_requests(&mut self) {
        self.requests.clear();
    }

    // Param is passed by value, moved
    pub fn set_requests(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.requests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requests(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.requests
    }

    // Take field
    pub fn take_requests(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.requests, ::std::vec::Vec::new())
    }

    // optional .api.resource.v1beta2.DeviceConfiguration deviceConfiguration = 3;

    pub fn deviceConfiguration(&self) -> &DeviceConfiguration {
        self.deviceConfiguration.as_ref().unwrap_or_else(|| <DeviceConfiguration as ::protobuf::Message>::default_instance())
    }

    pub fn clear_deviceConfiguration(&mut self) {
        self.deviceConfiguration.clear();
    }

    pub fn has_deviceConfiguration(&self) -> bool {
        self.deviceConfiguration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deviceConfiguration(&mut self, v: DeviceConfiguration) {
        self.deviceConfiguration = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deviceConfiguration(&mut self) -> &mut DeviceConfiguration {
        self.deviceConfiguration.mut_or_insert_default()
    }

    // Take field
    pub fn take_deviceConfiguration(&mut self) -> DeviceConfiguration {
        self.deviceConfiguration.take().unwrap_or_else(|| DeviceConfiguration::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source",
            |m: &DeviceAllocationConfiguration| { &m.source },
            |m: &mut DeviceAllocationConfiguration| { &mut m.source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "requests",
            |m: &DeviceAllocationConfiguration| { &m.requests },
            |m: &mut DeviceAllocationConfiguration| { &mut m.requests },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeviceConfiguration>(
            "deviceConfiguration",
            |m: &DeviceAllocationConfiguration| { &m.deviceConfiguration },
            |m: &mut DeviceAllocationConfiguration| { &mut m.deviceConfiguration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceAllocationConfiguration>(
            "DeviceAllocationConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceAllocationConfiguration {
    const NAME: &'static str = "DeviceAllocationConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.source = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.requests.push(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.deviceConfiguration)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.requests {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(v) = self.deviceConfiguration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.source.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.requests {
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.deviceConfiguration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceAllocationConfiguration {
        DeviceAllocationConfiguration::new()
    }

    fn clear(&mut self) {
        self.source = ::std::option::Option::None;
        self.requests.clear();
        self.deviceConfiguration.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceAllocationConfiguration {
        static instance: DeviceAllocationConfiguration = DeviceAllocationConfiguration {
            source: ::std::option::Option::None,
            requests: ::std::vec::Vec::new(),
            deviceConfiguration: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceAllocationConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceAllocationConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceAllocationConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceAllocationConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.DeviceAllocationResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceAllocationResult {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceAllocationResult.results)
    pub results: ::std::vec::Vec<DeviceRequestAllocationResult>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceAllocationResult.config)
    pub config: ::std::vec::Vec<DeviceAllocationConfiguration>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.DeviceAllocationResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceAllocationResult {
    fn default() -> &'a DeviceAllocationResult {
        <DeviceAllocationResult as ::protobuf::Message>::default_instance()
    }
}

impl DeviceAllocationResult {
    pub fn new() -> DeviceAllocationResult {
        ::std::default::Default::default()
    }

    // repeated .api.resource.v1beta2.DeviceRequestAllocationResult results = 1;

    pub fn results(&self) -> &[DeviceRequestAllocationResult] {
        &self.results
    }

    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::std::vec::Vec<DeviceRequestAllocationResult>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::std::vec::Vec<DeviceRequestAllocationResult> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::std::vec::Vec<DeviceRequestAllocationResult> {
        ::std::mem::replace(&mut self.results, ::std::vec::Vec::new())
    }

    // repeated .api.resource.v1beta2.DeviceAllocationConfiguration config = 2;

    pub fn config(&self) -> &[DeviceAllocationConfiguration] {
        &self.config
    }

    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: ::std::vec::Vec<DeviceAllocationConfiguration>) {
        self.config = v;
    }

    // Mutable pointer to the field.
    pub fn mut_config(&mut self) -> &mut ::std::vec::Vec<DeviceAllocationConfiguration> {
        &mut self.config
    }

    // Take field
    pub fn take_config(&mut self) -> ::std::vec::Vec<DeviceAllocationConfiguration> {
        ::std::mem::replace(&mut self.config, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &DeviceAllocationResult| { &m.results },
            |m: &mut DeviceAllocationResult| { &mut m.results },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "config",
            |m: &DeviceAllocationResult| { &m.config },
            |m: &mut DeviceAllocationResult| { &mut m.config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceAllocationResult>(
            "DeviceAllocationResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceAllocationResult {
    const NAME: &'static str = "DeviceAllocationResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                18 => {
                    self.config.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.config {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.config {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceAllocationResult {
        DeviceAllocationResult::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceAllocationResult {
        static instance: DeviceAllocationResult = DeviceAllocationResult {
            results: ::std::vec::Vec::new(),
            config: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceAllocationResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceAllocationResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceAllocationResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceAllocationResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.DeviceAttribute)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceAttribute {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceAttribute.int)
    pub int: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceAttribute.bool)
    pub bool: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceAttribute.string)
    pub string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceAttribute.version)
    pub version: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.DeviceAttribute.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceAttribute {
    fn default() -> &'a DeviceAttribute {
        <DeviceAttribute as ::protobuf::Message>::default_instance()
    }
}

impl DeviceAttribute {
    pub fn new() -> DeviceAttribute {
        ::std::default::Default::default()
    }

    // optional int64 int = 2;

    pub fn int(&self) -> i64 {
        self.int.unwrap_or(0)
    }

    pub fn clear_int(&mut self) {
        self.int = ::std::option::Option::None;
    }

    pub fn has_int(&self) -> bool {
        self.int.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int(&mut self, v: i64) {
        self.int = ::std::option::Option::Some(v);
    }

    // optional bool bool = 3;

    pub fn bool(&self) -> bool {
        self.bool.unwrap_or(false)
    }

    pub fn clear_bool(&mut self) {
        self.bool = ::std::option::Option::None;
    }

    pub fn has_bool(&self) -> bool {
        self.bool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bool(&mut self, v: bool) {
        self.bool = ::std::option::Option::Some(v);
    }

    // optional string string = 4;

    pub fn string(&self) -> &str {
        match self.string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string(&mut self) {
        self.string = ::std::option::Option::None;
    }

    pub fn has_string(&self) -> bool {
        self.string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string(&mut self, v: ::std::string::String) {
        self.string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string(&mut self) -> &mut ::std::string::String {
        if self.string.is_none() {
            self.string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string.as_mut().unwrap()
    }

    // Take field
    pub fn take_string(&mut self) -> ::std::string::String {
        self.string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 5;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "int",
            |m: &DeviceAttribute| { &m.int },
            |m: &mut DeviceAttribute| { &mut m.int },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bool",
            |m: &DeviceAttribute| { &m.bool },
            |m: &mut DeviceAttribute| { &mut m.bool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "string",
            |m: &DeviceAttribute| { &m.string },
            |m: &mut DeviceAttribute| { &mut m.string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &DeviceAttribute| { &m.version },
            |m: &mut DeviceAttribute| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceAttribute>(
            "DeviceAttribute",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceAttribute {
    const NAME: &'static str = "DeviceAttribute";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.int = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.bool = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.string = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.int {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.bool {
            my_size += 1 + 1;
        }
        if let Some(v) = self.string.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.int {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.bool {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.string.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceAttribute {
        DeviceAttribute::new()
    }

    fn clear(&mut self) {
        self.int = ::std::option::Option::None;
        self.bool = ::std::option::Option::None;
        self.string = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceAttribute {
        static instance: DeviceAttribute = DeviceAttribute {
            int: ::std::option::Option::None,
            bool: ::std::option::Option::None,
            string: ::std::option::Option::None,
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceAttribute {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceAttribute").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceAttribute {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.DeviceCapacity)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceCapacity {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceCapacity.value)
    pub value: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::api::resource::Quantity>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.DeviceCapacity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceCapacity {
    fn default() -> &'a DeviceCapacity {
        <DeviceCapacity as ::protobuf::Message>::default_instance()
    }
}

impl DeviceCapacity {
    pub fn new() -> DeviceCapacity {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.api.resource.Quantity value = 1;

    pub fn value(&self) -> &crate::v1_33::apimachinery::pkg::api::resource::Quantity {
        self.value.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::api::resource::Quantity as ::protobuf::Message>::default_instance())
    }

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: crate::v1_33::apimachinery::pkg::api::resource::Quantity) {
        self.value = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut crate::v1_33::apimachinery::pkg::api::resource::Quantity {
        self.value.mut_or_insert_default()
    }

    // Take field
    pub fn take_value(&mut self) -> crate::v1_33::apimachinery::pkg::api::resource::Quantity {
        self.value.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::api::resource::Quantity::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::api::resource::Quantity>(
            "value",
            |m: &DeviceCapacity| { &m.value },
            |m: &mut DeviceCapacity| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceCapacity>(
            "DeviceCapacity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceCapacity {
    const NAME: &'static str = "DeviceCapacity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceCapacity {
        DeviceCapacity::new()
    }

    fn clear(&mut self) {
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceCapacity {
        static instance: DeviceCapacity = DeviceCapacity {
            value: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceCapacity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceCapacity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceCapacity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceCapacity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.DeviceClaim)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceClaim {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceClaim.requests)
    pub requests: ::std::vec::Vec<DeviceRequest>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceClaim.constraints)
    pub constraints: ::std::vec::Vec<DeviceConstraint>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceClaim.config)
    pub config: ::std::vec::Vec<DeviceClaimConfiguration>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.DeviceClaim.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceClaim {
    fn default() -> &'a DeviceClaim {
        <DeviceClaim as ::protobuf::Message>::default_instance()
    }
}

impl DeviceClaim {
    pub fn new() -> DeviceClaim {
        ::std::default::Default::default()
    }

    // repeated .api.resource.v1beta2.DeviceRequest requests = 1;

    pub fn requests(&self) -> &[DeviceRequest] {
        &self.requests
    }

    pub fn clear_requests(&mut self) {
        self.requests.clear();
    }

    // Param is passed by value, moved
    pub fn set_requests(&mut self, v: ::std::vec::Vec<DeviceRequest>) {
        self.requests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requests(&mut self) -> &mut ::std::vec::Vec<DeviceRequest> {
        &mut self.requests
    }

    // Take field
    pub fn take_requests(&mut self) -> ::std::vec::Vec<DeviceRequest> {
        ::std::mem::replace(&mut self.requests, ::std::vec::Vec::new())
    }

    // repeated .api.resource.v1beta2.DeviceConstraint constraints = 2;

    pub fn constraints(&self) -> &[DeviceConstraint] {
        &self.constraints
    }

    pub fn clear_constraints(&mut self) {
        self.constraints.clear();
    }

    // Param is passed by value, moved
    pub fn set_constraints(&mut self, v: ::std::vec::Vec<DeviceConstraint>) {
        self.constraints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_constraints(&mut self) -> &mut ::std::vec::Vec<DeviceConstraint> {
        &mut self.constraints
    }

    // Take field
    pub fn take_constraints(&mut self) -> ::std::vec::Vec<DeviceConstraint> {
        ::std::mem::replace(&mut self.constraints, ::std::vec::Vec::new())
    }

    // repeated .api.resource.v1beta2.DeviceClaimConfiguration config = 3;

    pub fn config(&self) -> &[DeviceClaimConfiguration] {
        &self.config
    }

    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: ::std::vec::Vec<DeviceClaimConfiguration>) {
        self.config = v;
    }

    // Mutable pointer to the field.
    pub fn mut_config(&mut self) -> &mut ::std::vec::Vec<DeviceClaimConfiguration> {
        &mut self.config
    }

    // Take field
    pub fn take_config(&mut self) -> ::std::vec::Vec<DeviceClaimConfiguration> {
        ::std::mem::replace(&mut self.config, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "requests",
            |m: &DeviceClaim| { &m.requests },
            |m: &mut DeviceClaim| { &mut m.requests },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "constraints",
            |m: &DeviceClaim| { &m.constraints },
            |m: &mut DeviceClaim| { &mut m.constraints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "config",
            |m: &DeviceClaim| { &m.config },
            |m: &mut DeviceClaim| { &mut m.config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceClaim>(
            "DeviceClaim",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceClaim {
    const NAME: &'static str = "DeviceClaim";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.requests.push(is.read_message()?);
                },
                18 => {
                    self.constraints.push(is.read_message()?);
                },
                26 => {
                    self.config.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.requests {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.constraints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.config {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.requests {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.constraints {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.config {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceClaim {
        DeviceClaim::new()
    }

    fn clear(&mut self) {
        self.requests.clear();
        self.constraints.clear();
        self.config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceClaim {
        static instance: DeviceClaim = DeviceClaim {
            requests: ::std::vec::Vec::new(),
            constraints: ::std::vec::Vec::new(),
            config: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceClaim {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceClaim").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceClaim {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceClaim {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.DeviceClaimConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceClaimConfiguration {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceClaimConfiguration.requests)
    pub requests: ::std::vec::Vec<::std::string::String>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceClaimConfiguration.deviceConfiguration)
    pub deviceConfiguration: ::protobuf::MessageField<DeviceConfiguration>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.DeviceClaimConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceClaimConfiguration {
    fn default() -> &'a DeviceClaimConfiguration {
        <DeviceClaimConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl DeviceClaimConfiguration {
    pub fn new() -> DeviceClaimConfiguration {
        ::std::default::Default::default()
    }

    // repeated string requests = 1;

    pub fn requests(&self) -> &[::std::string::String] {
        &self.requests
    }

    pub fn clear_requests(&mut self) {
        self.requests.clear();
    }

    // Param is passed by value, moved
    pub fn set_requests(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.requests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requests(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.requests
    }

    // Take field
    pub fn take_requests(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.requests, ::std::vec::Vec::new())
    }

    // optional .api.resource.v1beta2.DeviceConfiguration deviceConfiguration = 2;

    pub fn deviceConfiguration(&self) -> &DeviceConfiguration {
        self.deviceConfiguration.as_ref().unwrap_or_else(|| <DeviceConfiguration as ::protobuf::Message>::default_instance())
    }

    pub fn clear_deviceConfiguration(&mut self) {
        self.deviceConfiguration.clear();
    }

    pub fn has_deviceConfiguration(&self) -> bool {
        self.deviceConfiguration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deviceConfiguration(&mut self, v: DeviceConfiguration) {
        self.deviceConfiguration = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deviceConfiguration(&mut self) -> &mut DeviceConfiguration {
        self.deviceConfiguration.mut_or_insert_default()
    }

    // Take field
    pub fn take_deviceConfiguration(&mut self) -> DeviceConfiguration {
        self.deviceConfiguration.take().unwrap_or_else(|| DeviceConfiguration::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "requests",
            |m: &DeviceClaimConfiguration| { &m.requests },
            |m: &mut DeviceClaimConfiguration| { &mut m.requests },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeviceConfiguration>(
            "deviceConfiguration",
            |m: &DeviceClaimConfiguration| { &m.deviceConfiguration },
            |m: &mut DeviceClaimConfiguration| { &mut m.deviceConfiguration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceClaimConfiguration>(
            "DeviceClaimConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceClaimConfiguration {
    const NAME: &'static str = "DeviceClaimConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.requests.push(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.deviceConfiguration)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.requests {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.deviceConfiguration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.requests {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.deviceConfiguration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceClaimConfiguration {
        DeviceClaimConfiguration::new()
    }

    fn clear(&mut self) {
        self.requests.clear();
        self.deviceConfiguration.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceClaimConfiguration {
        static instance: DeviceClaimConfiguration = DeviceClaimConfiguration {
            requests: ::std::vec::Vec::new(),
            deviceConfiguration: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceClaimConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceClaimConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceClaimConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceClaimConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.DeviceClass)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceClass {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceClass.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceClass.spec)
    pub spec: ::protobuf::MessageField<DeviceClassSpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.DeviceClass.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceClass {
    fn default() -> &'a DeviceClass {
        <DeviceClass as ::protobuf::Message>::default_instance()
    }
}

impl DeviceClass {
    pub fn new() -> DeviceClass {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.resource.v1beta2.DeviceClassSpec spec = 2;

    pub fn spec(&self) -> &DeviceClassSpec {
        self.spec.as_ref().unwrap_or_else(|| <DeviceClassSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: DeviceClassSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut DeviceClassSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> DeviceClassSpec {
        self.spec.take().unwrap_or_else(|| DeviceClassSpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &DeviceClass| { &m.metadata },
            |m: &mut DeviceClass| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeviceClassSpec>(
            "spec",
            |m: &DeviceClass| { &m.spec },
            |m: &mut DeviceClass| { &mut m.spec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceClass>(
            "DeviceClass",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceClass {
    const NAME: &'static str = "DeviceClass";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceClass {
        DeviceClass::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceClass {
        static instance: DeviceClass = DeviceClass {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceClass {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceClass").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceClass {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.DeviceClassConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceClassConfiguration {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceClassConfiguration.deviceConfiguration)
    pub deviceConfiguration: ::protobuf::MessageField<DeviceConfiguration>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.DeviceClassConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceClassConfiguration {
    fn default() -> &'a DeviceClassConfiguration {
        <DeviceClassConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl DeviceClassConfiguration {
    pub fn new() -> DeviceClassConfiguration {
        ::std::default::Default::default()
    }

    // optional .api.resource.v1beta2.DeviceConfiguration deviceConfiguration = 1;

    pub fn deviceConfiguration(&self) -> &DeviceConfiguration {
        self.deviceConfiguration.as_ref().unwrap_or_else(|| <DeviceConfiguration as ::protobuf::Message>::default_instance())
    }

    pub fn clear_deviceConfiguration(&mut self) {
        self.deviceConfiguration.clear();
    }

    pub fn has_deviceConfiguration(&self) -> bool {
        self.deviceConfiguration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deviceConfiguration(&mut self, v: DeviceConfiguration) {
        self.deviceConfiguration = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deviceConfiguration(&mut self) -> &mut DeviceConfiguration {
        self.deviceConfiguration.mut_or_insert_default()
    }

    // Take field
    pub fn take_deviceConfiguration(&mut self) -> DeviceConfiguration {
        self.deviceConfiguration.take().unwrap_or_else(|| DeviceConfiguration::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeviceConfiguration>(
            "deviceConfiguration",
            |m: &DeviceClassConfiguration| { &m.deviceConfiguration },
            |m: &mut DeviceClassConfiguration| { &mut m.deviceConfiguration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceClassConfiguration>(
            "DeviceClassConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceClassConfiguration {
    const NAME: &'static str = "DeviceClassConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.deviceConfiguration)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.deviceConfiguration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.deviceConfiguration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceClassConfiguration {
        DeviceClassConfiguration::new()
    }

    fn clear(&mut self) {
        self.deviceConfiguration.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceClassConfiguration {
        static instance: DeviceClassConfiguration = DeviceClassConfiguration {
            deviceConfiguration: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceClassConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceClassConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceClassConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceClassConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.DeviceClassList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceClassList {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceClassList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceClassList.items)
    pub items: ::std::vec::Vec<DeviceClass>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.DeviceClassList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceClassList {
    fn default() -> &'a DeviceClassList {
        <DeviceClassList as ::protobuf::Message>::default_instance()
    }
}

impl DeviceClassList {
    pub fn new() -> DeviceClassList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.resource.v1beta2.DeviceClass items = 2;

    pub fn items(&self) -> &[DeviceClass] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<DeviceClass>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<DeviceClass> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<DeviceClass> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &DeviceClassList| { &m.metadata },
            |m: &mut DeviceClassList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &DeviceClassList| { &m.items },
            |m: &mut DeviceClassList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceClassList>(
            "DeviceClassList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceClassList {
    const NAME: &'static str = "DeviceClassList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceClassList {
        DeviceClassList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceClassList {
        static instance: DeviceClassList = DeviceClassList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceClassList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceClassList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceClassList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceClassList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.DeviceClassSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceClassSpec {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceClassSpec.selectors)
    pub selectors: ::std::vec::Vec<DeviceSelector>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceClassSpec.config)
    pub config: ::std::vec::Vec<DeviceClassConfiguration>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.DeviceClassSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceClassSpec {
    fn default() -> &'a DeviceClassSpec {
        <DeviceClassSpec as ::protobuf::Message>::default_instance()
    }
}

impl DeviceClassSpec {
    pub fn new() -> DeviceClassSpec {
        ::std::default::Default::default()
    }

    // repeated .api.resource.v1beta2.DeviceSelector selectors = 1;

    pub fn selectors(&self) -> &[DeviceSelector] {
        &self.selectors
    }

    pub fn clear_selectors(&mut self) {
        self.selectors.clear();
    }

    // Param is passed by value, moved
    pub fn set_selectors(&mut self, v: ::std::vec::Vec<DeviceSelector>) {
        self.selectors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_selectors(&mut self) -> &mut ::std::vec::Vec<DeviceSelector> {
        &mut self.selectors
    }

    // Take field
    pub fn take_selectors(&mut self) -> ::std::vec::Vec<DeviceSelector> {
        ::std::mem::replace(&mut self.selectors, ::std::vec::Vec::new())
    }

    // repeated .api.resource.v1beta2.DeviceClassConfiguration config = 2;

    pub fn config(&self) -> &[DeviceClassConfiguration] {
        &self.config
    }

    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: ::std::vec::Vec<DeviceClassConfiguration>) {
        self.config = v;
    }

    // Mutable pointer to the field.
    pub fn mut_config(&mut self) -> &mut ::std::vec::Vec<DeviceClassConfiguration> {
        &mut self.config
    }

    // Take field
    pub fn take_config(&mut self) -> ::std::vec::Vec<DeviceClassConfiguration> {
        ::std::mem::replace(&mut self.config, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "selectors",
            |m: &DeviceClassSpec| { &m.selectors },
            |m: &mut DeviceClassSpec| { &mut m.selectors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "config",
            |m: &DeviceClassSpec| { &m.config },
            |m: &mut DeviceClassSpec| { &mut m.config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceClassSpec>(
            "DeviceClassSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceClassSpec {
    const NAME: &'static str = "DeviceClassSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.selectors.push(is.read_message()?);
                },
                18 => {
                    self.config.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.selectors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.config {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.selectors {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.config {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceClassSpec {
        DeviceClassSpec::new()
    }

    fn clear(&mut self) {
        self.selectors.clear();
        self.config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceClassSpec {
        static instance: DeviceClassSpec = DeviceClassSpec {
            selectors: ::std::vec::Vec::new(),
            config: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceClassSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceClassSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceClassSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceClassSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.DeviceConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceConfiguration {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceConfiguration.opaque)
    pub opaque: ::protobuf::MessageField<OpaqueDeviceConfiguration>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.DeviceConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceConfiguration {
    fn default() -> &'a DeviceConfiguration {
        <DeviceConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl DeviceConfiguration {
    pub fn new() -> DeviceConfiguration {
        ::std::default::Default::default()
    }

    // optional .api.resource.v1beta2.OpaqueDeviceConfiguration opaque = 1;

    pub fn opaque(&self) -> &OpaqueDeviceConfiguration {
        self.opaque.as_ref().unwrap_or_else(|| <OpaqueDeviceConfiguration as ::protobuf::Message>::default_instance())
    }

    pub fn clear_opaque(&mut self) {
        self.opaque.clear();
    }

    pub fn has_opaque(&self) -> bool {
        self.opaque.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opaque(&mut self, v: OpaqueDeviceConfiguration) {
        self.opaque = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_opaque(&mut self) -> &mut OpaqueDeviceConfiguration {
        self.opaque.mut_or_insert_default()
    }

    // Take field
    pub fn take_opaque(&mut self) -> OpaqueDeviceConfiguration {
        self.opaque.take().unwrap_or_else(|| OpaqueDeviceConfiguration::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, OpaqueDeviceConfiguration>(
            "opaque",
            |m: &DeviceConfiguration| { &m.opaque },
            |m: &mut DeviceConfiguration| { &mut m.opaque },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceConfiguration>(
            "DeviceConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceConfiguration {
    const NAME: &'static str = "DeviceConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.opaque)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.opaque.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.opaque.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceConfiguration {
        DeviceConfiguration::new()
    }

    fn clear(&mut self) {
        self.opaque.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceConfiguration {
        static instance: DeviceConfiguration = DeviceConfiguration {
            opaque: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.DeviceConstraint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceConstraint {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceConstraint.requests)
    pub requests: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceConstraint.matchAttribute)
    pub matchAttribute: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.DeviceConstraint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceConstraint {
    fn default() -> &'a DeviceConstraint {
        <DeviceConstraint as ::protobuf::Message>::default_instance()
    }
}

impl DeviceConstraint {
    pub fn new() -> DeviceConstraint {
        ::std::default::Default::default()
    }

    // repeated string requests = 1;

    pub fn requests(&self) -> &[::std::string::String] {
        &self.requests
    }

    pub fn clear_requests(&mut self) {
        self.requests.clear();
    }

    // Param is passed by value, moved
    pub fn set_requests(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.requests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requests(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.requests
    }

    // Take field
    pub fn take_requests(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.requests, ::std::vec::Vec::new())
    }

    // optional string matchAttribute = 2;

    pub fn matchAttribute(&self) -> &str {
        match self.matchAttribute.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_matchAttribute(&mut self) {
        self.matchAttribute = ::std::option::Option::None;
    }

    pub fn has_matchAttribute(&self) -> bool {
        self.matchAttribute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchAttribute(&mut self, v: ::std::string::String) {
        self.matchAttribute = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_matchAttribute(&mut self) -> &mut ::std::string::String {
        if self.matchAttribute.is_none() {
            self.matchAttribute = ::std::option::Option::Some(::std::string::String::new());
        }
        self.matchAttribute.as_mut().unwrap()
    }

    // Take field
    pub fn take_matchAttribute(&mut self) -> ::std::string::String {
        self.matchAttribute.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "requests",
            |m: &DeviceConstraint| { &m.requests },
            |m: &mut DeviceConstraint| { &mut m.requests },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchAttribute",
            |m: &DeviceConstraint| { &m.matchAttribute },
            |m: &mut DeviceConstraint| { &mut m.matchAttribute },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceConstraint>(
            "DeviceConstraint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceConstraint {
    const NAME: &'static str = "DeviceConstraint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.requests.push(is.read_string()?);
                },
                18 => {
                    self.matchAttribute = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.requests {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.matchAttribute.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.requests {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.matchAttribute.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceConstraint {
        DeviceConstraint::new()
    }

    fn clear(&mut self) {
        self.requests.clear();
        self.matchAttribute = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceConstraint {
        static instance: DeviceConstraint = DeviceConstraint {
            requests: ::std::vec::Vec::new(),
            matchAttribute: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceConstraint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceConstraint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceConstraint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceConstraint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.DeviceCounterConsumption)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceCounterConsumption {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceCounterConsumption.counterSet)
    pub counterSet: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceCounterConsumption.counters)
    pub counters: ::std::collections::BTreeMap<::std::string::String, Counter>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.DeviceCounterConsumption.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceCounterConsumption {
    fn default() -> &'a DeviceCounterConsumption {
        <DeviceCounterConsumption as ::protobuf::Message>::default_instance()
    }
}

impl DeviceCounterConsumption {
    pub fn new() -> DeviceCounterConsumption {
        ::std::default::Default::default()
    }

    // optional string counterSet = 1;

    pub fn counterSet(&self) -> &str {
        match self.counterSet.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_counterSet(&mut self) {
        self.counterSet = ::std::option::Option::None;
    }

    pub fn has_counterSet(&self) -> bool {
        self.counterSet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_counterSet(&mut self, v: ::std::string::String) {
        self.counterSet = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_counterSet(&mut self) -> &mut ::std::string::String {
        if self.counterSet.is_none() {
            self.counterSet = ::std::option::Option::Some(::std::string::String::new());
        }
        self.counterSet.as_mut().unwrap()
    }

    // Take field
    pub fn take_counterSet(&mut self) -> ::std::string::String {
        self.counterSet.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.resource.v1beta2.DeviceCounterConsumption.CountersEntry counters = 2;

    pub fn counters(&self) -> &::std::collections::BTreeMap<::std::string::String, Counter> {
        &self.counters
    }

    pub fn clear_counters(&mut self) {
        self.counters.clear();
    }

    // Param is passed by value, moved
    pub fn set_counters(&mut self, v: ::std::collections::BTreeMap<::std::string::String, Counter>) {
        self.counters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_counters(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, Counter> {
        &mut self.counters
    }

    // Take field
    pub fn take_counters(&mut self) -> ::std::collections::BTreeMap<::std::string::String, Counter> {
        ::std::mem::replace(&mut self.counters, ::std::collections::BTreeMap::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "counterSet",
            |m: &DeviceCounterConsumption| { &m.counterSet },
            |m: &mut DeviceCounterConsumption| { &mut m.counterSet },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "counters",
            |m: &DeviceCounterConsumption| { &m.counters },
            |m: &mut DeviceCounterConsumption| { &mut m.counters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceCounterConsumption>(
            "DeviceCounterConsumption",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceCounterConsumption {
    const NAME: &'static str = "DeviceCounterConsumption";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.counterSet = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.counters.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.counterSet.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for (k, v) in &self.counters {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.counterSet.as_ref() {
            os.write_string(1, v)?;
        }
        for (k, v) in &self.counters {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceCounterConsumption {
        DeviceCounterConsumption::new()
    }

    fn clear(&mut self) {
        self.counterSet = ::std::option::Option::None;
        self.counters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceCounterConsumption {
        static instance: ::protobuf::rt::Lazy<DeviceCounterConsumption> = ::protobuf::rt::Lazy::new();
        instance.get(DeviceCounterConsumption::new)
    }
}

impl ::protobuf::MessageFull for DeviceCounterConsumption {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceCounterConsumption").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceCounterConsumption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceCounterConsumption {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.DeviceRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceRequest {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceRequest.name)
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceRequest.exactly)
    pub exactly: ::protobuf::MessageField<ExactDeviceRequest>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceRequest.firstAvailable)
    pub firstAvailable: ::std::vec::Vec<DeviceSubRequest>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.DeviceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceRequest {
    fn default() -> &'a DeviceRequest {
        <DeviceRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeviceRequest {
    pub fn new() -> DeviceRequest {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.resource.v1beta2.ExactDeviceRequest exactly = 2;

    pub fn exactly(&self) -> &ExactDeviceRequest {
        self.exactly.as_ref().unwrap_or_else(|| <ExactDeviceRequest as ::protobuf::Message>::default_instance())
    }

    pub fn clear_exactly(&mut self) {
        self.exactly.clear();
    }

    pub fn has_exactly(&self) -> bool {
        self.exactly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exactly(&mut self, v: ExactDeviceRequest) {
        self.exactly = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exactly(&mut self) -> &mut ExactDeviceRequest {
        self.exactly.mut_or_insert_default()
    }

    // Take field
    pub fn take_exactly(&mut self) -> ExactDeviceRequest {
        self.exactly.take().unwrap_or_else(|| ExactDeviceRequest::new())
    }

    // repeated .api.resource.v1beta2.DeviceSubRequest firstAvailable = 3;

    pub fn firstAvailable(&self) -> &[DeviceSubRequest] {
        &self.firstAvailable
    }

    pub fn clear_firstAvailable(&mut self) {
        self.firstAvailable.clear();
    }

    // Param is passed by value, moved
    pub fn set_firstAvailable(&mut self, v: ::std::vec::Vec<DeviceSubRequest>) {
        self.firstAvailable = v;
    }

    // Mutable pointer to the field.
    pub fn mut_firstAvailable(&mut self) -> &mut ::std::vec::Vec<DeviceSubRequest> {
        &mut self.firstAvailable
    }

    // Take field
    pub fn take_firstAvailable(&mut self) -> ::std::vec::Vec<DeviceSubRequest> {
        ::std::mem::replace(&mut self.firstAvailable, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &DeviceRequest| { &m.name },
            |m: &mut DeviceRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExactDeviceRequest>(
            "exactly",
            |m: &DeviceRequest| { &m.exactly },
            |m: &mut DeviceRequest| { &mut m.exactly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "firstAvailable",
            |m: &DeviceRequest| { &m.firstAvailable },
            |m: &mut DeviceRequest| { &mut m.firstAvailable },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceRequest>(
            "DeviceRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceRequest {
    const NAME: &'static str = "DeviceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.exactly)?;
                },
                26 => {
                    self.firstAvailable.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.exactly.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.firstAvailable {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.exactly.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.firstAvailable {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceRequest {
        DeviceRequest::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.exactly.clear();
        self.firstAvailable.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceRequest {
        static instance: DeviceRequest = DeviceRequest {
            name: ::std::option::Option::None,
            exactly: ::protobuf::MessageField::none(),
            firstAvailable: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.DeviceRequestAllocationResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceRequestAllocationResult {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceRequestAllocationResult.request)
    pub request: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceRequestAllocationResult.driver)
    pub driver: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceRequestAllocationResult.pool)
    pub pool: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceRequestAllocationResult.device)
    pub device: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceRequestAllocationResult.adminAccess)
    pub adminAccess: ::std::option::Option<bool>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceRequestAllocationResult.tolerations)
    pub tolerations: ::std::vec::Vec<DeviceToleration>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.DeviceRequestAllocationResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceRequestAllocationResult {
    fn default() -> &'a DeviceRequestAllocationResult {
        <DeviceRequestAllocationResult as ::protobuf::Message>::default_instance()
    }
}

impl DeviceRequestAllocationResult {
    pub fn new() -> DeviceRequestAllocationResult {
        ::std::default::Default::default()
    }

    // optional string request = 1;

    pub fn request(&self) -> &str {
        match self.request.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_request(&self) -> bool {
        self.request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request(&mut self, v: ::std::string::String) {
        self.request = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request(&mut self) -> &mut ::std::string::String {
        if self.request.is_none() {
            self.request = ::std::option::Option::Some(::std::string::String::new());
        }
        self.request.as_mut().unwrap()
    }

    // Take field
    pub fn take_request(&mut self) -> ::std::string::String {
        self.request.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string driver = 2;

    pub fn driver(&self) -> &str {
        match self.driver.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_driver(&mut self) {
        self.driver = ::std::option::Option::None;
    }

    pub fn has_driver(&self) -> bool {
        self.driver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driver(&mut self, v: ::std::string::String) {
        self.driver = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver(&mut self) -> &mut ::std::string::String {
        if self.driver.is_none() {
            self.driver = ::std::option::Option::Some(::std::string::String::new());
        }
        self.driver.as_mut().unwrap()
    }

    // Take field
    pub fn take_driver(&mut self) -> ::std::string::String {
        self.driver.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pool = 3;

    pub fn pool(&self) -> &str {
        match self.pool.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pool(&mut self) {
        self.pool = ::std::option::Option::None;
    }

    pub fn has_pool(&self) -> bool {
        self.pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pool(&mut self, v: ::std::string::String) {
        self.pool = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pool(&mut self) -> &mut ::std::string::String {
        if self.pool.is_none() {
            self.pool = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pool.as_mut().unwrap()
    }

    // Take field
    pub fn take_pool(&mut self) -> ::std::string::String {
        self.pool.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string device = 4;

    pub fn device(&self) -> &str {
        match self.device.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device(&mut self) {
        self.device = ::std::option::Option::None;
    }

    pub fn has_device(&self) -> bool {
        self.device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: ::std::string::String) {
        self.device = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut ::std::string::String {
        if self.device.is_none() {
            self.device = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device.as_mut().unwrap()
    }

    // Take field
    pub fn take_device(&mut self) -> ::std::string::String {
        self.device.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool adminAccess = 5;

    pub fn adminAccess(&self) -> bool {
        self.adminAccess.unwrap_or(false)
    }

    pub fn clear_adminAccess(&mut self) {
        self.adminAccess = ::std::option::Option::None;
    }

    pub fn has_adminAccess(&self) -> bool {
        self.adminAccess.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adminAccess(&mut self, v: bool) {
        self.adminAccess = ::std::option::Option::Some(v);
    }

    // repeated .api.resource.v1beta2.DeviceToleration tolerations = 6;

    pub fn tolerations(&self) -> &[DeviceToleration] {
        &self.tolerations
    }

    pub fn clear_tolerations(&mut self) {
        self.tolerations.clear();
    }

    // Param is passed by value, moved
    pub fn set_tolerations(&mut self, v: ::std::vec::Vec<DeviceToleration>) {
        self.tolerations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tolerations(&mut self) -> &mut ::std::vec::Vec<DeviceToleration> {
        &mut self.tolerations
    }

    // Take field
    pub fn take_tolerations(&mut self) -> ::std::vec::Vec<DeviceToleration> {
        ::std::mem::replace(&mut self.tolerations, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request",
            |m: &DeviceRequestAllocationResult| { &m.request },
            |m: &mut DeviceRequestAllocationResult| { &mut m.request },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "driver",
            |m: &DeviceRequestAllocationResult| { &m.driver },
            |m: &mut DeviceRequestAllocationResult| { &mut m.driver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pool",
            |m: &DeviceRequestAllocationResult| { &m.pool },
            |m: &mut DeviceRequestAllocationResult| { &mut m.pool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "device",
            |m: &DeviceRequestAllocationResult| { &m.device },
            |m: &mut DeviceRequestAllocationResult| { &mut m.device },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "adminAccess",
            |m: &DeviceRequestAllocationResult| { &m.adminAccess },
            |m: &mut DeviceRequestAllocationResult| { &mut m.adminAccess },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tolerations",
            |m: &DeviceRequestAllocationResult| { &m.tolerations },
            |m: &mut DeviceRequestAllocationResult| { &mut m.tolerations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceRequestAllocationResult>(
            "DeviceRequestAllocationResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceRequestAllocationResult {
    const NAME: &'static str = "DeviceRequestAllocationResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.request = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.driver = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.pool = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.device = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.adminAccess = ::std::option::Option::Some(is.read_bool()?);
                },
                50 => {
                    self.tolerations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.driver.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.pool.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.device.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.adminAccess {
            my_size += 1 + 1;
        }
        for value in &self.tolerations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.driver.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.pool.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.device.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.adminAccess {
            os.write_bool(5, v)?;
        }
        for v in &self.tolerations {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceRequestAllocationResult {
        DeviceRequestAllocationResult::new()
    }

    fn clear(&mut self) {
        self.request = ::std::option::Option::None;
        self.driver = ::std::option::Option::None;
        self.pool = ::std::option::Option::None;
        self.device = ::std::option::Option::None;
        self.adminAccess = ::std::option::Option::None;
        self.tolerations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceRequestAllocationResult {
        static instance: DeviceRequestAllocationResult = DeviceRequestAllocationResult {
            request: ::std::option::Option::None,
            driver: ::std::option::Option::None,
            pool: ::std::option::Option::None,
            device: ::std::option::Option::None,
            adminAccess: ::std::option::Option::None,
            tolerations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceRequestAllocationResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceRequestAllocationResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceRequestAllocationResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceRequestAllocationResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.DeviceSelector)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceSelector {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceSelector.cel)
    pub cel: ::protobuf::MessageField<CELDeviceSelector>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.DeviceSelector.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceSelector {
    fn default() -> &'a DeviceSelector {
        <DeviceSelector as ::protobuf::Message>::default_instance()
    }
}

impl DeviceSelector {
    pub fn new() -> DeviceSelector {
        ::std::default::Default::default()
    }

    // optional .api.resource.v1beta2.CELDeviceSelector cel = 1;

    pub fn cel(&self) -> &CELDeviceSelector {
        self.cel.as_ref().unwrap_or_else(|| <CELDeviceSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_cel(&mut self) {
        self.cel.clear();
    }

    pub fn has_cel(&self) -> bool {
        self.cel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cel(&mut self, v: CELDeviceSelector) {
        self.cel = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cel(&mut self) -> &mut CELDeviceSelector {
        self.cel.mut_or_insert_default()
    }

    // Take field
    pub fn take_cel(&mut self) -> CELDeviceSelector {
        self.cel.take().unwrap_or_else(|| CELDeviceSelector::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CELDeviceSelector>(
            "cel",
            |m: &DeviceSelector| { &m.cel },
            |m: &mut DeviceSelector| { &mut m.cel },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceSelector>(
            "DeviceSelector",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceSelector {
    const NAME: &'static str = "DeviceSelector";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cel)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cel.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceSelector {
        DeviceSelector::new()
    }

    fn clear(&mut self) {
        self.cel.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceSelector {
        static instance: DeviceSelector = DeviceSelector {
            cel: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceSelector {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceSelector").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceSelector {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.DeviceSubRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceSubRequest {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceSubRequest.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceSubRequest.deviceClassName)
    pub deviceClassName: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceSubRequest.selectors)
    pub selectors: ::std::vec::Vec<DeviceSelector>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceSubRequest.allocationMode)
    pub allocationMode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceSubRequest.count)
    pub count: ::std::option::Option<i64>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceSubRequest.tolerations)
    pub tolerations: ::std::vec::Vec<DeviceToleration>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.DeviceSubRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceSubRequest {
    fn default() -> &'a DeviceSubRequest {
        <DeviceSubRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeviceSubRequest {
    pub fn new() -> DeviceSubRequest {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string deviceClassName = 2;

    pub fn deviceClassName(&self) -> &str {
        match self.deviceClassName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_deviceClassName(&mut self) {
        self.deviceClassName = ::std::option::Option::None;
    }

    pub fn has_deviceClassName(&self) -> bool {
        self.deviceClassName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deviceClassName(&mut self, v: ::std::string::String) {
        self.deviceClassName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deviceClassName(&mut self) -> &mut ::std::string::String {
        if self.deviceClassName.is_none() {
            self.deviceClassName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.deviceClassName.as_mut().unwrap()
    }

    // Take field
    pub fn take_deviceClassName(&mut self) -> ::std::string::String {
        self.deviceClassName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.resource.v1beta2.DeviceSelector selectors = 3;

    pub fn selectors(&self) -> &[DeviceSelector] {
        &self.selectors
    }

    pub fn clear_selectors(&mut self) {
        self.selectors.clear();
    }

    // Param is passed by value, moved
    pub fn set_selectors(&mut self, v: ::std::vec::Vec<DeviceSelector>) {
        self.selectors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_selectors(&mut self) -> &mut ::std::vec::Vec<DeviceSelector> {
        &mut self.selectors
    }

    // Take field
    pub fn take_selectors(&mut self) -> ::std::vec::Vec<DeviceSelector> {
        ::std::mem::replace(&mut self.selectors, ::std::vec::Vec::new())
    }

    // optional string allocationMode = 4;

    pub fn allocationMode(&self) -> &str {
        match self.allocationMode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_allocationMode(&mut self) {
        self.allocationMode = ::std::option::Option::None;
    }

    pub fn has_allocationMode(&self) -> bool {
        self.allocationMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allocationMode(&mut self, v: ::std::string::String) {
        self.allocationMode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allocationMode(&mut self) -> &mut ::std::string::String {
        if self.allocationMode.is_none() {
            self.allocationMode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.allocationMode.as_mut().unwrap()
    }

    // Take field
    pub fn take_allocationMode(&mut self) -> ::std::string::String {
        self.allocationMode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 count = 5;

    pub fn count(&self) -> i64 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i64) {
        self.count = ::std::option::Option::Some(v);
    }

    // repeated .api.resource.v1beta2.DeviceToleration tolerations = 6;

    pub fn tolerations(&self) -> &[DeviceToleration] {
        &self.tolerations
    }

    pub fn clear_tolerations(&mut self) {
        self.tolerations.clear();
    }

    // Param is passed by value, moved
    pub fn set_tolerations(&mut self, v: ::std::vec::Vec<DeviceToleration>) {
        self.tolerations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tolerations(&mut self) -> &mut ::std::vec::Vec<DeviceToleration> {
        &mut self.tolerations
    }

    // Take field
    pub fn take_tolerations(&mut self) -> ::std::vec::Vec<DeviceToleration> {
        ::std::mem::replace(&mut self.tolerations, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &DeviceSubRequest| { &m.name },
            |m: &mut DeviceSubRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deviceClassName",
            |m: &DeviceSubRequest| { &m.deviceClassName },
            |m: &mut DeviceSubRequest| { &mut m.deviceClassName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "selectors",
            |m: &DeviceSubRequest| { &m.selectors },
            |m: &mut DeviceSubRequest| { &mut m.selectors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allocationMode",
            |m: &DeviceSubRequest| { &m.allocationMode },
            |m: &mut DeviceSubRequest| { &mut m.allocationMode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &DeviceSubRequest| { &m.count },
            |m: &mut DeviceSubRequest| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tolerations",
            |m: &DeviceSubRequest| { &m.tolerations },
            |m: &mut DeviceSubRequest| { &mut m.tolerations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceSubRequest>(
            "DeviceSubRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceSubRequest {
    const NAME: &'static str = "DeviceSubRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.deviceClassName = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.selectors.push(is.read_message()?);
                },
                34 => {
                    self.allocationMode = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.count = ::std::option::Option::Some(is.read_int64()?);
                },
                50 => {
                    self.tolerations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.deviceClassName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.selectors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.allocationMode.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        for value in &self.tolerations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.deviceClassName.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.selectors {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.allocationMode.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.count {
            os.write_int64(5, v)?;
        }
        for v in &self.tolerations {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceSubRequest {
        DeviceSubRequest::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.deviceClassName = ::std::option::Option::None;
        self.selectors.clear();
        self.allocationMode = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.tolerations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceSubRequest {
        static instance: DeviceSubRequest = DeviceSubRequest {
            name: ::std::option::Option::None,
            deviceClassName: ::std::option::Option::None,
            selectors: ::std::vec::Vec::new(),
            allocationMode: ::std::option::Option::None,
            count: ::std::option::Option::None,
            tolerations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceSubRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceSubRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceSubRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceSubRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.DeviceTaint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceTaint {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceTaint.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceTaint.value)
    pub value: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceTaint.effect)
    pub effect: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceTaint.timeAdded)
    pub timeAdded: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::Time>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.DeviceTaint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceTaint {
    fn default() -> &'a DeviceTaint {
        <DeviceTaint as ::protobuf::Message>::default_instance()
    }
}

impl DeviceTaint {
    pub fn new() -> DeviceTaint {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string effect = 3;

    pub fn effect(&self) -> &str {
        match self.effect.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_effect(&mut self) {
        self.effect = ::std::option::Option::None;
    }

    pub fn has_effect(&self) -> bool {
        self.effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: ::std::string::String) {
        self.effect = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_effect(&mut self) -> &mut ::std::string::String {
        if self.effect.is_none() {
            self.effect = ::std::option::Option::Some(::std::string::String::new());
        }
        self.effect.as_mut().unwrap()
    }

    // Take field
    pub fn take_effect(&mut self) -> ::std::string::String {
        self.effect.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time timeAdded = 4;

    pub fn timeAdded(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::Time {
        self.timeAdded.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_timeAdded(&mut self) {
        self.timeAdded.clear();
    }

    pub fn has_timeAdded(&self) -> bool {
        self.timeAdded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeAdded(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::Time) {
        self.timeAdded = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timeAdded(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::Time {
        self.timeAdded.mut_or_insert_default()
    }

    // Take field
    pub fn take_timeAdded(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::Time {
        self.timeAdded.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &DeviceTaint| { &m.key },
            |m: &mut DeviceTaint| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &DeviceTaint| { &m.value },
            |m: &mut DeviceTaint| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "effect",
            |m: &DeviceTaint| { &m.effect },
            |m: &mut DeviceTaint| { &mut m.effect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::Time>(
            "timeAdded",
            |m: &DeviceTaint| { &m.timeAdded },
            |m: &mut DeviceTaint| { &mut m.timeAdded },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceTaint>(
            "DeviceTaint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceTaint {
    const NAME: &'static str = "DeviceTaint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.effect = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timeAdded)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.effect.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.timeAdded.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.effect.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.timeAdded.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceTaint {
        DeviceTaint::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.effect = ::std::option::Option::None;
        self.timeAdded.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceTaint {
        static instance: DeviceTaint = DeviceTaint {
            key: ::std::option::Option::None,
            value: ::std::option::Option::None,
            effect: ::std::option::Option::None,
            timeAdded: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceTaint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceTaint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceTaint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceTaint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.DeviceToleration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceToleration {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceToleration.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceToleration.operator)
    pub operator: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceToleration.value)
    pub value: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceToleration.effect)
    pub effect: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.DeviceToleration.tolerationSeconds)
    pub tolerationSeconds: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.DeviceToleration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceToleration {
    fn default() -> &'a DeviceToleration {
        <DeviceToleration as ::protobuf::Message>::default_instance()
    }
}

impl DeviceToleration {
    pub fn new() -> DeviceToleration {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string operator = 2;

    pub fn operator(&self) -> &str {
        match self.operator.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_operator(&mut self) {
        self.operator = ::std::option::Option::None;
    }

    pub fn has_operator(&self) -> bool {
        self.operator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operator(&mut self, v: ::std::string::String) {
        self.operator = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operator(&mut self) -> &mut ::std::string::String {
        if self.operator.is_none() {
            self.operator = ::std::option::Option::Some(::std::string::String::new());
        }
        self.operator.as_mut().unwrap()
    }

    // Take field
    pub fn take_operator(&mut self) -> ::std::string::String {
        self.operator.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 3;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string effect = 4;

    pub fn effect(&self) -> &str {
        match self.effect.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_effect(&mut self) {
        self.effect = ::std::option::Option::None;
    }

    pub fn has_effect(&self) -> bool {
        self.effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: ::std::string::String) {
        self.effect = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_effect(&mut self) -> &mut ::std::string::String {
        if self.effect.is_none() {
            self.effect = ::std::option::Option::Some(::std::string::String::new());
        }
        self.effect.as_mut().unwrap()
    }

    // Take field
    pub fn take_effect(&mut self) -> ::std::string::String {
        self.effect.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 tolerationSeconds = 5;

    pub fn tolerationSeconds(&self) -> i64 {
        self.tolerationSeconds.unwrap_or(0)
    }

    pub fn clear_tolerationSeconds(&mut self) {
        self.tolerationSeconds = ::std::option::Option::None;
    }

    pub fn has_tolerationSeconds(&self) -> bool {
        self.tolerationSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tolerationSeconds(&mut self, v: i64) {
        self.tolerationSeconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &DeviceToleration| { &m.key },
            |m: &mut DeviceToleration| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "operator",
            |m: &DeviceToleration| { &m.operator },
            |m: &mut DeviceToleration| { &mut m.operator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &DeviceToleration| { &m.value },
            |m: &mut DeviceToleration| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "effect",
            |m: &DeviceToleration| { &m.effect },
            |m: &mut DeviceToleration| { &mut m.effect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tolerationSeconds",
            |m: &DeviceToleration| { &m.tolerationSeconds },
            |m: &mut DeviceToleration| { &mut m.tolerationSeconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceToleration>(
            "DeviceToleration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceToleration {
    const NAME: &'static str = "DeviceToleration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.operator = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.effect = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.tolerationSeconds = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.operator.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.effect.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.tolerationSeconds {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.operator.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.effect.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.tolerationSeconds {
            os.write_int64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceToleration {
        DeviceToleration::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.operator = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.effect = ::std::option::Option::None;
        self.tolerationSeconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceToleration {
        static instance: DeviceToleration = DeviceToleration {
            key: ::std::option::Option::None,
            operator: ::std::option::Option::None,
            value: ::std::option::Option::None,
            effect: ::std::option::Option::None,
            tolerationSeconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceToleration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceToleration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceToleration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceToleration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.ExactDeviceRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExactDeviceRequest {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta2.ExactDeviceRequest.deviceClassName)
    pub deviceClassName: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.ExactDeviceRequest.selectors)
    pub selectors: ::std::vec::Vec<DeviceSelector>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.ExactDeviceRequest.allocationMode)
    pub allocationMode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.ExactDeviceRequest.count)
    pub count: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.ExactDeviceRequest.adminAccess)
    pub adminAccess: ::std::option::Option<bool>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.ExactDeviceRequest.tolerations)
    pub tolerations: ::std::vec::Vec<DeviceToleration>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.ExactDeviceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExactDeviceRequest {
    fn default() -> &'a ExactDeviceRequest {
        <ExactDeviceRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExactDeviceRequest {
    pub fn new() -> ExactDeviceRequest {
        ::std::default::Default::default()
    }

    // optional string deviceClassName = 1;

    pub fn deviceClassName(&self) -> &str {
        match self.deviceClassName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_deviceClassName(&mut self) {
        self.deviceClassName = ::std::option::Option::None;
    }

    pub fn has_deviceClassName(&self) -> bool {
        self.deviceClassName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deviceClassName(&mut self, v: ::std::string::String) {
        self.deviceClassName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deviceClassName(&mut self) -> &mut ::std::string::String {
        if self.deviceClassName.is_none() {
            self.deviceClassName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.deviceClassName.as_mut().unwrap()
    }

    // Take field
    pub fn take_deviceClassName(&mut self) -> ::std::string::String {
        self.deviceClassName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.resource.v1beta2.DeviceSelector selectors = 2;

    pub fn selectors(&self) -> &[DeviceSelector] {
        &self.selectors
    }

    pub fn clear_selectors(&mut self) {
        self.selectors.clear();
    }

    // Param is passed by value, moved
    pub fn set_selectors(&mut self, v: ::std::vec::Vec<DeviceSelector>) {
        self.selectors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_selectors(&mut self) -> &mut ::std::vec::Vec<DeviceSelector> {
        &mut self.selectors
    }

    // Take field
    pub fn take_selectors(&mut self) -> ::std::vec::Vec<DeviceSelector> {
        ::std::mem::replace(&mut self.selectors, ::std::vec::Vec::new())
    }

    // optional string allocationMode = 3;

    pub fn allocationMode(&self) -> &str {
        match self.allocationMode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_allocationMode(&mut self) {
        self.allocationMode = ::std::option::Option::None;
    }

    pub fn has_allocationMode(&self) -> bool {
        self.allocationMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allocationMode(&mut self, v: ::std::string::String) {
        self.allocationMode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allocationMode(&mut self) -> &mut ::std::string::String {
        if self.allocationMode.is_none() {
            self.allocationMode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.allocationMode.as_mut().unwrap()
    }

    // Take field
    pub fn take_allocationMode(&mut self) -> ::std::string::String {
        self.allocationMode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 count = 4;

    pub fn count(&self) -> i64 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i64) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional bool adminAccess = 5;

    pub fn adminAccess(&self) -> bool {
        self.adminAccess.unwrap_or(false)
    }

    pub fn clear_adminAccess(&mut self) {
        self.adminAccess = ::std::option::Option::None;
    }

    pub fn has_adminAccess(&self) -> bool {
        self.adminAccess.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adminAccess(&mut self, v: bool) {
        self.adminAccess = ::std::option::Option::Some(v);
    }

    // repeated .api.resource.v1beta2.DeviceToleration tolerations = 6;

    pub fn tolerations(&self) -> &[DeviceToleration] {
        &self.tolerations
    }

    pub fn clear_tolerations(&mut self) {
        self.tolerations.clear();
    }

    // Param is passed by value, moved
    pub fn set_tolerations(&mut self, v: ::std::vec::Vec<DeviceToleration>) {
        self.tolerations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tolerations(&mut self) -> &mut ::std::vec::Vec<DeviceToleration> {
        &mut self.tolerations
    }

    // Take field
    pub fn take_tolerations(&mut self) -> ::std::vec::Vec<DeviceToleration> {
        ::std::mem::replace(&mut self.tolerations, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deviceClassName",
            |m: &ExactDeviceRequest| { &m.deviceClassName },
            |m: &mut ExactDeviceRequest| { &mut m.deviceClassName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "selectors",
            |m: &ExactDeviceRequest| { &m.selectors },
            |m: &mut ExactDeviceRequest| { &mut m.selectors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allocationMode",
            |m: &ExactDeviceRequest| { &m.allocationMode },
            |m: &mut ExactDeviceRequest| { &mut m.allocationMode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &ExactDeviceRequest| { &m.count },
            |m: &mut ExactDeviceRequest| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "adminAccess",
            |m: &ExactDeviceRequest| { &m.adminAccess },
            |m: &mut ExactDeviceRequest| { &mut m.adminAccess },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tolerations",
            |m: &ExactDeviceRequest| { &m.tolerations },
            |m: &mut ExactDeviceRequest| { &mut m.tolerations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExactDeviceRequest>(
            "ExactDeviceRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExactDeviceRequest {
    const NAME: &'static str = "ExactDeviceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.deviceClassName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.selectors.push(is.read_message()?);
                },
                26 => {
                    self.allocationMode = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.count = ::std::option::Option::Some(is.read_int64()?);
                },
                40 => {
                    self.adminAccess = ::std::option::Option::Some(is.read_bool()?);
                },
                50 => {
                    self.tolerations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.deviceClassName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.selectors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.allocationMode.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.adminAccess {
            my_size += 1 + 1;
        }
        for value in &self.tolerations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.deviceClassName.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.selectors {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.allocationMode.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.count {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.adminAccess {
            os.write_bool(5, v)?;
        }
        for v in &self.tolerations {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExactDeviceRequest {
        ExactDeviceRequest::new()
    }

    fn clear(&mut self) {
        self.deviceClassName = ::std::option::Option::None;
        self.selectors.clear();
        self.allocationMode = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.adminAccess = ::std::option::Option::None;
        self.tolerations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExactDeviceRequest {
        static instance: ExactDeviceRequest = ExactDeviceRequest {
            deviceClassName: ::std::option::Option::None,
            selectors: ::std::vec::Vec::new(),
            allocationMode: ::std::option::Option::None,
            count: ::std::option::Option::None,
            adminAccess: ::std::option::Option::None,
            tolerations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExactDeviceRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExactDeviceRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExactDeviceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExactDeviceRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.NetworkDeviceData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NetworkDeviceData {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta2.NetworkDeviceData.interfaceName)
    pub interfaceName: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.NetworkDeviceData.ips)
    pub ips: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.NetworkDeviceData.hardwareAddress)
    pub hardwareAddress: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.NetworkDeviceData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NetworkDeviceData {
    fn default() -> &'a NetworkDeviceData {
        <NetworkDeviceData as ::protobuf::Message>::default_instance()
    }
}

impl NetworkDeviceData {
    pub fn new() -> NetworkDeviceData {
        ::std::default::Default::default()
    }

    // optional string interfaceName = 1;

    pub fn interfaceName(&self) -> &str {
        match self.interfaceName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_interfaceName(&mut self) {
        self.interfaceName = ::std::option::Option::None;
    }

    pub fn has_interfaceName(&self) -> bool {
        self.interfaceName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interfaceName(&mut self, v: ::std::string::String) {
        self.interfaceName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interfaceName(&mut self) -> &mut ::std::string::String {
        if self.interfaceName.is_none() {
            self.interfaceName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.interfaceName.as_mut().unwrap()
    }

    // Take field
    pub fn take_interfaceName(&mut self) -> ::std::string::String {
        self.interfaceName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string ips = 2;

    pub fn ips(&self) -> &[::std::string::String] {
        &self.ips
    }

    pub fn clear_ips(&mut self) {
        self.ips.clear();
    }

    // Param is passed by value, moved
    pub fn set_ips(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.ips = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ips(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.ips
    }

    // Take field
    pub fn take_ips(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.ips, ::std::vec::Vec::new())
    }

    // optional string hardwareAddress = 3;

    pub fn hardwareAddress(&self) -> &str {
        match self.hardwareAddress.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hardwareAddress(&mut self) {
        self.hardwareAddress = ::std::option::Option::None;
    }

    pub fn has_hardwareAddress(&self) -> bool {
        self.hardwareAddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hardwareAddress(&mut self, v: ::std::string::String) {
        self.hardwareAddress = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hardwareAddress(&mut self) -> &mut ::std::string::String {
        if self.hardwareAddress.is_none() {
            self.hardwareAddress = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hardwareAddress.as_mut().unwrap()
    }

    // Take field
    pub fn take_hardwareAddress(&mut self) -> ::std::string::String {
        self.hardwareAddress.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "interfaceName",
            |m: &NetworkDeviceData| { &m.interfaceName },
            |m: &mut NetworkDeviceData| { &mut m.interfaceName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ips",
            |m: &NetworkDeviceData| { &m.ips },
            |m: &mut NetworkDeviceData| { &mut m.ips },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hardwareAddress",
            |m: &NetworkDeviceData| { &m.hardwareAddress },
            |m: &mut NetworkDeviceData| { &mut m.hardwareAddress },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NetworkDeviceData>(
            "NetworkDeviceData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NetworkDeviceData {
    const NAME: &'static str = "NetworkDeviceData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.interfaceName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.ips.push(is.read_string()?);
                },
                26 => {
                    self.hardwareAddress = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.interfaceName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.ips {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(v) = self.hardwareAddress.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.interfaceName.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.ips {
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.hardwareAddress.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NetworkDeviceData {
        NetworkDeviceData::new()
    }

    fn clear(&mut self) {
        self.interfaceName = ::std::option::Option::None;
        self.ips.clear();
        self.hardwareAddress = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NetworkDeviceData {
        static instance: NetworkDeviceData = NetworkDeviceData {
            interfaceName: ::std::option::Option::None,
            ips: ::std::vec::Vec::new(),
            hardwareAddress: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NetworkDeviceData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NetworkDeviceData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NetworkDeviceData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkDeviceData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.OpaqueDeviceConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OpaqueDeviceConfiguration {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta2.OpaqueDeviceConfiguration.driver)
    pub driver: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.OpaqueDeviceConfiguration.parameters)
    pub parameters: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::runtime::RawExtension>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.OpaqueDeviceConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OpaqueDeviceConfiguration {
    fn default() -> &'a OpaqueDeviceConfiguration {
        <OpaqueDeviceConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl OpaqueDeviceConfiguration {
    pub fn new() -> OpaqueDeviceConfiguration {
        ::std::default::Default::default()
    }

    // optional string driver = 1;

    pub fn driver(&self) -> &str {
        match self.driver.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_driver(&mut self) {
        self.driver = ::std::option::Option::None;
    }

    pub fn has_driver(&self) -> bool {
        self.driver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driver(&mut self, v: ::std::string::String) {
        self.driver = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver(&mut self) -> &mut ::std::string::String {
        if self.driver.is_none() {
            self.driver = ::std::option::Option::Some(::std::string::String::new());
        }
        self.driver.as_mut().unwrap()
    }

    // Take field
    pub fn take_driver(&mut self) -> ::std::string::String {
        self.driver.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.runtime.RawExtension parameters = 2;

    pub fn parameters(&self) -> &crate::v1_33::apimachinery::pkg::runtime::RawExtension {
        self.parameters.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::runtime::RawExtension as ::protobuf::Message>::default_instance())
    }

    pub fn clear_parameters(&mut self) {
        self.parameters.clear();
    }

    pub fn has_parameters(&self) -> bool {
        self.parameters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameters(&mut self, v: crate::v1_33::apimachinery::pkg::runtime::RawExtension) {
        self.parameters = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parameters(&mut self) -> &mut crate::v1_33::apimachinery::pkg::runtime::RawExtension {
        self.parameters.mut_or_insert_default()
    }

    // Take field
    pub fn take_parameters(&mut self) -> crate::v1_33::apimachinery::pkg::runtime::RawExtension {
        self.parameters.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::runtime::RawExtension::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "driver",
            |m: &OpaqueDeviceConfiguration| { &m.driver },
            |m: &mut OpaqueDeviceConfiguration| { &mut m.driver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::runtime::RawExtension>(
            "parameters",
            |m: &OpaqueDeviceConfiguration| { &m.parameters },
            |m: &mut OpaqueDeviceConfiguration| { &mut m.parameters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OpaqueDeviceConfiguration>(
            "OpaqueDeviceConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OpaqueDeviceConfiguration {
    const NAME: &'static str = "OpaqueDeviceConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.driver = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.parameters)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.driver.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.parameters.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.driver.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.parameters.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OpaqueDeviceConfiguration {
        OpaqueDeviceConfiguration::new()
    }

    fn clear(&mut self) {
        self.driver = ::std::option::Option::None;
        self.parameters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OpaqueDeviceConfiguration {
        static instance: OpaqueDeviceConfiguration = OpaqueDeviceConfiguration {
            driver: ::std::option::Option::None,
            parameters: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OpaqueDeviceConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OpaqueDeviceConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OpaqueDeviceConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpaqueDeviceConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.ResourceClaim)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaim {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceClaim.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceClaim.spec)
    pub spec: ::protobuf::MessageField<ResourceClaimSpec>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceClaim.status)
    pub status: ::protobuf::MessageField<ResourceClaimStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.ResourceClaim.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaim {
    fn default() -> &'a ResourceClaim {
        <ResourceClaim as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaim {
    pub fn new() -> ResourceClaim {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.resource.v1beta2.ResourceClaimSpec spec = 2;

    pub fn spec(&self) -> &ResourceClaimSpec {
        self.spec.as_ref().unwrap_or_else(|| <ResourceClaimSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ResourceClaimSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ResourceClaimSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ResourceClaimSpec {
        self.spec.take().unwrap_or_else(|| ResourceClaimSpec::new())
    }

    // optional .api.resource.v1beta2.ResourceClaimStatus status = 3;

    pub fn status(&self) -> &ResourceClaimStatus {
        self.status.as_ref().unwrap_or_else(|| <ResourceClaimStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ResourceClaimStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ResourceClaimStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> ResourceClaimStatus {
        self.status.take().unwrap_or_else(|| ResourceClaimStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ResourceClaim| { &m.metadata },
            |m: &mut ResourceClaim| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceClaimSpec>(
            "spec",
            |m: &ResourceClaim| { &m.spec },
            |m: &mut ResourceClaim| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceClaimStatus>(
            "status",
            |m: &ResourceClaim| { &m.status },
            |m: &mut ResourceClaim| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaim>(
            "ResourceClaim",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaim {
    const NAME: &'static str = "ResourceClaim";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaim {
        ResourceClaim::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaim {
        static instance: ResourceClaim = ResourceClaim {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaim {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaim").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaim {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaim {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.ResourceClaimConsumerReference)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaimConsumerReference {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceClaimConsumerReference.apiGroup)
    pub apiGroup: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceClaimConsumerReference.resource)
    pub resource: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceClaimConsumerReference.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceClaimConsumerReference.uid)
    pub uid: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.ResourceClaimConsumerReference.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaimConsumerReference {
    fn default() -> &'a ResourceClaimConsumerReference {
        <ResourceClaimConsumerReference as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaimConsumerReference {
    pub fn new() -> ResourceClaimConsumerReference {
        ::std::default::Default::default()
    }

    // optional string apiGroup = 1;

    pub fn apiGroup(&self) -> &str {
        match self.apiGroup.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_apiGroup(&mut self) {
        self.apiGroup = ::std::option::Option::None;
    }

    pub fn has_apiGroup(&self) -> bool {
        self.apiGroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiGroup(&mut self, v: ::std::string::String) {
        self.apiGroup = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiGroup(&mut self) -> &mut ::std::string::String {
        if self.apiGroup.is_none() {
            self.apiGroup = ::std::option::Option::Some(::std::string::String::new());
        }
        self.apiGroup.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiGroup(&mut self) -> ::std::string::String {
        self.apiGroup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resource = 3;

    pub fn resource(&self) -> &str {
        match self.resource.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resource(&mut self) {
        self.resource = ::std::option::Option::None;
    }

    pub fn has_resource(&self) -> bool {
        self.resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: ::std::string::String) {
        self.resource = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut ::std::string::String {
        if self.resource.is_none() {
            self.resource = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resource.as_mut().unwrap()
    }

    // Take field
    pub fn take_resource(&mut self) -> ::std::string::String {
        self.resource.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 4;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string uid = 5;

    pub fn uid(&self) -> &str {
        match self.uid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_uid(&mut self) {
        self.uid = ::std::option::Option::None;
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if self.uid.is_none() {
            self.uid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        self.uid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "apiGroup",
            |m: &ResourceClaimConsumerReference| { &m.apiGroup },
            |m: &mut ResourceClaimConsumerReference| { &mut m.apiGroup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resource",
            |m: &ResourceClaimConsumerReference| { &m.resource },
            |m: &mut ResourceClaimConsumerReference| { &mut m.resource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ResourceClaimConsumerReference| { &m.name },
            |m: &mut ResourceClaimConsumerReference| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uid",
            |m: &ResourceClaimConsumerReference| { &m.uid },
            |m: &mut ResourceClaimConsumerReference| { &mut m.uid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaimConsumerReference>(
            "ResourceClaimConsumerReference",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaimConsumerReference {
    const NAME: &'static str = "ResourceClaimConsumerReference";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.apiGroup = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.resource = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.uid = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.apiGroup.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.resource.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.uid.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.apiGroup.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.resource.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.uid.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaimConsumerReference {
        ResourceClaimConsumerReference::new()
    }

    fn clear(&mut self) {
        self.apiGroup = ::std::option::Option::None;
        self.resource = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.uid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaimConsumerReference {
        static instance: ResourceClaimConsumerReference = ResourceClaimConsumerReference {
            apiGroup: ::std::option::Option::None,
            resource: ::std::option::Option::None,
            name: ::std::option::Option::None,
            uid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaimConsumerReference {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaimConsumerReference").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaimConsumerReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaimConsumerReference {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.ResourceClaimList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaimList {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceClaimList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceClaimList.items)
    pub items: ::std::vec::Vec<ResourceClaim>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.ResourceClaimList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaimList {
    fn default() -> &'a ResourceClaimList {
        <ResourceClaimList as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaimList {
    pub fn new() -> ResourceClaimList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.resource.v1beta2.ResourceClaim items = 2;

    pub fn items(&self) -> &[ResourceClaim] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ResourceClaim>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ResourceClaim> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ResourceClaim> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ResourceClaimList| { &m.metadata },
            |m: &mut ResourceClaimList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ResourceClaimList| { &m.items },
            |m: &mut ResourceClaimList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaimList>(
            "ResourceClaimList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaimList {
    const NAME: &'static str = "ResourceClaimList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaimList {
        ResourceClaimList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaimList {
        static instance: ResourceClaimList = ResourceClaimList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaimList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaimList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaimList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaimList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.ResourceClaimSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaimSpec {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceClaimSpec.devices)
    pub devices: ::protobuf::MessageField<DeviceClaim>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.ResourceClaimSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaimSpec {
    fn default() -> &'a ResourceClaimSpec {
        <ResourceClaimSpec as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaimSpec {
    pub fn new() -> ResourceClaimSpec {
        ::std::default::Default::default()
    }

    // optional .api.resource.v1beta2.DeviceClaim devices = 1;

    pub fn devices(&self) -> &DeviceClaim {
        self.devices.as_ref().unwrap_or_else(|| <DeviceClaim as ::protobuf::Message>::default_instance())
    }

    pub fn clear_devices(&mut self) {
        self.devices.clear();
    }

    pub fn has_devices(&self) -> bool {
        self.devices.is_some()
    }

    // Param is passed by value, moved
    pub fn set_devices(&mut self, v: DeviceClaim) {
        self.devices = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_devices(&mut self) -> &mut DeviceClaim {
        self.devices.mut_or_insert_default()
    }

    // Take field
    pub fn take_devices(&mut self) -> DeviceClaim {
        self.devices.take().unwrap_or_else(|| DeviceClaim::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeviceClaim>(
            "devices",
            |m: &ResourceClaimSpec| { &m.devices },
            |m: &mut ResourceClaimSpec| { &mut m.devices },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaimSpec>(
            "ResourceClaimSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaimSpec {
    const NAME: &'static str = "ResourceClaimSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.devices)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.devices.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.devices.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaimSpec {
        ResourceClaimSpec::new()
    }

    fn clear(&mut self) {
        self.devices.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaimSpec {
        static instance: ResourceClaimSpec = ResourceClaimSpec {
            devices: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaimSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaimSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaimSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaimSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.ResourceClaimStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaimStatus {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceClaimStatus.allocation)
    pub allocation: ::protobuf::MessageField<AllocationResult>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceClaimStatus.reservedFor)
    pub reservedFor: ::std::vec::Vec<ResourceClaimConsumerReference>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceClaimStatus.devices)
    pub devices: ::std::vec::Vec<AllocatedDeviceStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.ResourceClaimStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaimStatus {
    fn default() -> &'a ResourceClaimStatus {
        <ResourceClaimStatus as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaimStatus {
    pub fn new() -> ResourceClaimStatus {
        ::std::default::Default::default()
    }

    // optional .api.resource.v1beta2.AllocationResult allocation = 1;

    pub fn allocation(&self) -> &AllocationResult {
        self.allocation.as_ref().unwrap_or_else(|| <AllocationResult as ::protobuf::Message>::default_instance())
    }

    pub fn clear_allocation(&mut self) {
        self.allocation.clear();
    }

    pub fn has_allocation(&self) -> bool {
        self.allocation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allocation(&mut self, v: AllocationResult) {
        self.allocation = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allocation(&mut self) -> &mut AllocationResult {
        self.allocation.mut_or_insert_default()
    }

    // Take field
    pub fn take_allocation(&mut self) -> AllocationResult {
        self.allocation.take().unwrap_or_else(|| AllocationResult::new())
    }

    // repeated .api.resource.v1beta2.ResourceClaimConsumerReference reservedFor = 2;

    pub fn reservedFor(&self) -> &[ResourceClaimConsumerReference] {
        &self.reservedFor
    }

    pub fn clear_reservedFor(&mut self) {
        self.reservedFor.clear();
    }

    // Param is passed by value, moved
    pub fn set_reservedFor(&mut self, v: ::std::vec::Vec<ResourceClaimConsumerReference>) {
        self.reservedFor = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reservedFor(&mut self) -> &mut ::std::vec::Vec<ResourceClaimConsumerReference> {
        &mut self.reservedFor
    }

    // Take field
    pub fn take_reservedFor(&mut self) -> ::std::vec::Vec<ResourceClaimConsumerReference> {
        ::std::mem::replace(&mut self.reservedFor, ::std::vec::Vec::new())
    }

    // repeated .api.resource.v1beta2.AllocatedDeviceStatus devices = 4;

    pub fn devices(&self) -> &[AllocatedDeviceStatus] {
        &self.devices
    }

    pub fn clear_devices(&mut self) {
        self.devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_devices(&mut self, v: ::std::vec::Vec<AllocatedDeviceStatus>) {
        self.devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_devices(&mut self) -> &mut ::std::vec::Vec<AllocatedDeviceStatus> {
        &mut self.devices
    }

    // Take field
    pub fn take_devices(&mut self) -> ::std::vec::Vec<AllocatedDeviceStatus> {
        ::std::mem::replace(&mut self.devices, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AllocationResult>(
            "allocation",
            |m: &ResourceClaimStatus| { &m.allocation },
            |m: &mut ResourceClaimStatus| { &mut m.allocation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reservedFor",
            |m: &ResourceClaimStatus| { &m.reservedFor },
            |m: &mut ResourceClaimStatus| { &mut m.reservedFor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "devices",
            |m: &ResourceClaimStatus| { &m.devices },
            |m: &mut ResourceClaimStatus| { &mut m.devices },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaimStatus>(
            "ResourceClaimStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaimStatus {
    const NAME: &'static str = "ResourceClaimStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.allocation)?;
                },
                18 => {
                    self.reservedFor.push(is.read_message()?);
                },
                34 => {
                    self.devices.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.allocation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.reservedFor {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.devices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.allocation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.reservedFor {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.devices {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaimStatus {
        ResourceClaimStatus::new()
    }

    fn clear(&mut self) {
        self.allocation.clear();
        self.reservedFor.clear();
        self.devices.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaimStatus {
        static instance: ResourceClaimStatus = ResourceClaimStatus {
            allocation: ::protobuf::MessageField::none(),
            reservedFor: ::std::vec::Vec::new(),
            devices: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaimStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaimStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaimStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaimStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.ResourceClaimTemplate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaimTemplate {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceClaimTemplate.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceClaimTemplate.spec)
    pub spec: ::protobuf::MessageField<ResourceClaimTemplateSpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.ResourceClaimTemplate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaimTemplate {
    fn default() -> &'a ResourceClaimTemplate {
        <ResourceClaimTemplate as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaimTemplate {
    pub fn new() -> ResourceClaimTemplate {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.resource.v1beta2.ResourceClaimTemplateSpec spec = 2;

    pub fn spec(&self) -> &ResourceClaimTemplateSpec {
        self.spec.as_ref().unwrap_or_else(|| <ResourceClaimTemplateSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ResourceClaimTemplateSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ResourceClaimTemplateSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ResourceClaimTemplateSpec {
        self.spec.take().unwrap_or_else(|| ResourceClaimTemplateSpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ResourceClaimTemplate| { &m.metadata },
            |m: &mut ResourceClaimTemplate| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceClaimTemplateSpec>(
            "spec",
            |m: &ResourceClaimTemplate| { &m.spec },
            |m: &mut ResourceClaimTemplate| { &mut m.spec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaimTemplate>(
            "ResourceClaimTemplate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaimTemplate {
    const NAME: &'static str = "ResourceClaimTemplate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaimTemplate {
        ResourceClaimTemplate::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaimTemplate {
        static instance: ResourceClaimTemplate = ResourceClaimTemplate {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaimTemplate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaimTemplate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaimTemplate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaimTemplate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.ResourceClaimTemplateList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaimTemplateList {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceClaimTemplateList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceClaimTemplateList.items)
    pub items: ::std::vec::Vec<ResourceClaimTemplate>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.ResourceClaimTemplateList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaimTemplateList {
    fn default() -> &'a ResourceClaimTemplateList {
        <ResourceClaimTemplateList as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaimTemplateList {
    pub fn new() -> ResourceClaimTemplateList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.resource.v1beta2.ResourceClaimTemplate items = 2;

    pub fn items(&self) -> &[ResourceClaimTemplate] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ResourceClaimTemplate>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ResourceClaimTemplate> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ResourceClaimTemplate> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ResourceClaimTemplateList| { &m.metadata },
            |m: &mut ResourceClaimTemplateList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ResourceClaimTemplateList| { &m.items },
            |m: &mut ResourceClaimTemplateList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaimTemplateList>(
            "ResourceClaimTemplateList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaimTemplateList {
    const NAME: &'static str = "ResourceClaimTemplateList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaimTemplateList {
        ResourceClaimTemplateList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaimTemplateList {
        static instance: ResourceClaimTemplateList = ResourceClaimTemplateList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaimTemplateList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaimTemplateList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaimTemplateList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaimTemplateList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.ResourceClaimTemplateSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaimTemplateSpec {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceClaimTemplateSpec.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceClaimTemplateSpec.spec)
    pub spec: ::protobuf::MessageField<ResourceClaimSpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.ResourceClaimTemplateSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaimTemplateSpec {
    fn default() -> &'a ResourceClaimTemplateSpec {
        <ResourceClaimTemplateSpec as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaimTemplateSpec {
    pub fn new() -> ResourceClaimTemplateSpec {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.resource.v1beta2.ResourceClaimSpec spec = 2;

    pub fn spec(&self) -> &ResourceClaimSpec {
        self.spec.as_ref().unwrap_or_else(|| <ResourceClaimSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ResourceClaimSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ResourceClaimSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ResourceClaimSpec {
        self.spec.take().unwrap_or_else(|| ResourceClaimSpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ResourceClaimTemplateSpec| { &m.metadata },
            |m: &mut ResourceClaimTemplateSpec| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceClaimSpec>(
            "spec",
            |m: &ResourceClaimTemplateSpec| { &m.spec },
            |m: &mut ResourceClaimTemplateSpec| { &mut m.spec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaimTemplateSpec>(
            "ResourceClaimTemplateSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaimTemplateSpec {
    const NAME: &'static str = "ResourceClaimTemplateSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaimTemplateSpec {
        ResourceClaimTemplateSpec::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaimTemplateSpec {
        static instance: ResourceClaimTemplateSpec = ResourceClaimTemplateSpec {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaimTemplateSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaimTemplateSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaimTemplateSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaimTemplateSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.ResourcePool)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourcePool {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourcePool.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourcePool.generation)
    pub generation: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourcePool.resourceSliceCount)
    pub resourceSliceCount: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.ResourcePool.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourcePool {
    fn default() -> &'a ResourcePool {
        <ResourcePool as ::protobuf::Message>::default_instance()
    }
}

impl ResourcePool {
    pub fn new() -> ResourcePool {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 generation = 2;

    pub fn generation(&self) -> i64 {
        self.generation.unwrap_or(0)
    }

    pub fn clear_generation(&mut self) {
        self.generation = ::std::option::Option::None;
    }

    pub fn has_generation(&self) -> bool {
        self.generation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generation(&mut self, v: i64) {
        self.generation = ::std::option::Option::Some(v);
    }

    // optional int64 resourceSliceCount = 3;

    pub fn resourceSliceCount(&self) -> i64 {
        self.resourceSliceCount.unwrap_or(0)
    }

    pub fn clear_resourceSliceCount(&mut self) {
        self.resourceSliceCount = ::std::option::Option::None;
    }

    pub fn has_resourceSliceCount(&self) -> bool {
        self.resourceSliceCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceSliceCount(&mut self, v: i64) {
        self.resourceSliceCount = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ResourcePool| { &m.name },
            |m: &mut ResourcePool| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "generation",
            |m: &ResourcePool| { &m.generation },
            |m: &mut ResourcePool| { &mut m.generation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resourceSliceCount",
            |m: &ResourcePool| { &m.resourceSliceCount },
            |m: &mut ResourcePool| { &mut m.resourceSliceCount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourcePool>(
            "ResourcePool",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourcePool {
    const NAME: &'static str = "ResourcePool";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.generation = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.resourceSliceCount = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.generation {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.resourceSliceCount {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.generation {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.resourceSliceCount {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourcePool {
        ResourcePool::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.generation = ::std::option::Option::None;
        self.resourceSliceCount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourcePool {
        static instance: ResourcePool = ResourcePool {
            name: ::std::option::Option::None,
            generation: ::std::option::Option::None,
            resourceSliceCount: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourcePool {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourcePool").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourcePool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourcePool {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.ResourceSlice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceSlice {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceSlice.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceSlice.spec)
    pub spec: ::protobuf::MessageField<ResourceSliceSpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.ResourceSlice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceSlice {
    fn default() -> &'a ResourceSlice {
        <ResourceSlice as ::protobuf::Message>::default_instance()
    }
}

impl ResourceSlice {
    pub fn new() -> ResourceSlice {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.resource.v1beta2.ResourceSliceSpec spec = 2;

    pub fn spec(&self) -> &ResourceSliceSpec {
        self.spec.as_ref().unwrap_or_else(|| <ResourceSliceSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ResourceSliceSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ResourceSliceSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ResourceSliceSpec {
        self.spec.take().unwrap_or_else(|| ResourceSliceSpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ResourceSlice| { &m.metadata },
            |m: &mut ResourceSlice| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceSliceSpec>(
            "spec",
            |m: &ResourceSlice| { &m.spec },
            |m: &mut ResourceSlice| { &mut m.spec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceSlice>(
            "ResourceSlice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceSlice {
    const NAME: &'static str = "ResourceSlice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceSlice {
        ResourceSlice::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceSlice {
        static instance: ResourceSlice = ResourceSlice {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceSlice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceSlice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceSlice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceSlice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.ResourceSliceList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceSliceList {
    // message fields
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceSliceList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceSliceList.items)
    pub items: ::std::vec::Vec<ResourceSlice>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.ResourceSliceList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceSliceList {
    fn default() -> &'a ResourceSliceList {
        <ResourceSliceList as ::protobuf::Message>::default_instance()
    }
}

impl ResourceSliceList {
    pub fn new() -> ResourceSliceList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.resource.v1beta2.ResourceSlice items = 2;

    pub fn items(&self) -> &[ResourceSlice] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ResourceSlice>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ResourceSlice> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ResourceSlice> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ResourceSliceList| { &m.metadata },
            |m: &mut ResourceSliceList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ResourceSliceList| { &m.items },
            |m: &mut ResourceSliceList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceSliceList>(
            "ResourceSliceList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceSliceList {
    const NAME: &'static str = "ResourceSliceList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceSliceList {
        ResourceSliceList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceSliceList {
        static instance: ResourceSliceList = ResourceSliceList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceSliceList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceSliceList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceSliceList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceSliceList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta2.ResourceSliceSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceSliceSpec {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceSliceSpec.driver)
    pub driver: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceSliceSpec.pool)
    pub pool: ::protobuf::MessageField<ResourcePool>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceSliceSpec.nodeName)
    pub nodeName: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_33::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceSliceSpec.nodeSelector)
    pub nodeSelector: ::protobuf::MessageField<crate::v1_33::api::core::v1::NodeSelector>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceSliceSpec.allNodes)
    pub allNodes: ::std::option::Option<bool>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceSliceSpec.devices)
    pub devices: ::std::vec::Vec<Device>,
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceSliceSpec.perDeviceNodeSelection)
    pub perDeviceNodeSelection: ::std::option::Option<bool>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta2.ResourceSliceSpec.sharedCounters)
    pub sharedCounters: ::std::vec::Vec<CounterSet>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta2.ResourceSliceSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceSliceSpec {
    fn default() -> &'a ResourceSliceSpec {
        <ResourceSliceSpec as ::protobuf::Message>::default_instance()
    }
}

impl ResourceSliceSpec {
    pub fn new() -> ResourceSliceSpec {
        ::std::default::Default::default()
    }

    // optional string driver = 1;

    pub fn driver(&self) -> &str {
        match self.driver.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_driver(&mut self) {
        self.driver = ::std::option::Option::None;
    }

    pub fn has_driver(&self) -> bool {
        self.driver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driver(&mut self, v: ::std::string::String) {
        self.driver = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver(&mut self) -> &mut ::std::string::String {
        if self.driver.is_none() {
            self.driver = ::std::option::Option::Some(::std::string::String::new());
        }
        self.driver.as_mut().unwrap()
    }

    // Take field
    pub fn take_driver(&mut self) -> ::std::string::String {
        self.driver.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.resource.v1beta2.ResourcePool pool = 2;

    pub fn pool(&self) -> &ResourcePool {
        self.pool.as_ref().unwrap_or_else(|| <ResourcePool as ::protobuf::Message>::default_instance())
    }

    pub fn clear_pool(&mut self) {
        self.pool.clear();
    }

    pub fn has_pool(&self) -> bool {
        self.pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pool(&mut self, v: ResourcePool) {
        self.pool = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pool(&mut self) -> &mut ResourcePool {
        self.pool.mut_or_insert_default()
    }

    // Take field
    pub fn take_pool(&mut self) -> ResourcePool {
        self.pool.take().unwrap_or_else(|| ResourcePool::new())
    }

    // optional string nodeName = 3;

    pub fn nodeName(&self) -> &str {
        match self.nodeName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nodeName(&mut self) {
        self.nodeName = ::std::option::Option::None;
    }

    pub fn has_nodeName(&self) -> bool {
        self.nodeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeName(&mut self, v: ::std::string::String) {
        self.nodeName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeName(&mut self) -> &mut ::std::string::String {
        if self.nodeName.is_none() {
            self.nodeName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.nodeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodeName(&mut self) -> ::std::string::String {
        self.nodeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.NodeSelector nodeSelector = 4;

    pub fn nodeSelector(&self) -> &crate::v1_33::api::core::v1::NodeSelector {
        self.nodeSelector.as_ref().unwrap_or_else(|| <crate::v1_33::api::core::v1::NodeSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_nodeSelector(&mut self) {
        self.nodeSelector.clear();
    }

    pub fn has_nodeSelector(&self) -> bool {
        self.nodeSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeSelector(&mut self, v: crate::v1_33::api::core::v1::NodeSelector) {
        self.nodeSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeSelector(&mut self) -> &mut crate::v1_33::api::core::v1::NodeSelector {
        self.nodeSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_nodeSelector(&mut self) -> crate::v1_33::api::core::v1::NodeSelector {
        self.nodeSelector.take().unwrap_or_else(|| crate::v1_33::api::core::v1::NodeSelector::new())
    }

    // optional bool allNodes = 5;

    pub fn allNodes(&self) -> bool {
        self.allNodes.unwrap_or(false)
    }

    pub fn clear_allNodes(&mut self) {
        self.allNodes = ::std::option::Option::None;
    }

    pub fn has_allNodes(&self) -> bool {
        self.allNodes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allNodes(&mut self, v: bool) {
        self.allNodes = ::std::option::Option::Some(v);
    }

    // repeated .api.resource.v1beta2.Device devices = 6;

    pub fn devices(&self) -> &[Device] {
        &self.devices
    }

    pub fn clear_devices(&mut self) {
        self.devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_devices(&mut self, v: ::std::vec::Vec<Device>) {
        self.devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_devices(&mut self) -> &mut ::std::vec::Vec<Device> {
        &mut self.devices
    }

    // Take field
    pub fn take_devices(&mut self) -> ::std::vec::Vec<Device> {
        ::std::mem::replace(&mut self.devices, ::std::vec::Vec::new())
    }

    // optional bool perDeviceNodeSelection = 7;

    pub fn perDeviceNodeSelection(&self) -> bool {
        self.perDeviceNodeSelection.unwrap_or(false)
    }

    pub fn clear_perDeviceNodeSelection(&mut self) {
        self.perDeviceNodeSelection = ::std::option::Option::None;
    }

    pub fn has_perDeviceNodeSelection(&self) -> bool {
        self.perDeviceNodeSelection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_perDeviceNodeSelection(&mut self, v: bool) {
        self.perDeviceNodeSelection = ::std::option::Option::Some(v);
    }

    // repeated .api.resource.v1beta2.CounterSet sharedCounters = 8;

    pub fn sharedCounters(&self) -> &[CounterSet] {
        &self.sharedCounters
    }

    pub fn clear_sharedCounters(&mut self) {
        self.sharedCounters.clear();
    }

    // Param is passed by value, moved
    pub fn set_sharedCounters(&mut self, v: ::std::vec::Vec<CounterSet>) {
        self.sharedCounters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sharedCounters(&mut self) -> &mut ::std::vec::Vec<CounterSet> {
        &mut self.sharedCounters
    }

    // Take field
    pub fn take_sharedCounters(&mut self) -> ::std::vec::Vec<CounterSet> {
        ::std::mem::replace(&mut self.sharedCounters, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "driver",
            |m: &ResourceSliceSpec| { &m.driver },
            |m: &mut ResourceSliceSpec| { &mut m.driver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourcePool>(
            "pool",
            |m: &ResourceSliceSpec| { &m.pool },
            |m: &mut ResourceSliceSpec| { &mut m.pool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nodeName",
            |m: &ResourceSliceSpec| { &m.nodeName },
            |m: &mut ResourceSliceSpec| { &mut m.nodeName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_33::api::core::v1::NodeSelector>(
            "nodeSelector",
            |m: &ResourceSliceSpec| { &m.nodeSelector },
            |m: &mut ResourceSliceSpec| { &mut m.nodeSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allNodes",
            |m: &ResourceSliceSpec| { &m.allNodes },
            |m: &mut ResourceSliceSpec| { &mut m.allNodes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "devices",
            |m: &ResourceSliceSpec| { &m.devices },
            |m: &mut ResourceSliceSpec| { &mut m.devices },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "perDeviceNodeSelection",
            |m: &ResourceSliceSpec| { &m.perDeviceNodeSelection },
            |m: &mut ResourceSliceSpec| { &mut m.perDeviceNodeSelection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sharedCounters",
            |m: &ResourceSliceSpec| { &m.sharedCounters },
            |m: &mut ResourceSliceSpec| { &mut m.sharedCounters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceSliceSpec>(
            "ResourceSliceSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceSliceSpec {
    const NAME: &'static str = "ResourceSliceSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.driver = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pool)?;
                },
                26 => {
                    self.nodeName = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.nodeSelector)?;
                },
                40 => {
                    self.allNodes = ::std::option::Option::Some(is.read_bool()?);
                },
                50 => {
                    self.devices.push(is.read_message()?);
                },
                56 => {
                    self.perDeviceNodeSelection = ::std::option::Option::Some(is.read_bool()?);
                },
                66 => {
                    self.sharedCounters.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.driver.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.pool.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.nodeName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.nodeSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.allNodes {
            my_size += 1 + 1;
        }
        for value in &self.devices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.perDeviceNodeSelection {
            my_size += 1 + 1;
        }
        for value in &self.sharedCounters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.driver.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.pool.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.nodeName.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.nodeSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.allNodes {
            os.write_bool(5, v)?;
        }
        for v in &self.devices {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.perDeviceNodeSelection {
            os.write_bool(7, v)?;
        }
        for v in &self.sharedCounters {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceSliceSpec {
        ResourceSliceSpec::new()
    }

    fn clear(&mut self) {
        self.driver = ::std::option::Option::None;
        self.pool.clear();
        self.nodeName = ::std::option::Option::None;
        self.nodeSelector.clear();
        self.allNodes = ::std::option::Option::None;
        self.devices.clear();
        self.perDeviceNodeSelection = ::std::option::Option::None;
        self.sharedCounters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceSliceSpec {
        static instance: ResourceSliceSpec = ResourceSliceSpec {
            driver: ::std::option::Option::None,
            pool: ::protobuf::MessageField::none(),
            nodeName: ::std::option::Option::None,
            nodeSelector: ::protobuf::MessageField::none(),
            allNodes: ::std::option::Option::None,
            devices: ::std::vec::Vec::new(),
            perDeviceNodeSelection: ::std::option::Option::None,
            sharedCounters: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceSliceSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceSliceSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceSliceSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceSliceSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n$api/resource/v1beta2/generated.proto\x12\x14api.resource.v1beta2\x1a\
    \x1bapi/core/v1/generated.proto\x1a-apimachinery/pkg/api/resource/genera\
    ted.proto\x1a-apimachinery/pkg/apis/meta/v1/generated.proto\x1a(apimachi\
    nery/pkg/runtime/generated.proto\x1a/apimachinery/pkg/runtime/schema/gen\
    erated.proto\"\xac\x02\n\x15AllocatedDeviceStatus\x12\x16\n\x06driver\
    \x18\x01\x20\x01(\tR\x06driver\x12\x12\n\x04pool\x18\x02\x20\x01(\tR\x04\
    pool\x12\x16\n\x06device\x18\x03\x20\x01(\tR\x06device\x12H\n\ncondition\
    s\x18\x04\x20\x03(\x0b2(.apimachinery.pkg.apis.meta.v1.ConditionR\ncondi\
    tions\x12:\n\x04data\x18\x05\x20\x01(\x0b2&.apimachinery.pkg.runtime.Raw\
    ExtensionR\x04data\x12I\n\x0bnetworkData\x18\x06\x20\x01(\x0b2'.api.reso\
    urce.v1beta2.NetworkDeviceDataR\x0bnetworkData\"\x99\x01\n\x10Allocation\
    Result\x12F\n\x07devices\x18\x01\x20\x01(\x0b2,.api.resource.v1beta2.Dev\
    iceAllocationResultR\x07devices\x12=\n\x0cnodeSelector\x18\x03\x20\x01(\
    \x0b2\x19.api.core.v1.NodeSelectorR\x0cnodeSelector\"3\n\x11CELDeviceSel\
    ector\x12\x1e\n\nexpression\x18\x01\x20\x01(\tR\nexpression\"H\n\x07Coun\
    ter\x12=\n\x05value\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.api.resource\
    .QuantityR\x05value\"\xc8\x01\n\nCounterSet\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x12J\n\x08counters\x18\x02\x20\x03(\x0b2..api.resou\
    rce.v1beta2.CounterSet.CountersEntryR\x08counters\x1aZ\n\rCountersEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x123\n\x05value\x18\x02\x20\
    \x01(\x0b2\x1d.api.resource.v1beta2.CounterR\x05value:\x028\x01\"\x89\
    \x05\n\x06Device\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12L\n\na\
    ttributes\x18\x02\x20\x03(\x0b2,.api.resource.v1beta2.Device.AttributesE\
    ntryR\nattributes\x12F\n\x08capacity\x18\x03\x20\x03(\x0b2*.api.resource\
    .v1beta2.Device.CapacityEntryR\x08capacity\x12Z\n\x10consumesCounters\
    \x18\x04\x20\x03(\x0b2..api.resource.v1beta2.DeviceCounterConsumptionR\
    \x10consumesCounters\x12\x1a\n\x08nodeName\x18\x05\x20\x01(\tR\x08nodeNa\
    me\x12=\n\x0cnodeSelector\x18\x06\x20\x01(\x0b2\x19.api.core.v1.NodeSele\
    ctorR\x0cnodeSelector\x12\x1a\n\x08allNodes\x18\x07\x20\x01(\x08R\x08all\
    Nodes\x129\n\x06taints\x18\x08\x20\x03(\x0b2!.api.resource.v1beta2.Devic\
    eTaintR\x06taints\x1ad\n\x0fAttributesEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12;\n\x05value\x18\x02\x20\x01(\x0b2%.api.resource.v1be\
    ta2.DeviceAttributeR\x05value:\x028\x01\x1aa\n\rCapacityEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12:\n\x05value\x18\x02\x20\x01(\x0b2\
    $.api.resource.v1beta2.DeviceCapacityR\x05value:\x028\x01\"\xb0\x01\n\
    \x1dDeviceAllocationConfiguration\x12\x16\n\x06source\x18\x01\x20\x01(\t\
    R\x06source\x12\x1a\n\x08requests\x18\x02\x20\x03(\tR\x08requests\x12[\n\
    \x13deviceConfiguration\x18\x03\x20\x01(\x0b2).api.resource.v1beta2.Devi\
    ceConfigurationR\x13deviceConfiguration\"\xb4\x01\n\x16DeviceAllocationR\
    esult\x12M\n\x07results\x18\x01\x20\x03(\x0b23.api.resource.v1beta2.Devi\
    ceRequestAllocationResultR\x07results\x12K\n\x06config\x18\x02\x20\x03(\
    \x0b23.api.resource.v1beta2.DeviceAllocationConfigurationR\x06config\"i\
    \n\x0fDeviceAttribute\x12\x10\n\x03int\x18\x02\x20\x01(\x03R\x03int\x12\
    \x12\n\x04bool\x18\x03\x20\x01(\x08R\x04bool\x12\x16\n\x06string\x18\x04\
    \x20\x01(\tR\x06string\x12\x18\n\x07version\x18\x05\x20\x01(\tR\x07versi\
    on\"O\n\x0eDeviceCapacity\x12=\n\x05value\x18\x01\x20\x01(\x0b2'.apimach\
    inery.pkg.api.resource.QuantityR\x05value\"\xe0\x01\n\x0bDeviceClaim\x12\
    ?\n\x08requests\x18\x01\x20\x03(\x0b2#.api.resource.v1beta2.DeviceReques\
    tR\x08requests\x12H\n\x0bconstraints\x18\x02\x20\x03(\x0b2&.api.resource\
    .v1beta2.DeviceConstraintR\x0bconstraints\x12F\n\x06config\x18\x03\x20\
    \x03(\x0b2..api.resource.v1beta2.DeviceClaimConfigurationR\x06config\"\
    \x93\x01\n\x18DeviceClaimConfiguration\x12\x1a\n\x08requests\x18\x01\x20\
    \x03(\tR\x08requests\x12[\n\x13deviceConfiguration\x18\x02\x20\x01(\x0b2\
    ).api.resource.v1beta2.DeviceConfigurationR\x13deviceConfiguration\"\x8f\
    \x01\n\x0bDeviceClass\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachi\
    nery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x129\n\x04spec\x18\x02\x20\
    \x01(\x0b2%.api.resource.v1beta2.DeviceClassSpecR\x04spec\"w\n\x18Device\
    ClassConfiguration\x12[\n\x13deviceConfiguration\x18\x01\x20\x01(\x0b2).\
    api.resource.v1beta2.DeviceConfigurationR\x13deviceConfiguration\"\x8f\
    \x01\n\x0fDeviceClassList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apim\
    achinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x127\n\x05items\x18\x02\
    \x20\x03(\x0b2!.api.resource.v1beta2.DeviceClassR\x05items\"\x9d\x01\n\
    \x0fDeviceClassSpec\x12B\n\tselectors\x18\x01\x20\x03(\x0b2$.api.resourc\
    e.v1beta2.DeviceSelectorR\tselectors\x12F\n\x06config\x18\x02\x20\x03(\
    \x0b2..api.resource.v1beta2.DeviceClassConfigurationR\x06config\"^\n\x13\
    DeviceConfiguration\x12G\n\x06opaque\x18\x01\x20\x01(\x0b2/.api.resource\
    .v1beta2.OpaqueDeviceConfigurationR\x06opaque\"V\n\x10DeviceConstraint\
    \x12\x1a\n\x08requests\x18\x01\x20\x03(\tR\x08requests\x12&\n\x0ematchAt\
    tribute\x18\x02\x20\x01(\tR\x0ematchAttribute\"\xf0\x01\n\x18DeviceCount\
    erConsumption\x12\x1e\n\ncounterSet\x18\x01\x20\x01(\tR\ncounterSet\x12X\
    \n\x08counters\x18\x02\x20\x03(\x0b2<.api.resource.v1beta2.DeviceCounter\
    Consumption.CountersEntryR\x08counters\x1aZ\n\rCountersEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x123\n\x05value\x18\x02\x20\x01(\x0b2\
    \x1d.api.resource.v1beta2.CounterR\x05value:\x028\x01\"\xb7\x01\n\rDevic\
    eRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12B\n\x07exactly\
    \x18\x02\x20\x01(\x0b2(.api.resource.v1beta2.ExactDeviceRequestR\x07exac\
    tly\x12N\n\x0efirstAvailable\x18\x03\x20\x03(\x0b2&.api.resource.v1beta2\
    .DeviceSubRequestR\x0efirstAvailable\"\xe9\x01\n\x1dDeviceRequestAllocat\
    ionResult\x12\x18\n\x07request\x18\x01\x20\x01(\tR\x07request\x12\x16\n\
    \x06driver\x18\x02\x20\x01(\tR\x06driver\x12\x12\n\x04pool\x18\x03\x20\
    \x01(\tR\x04pool\x12\x16\n\x06device\x18\x04\x20\x01(\tR\x06device\x12\
    \x20\n\x0badminAccess\x18\x05\x20\x01(\x08R\x0badminAccess\x12H\n\x0btol\
    erations\x18\x06\x20\x03(\x0b2&.api.resource.v1beta2.DeviceTolerationR\
    \x0btolerations\"K\n\x0eDeviceSelector\x129\n\x03cel\x18\x01\x20\x01(\
    \x0b2'.api.resource.v1beta2.CELDeviceSelectorR\x03cel\"\x9c\x02\n\x10Dev\
    iceSubRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12(\n\x0fde\
    viceClassName\x18\x02\x20\x01(\tR\x0fdeviceClassName\x12B\n\tselectors\
    \x18\x03\x20\x03(\x0b2$.api.resource.v1beta2.DeviceSelectorR\tselectors\
    \x12&\n\x0eallocationMode\x18\x04\x20\x01(\tR\x0eallocationMode\x12\x14\
    \n\x05count\x18\x05\x20\x01(\x03R\x05count\x12H\n\x0btolerations\x18\x06\
    \x20\x03(\x0b2&.api.resource.v1beta2.DeviceTolerationR\x0btolerations\"\
    \x90\x01\n\x0bDeviceTaint\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\x12\x16\n\x06effect\x18\
    \x03\x20\x01(\tR\x06effect\x12A\n\ttimeAdded\x18\x04\x20\x01(\x0b2#.apim\
    achinery.pkg.apis.meta.v1.TimeR\ttimeAdded\"\x9c\x01\n\x10DeviceTolerati\
    on\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x1a\n\x08operator\x18\
    \x02\x20\x01(\tR\x08operator\x12\x14\n\x05value\x18\x03\x20\x01(\tR\x05v\
    alue\x12\x16\n\x06effect\x18\x04\x20\x01(\tR\x06effect\x12,\n\x11tolerat\
    ionSeconds\x18\x05\x20\x01(\x03R\x11tolerationSeconds\"\xac\x02\n\x12Exa\
    ctDeviceRequest\x12(\n\x0fdeviceClassName\x18\x01\x20\x01(\tR\x0fdeviceC\
    lassName\x12B\n\tselectors\x18\x02\x20\x03(\x0b2$.api.resource.v1beta2.D\
    eviceSelectorR\tselectors\x12&\n\x0eallocationMode\x18\x03\x20\x01(\tR\
    \x0eallocationMode\x12\x14\n\x05count\x18\x04\x20\x01(\x03R\x05count\x12\
    \x20\n\x0badminAccess\x18\x05\x20\x01(\x08R\x0badminAccess\x12H\n\x0btol\
    erations\x18\x06\x20\x03(\x0b2&.api.resource.v1beta2.DeviceTolerationR\
    \x0btolerations\"u\n\x11NetworkDeviceData\x12$\n\rinterfaceName\x18\x01\
    \x20\x01(\tR\rinterfaceName\x12\x10\n\x03ips\x18\x02\x20\x03(\tR\x03ips\
    \x12(\n\x0fhardwareAddress\x18\x03\x20\x01(\tR\x0fhardwareAddress\"{\n\
    \x19OpaqueDeviceConfiguration\x12\x16\n\x06driver\x18\x01\x20\x01(\tR\
    \x06driver\x12F\n\nparameters\x18\x02\x20\x01(\x0b2&.apimachinery.pkg.ru\
    ntime.RawExtensionR\nparameters\"\xd6\x01\n\rResourceClaim\x12E\n\x08met\
    adata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\
    \x08metadata\x12;\n\x04spec\x18\x02\x20\x01(\x0b2'.api.resource.v1beta2.\
    ResourceClaimSpecR\x04spec\x12A\n\x06status\x18\x03\x20\x01(\x0b2).api.r\
    esource.v1beta2.ResourceClaimStatusR\x06status\"~\n\x1eResourceClaimCons\
    umerReference\x12\x1a\n\x08apiGroup\x18\x01\x20\x01(\tR\x08apiGroup\x12\
    \x1a\n\x08resource\x18\x03\x20\x01(\tR\x08resource\x12\x12\n\x04name\x18\
    \x04\x20\x01(\tR\x04name\x12\x10\n\x03uid\x18\x05\x20\x01(\tR\x03uid\"\
    \x93\x01\n\x11ResourceClaimList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2\
    '.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x129\n\x05items\
    \x18\x02\x20\x03(\x0b2#.api.resource.v1beta2.ResourceClaimR\x05items\"P\
    \n\x11ResourceClaimSpec\x12;\n\x07devices\x18\x01\x20\x01(\x0b2!.api.res\
    ource.v1beta2.DeviceClaimR\x07devices\"\xfc\x01\n\x13ResourceClaimStatus\
    \x12F\n\nallocation\x18\x01\x20\x01(\x0b2&.api.resource.v1beta2.Allocati\
    onResultR\nallocation\x12V\n\x0breservedFor\x18\x02\x20\x03(\x0b24.api.r\
    esource.v1beta2.ResourceClaimConsumerReferenceR\x0breservedFor\x12E\n\
    \x07devices\x18\x04\x20\x03(\x0b2+.api.resource.v1beta2.AllocatedDeviceS\
    tatusR\x07devices\"\xa3\x01\n\x15ResourceClaimTemplate\x12E\n\x08metadat\
    a\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08me\
    tadata\x12C\n\x04spec\x18\x02\x20\x01(\x0b2/.api.resource.v1beta2.Resour\
    ceClaimTemplateSpecR\x04spec\"\xa3\x01\n\x19ResourceClaimTemplateList\
    \x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1\
    .ListMetaR\x08metadata\x12A\n\x05items\x18\x02\x20\x03(\x0b2+.api.resour\
    ce.v1beta2.ResourceClaimTemplateR\x05items\"\x9f\x01\n\x19ResourceClaimT\
    emplateSpec\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.a\
    pis.meta.v1.ObjectMetaR\x08metadata\x12;\n\x04spec\x18\x02\x20\x01(\x0b2\
    '.api.resource.v1beta2.ResourceClaimSpecR\x04spec\"r\n\x0cResourcePool\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1e\n\ngeneration\x18\
    \x02\x20\x01(\x03R\ngeneration\x12.\n\x12resourceSliceCount\x18\x03\x20\
    \x01(\x03R\x12resourceSliceCount\"\x93\x01\n\rResourceSlice\x12E\n\x08me\
    tadata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\
    \x08metadata\x12;\n\x04spec\x18\x02\x20\x01(\x0b2'.api.resource.v1beta2.\
    ResourceSliceSpecR\x04spec\"\x93\x01\n\x11ResourceSliceList\x12C\n\x08me\
    tadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMetaR\
    \x08metadata\x129\n\x05items\x18\x02\x20\x03(\x0b2#.api.resource.v1beta2\
    .ResourceSliceR\x05items\"\x94\x03\n\x11ResourceSliceSpec\x12\x16\n\x06d\
    river\x18\x01\x20\x01(\tR\x06driver\x126\n\x04pool\x18\x02\x20\x01(\x0b2\
    \".api.resource.v1beta2.ResourcePoolR\x04pool\x12\x1a\n\x08nodeName\x18\
    \x03\x20\x01(\tR\x08nodeName\x12=\n\x0cnodeSelector\x18\x04\x20\x01(\x0b\
    2\x19.api.core.v1.NodeSelectorR\x0cnodeSelector\x12\x1a\n\x08allNodes\
    \x18\x05\x20\x01(\x08R\x08allNodes\x126\n\x07devices\x18\x06\x20\x03(\
    \x0b2\x1c.api.resource.v1beta2.DeviceR\x07devices\x126\n\x16perDeviceNod\
    eSelection\x18\x07\x20\x01(\x08R\x16perDeviceNodeSelection\x12H\n\x0esha\
    redCounters\x18\x08\x20\x03(\x0b2\x20.api.resource.v1beta2.CounterSetR\
    \x0esharedCountersB\x1dZ\x1bk8s.io/api/resource/v1beta2\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(5);
            deps.push(super::v1beta2::file_descriptor().clone());
            deps.push(super::v1beta2::file_descriptor().clone());
            deps.push(super::v1beta2::file_descriptor().clone());
            deps.push(super::v1beta2::file_descriptor().clone());
            deps.push(super::v1beta2::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(40);
            messages.push(AllocatedDeviceStatus::generated_message_descriptor_data());
            messages.push(AllocationResult::generated_message_descriptor_data());
            messages.push(CELDeviceSelector::generated_message_descriptor_data());
            messages.push(Counter::generated_message_descriptor_data());
            messages.push(CounterSet::generated_message_descriptor_data());
            messages.push(Device::generated_message_descriptor_data());
            messages.push(DeviceAllocationConfiguration::generated_message_descriptor_data());
            messages.push(DeviceAllocationResult::generated_message_descriptor_data());
            messages.push(DeviceAttribute::generated_message_descriptor_data());
            messages.push(DeviceCapacity::generated_message_descriptor_data());
            messages.push(DeviceClaim::generated_message_descriptor_data());
            messages.push(DeviceClaimConfiguration::generated_message_descriptor_data());
            messages.push(DeviceClass::generated_message_descriptor_data());
            messages.push(DeviceClassConfiguration::generated_message_descriptor_data());
            messages.push(DeviceClassList::generated_message_descriptor_data());
            messages.push(DeviceClassSpec::generated_message_descriptor_data());
            messages.push(DeviceConfiguration::generated_message_descriptor_data());
            messages.push(DeviceConstraint::generated_message_descriptor_data());
            messages.push(DeviceCounterConsumption::generated_message_descriptor_data());
            messages.push(DeviceRequest::generated_message_descriptor_data());
            messages.push(DeviceRequestAllocationResult::generated_message_descriptor_data());
            messages.push(DeviceSelector::generated_message_descriptor_data());
            messages.push(DeviceSubRequest::generated_message_descriptor_data());
            messages.push(DeviceTaint::generated_message_descriptor_data());
            messages.push(DeviceToleration::generated_message_descriptor_data());
            messages.push(ExactDeviceRequest::generated_message_descriptor_data());
            messages.push(NetworkDeviceData::generated_message_descriptor_data());
            messages.push(OpaqueDeviceConfiguration::generated_message_descriptor_data());
            messages.push(ResourceClaim::generated_message_descriptor_data());
            messages.push(ResourceClaimConsumerReference::generated_message_descriptor_data());
            messages.push(ResourceClaimList::generated_message_descriptor_data());
            messages.push(ResourceClaimSpec::generated_message_descriptor_data());
            messages.push(ResourceClaimStatus::generated_message_descriptor_data());
            messages.push(ResourceClaimTemplate::generated_message_descriptor_data());
            messages.push(ResourceClaimTemplateList::generated_message_descriptor_data());
            messages.push(ResourceClaimTemplateSpec::generated_message_descriptor_data());
            messages.push(ResourcePool::generated_message_descriptor_data());
            messages.push(ResourceSlice::generated_message_descriptor_data());
            messages.push(ResourceSliceList::generated_message_descriptor_data());
            messages.push(ResourceSliceSpec::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
