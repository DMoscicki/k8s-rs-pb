// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc 30.2
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `api/flowcontrol/v1beta2/generated.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.flowcontrol.v1beta2.ExemptPriorityLevelConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExemptPriorityLevelConfiguration {
    // message fields
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.ExemptPriorityLevelConfiguration.nominalConcurrencyShares)
    pub nominalConcurrencyShares: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.ExemptPriorityLevelConfiguration.lendablePercent)
    pub lendablePercent: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.flowcontrol.v1beta2.ExemptPriorityLevelConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExemptPriorityLevelConfiguration {
    fn default() -> &'a ExemptPriorityLevelConfiguration {
        <ExemptPriorityLevelConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl ExemptPriorityLevelConfiguration {
    pub fn new() -> ExemptPriorityLevelConfiguration {
        ::std::default::Default::default()
    }

    // optional int32 nominalConcurrencyShares = 1;

    pub fn nominalConcurrencyShares(&self) -> i32 {
        self.nominalConcurrencyShares.unwrap_or(0)
    }

    pub fn clear_nominalConcurrencyShares(&mut self) {
        self.nominalConcurrencyShares = ::std::option::Option::None;
    }

    pub fn has_nominalConcurrencyShares(&self) -> bool {
        self.nominalConcurrencyShares.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nominalConcurrencyShares(&mut self, v: i32) {
        self.nominalConcurrencyShares = ::std::option::Option::Some(v);
    }

    // optional int32 lendablePercent = 2;

    pub fn lendablePercent(&self) -> i32 {
        self.lendablePercent.unwrap_or(0)
    }

    pub fn clear_lendablePercent(&mut self) {
        self.lendablePercent = ::std::option::Option::None;
    }

    pub fn has_lendablePercent(&self) -> bool {
        self.lendablePercent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lendablePercent(&mut self, v: i32) {
        self.lendablePercent = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nominalConcurrencyShares",
            |m: &ExemptPriorityLevelConfiguration| { &m.nominalConcurrencyShares },
            |m: &mut ExemptPriorityLevelConfiguration| { &mut m.nominalConcurrencyShares },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lendablePercent",
            |m: &ExemptPriorityLevelConfiguration| { &m.lendablePercent },
            |m: &mut ExemptPriorityLevelConfiguration| { &mut m.lendablePercent },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExemptPriorityLevelConfiguration>(
            "ExemptPriorityLevelConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExemptPriorityLevelConfiguration {
    const NAME: &'static str = "ExemptPriorityLevelConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.nominalConcurrencyShares = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.lendablePercent = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.nominalConcurrencyShares {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.lendablePercent {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.nominalConcurrencyShares {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.lendablePercent {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExemptPriorityLevelConfiguration {
        ExemptPriorityLevelConfiguration::new()
    }

    fn clear(&mut self) {
        self.nominalConcurrencyShares = ::std::option::Option::None;
        self.lendablePercent = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExemptPriorityLevelConfiguration {
        static instance: ExemptPriorityLevelConfiguration = ExemptPriorityLevelConfiguration {
            nominalConcurrencyShares: ::std::option::Option::None,
            lendablePercent: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExemptPriorityLevelConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExemptPriorityLevelConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExemptPriorityLevelConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExemptPriorityLevelConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.flowcontrol.v1beta2.FlowDistinguisherMethod)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FlowDistinguisherMethod {
    // message fields
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.FlowDistinguisherMethod.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.flowcontrol.v1beta2.FlowDistinguisherMethod.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FlowDistinguisherMethod {
    fn default() -> &'a FlowDistinguisherMethod {
        <FlowDistinguisherMethod as ::protobuf::Message>::default_instance()
    }
}

impl FlowDistinguisherMethod {
    pub fn new() -> FlowDistinguisherMethod {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &FlowDistinguisherMethod| { &m.type_ },
            |m: &mut FlowDistinguisherMethod| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FlowDistinguisherMethod>(
            "FlowDistinguisherMethod",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FlowDistinguisherMethod {
    const NAME: &'static str = "FlowDistinguisherMethod";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FlowDistinguisherMethod {
        FlowDistinguisherMethod::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FlowDistinguisherMethod {
        static instance: FlowDistinguisherMethod = FlowDistinguisherMethod {
            type_: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FlowDistinguisherMethod {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FlowDistinguisherMethod").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FlowDistinguisherMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowDistinguisherMethod {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.flowcontrol.v1beta2.FlowSchema)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FlowSchema {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.FlowSchema.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.FlowSchema.spec)
    pub spec: ::protobuf::MessageField<FlowSchemaSpec>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.FlowSchema.status)
    pub status: ::protobuf::MessageField<FlowSchemaStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.flowcontrol.v1beta2.FlowSchema.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FlowSchema {
    fn default() -> &'a FlowSchema {
        <FlowSchema as ::protobuf::Message>::default_instance()
    }
}

impl FlowSchema {
    pub fn new() -> FlowSchema {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.flowcontrol.v1beta2.FlowSchemaSpec spec = 2;

    pub fn spec(&self) -> &FlowSchemaSpec {
        self.spec.as_ref().unwrap_or_else(|| <FlowSchemaSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: FlowSchemaSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut FlowSchemaSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> FlowSchemaSpec {
        self.spec.take().unwrap_or_else(|| FlowSchemaSpec::new())
    }

    // optional .api.flowcontrol.v1beta2.FlowSchemaStatus status = 3;

    pub fn status(&self) -> &FlowSchemaStatus {
        self.status.as_ref().unwrap_or_else(|| <FlowSchemaStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: FlowSchemaStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut FlowSchemaStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> FlowSchemaStatus {
        self.status.take().unwrap_or_else(|| FlowSchemaStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &FlowSchema| { &m.metadata },
            |m: &mut FlowSchema| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FlowSchemaSpec>(
            "spec",
            |m: &FlowSchema| { &m.spec },
            |m: &mut FlowSchema| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FlowSchemaStatus>(
            "status",
            |m: &FlowSchema| { &m.status },
            |m: &mut FlowSchema| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FlowSchema>(
            "FlowSchema",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FlowSchema {
    const NAME: &'static str = "FlowSchema";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FlowSchema {
        FlowSchema::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FlowSchema {
        static instance: FlowSchema = FlowSchema {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FlowSchema {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FlowSchema").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FlowSchema {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowSchema {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.flowcontrol.v1beta2.FlowSchemaCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FlowSchemaCondition {
    // message fields
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.FlowSchemaCondition.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.FlowSchemaCondition.status)
    pub status: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.FlowSchemaCondition.lastTransitionTime)
    pub lastTransitionTime: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.FlowSchemaCondition.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.FlowSchemaCondition.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.flowcontrol.v1beta2.FlowSchemaCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FlowSchemaCondition {
    fn default() -> &'a FlowSchemaCondition {
        <FlowSchemaCondition as ::protobuf::Message>::default_instance()
    }
}

impl FlowSchemaCondition {
    pub fn new() -> FlowSchemaCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

    pub fn lastTransitionTime(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastTransitionTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional string reason = 4;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 5;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &FlowSchemaCondition| { &m.type_ },
            |m: &mut FlowSchemaCondition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &FlowSchemaCondition| { &m.status },
            |m: &mut FlowSchemaCondition| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>(
            "lastTransitionTime",
            |m: &FlowSchemaCondition| { &m.lastTransitionTime },
            |m: &mut FlowSchemaCondition| { &mut m.lastTransitionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &FlowSchemaCondition| { &m.reason },
            |m: &mut FlowSchemaCondition| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &FlowSchemaCondition| { &m.message },
            |m: &mut FlowSchemaCondition| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FlowSchemaCondition>(
            "FlowSchemaCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FlowSchemaCondition {
    const NAME: &'static str = "FlowSchemaCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTransitionTime)?;
                },
                34 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FlowSchemaCondition {
        FlowSchemaCondition::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.lastTransitionTime.clear();
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FlowSchemaCondition {
        static instance: FlowSchemaCondition = FlowSchemaCondition {
            type_: ::std::option::Option::None,
            status: ::std::option::Option::None,
            lastTransitionTime: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FlowSchemaCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FlowSchemaCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FlowSchemaCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowSchemaCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.flowcontrol.v1beta2.FlowSchemaList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FlowSchemaList {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.FlowSchemaList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.FlowSchemaList.items)
    pub items: ::std::vec::Vec<FlowSchema>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.flowcontrol.v1beta2.FlowSchemaList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FlowSchemaList {
    fn default() -> &'a FlowSchemaList {
        <FlowSchemaList as ::protobuf::Message>::default_instance()
    }
}

impl FlowSchemaList {
    pub fn new() -> FlowSchemaList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.flowcontrol.v1beta2.FlowSchema items = 2;

    pub fn items(&self) -> &[FlowSchema] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<FlowSchema>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<FlowSchema> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<FlowSchema> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &FlowSchemaList| { &m.metadata },
            |m: &mut FlowSchemaList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &FlowSchemaList| { &m.items },
            |m: &mut FlowSchemaList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FlowSchemaList>(
            "FlowSchemaList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FlowSchemaList {
    const NAME: &'static str = "FlowSchemaList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FlowSchemaList {
        FlowSchemaList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FlowSchemaList {
        static instance: FlowSchemaList = FlowSchemaList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FlowSchemaList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FlowSchemaList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FlowSchemaList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowSchemaList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.flowcontrol.v1beta2.FlowSchemaSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FlowSchemaSpec {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.FlowSchemaSpec.priorityLevelConfiguration)
    pub priorityLevelConfiguration: ::protobuf::MessageField<PriorityLevelConfigurationReference>,
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.FlowSchemaSpec.matchingPrecedence)
    pub matchingPrecedence: ::std::option::Option<i32>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.FlowSchemaSpec.distinguisherMethod)
    pub distinguisherMethod: ::protobuf::MessageField<FlowDistinguisherMethod>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.FlowSchemaSpec.rules)
    pub rules: ::std::vec::Vec<PolicyRulesWithSubjects>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.flowcontrol.v1beta2.FlowSchemaSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FlowSchemaSpec {
    fn default() -> &'a FlowSchemaSpec {
        <FlowSchemaSpec as ::protobuf::Message>::default_instance()
    }
}

impl FlowSchemaSpec {
    pub fn new() -> FlowSchemaSpec {
        ::std::default::Default::default()
    }

    // optional .api.flowcontrol.v1beta2.PriorityLevelConfigurationReference priorityLevelConfiguration = 1;

    pub fn priorityLevelConfiguration(&self) -> &PriorityLevelConfigurationReference {
        self.priorityLevelConfiguration.as_ref().unwrap_or_else(|| <PriorityLevelConfigurationReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_priorityLevelConfiguration(&mut self) {
        self.priorityLevelConfiguration.clear();
    }

    pub fn has_priorityLevelConfiguration(&self) -> bool {
        self.priorityLevelConfiguration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priorityLevelConfiguration(&mut self, v: PriorityLevelConfigurationReference) {
        self.priorityLevelConfiguration = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_priorityLevelConfiguration(&mut self) -> &mut PriorityLevelConfigurationReference {
        self.priorityLevelConfiguration.mut_or_insert_default()
    }

    // Take field
    pub fn take_priorityLevelConfiguration(&mut self) -> PriorityLevelConfigurationReference {
        self.priorityLevelConfiguration.take().unwrap_or_else(|| PriorityLevelConfigurationReference::new())
    }

    // optional int32 matchingPrecedence = 2;

    pub fn matchingPrecedence(&self) -> i32 {
        self.matchingPrecedence.unwrap_or(0)
    }

    pub fn clear_matchingPrecedence(&mut self) {
        self.matchingPrecedence = ::std::option::Option::None;
    }

    pub fn has_matchingPrecedence(&self) -> bool {
        self.matchingPrecedence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchingPrecedence(&mut self, v: i32) {
        self.matchingPrecedence = ::std::option::Option::Some(v);
    }

    // optional .api.flowcontrol.v1beta2.FlowDistinguisherMethod distinguisherMethod = 3;

    pub fn distinguisherMethod(&self) -> &FlowDistinguisherMethod {
        self.distinguisherMethod.as_ref().unwrap_or_else(|| <FlowDistinguisherMethod as ::protobuf::Message>::default_instance())
    }

    pub fn clear_distinguisherMethod(&mut self) {
        self.distinguisherMethod.clear();
    }

    pub fn has_distinguisherMethod(&self) -> bool {
        self.distinguisherMethod.is_some()
    }

    // Param is passed by value, moved
    pub fn set_distinguisherMethod(&mut self, v: FlowDistinguisherMethod) {
        self.distinguisherMethod = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_distinguisherMethod(&mut self) -> &mut FlowDistinguisherMethod {
        self.distinguisherMethod.mut_or_insert_default()
    }

    // Take field
    pub fn take_distinguisherMethod(&mut self) -> FlowDistinguisherMethod {
        self.distinguisherMethod.take().unwrap_or_else(|| FlowDistinguisherMethod::new())
    }

    // repeated .api.flowcontrol.v1beta2.PolicyRulesWithSubjects rules = 4;

    pub fn rules(&self) -> &[PolicyRulesWithSubjects] {
        &self.rules
    }

    pub fn clear_rules(&mut self) {
        self.rules.clear();
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: ::std::vec::Vec<PolicyRulesWithSubjects>) {
        self.rules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rules(&mut self) -> &mut ::std::vec::Vec<PolicyRulesWithSubjects> {
        &mut self.rules
    }

    // Take field
    pub fn take_rules(&mut self) -> ::std::vec::Vec<PolicyRulesWithSubjects> {
        ::std::mem::replace(&mut self.rules, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PriorityLevelConfigurationReference>(
            "priorityLevelConfiguration",
            |m: &FlowSchemaSpec| { &m.priorityLevelConfiguration },
            |m: &mut FlowSchemaSpec| { &mut m.priorityLevelConfiguration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchingPrecedence",
            |m: &FlowSchemaSpec| { &m.matchingPrecedence },
            |m: &mut FlowSchemaSpec| { &mut m.matchingPrecedence },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FlowDistinguisherMethod>(
            "distinguisherMethod",
            |m: &FlowSchemaSpec| { &m.distinguisherMethod },
            |m: &mut FlowSchemaSpec| { &mut m.distinguisherMethod },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rules",
            |m: &FlowSchemaSpec| { &m.rules },
            |m: &mut FlowSchemaSpec| { &mut m.rules },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FlowSchemaSpec>(
            "FlowSchemaSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FlowSchemaSpec {
    const NAME: &'static str = "FlowSchemaSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.priorityLevelConfiguration)?;
                },
                16 => {
                    self.matchingPrecedence = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.distinguisherMethod)?;
                },
                34 => {
                    self.rules.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.priorityLevelConfiguration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.matchingPrecedence {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.distinguisherMethod.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.priorityLevelConfiguration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.matchingPrecedence {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.distinguisherMethod.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.rules {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FlowSchemaSpec {
        FlowSchemaSpec::new()
    }

    fn clear(&mut self) {
        self.priorityLevelConfiguration.clear();
        self.matchingPrecedence = ::std::option::Option::None;
        self.distinguisherMethod.clear();
        self.rules.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FlowSchemaSpec {
        static instance: FlowSchemaSpec = FlowSchemaSpec {
            priorityLevelConfiguration: ::protobuf::MessageField::none(),
            matchingPrecedence: ::std::option::Option::None,
            distinguisherMethod: ::protobuf::MessageField::none(),
            rules: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FlowSchemaSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FlowSchemaSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FlowSchemaSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowSchemaSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.flowcontrol.v1beta2.FlowSchemaStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FlowSchemaStatus {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.FlowSchemaStatus.conditions)
    pub conditions: ::std::vec::Vec<FlowSchemaCondition>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.flowcontrol.v1beta2.FlowSchemaStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FlowSchemaStatus {
    fn default() -> &'a FlowSchemaStatus {
        <FlowSchemaStatus as ::protobuf::Message>::default_instance()
    }
}

impl FlowSchemaStatus {
    pub fn new() -> FlowSchemaStatus {
        ::std::default::Default::default()
    }

    // repeated .api.flowcontrol.v1beta2.FlowSchemaCondition conditions = 1;

    pub fn conditions(&self) -> &[FlowSchemaCondition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<FlowSchemaCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<FlowSchemaCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<FlowSchemaCondition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &FlowSchemaStatus| { &m.conditions },
            |m: &mut FlowSchemaStatus| { &mut m.conditions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FlowSchemaStatus>(
            "FlowSchemaStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FlowSchemaStatus {
    const NAME: &'static str = "FlowSchemaStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.conditions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FlowSchemaStatus {
        FlowSchemaStatus::new()
    }

    fn clear(&mut self) {
        self.conditions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FlowSchemaStatus {
        static instance: FlowSchemaStatus = FlowSchemaStatus {
            conditions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FlowSchemaStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FlowSchemaStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FlowSchemaStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowSchemaStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.flowcontrol.v1beta2.GroupSubject)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GroupSubject {
    // message fields
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.GroupSubject.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.flowcontrol.v1beta2.GroupSubject.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GroupSubject {
    fn default() -> &'a GroupSubject {
        <GroupSubject as ::protobuf::Message>::default_instance()
    }
}

impl GroupSubject {
    pub fn new() -> GroupSubject {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &GroupSubject| { &m.name },
            |m: &mut GroupSubject| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupSubject>(
            "GroupSubject",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GroupSubject {
    const NAME: &'static str = "GroupSubject";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GroupSubject {
        GroupSubject::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GroupSubject {
        static instance: GroupSubject = GroupSubject {
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GroupSubject {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GroupSubject").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GroupSubject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupSubject {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.flowcontrol.v1beta2.LimitResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LimitResponse {
    // message fields
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.LimitResponse.type)
    pub type_: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.LimitResponse.queuing)
    pub queuing: ::protobuf::MessageField<QueuingConfiguration>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.flowcontrol.v1beta2.LimitResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LimitResponse {
    fn default() -> &'a LimitResponse {
        <LimitResponse as ::protobuf::Message>::default_instance()
    }
}

impl LimitResponse {
    pub fn new() -> LimitResponse {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.flowcontrol.v1beta2.QueuingConfiguration queuing = 2;

    pub fn queuing(&self) -> &QueuingConfiguration {
        self.queuing.as_ref().unwrap_or_else(|| <QueuingConfiguration as ::protobuf::Message>::default_instance())
    }

    pub fn clear_queuing(&mut self) {
        self.queuing.clear();
    }

    pub fn has_queuing(&self) -> bool {
        self.queuing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queuing(&mut self, v: QueuingConfiguration) {
        self.queuing = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_queuing(&mut self) -> &mut QueuingConfiguration {
        self.queuing.mut_or_insert_default()
    }

    // Take field
    pub fn take_queuing(&mut self) -> QueuingConfiguration {
        self.queuing.take().unwrap_or_else(|| QueuingConfiguration::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &LimitResponse| { &m.type_ },
            |m: &mut LimitResponse| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, QueuingConfiguration>(
            "queuing",
            |m: &LimitResponse| { &m.queuing },
            |m: &mut LimitResponse| { &mut m.queuing },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LimitResponse>(
            "LimitResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LimitResponse {
    const NAME: &'static str = "LimitResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.queuing)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.queuing.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.queuing.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LimitResponse {
        LimitResponse::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.queuing.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LimitResponse {
        static instance: LimitResponse = LimitResponse {
            type_: ::std::option::Option::None,
            queuing: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LimitResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LimitResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LimitResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LimitResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.flowcontrol.v1beta2.LimitedPriorityLevelConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LimitedPriorityLevelConfiguration {
    // message fields
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.LimitedPriorityLevelConfiguration.assuredConcurrencyShares)
    pub assuredConcurrencyShares: ::std::option::Option<i32>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.LimitedPriorityLevelConfiguration.limitResponse)
    pub limitResponse: ::protobuf::MessageField<LimitResponse>,
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.LimitedPriorityLevelConfiguration.lendablePercent)
    pub lendablePercent: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.LimitedPriorityLevelConfiguration.borrowingLimitPercent)
    pub borrowingLimitPercent: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.flowcontrol.v1beta2.LimitedPriorityLevelConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LimitedPriorityLevelConfiguration {
    fn default() -> &'a LimitedPriorityLevelConfiguration {
        <LimitedPriorityLevelConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl LimitedPriorityLevelConfiguration {
    pub fn new() -> LimitedPriorityLevelConfiguration {
        ::std::default::Default::default()
    }

    // optional int32 assuredConcurrencyShares = 1;

    pub fn assuredConcurrencyShares(&self) -> i32 {
        self.assuredConcurrencyShares.unwrap_or(0)
    }

    pub fn clear_assuredConcurrencyShares(&mut self) {
        self.assuredConcurrencyShares = ::std::option::Option::None;
    }

    pub fn has_assuredConcurrencyShares(&self) -> bool {
        self.assuredConcurrencyShares.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assuredConcurrencyShares(&mut self, v: i32) {
        self.assuredConcurrencyShares = ::std::option::Option::Some(v);
    }

    // optional .api.flowcontrol.v1beta2.LimitResponse limitResponse = 2;

    pub fn limitResponse(&self) -> &LimitResponse {
        self.limitResponse.as_ref().unwrap_or_else(|| <LimitResponse as ::protobuf::Message>::default_instance())
    }

    pub fn clear_limitResponse(&mut self) {
        self.limitResponse.clear();
    }

    pub fn has_limitResponse(&self) -> bool {
        self.limitResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limitResponse(&mut self, v: LimitResponse) {
        self.limitResponse = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limitResponse(&mut self) -> &mut LimitResponse {
        self.limitResponse.mut_or_insert_default()
    }

    // Take field
    pub fn take_limitResponse(&mut self) -> LimitResponse {
        self.limitResponse.take().unwrap_or_else(|| LimitResponse::new())
    }

    // optional int32 lendablePercent = 3;

    pub fn lendablePercent(&self) -> i32 {
        self.lendablePercent.unwrap_or(0)
    }

    pub fn clear_lendablePercent(&mut self) {
        self.lendablePercent = ::std::option::Option::None;
    }

    pub fn has_lendablePercent(&self) -> bool {
        self.lendablePercent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lendablePercent(&mut self, v: i32) {
        self.lendablePercent = ::std::option::Option::Some(v);
    }

    // optional int32 borrowingLimitPercent = 4;

    pub fn borrowingLimitPercent(&self) -> i32 {
        self.borrowingLimitPercent.unwrap_or(0)
    }

    pub fn clear_borrowingLimitPercent(&mut self) {
        self.borrowingLimitPercent = ::std::option::Option::None;
    }

    pub fn has_borrowingLimitPercent(&self) -> bool {
        self.borrowingLimitPercent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_borrowingLimitPercent(&mut self, v: i32) {
        self.borrowingLimitPercent = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "assuredConcurrencyShares",
            |m: &LimitedPriorityLevelConfiguration| { &m.assuredConcurrencyShares },
            |m: &mut LimitedPriorityLevelConfiguration| { &mut m.assuredConcurrencyShares },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LimitResponse>(
            "limitResponse",
            |m: &LimitedPriorityLevelConfiguration| { &m.limitResponse },
            |m: &mut LimitedPriorityLevelConfiguration| { &mut m.limitResponse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lendablePercent",
            |m: &LimitedPriorityLevelConfiguration| { &m.lendablePercent },
            |m: &mut LimitedPriorityLevelConfiguration| { &mut m.lendablePercent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "borrowingLimitPercent",
            |m: &LimitedPriorityLevelConfiguration| { &m.borrowingLimitPercent },
            |m: &mut LimitedPriorityLevelConfiguration| { &mut m.borrowingLimitPercent },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LimitedPriorityLevelConfiguration>(
            "LimitedPriorityLevelConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LimitedPriorityLevelConfiguration {
    const NAME: &'static str = "LimitedPriorityLevelConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.assuredConcurrencyShares = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.limitResponse)?;
                },
                24 => {
                    self.lendablePercent = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.borrowingLimitPercent = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.assuredConcurrencyShares {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.limitResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.lendablePercent {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.borrowingLimitPercent {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.assuredConcurrencyShares {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.limitResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.lendablePercent {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.borrowingLimitPercent {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LimitedPriorityLevelConfiguration {
        LimitedPriorityLevelConfiguration::new()
    }

    fn clear(&mut self) {
        self.assuredConcurrencyShares = ::std::option::Option::None;
        self.limitResponse.clear();
        self.lendablePercent = ::std::option::Option::None;
        self.borrowingLimitPercent = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LimitedPriorityLevelConfiguration {
        static instance: LimitedPriorityLevelConfiguration = LimitedPriorityLevelConfiguration {
            assuredConcurrencyShares: ::std::option::Option::None,
            limitResponse: ::protobuf::MessageField::none(),
            lendablePercent: ::std::option::Option::None,
            borrowingLimitPercent: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LimitedPriorityLevelConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LimitedPriorityLevelConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LimitedPriorityLevelConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LimitedPriorityLevelConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.flowcontrol.v1beta2.NonResourcePolicyRule)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NonResourcePolicyRule {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.NonResourcePolicyRule.verbs)
    pub verbs: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.NonResourcePolicyRule.nonResourceURLs)
    pub nonResourceURLs: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.flowcontrol.v1beta2.NonResourcePolicyRule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NonResourcePolicyRule {
    fn default() -> &'a NonResourcePolicyRule {
        <NonResourcePolicyRule as ::protobuf::Message>::default_instance()
    }
}

impl NonResourcePolicyRule {
    pub fn new() -> NonResourcePolicyRule {
        ::std::default::Default::default()
    }

    // repeated string verbs = 1;

    pub fn verbs(&self) -> &[::std::string::String] {
        &self.verbs
    }

    pub fn clear_verbs(&mut self) {
        self.verbs.clear();
    }

    // Param is passed by value, moved
    pub fn set_verbs(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.verbs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_verbs(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.verbs
    }

    // Take field
    pub fn take_verbs(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.verbs, ::std::vec::Vec::new())
    }

    // repeated string nonResourceURLs = 6;

    pub fn nonResourceURLs(&self) -> &[::std::string::String] {
        &self.nonResourceURLs
    }

    pub fn clear_nonResourceURLs(&mut self) {
        self.nonResourceURLs.clear();
    }

    // Param is passed by value, moved
    pub fn set_nonResourceURLs(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.nonResourceURLs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nonResourceURLs(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.nonResourceURLs
    }

    // Take field
    pub fn take_nonResourceURLs(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.nonResourceURLs, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "verbs",
            |m: &NonResourcePolicyRule| { &m.verbs },
            |m: &mut NonResourcePolicyRule| { &mut m.verbs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nonResourceURLs",
            |m: &NonResourcePolicyRule| { &m.nonResourceURLs },
            |m: &mut NonResourcePolicyRule| { &mut m.nonResourceURLs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NonResourcePolicyRule>(
            "NonResourcePolicyRule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NonResourcePolicyRule {
    const NAME: &'static str = "NonResourcePolicyRule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.verbs.push(is.read_string()?);
                },
                50 => {
                    self.nonResourceURLs.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.verbs {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.nonResourceURLs {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.verbs {
            os.write_string(1, &v)?;
        };
        for v in &self.nonResourceURLs {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NonResourcePolicyRule {
        NonResourcePolicyRule::new()
    }

    fn clear(&mut self) {
        self.verbs.clear();
        self.nonResourceURLs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NonResourcePolicyRule {
        static instance: NonResourcePolicyRule = NonResourcePolicyRule {
            verbs: ::std::vec::Vec::new(),
            nonResourceURLs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NonResourcePolicyRule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NonResourcePolicyRule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NonResourcePolicyRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NonResourcePolicyRule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.flowcontrol.v1beta2.PolicyRulesWithSubjects)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PolicyRulesWithSubjects {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.PolicyRulesWithSubjects.subjects)
    pub subjects: ::std::vec::Vec<Subject>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.PolicyRulesWithSubjects.resourceRules)
    pub resourceRules: ::std::vec::Vec<ResourcePolicyRule>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.PolicyRulesWithSubjects.nonResourceRules)
    pub nonResourceRules: ::std::vec::Vec<NonResourcePolicyRule>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.flowcontrol.v1beta2.PolicyRulesWithSubjects.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PolicyRulesWithSubjects {
    fn default() -> &'a PolicyRulesWithSubjects {
        <PolicyRulesWithSubjects as ::protobuf::Message>::default_instance()
    }
}

impl PolicyRulesWithSubjects {
    pub fn new() -> PolicyRulesWithSubjects {
        ::std::default::Default::default()
    }

    // repeated .api.flowcontrol.v1beta2.Subject subjects = 1;

    pub fn subjects(&self) -> &[Subject] {
        &self.subjects
    }

    pub fn clear_subjects(&mut self) {
        self.subjects.clear();
    }

    // Param is passed by value, moved
    pub fn set_subjects(&mut self, v: ::std::vec::Vec<Subject>) {
        self.subjects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subjects(&mut self) -> &mut ::std::vec::Vec<Subject> {
        &mut self.subjects
    }

    // Take field
    pub fn take_subjects(&mut self) -> ::std::vec::Vec<Subject> {
        ::std::mem::replace(&mut self.subjects, ::std::vec::Vec::new())
    }

    // repeated .api.flowcontrol.v1beta2.ResourcePolicyRule resourceRules = 2;

    pub fn resourceRules(&self) -> &[ResourcePolicyRule] {
        &self.resourceRules
    }

    pub fn clear_resourceRules(&mut self) {
        self.resourceRules.clear();
    }

    // Param is passed by value, moved
    pub fn set_resourceRules(&mut self, v: ::std::vec::Vec<ResourcePolicyRule>) {
        self.resourceRules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resourceRules(&mut self) -> &mut ::std::vec::Vec<ResourcePolicyRule> {
        &mut self.resourceRules
    }

    // Take field
    pub fn take_resourceRules(&mut self) -> ::std::vec::Vec<ResourcePolicyRule> {
        ::std::mem::replace(&mut self.resourceRules, ::std::vec::Vec::new())
    }

    // repeated .api.flowcontrol.v1beta2.NonResourcePolicyRule nonResourceRules = 3;

    pub fn nonResourceRules(&self) -> &[NonResourcePolicyRule] {
        &self.nonResourceRules
    }

    pub fn clear_nonResourceRules(&mut self) {
        self.nonResourceRules.clear();
    }

    // Param is passed by value, moved
    pub fn set_nonResourceRules(&mut self, v: ::std::vec::Vec<NonResourcePolicyRule>) {
        self.nonResourceRules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nonResourceRules(&mut self) -> &mut ::std::vec::Vec<NonResourcePolicyRule> {
        &mut self.nonResourceRules
    }

    // Take field
    pub fn take_nonResourceRules(&mut self) -> ::std::vec::Vec<NonResourcePolicyRule> {
        ::std::mem::replace(&mut self.nonResourceRules, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subjects",
            |m: &PolicyRulesWithSubjects| { &m.subjects },
            |m: &mut PolicyRulesWithSubjects| { &mut m.subjects },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resourceRules",
            |m: &PolicyRulesWithSubjects| { &m.resourceRules },
            |m: &mut PolicyRulesWithSubjects| { &mut m.resourceRules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nonResourceRules",
            |m: &PolicyRulesWithSubjects| { &m.nonResourceRules },
            |m: &mut PolicyRulesWithSubjects| { &mut m.nonResourceRules },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PolicyRulesWithSubjects>(
            "PolicyRulesWithSubjects",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PolicyRulesWithSubjects {
    const NAME: &'static str = "PolicyRulesWithSubjects";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.subjects.push(is.read_message()?);
                },
                18 => {
                    self.resourceRules.push(is.read_message()?);
                },
                26 => {
                    self.nonResourceRules.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.subjects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.resourceRules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.nonResourceRules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.subjects {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.resourceRules {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.nonResourceRules {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PolicyRulesWithSubjects {
        PolicyRulesWithSubjects::new()
    }

    fn clear(&mut self) {
        self.subjects.clear();
        self.resourceRules.clear();
        self.nonResourceRules.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PolicyRulesWithSubjects {
        static instance: PolicyRulesWithSubjects = PolicyRulesWithSubjects {
            subjects: ::std::vec::Vec::new(),
            resourceRules: ::std::vec::Vec::new(),
            nonResourceRules: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PolicyRulesWithSubjects {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PolicyRulesWithSubjects").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PolicyRulesWithSubjects {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PolicyRulesWithSubjects {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.flowcontrol.v1beta2.PriorityLevelConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PriorityLevelConfiguration {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.PriorityLevelConfiguration.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.PriorityLevelConfiguration.spec)
    pub spec: ::protobuf::MessageField<PriorityLevelConfigurationSpec>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.PriorityLevelConfiguration.status)
    pub status: ::protobuf::MessageField<PriorityLevelConfigurationStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.flowcontrol.v1beta2.PriorityLevelConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PriorityLevelConfiguration {
    fn default() -> &'a PriorityLevelConfiguration {
        <PriorityLevelConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl PriorityLevelConfiguration {
    pub fn new() -> PriorityLevelConfiguration {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.flowcontrol.v1beta2.PriorityLevelConfigurationSpec spec = 2;

    pub fn spec(&self) -> &PriorityLevelConfigurationSpec {
        self.spec.as_ref().unwrap_or_else(|| <PriorityLevelConfigurationSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: PriorityLevelConfigurationSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut PriorityLevelConfigurationSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> PriorityLevelConfigurationSpec {
        self.spec.take().unwrap_or_else(|| PriorityLevelConfigurationSpec::new())
    }

    // optional .api.flowcontrol.v1beta2.PriorityLevelConfigurationStatus status = 3;

    pub fn status(&self) -> &PriorityLevelConfigurationStatus {
        self.status.as_ref().unwrap_or_else(|| <PriorityLevelConfigurationStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: PriorityLevelConfigurationStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut PriorityLevelConfigurationStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> PriorityLevelConfigurationStatus {
        self.status.take().unwrap_or_else(|| PriorityLevelConfigurationStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &PriorityLevelConfiguration| { &m.metadata },
            |m: &mut PriorityLevelConfiguration| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PriorityLevelConfigurationSpec>(
            "spec",
            |m: &PriorityLevelConfiguration| { &m.spec },
            |m: &mut PriorityLevelConfiguration| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PriorityLevelConfigurationStatus>(
            "status",
            |m: &PriorityLevelConfiguration| { &m.status },
            |m: &mut PriorityLevelConfiguration| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PriorityLevelConfiguration>(
            "PriorityLevelConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PriorityLevelConfiguration {
    const NAME: &'static str = "PriorityLevelConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PriorityLevelConfiguration {
        PriorityLevelConfiguration::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PriorityLevelConfiguration {
        static instance: PriorityLevelConfiguration = PriorityLevelConfiguration {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PriorityLevelConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PriorityLevelConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PriorityLevelConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PriorityLevelConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.flowcontrol.v1beta2.PriorityLevelConfigurationCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PriorityLevelConfigurationCondition {
    // message fields
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.PriorityLevelConfigurationCondition.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.PriorityLevelConfigurationCondition.status)
    pub status: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.PriorityLevelConfigurationCondition.lastTransitionTime)
    pub lastTransitionTime: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.PriorityLevelConfigurationCondition.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.PriorityLevelConfigurationCondition.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.flowcontrol.v1beta2.PriorityLevelConfigurationCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PriorityLevelConfigurationCondition {
    fn default() -> &'a PriorityLevelConfigurationCondition {
        <PriorityLevelConfigurationCondition as ::protobuf::Message>::default_instance()
    }
}

impl PriorityLevelConfigurationCondition {
    pub fn new() -> PriorityLevelConfigurationCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

    pub fn lastTransitionTime(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastTransitionTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional string reason = 4;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 5;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &PriorityLevelConfigurationCondition| { &m.type_ },
            |m: &mut PriorityLevelConfigurationCondition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &PriorityLevelConfigurationCondition| { &m.status },
            |m: &mut PriorityLevelConfigurationCondition| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>(
            "lastTransitionTime",
            |m: &PriorityLevelConfigurationCondition| { &m.lastTransitionTime },
            |m: &mut PriorityLevelConfigurationCondition| { &mut m.lastTransitionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &PriorityLevelConfigurationCondition| { &m.reason },
            |m: &mut PriorityLevelConfigurationCondition| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &PriorityLevelConfigurationCondition| { &m.message },
            |m: &mut PriorityLevelConfigurationCondition| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PriorityLevelConfigurationCondition>(
            "PriorityLevelConfigurationCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PriorityLevelConfigurationCondition {
    const NAME: &'static str = "PriorityLevelConfigurationCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTransitionTime)?;
                },
                34 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PriorityLevelConfigurationCondition {
        PriorityLevelConfigurationCondition::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.lastTransitionTime.clear();
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PriorityLevelConfigurationCondition {
        static instance: PriorityLevelConfigurationCondition = PriorityLevelConfigurationCondition {
            type_: ::std::option::Option::None,
            status: ::std::option::Option::None,
            lastTransitionTime: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PriorityLevelConfigurationCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PriorityLevelConfigurationCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PriorityLevelConfigurationCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PriorityLevelConfigurationCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.flowcontrol.v1beta2.PriorityLevelConfigurationList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PriorityLevelConfigurationList {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.PriorityLevelConfigurationList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.PriorityLevelConfigurationList.items)
    pub items: ::std::vec::Vec<PriorityLevelConfiguration>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.flowcontrol.v1beta2.PriorityLevelConfigurationList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PriorityLevelConfigurationList {
    fn default() -> &'a PriorityLevelConfigurationList {
        <PriorityLevelConfigurationList as ::protobuf::Message>::default_instance()
    }
}

impl PriorityLevelConfigurationList {
    pub fn new() -> PriorityLevelConfigurationList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.flowcontrol.v1beta2.PriorityLevelConfiguration items = 2;

    pub fn items(&self) -> &[PriorityLevelConfiguration] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<PriorityLevelConfiguration>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<PriorityLevelConfiguration> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<PriorityLevelConfiguration> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &PriorityLevelConfigurationList| { &m.metadata },
            |m: &mut PriorityLevelConfigurationList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &PriorityLevelConfigurationList| { &m.items },
            |m: &mut PriorityLevelConfigurationList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PriorityLevelConfigurationList>(
            "PriorityLevelConfigurationList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PriorityLevelConfigurationList {
    const NAME: &'static str = "PriorityLevelConfigurationList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PriorityLevelConfigurationList {
        PriorityLevelConfigurationList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PriorityLevelConfigurationList {
        static instance: PriorityLevelConfigurationList = PriorityLevelConfigurationList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PriorityLevelConfigurationList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PriorityLevelConfigurationList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PriorityLevelConfigurationList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PriorityLevelConfigurationList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.flowcontrol.v1beta2.PriorityLevelConfigurationReference)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PriorityLevelConfigurationReference {
    // message fields
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.PriorityLevelConfigurationReference.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.flowcontrol.v1beta2.PriorityLevelConfigurationReference.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PriorityLevelConfigurationReference {
    fn default() -> &'a PriorityLevelConfigurationReference {
        <PriorityLevelConfigurationReference as ::protobuf::Message>::default_instance()
    }
}

impl PriorityLevelConfigurationReference {
    pub fn new() -> PriorityLevelConfigurationReference {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &PriorityLevelConfigurationReference| { &m.name },
            |m: &mut PriorityLevelConfigurationReference| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PriorityLevelConfigurationReference>(
            "PriorityLevelConfigurationReference",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PriorityLevelConfigurationReference {
    const NAME: &'static str = "PriorityLevelConfigurationReference";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PriorityLevelConfigurationReference {
        PriorityLevelConfigurationReference::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PriorityLevelConfigurationReference {
        static instance: PriorityLevelConfigurationReference = PriorityLevelConfigurationReference {
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PriorityLevelConfigurationReference {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PriorityLevelConfigurationReference").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PriorityLevelConfigurationReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PriorityLevelConfigurationReference {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.flowcontrol.v1beta2.PriorityLevelConfigurationSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PriorityLevelConfigurationSpec {
    // message fields
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.PriorityLevelConfigurationSpec.type)
    pub type_: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.PriorityLevelConfigurationSpec.limited)
    pub limited: ::protobuf::MessageField<LimitedPriorityLevelConfiguration>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.PriorityLevelConfigurationSpec.exempt)
    pub exempt: ::protobuf::MessageField<ExemptPriorityLevelConfiguration>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.flowcontrol.v1beta2.PriorityLevelConfigurationSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PriorityLevelConfigurationSpec {
    fn default() -> &'a PriorityLevelConfigurationSpec {
        <PriorityLevelConfigurationSpec as ::protobuf::Message>::default_instance()
    }
}

impl PriorityLevelConfigurationSpec {
    pub fn new() -> PriorityLevelConfigurationSpec {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.flowcontrol.v1beta2.LimitedPriorityLevelConfiguration limited = 2;

    pub fn limited(&self) -> &LimitedPriorityLevelConfiguration {
        self.limited.as_ref().unwrap_or_else(|| <LimitedPriorityLevelConfiguration as ::protobuf::Message>::default_instance())
    }

    pub fn clear_limited(&mut self) {
        self.limited.clear();
    }

    pub fn has_limited(&self) -> bool {
        self.limited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limited(&mut self, v: LimitedPriorityLevelConfiguration) {
        self.limited = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limited(&mut self) -> &mut LimitedPriorityLevelConfiguration {
        self.limited.mut_or_insert_default()
    }

    // Take field
    pub fn take_limited(&mut self) -> LimitedPriorityLevelConfiguration {
        self.limited.take().unwrap_or_else(|| LimitedPriorityLevelConfiguration::new())
    }

    // optional .api.flowcontrol.v1beta2.ExemptPriorityLevelConfiguration exempt = 3;

    pub fn exempt(&self) -> &ExemptPriorityLevelConfiguration {
        self.exempt.as_ref().unwrap_or_else(|| <ExemptPriorityLevelConfiguration as ::protobuf::Message>::default_instance())
    }

    pub fn clear_exempt(&mut self) {
        self.exempt.clear();
    }

    pub fn has_exempt(&self) -> bool {
        self.exempt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exempt(&mut self, v: ExemptPriorityLevelConfiguration) {
        self.exempt = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exempt(&mut self) -> &mut ExemptPriorityLevelConfiguration {
        self.exempt.mut_or_insert_default()
    }

    // Take field
    pub fn take_exempt(&mut self) -> ExemptPriorityLevelConfiguration {
        self.exempt.take().unwrap_or_else(|| ExemptPriorityLevelConfiguration::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &PriorityLevelConfigurationSpec| { &m.type_ },
            |m: &mut PriorityLevelConfigurationSpec| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LimitedPriorityLevelConfiguration>(
            "limited",
            |m: &PriorityLevelConfigurationSpec| { &m.limited },
            |m: &mut PriorityLevelConfigurationSpec| { &mut m.limited },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExemptPriorityLevelConfiguration>(
            "exempt",
            |m: &PriorityLevelConfigurationSpec| { &m.exempt },
            |m: &mut PriorityLevelConfigurationSpec| { &mut m.exempt },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PriorityLevelConfigurationSpec>(
            "PriorityLevelConfigurationSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PriorityLevelConfigurationSpec {
    const NAME: &'static str = "PriorityLevelConfigurationSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.limited)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.exempt)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.limited.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.exempt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.limited.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.exempt.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PriorityLevelConfigurationSpec {
        PriorityLevelConfigurationSpec::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.limited.clear();
        self.exempt.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PriorityLevelConfigurationSpec {
        static instance: PriorityLevelConfigurationSpec = PriorityLevelConfigurationSpec {
            type_: ::std::option::Option::None,
            limited: ::protobuf::MessageField::none(),
            exempt: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PriorityLevelConfigurationSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PriorityLevelConfigurationSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PriorityLevelConfigurationSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PriorityLevelConfigurationSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.flowcontrol.v1beta2.PriorityLevelConfigurationStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PriorityLevelConfigurationStatus {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.PriorityLevelConfigurationStatus.conditions)
    pub conditions: ::std::vec::Vec<PriorityLevelConfigurationCondition>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.flowcontrol.v1beta2.PriorityLevelConfigurationStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PriorityLevelConfigurationStatus {
    fn default() -> &'a PriorityLevelConfigurationStatus {
        <PriorityLevelConfigurationStatus as ::protobuf::Message>::default_instance()
    }
}

impl PriorityLevelConfigurationStatus {
    pub fn new() -> PriorityLevelConfigurationStatus {
        ::std::default::Default::default()
    }

    // repeated .api.flowcontrol.v1beta2.PriorityLevelConfigurationCondition conditions = 1;

    pub fn conditions(&self) -> &[PriorityLevelConfigurationCondition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<PriorityLevelConfigurationCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<PriorityLevelConfigurationCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<PriorityLevelConfigurationCondition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &PriorityLevelConfigurationStatus| { &m.conditions },
            |m: &mut PriorityLevelConfigurationStatus| { &mut m.conditions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PriorityLevelConfigurationStatus>(
            "PriorityLevelConfigurationStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PriorityLevelConfigurationStatus {
    const NAME: &'static str = "PriorityLevelConfigurationStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.conditions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PriorityLevelConfigurationStatus {
        PriorityLevelConfigurationStatus::new()
    }

    fn clear(&mut self) {
        self.conditions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PriorityLevelConfigurationStatus {
        static instance: PriorityLevelConfigurationStatus = PriorityLevelConfigurationStatus {
            conditions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PriorityLevelConfigurationStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PriorityLevelConfigurationStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PriorityLevelConfigurationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PriorityLevelConfigurationStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.flowcontrol.v1beta2.QueuingConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueuingConfiguration {
    // message fields
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.QueuingConfiguration.queues)
    pub queues: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.QueuingConfiguration.handSize)
    pub handSize: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.QueuingConfiguration.queueLengthLimit)
    pub queueLengthLimit: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.flowcontrol.v1beta2.QueuingConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueuingConfiguration {
    fn default() -> &'a QueuingConfiguration {
        <QueuingConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl QueuingConfiguration {
    pub fn new() -> QueuingConfiguration {
        ::std::default::Default::default()
    }

    // optional int32 queues = 1;

    pub fn queues(&self) -> i32 {
        self.queues.unwrap_or(0)
    }

    pub fn clear_queues(&mut self) {
        self.queues = ::std::option::Option::None;
    }

    pub fn has_queues(&self) -> bool {
        self.queues.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queues(&mut self, v: i32) {
        self.queues = ::std::option::Option::Some(v);
    }

    // optional int32 handSize = 2;

    pub fn handSize(&self) -> i32 {
        self.handSize.unwrap_or(0)
    }

    pub fn clear_handSize(&mut self) {
        self.handSize = ::std::option::Option::None;
    }

    pub fn has_handSize(&self) -> bool {
        self.handSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handSize(&mut self, v: i32) {
        self.handSize = ::std::option::Option::Some(v);
    }

    // optional int32 queueLengthLimit = 3;

    pub fn queueLengthLimit(&self) -> i32 {
        self.queueLengthLimit.unwrap_or(0)
    }

    pub fn clear_queueLengthLimit(&mut self) {
        self.queueLengthLimit = ::std::option::Option::None;
    }

    pub fn has_queueLengthLimit(&self) -> bool {
        self.queueLengthLimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queueLengthLimit(&mut self, v: i32) {
        self.queueLengthLimit = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "queues",
            |m: &QueuingConfiguration| { &m.queues },
            |m: &mut QueuingConfiguration| { &mut m.queues },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "handSize",
            |m: &QueuingConfiguration| { &m.handSize },
            |m: &mut QueuingConfiguration| { &mut m.handSize },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "queueLengthLimit",
            |m: &QueuingConfiguration| { &m.queueLengthLimit },
            |m: &mut QueuingConfiguration| { &mut m.queueLengthLimit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueuingConfiguration>(
            "QueuingConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueuingConfiguration {
    const NAME: &'static str = "QueuingConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.queues = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.handSize = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.queueLengthLimit = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.queues {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.handSize {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.queueLengthLimit {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.queues {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.handSize {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.queueLengthLimit {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueuingConfiguration {
        QueuingConfiguration::new()
    }

    fn clear(&mut self) {
        self.queues = ::std::option::Option::None;
        self.handSize = ::std::option::Option::None;
        self.queueLengthLimit = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueuingConfiguration {
        static instance: QueuingConfiguration = QueuingConfiguration {
            queues: ::std::option::Option::None,
            handSize: ::std::option::Option::None,
            queueLengthLimit: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueuingConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueuingConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueuingConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueuingConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.flowcontrol.v1beta2.ResourcePolicyRule)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourcePolicyRule {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.ResourcePolicyRule.verbs)
    pub verbs: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.ResourcePolicyRule.apiGroups)
    pub apiGroups: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.ResourcePolicyRule.resources)
    pub resources: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.ResourcePolicyRule.clusterScope)
    pub clusterScope: ::std::option::Option<bool>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.ResourcePolicyRule.namespaces)
    pub namespaces: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.flowcontrol.v1beta2.ResourcePolicyRule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourcePolicyRule {
    fn default() -> &'a ResourcePolicyRule {
        <ResourcePolicyRule as ::protobuf::Message>::default_instance()
    }
}

impl ResourcePolicyRule {
    pub fn new() -> ResourcePolicyRule {
        ::std::default::Default::default()
    }

    // repeated string verbs = 1;

    pub fn verbs(&self) -> &[::std::string::String] {
        &self.verbs
    }

    pub fn clear_verbs(&mut self) {
        self.verbs.clear();
    }

    // Param is passed by value, moved
    pub fn set_verbs(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.verbs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_verbs(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.verbs
    }

    // Take field
    pub fn take_verbs(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.verbs, ::std::vec::Vec::new())
    }

    // repeated string apiGroups = 2;

    pub fn apiGroups(&self) -> &[::std::string::String] {
        &self.apiGroups
    }

    pub fn clear_apiGroups(&mut self) {
        self.apiGroups.clear();
    }

    // Param is passed by value, moved
    pub fn set_apiGroups(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.apiGroups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apiGroups(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.apiGroups
    }

    // Take field
    pub fn take_apiGroups(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.apiGroups, ::std::vec::Vec::new())
    }

    // repeated string resources = 3;

    pub fn resources(&self) -> &[::std::string::String] {
        &self.resources
    }

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.resources, ::std::vec::Vec::new())
    }

    // optional bool clusterScope = 4;

    pub fn clusterScope(&self) -> bool {
        self.clusterScope.unwrap_or(false)
    }

    pub fn clear_clusterScope(&mut self) {
        self.clusterScope = ::std::option::Option::None;
    }

    pub fn has_clusterScope(&self) -> bool {
        self.clusterScope.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clusterScope(&mut self, v: bool) {
        self.clusterScope = ::std::option::Option::Some(v);
    }

    // repeated string namespaces = 5;

    pub fn namespaces(&self) -> &[::std::string::String] {
        &self.namespaces
    }

    pub fn clear_namespaces(&mut self) {
        self.namespaces.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespaces(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.namespaces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_namespaces(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.namespaces
    }

    // Take field
    pub fn take_namespaces(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.namespaces, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "verbs",
            |m: &ResourcePolicyRule| { &m.verbs },
            |m: &mut ResourcePolicyRule| { &mut m.verbs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apiGroups",
            |m: &ResourcePolicyRule| { &m.apiGroups },
            |m: &mut ResourcePolicyRule| { &mut m.apiGroups },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resources",
            |m: &ResourcePolicyRule| { &m.resources },
            |m: &mut ResourcePolicyRule| { &mut m.resources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clusterScope",
            |m: &ResourcePolicyRule| { &m.clusterScope },
            |m: &mut ResourcePolicyRule| { &mut m.clusterScope },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "namespaces",
            |m: &ResourcePolicyRule| { &m.namespaces },
            |m: &mut ResourcePolicyRule| { &mut m.namespaces },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourcePolicyRule>(
            "ResourcePolicyRule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourcePolicyRule {
    const NAME: &'static str = "ResourcePolicyRule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.verbs.push(is.read_string()?);
                },
                18 => {
                    self.apiGroups.push(is.read_string()?);
                },
                26 => {
                    self.resources.push(is.read_string()?);
                },
                32 => {
                    self.clusterScope = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.namespaces.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.verbs {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.apiGroups {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.resources {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(v) = self.clusterScope {
            my_size += 1 + 1;
        }
        for value in &self.namespaces {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.verbs {
            os.write_string(1, &v)?;
        };
        for v in &self.apiGroups {
            os.write_string(2, &v)?;
        };
        for v in &self.resources {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.clusterScope {
            os.write_bool(4, v)?;
        }
        for v in &self.namespaces {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourcePolicyRule {
        ResourcePolicyRule::new()
    }

    fn clear(&mut self) {
        self.verbs.clear();
        self.apiGroups.clear();
        self.resources.clear();
        self.clusterScope = ::std::option::Option::None;
        self.namespaces.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourcePolicyRule {
        static instance: ResourcePolicyRule = ResourcePolicyRule {
            verbs: ::std::vec::Vec::new(),
            apiGroups: ::std::vec::Vec::new(),
            resources: ::std::vec::Vec::new(),
            clusterScope: ::std::option::Option::None,
            namespaces: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourcePolicyRule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourcePolicyRule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourcePolicyRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourcePolicyRule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.flowcontrol.v1beta2.ServiceAccountSubject)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServiceAccountSubject {
    // message fields
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.ServiceAccountSubject.namespace)
    pub namespace: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.ServiceAccountSubject.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.flowcontrol.v1beta2.ServiceAccountSubject.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceAccountSubject {
    fn default() -> &'a ServiceAccountSubject {
        <ServiceAccountSubject as ::protobuf::Message>::default_instance()
    }
}

impl ServiceAccountSubject {
    pub fn new() -> ServiceAccountSubject {
        ::std::default::Default::default()
    }

    // optional string namespace = 1;

    pub fn namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_namespace(&mut self) {
        self.namespace = ::std::option::Option::None;
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "namespace",
            |m: &ServiceAccountSubject| { &m.namespace },
            |m: &mut ServiceAccountSubject| { &mut m.namespace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ServiceAccountSubject| { &m.name },
            |m: &mut ServiceAccountSubject| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServiceAccountSubject>(
            "ServiceAccountSubject",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServiceAccountSubject {
    const NAME: &'static str = "ServiceAccountSubject";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.namespace = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.namespace.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceAccountSubject {
        ServiceAccountSubject::new()
    }

    fn clear(&mut self) {
        self.namespace = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceAccountSubject {
        static instance: ServiceAccountSubject = ServiceAccountSubject {
            namespace: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServiceAccountSubject {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceAccountSubject").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceAccountSubject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceAccountSubject {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.flowcontrol.v1beta2.Subject)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Subject {
    // message fields
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.Subject.kind)
    pub kind: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.Subject.user)
    pub user: ::protobuf::MessageField<UserSubject>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.Subject.group)
    pub group: ::protobuf::MessageField<GroupSubject>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.Subject.serviceAccount)
    pub serviceAccount: ::protobuf::MessageField<ServiceAccountSubject>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.flowcontrol.v1beta2.Subject.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Subject {
    fn default() -> &'a Subject {
        <Subject as ::protobuf::Message>::default_instance()
    }
}

impl Subject {
    pub fn new() -> Subject {
        ::std::default::Default::default()
    }

    // optional string kind = 1;

    pub fn kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.flowcontrol.v1beta2.UserSubject user = 2;

    pub fn user(&self) -> &UserSubject {
        self.user.as_ref().unwrap_or_else(|| <UserSubject as ::protobuf::Message>::default_instance())
    }

    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: UserSubject) {
        self.user = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut UserSubject {
        self.user.mut_or_insert_default()
    }

    // Take field
    pub fn take_user(&mut self) -> UserSubject {
        self.user.take().unwrap_or_else(|| UserSubject::new())
    }

    // optional .api.flowcontrol.v1beta2.GroupSubject group = 3;

    pub fn group(&self) -> &GroupSubject {
        self.group.as_ref().unwrap_or_else(|| <GroupSubject as ::protobuf::Message>::default_instance())
    }

    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: GroupSubject) {
        self.group = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut GroupSubject {
        self.group.mut_or_insert_default()
    }

    // Take field
    pub fn take_group(&mut self) -> GroupSubject {
        self.group.take().unwrap_or_else(|| GroupSubject::new())
    }

    // optional .api.flowcontrol.v1beta2.ServiceAccountSubject serviceAccount = 4;

    pub fn serviceAccount(&self) -> &ServiceAccountSubject {
        self.serviceAccount.as_ref().unwrap_or_else(|| <ServiceAccountSubject as ::protobuf::Message>::default_instance())
    }

    pub fn clear_serviceAccount(&mut self) {
        self.serviceAccount.clear();
    }

    pub fn has_serviceAccount(&self) -> bool {
        self.serviceAccount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serviceAccount(&mut self, v: ServiceAccountSubject) {
        self.serviceAccount = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serviceAccount(&mut self) -> &mut ServiceAccountSubject {
        self.serviceAccount.mut_or_insert_default()
    }

    // Take field
    pub fn take_serviceAccount(&mut self) -> ServiceAccountSubject {
        self.serviceAccount.take().unwrap_or_else(|| ServiceAccountSubject::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &Subject| { &m.kind },
            |m: &mut Subject| { &mut m.kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UserSubject>(
            "user",
            |m: &Subject| { &m.user },
            |m: &mut Subject| { &mut m.user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GroupSubject>(
            "group",
            |m: &Subject| { &m.group },
            |m: &mut Subject| { &mut m.group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ServiceAccountSubject>(
            "serviceAccount",
            |m: &Subject| { &m.serviceAccount },
            |m: &mut Subject| { &mut m.serviceAccount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Subject>(
            "Subject",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Subject {
    const NAME: &'static str = "Subject";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.kind = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.group)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.serviceAccount)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.group.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.serviceAccount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.kind.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.user.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.group.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.serviceAccount.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Subject {
        Subject::new()
    }

    fn clear(&mut self) {
        self.kind = ::std::option::Option::None;
        self.user.clear();
        self.group.clear();
        self.serviceAccount.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Subject {
        static instance: Subject = Subject {
            kind: ::std::option::Option::None,
            user: ::protobuf::MessageField::none(),
            group: ::protobuf::MessageField::none(),
            serviceAccount: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Subject {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Subject").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Subject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Subject {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.flowcontrol.v1beta2.UserSubject)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserSubject {
    // message fields
    // @@protoc_insertion_point(field:api.flowcontrol.v1beta2.UserSubject.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.flowcontrol.v1beta2.UserSubject.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserSubject {
    fn default() -> &'a UserSubject {
        <UserSubject as ::protobuf::Message>::default_instance()
    }
}

impl UserSubject {
    pub fn new() -> UserSubject {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &UserSubject| { &m.name },
            |m: &mut UserSubject| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserSubject>(
            "UserSubject",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserSubject {
    const NAME: &'static str = "UserSubject";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserSubject {
        UserSubject::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserSubject {
        static instance: UserSubject = UserSubject {
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserSubject {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserSubject").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserSubject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserSubject {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n'api/flowcontrol/v1beta2/generated.proto\x12\x17api.flowcontrol.v1beta\
    2\x1a-apimachinery/pkg/apis/meta/v1/generated.proto\x1a(apimachinery/pkg\
    /runtime/generated.proto\x1a/apimachinery/pkg/runtime/schema/generated.p\
    roto\"\x88\x01\n\x20ExemptPriorityLevelConfiguration\x12:\n\x18nominalCo\
    ncurrencyShares\x18\x01\x20\x01(\x05R\x18nominalConcurrencyShares\x12(\n\
    \x0flendablePercent\x18\x02\x20\x01(\x05R\x0flendablePercent\"-\n\x17Flo\
    wDistinguisherMethod\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\"\xd3\
    \x01\n\nFlowSchema\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachiner\
    y.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12;\n\x04spec\x18\x02\x20\
    \x01(\x0b2'.api.flowcontrol.v1beta2.FlowSchemaSpecR\x04spec\x12A\n\x06st\
    atus\x18\x03\x20\x01(\x0b2).api.flowcontrol.v1beta2.FlowSchemaStatusR\
    \x06status\"\xc8\x01\n\x13FlowSchemaCondition\x12\x12\n\x04type\x18\x01\
    \x20\x01(\tR\x04type\x12\x16\n\x06status\x18\x02\x20\x01(\tR\x06status\
    \x12S\n\x12lastTransitionTime\x18\x03\x20\x01(\x0b2#.apimachinery.pkg.ap\
    is.meta.v1.TimeR\x12lastTransitionTime\x12\x16\n\x06reason\x18\x04\x20\
    \x01(\tR\x06reason\x12\x18\n\x07message\x18\x05\x20\x01(\tR\x07message\"\
    \x90\x01\n\x0eFlowSchemaList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.a\
    pimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x129\n\x05items\x18\
    \x02\x20\x03(\x0b2#.api.flowcontrol.v1beta2.FlowSchemaR\x05items\"\xea\
    \x02\n\x0eFlowSchemaSpec\x12|\n\x1apriorityLevelConfiguration\x18\x01\
    \x20\x01(\x0b2<.api.flowcontrol.v1beta2.PriorityLevelConfigurationRefere\
    nceR\x1apriorityLevelConfiguration\x12.\n\x12matchingPrecedence\x18\x02\
    \x20\x01(\x05R\x12matchingPrecedence\x12b\n\x13distinguisherMethod\x18\
    \x03\x20\x01(\x0b20.api.flowcontrol.v1beta2.FlowDistinguisherMethodR\x13\
    distinguisherMethod\x12F\n\x05rules\x18\x04\x20\x03(\x0b20.api.flowcontr\
    ol.v1beta2.PolicyRulesWithSubjectsR\x05rules\"`\n\x10FlowSchemaStatus\
    \x12L\n\nconditions\x18\x01\x20\x03(\x0b2,.api.flowcontrol.v1beta2.FlowS\
    chemaConditionR\nconditions\"\"\n\x0cGroupSubject\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\"l\n\rLimitResponse\x12\x12\n\x04type\x18\x01\
    \x20\x01(\tR\x04type\x12G\n\x07queuing\x18\x02\x20\x01(\x0b2-.api.flowco\
    ntrol.v1beta2.QueuingConfigurationR\x07queuing\"\x8d\x02\n!LimitedPriori\
    tyLevelConfiguration\x12:\n\x18assuredConcurrencyShares\x18\x01\x20\x01(\
    \x05R\x18assuredConcurrencyShares\x12L\n\rlimitResponse\x18\x02\x20\x01(\
    \x0b2&.api.flowcontrol.v1beta2.LimitResponseR\rlimitResponse\x12(\n\x0fl\
    endablePercent\x18\x03\x20\x01(\x05R\x0flendablePercent\x124\n\x15borrow\
    ingLimitPercent\x18\x04\x20\x01(\x05R\x15borrowingLimitPercent\"W\n\x15N\
    onResourcePolicyRule\x12\x14\n\x05verbs\x18\x01\x20\x03(\tR\x05verbs\x12\
    (\n\x0fnonResourceURLs\x18\x06\x20\x03(\tR\x0fnonResourceURLs\"\x86\x02\
    \n\x17PolicyRulesWithSubjects\x12<\n\x08subjects\x18\x01\x20\x03(\x0b2\
    \x20.api.flowcontrol.v1beta2.SubjectR\x08subjects\x12Q\n\rresourceRules\
    \x18\x02\x20\x03(\x0b2+.api.flowcontrol.v1beta2.ResourcePolicyRuleR\rres\
    ourceRules\x12Z\n\x10nonResourceRules\x18\x03\x20\x03(\x0b2..api.flowcon\
    trol.v1beta2.NonResourcePolicyRuleR\x10nonResourceRules\"\x83\x02\n\x1aP\
    riorityLevelConfiguration\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apim\
    achinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12K\n\x04spec\x18\x02\
    \x20\x01(\x0b27.api.flowcontrol.v1beta2.PriorityLevelConfigurationSpecR\
    \x04spec\x12Q\n\x06status\x18\x03\x20\x01(\x0b29.api.flowcontrol.v1beta2\
    .PriorityLevelConfigurationStatusR\x06status\"\xd8\x01\n#PriorityLevelCo\
    nfigurationCondition\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12\
    \x16\n\x06status\x18\x02\x20\x01(\tR\x06status\x12S\n\x12lastTransitionT\
    ime\x18\x03\x20\x01(\x0b2#.apimachinery.pkg.apis.meta.v1.TimeR\x12lastTr\
    ansitionTime\x12\x16\n\x06reason\x18\x04\x20\x01(\tR\x06reason\x12\x18\n\
    \x07message\x18\x05\x20\x01(\tR\x07message\"\xb0\x01\n\x1ePriorityLevelC\
    onfigurationList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.\
    pkg.apis.meta.v1.ListMetaR\x08metadata\x12I\n\x05items\x18\x02\x20\x03(\
    \x0b23.api.flowcontrol.v1beta2.PriorityLevelConfigurationR\x05items\"9\n\
    #PriorityLevelConfigurationReference\x12\x12\n\x04name\x18\x01\x20\x01(\
    \tR\x04name\"\xdd\x01\n\x1ePriorityLevelConfigurationSpec\x12\x12\n\x04t\
    ype\x18\x01\x20\x01(\tR\x04type\x12T\n\x07limited\x18\x02\x20\x01(\x0b2:\
    .api.flowcontrol.v1beta2.LimitedPriorityLevelConfigurationR\x07limited\
    \x12Q\n\x06exempt\x18\x03\x20\x01(\x0b29.api.flowcontrol.v1beta2.ExemptP\
    riorityLevelConfigurationR\x06exempt\"\x80\x01\n\x20PriorityLevelConfigu\
    rationStatus\x12\\\n\nconditions\x18\x01\x20\x03(\x0b2<.api.flowcontrol.\
    v1beta2.PriorityLevelConfigurationConditionR\nconditions\"v\n\x14Queuing\
    Configuration\x12\x16\n\x06queues\x18\x01\x20\x01(\x05R\x06queues\x12\
    \x1a\n\x08handSize\x18\x02\x20\x01(\x05R\x08handSize\x12*\n\x10queueLeng\
    thLimit\x18\x03\x20\x01(\x05R\x10queueLengthLimit\"\xaa\x01\n\x12Resourc\
    ePolicyRule\x12\x14\n\x05verbs\x18\x01\x20\x03(\tR\x05verbs\x12\x1c\n\ta\
    piGroups\x18\x02\x20\x03(\tR\tapiGroups\x12\x1c\n\tresources\x18\x03\x20\
    \x03(\tR\tresources\x12\"\n\x0cclusterScope\x18\x04\x20\x01(\x08R\x0cclu\
    sterScope\x12\x1e\n\nnamespaces\x18\x05\x20\x03(\tR\nnamespaces\"I\n\x15\
    ServiceAccountSubject\x12\x1c\n\tnamespace\x18\x01\x20\x01(\tR\tnamespac\
    e\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"\xec\x01\n\x07Subject\
    \x12\x12\n\x04kind\x18\x01\x20\x01(\tR\x04kind\x128\n\x04user\x18\x02\
    \x20\x01(\x0b2$.api.flowcontrol.v1beta2.UserSubjectR\x04user\x12;\n\x05g\
    roup\x18\x03\x20\x01(\x0b2%.api.flowcontrol.v1beta2.GroupSubjectR\x05gro\
    up\x12V\n\x0eserviceAccount\x18\x04\x20\x01(\x0b2..api.flowcontrol.v1bet\
    a2.ServiceAccountSubjectR\x0eserviceAccount\"!\n\x0bUserSubject\x12\x12\
    \n\x04name\x18\x01\x20\x01(\tR\x04nameB\x20Z\x1ek8s.io/api/flowcontrol/v\
    1beta2\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::v1beta2::file_descriptor().clone());
            deps.push(super::v1beta2::file_descriptor().clone());
            deps.push(super::v1beta2::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(23);
            messages.push(ExemptPriorityLevelConfiguration::generated_message_descriptor_data());
            messages.push(FlowDistinguisherMethod::generated_message_descriptor_data());
            messages.push(FlowSchema::generated_message_descriptor_data());
            messages.push(FlowSchemaCondition::generated_message_descriptor_data());
            messages.push(FlowSchemaList::generated_message_descriptor_data());
            messages.push(FlowSchemaSpec::generated_message_descriptor_data());
            messages.push(FlowSchemaStatus::generated_message_descriptor_data());
            messages.push(GroupSubject::generated_message_descriptor_data());
            messages.push(LimitResponse::generated_message_descriptor_data());
            messages.push(LimitedPriorityLevelConfiguration::generated_message_descriptor_data());
            messages.push(NonResourcePolicyRule::generated_message_descriptor_data());
            messages.push(PolicyRulesWithSubjects::generated_message_descriptor_data());
            messages.push(PriorityLevelConfiguration::generated_message_descriptor_data());
            messages.push(PriorityLevelConfigurationCondition::generated_message_descriptor_data());
            messages.push(PriorityLevelConfigurationList::generated_message_descriptor_data());
            messages.push(PriorityLevelConfigurationReference::generated_message_descriptor_data());
            messages.push(PriorityLevelConfigurationSpec::generated_message_descriptor_data());
            messages.push(PriorityLevelConfigurationStatus::generated_message_descriptor_data());
            messages.push(QueuingConfiguration::generated_message_descriptor_data());
            messages.push(ResourcePolicyRule::generated_message_descriptor_data());
            messages.push(ServiceAccountSubject::generated_message_descriptor_data());
            messages.push(Subject::generated_message_descriptor_data());
            messages.push(UserSubject::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
