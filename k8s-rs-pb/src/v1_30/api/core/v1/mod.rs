// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc 30.2
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `api/core/v1/generated.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.AWSElasticBlockStoreVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AWSElasticBlockStoreVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.AWSElasticBlockStoreVolumeSource.volumeID)
    pub volumeID: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.AWSElasticBlockStoreVolumeSource.fsType)
    pub fsType: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.AWSElasticBlockStoreVolumeSource.partition)
    pub partition: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.AWSElasticBlockStoreVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.AWSElasticBlockStoreVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AWSElasticBlockStoreVolumeSource {
    fn default() -> &'a AWSElasticBlockStoreVolumeSource {
        <AWSElasticBlockStoreVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl AWSElasticBlockStoreVolumeSource {
    pub fn new() -> AWSElasticBlockStoreVolumeSource {
        ::std::default::Default::default()
    }

    // optional string volumeID = 1;

    pub fn volumeID(&self) -> &str {
        match self.volumeID.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_volumeID(&mut self) {
        self.volumeID = ::std::option::Option::None;
    }

    pub fn has_volumeID(&self) -> bool {
        self.volumeID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeID(&mut self, v: ::std::string::String) {
        self.volumeID = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeID(&mut self) -> &mut ::std::string::String {
        if self.volumeID.is_none() {
            self.volumeID = ::std::option::Option::Some(::std::string::String::new());
        }
        self.volumeID.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeID(&mut self) -> ::std::string::String {
        self.volumeID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 2;

    pub fn fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fsType(&mut self) {
        self.fsType = ::std::option::Option::None;
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 partition = 3;

    pub fn partition(&self) -> i32 {
        self.partition.unwrap_or(0)
    }

    pub fn clear_partition(&mut self) {
        self.partition = ::std::option::Option::None;
    }

    pub fn has_partition(&self) -> bool {
        self.partition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partition(&mut self, v: i32) {
        self.partition = ::std::option::Option::Some(v);
    }

    // optional bool readOnly = 4;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volumeID",
            |m: &AWSElasticBlockStoreVolumeSource| { &m.volumeID },
            |m: &mut AWSElasticBlockStoreVolumeSource| { &mut m.volumeID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsType",
            |m: &AWSElasticBlockStoreVolumeSource| { &m.fsType },
            |m: &mut AWSElasticBlockStoreVolumeSource| { &mut m.fsType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "partition",
            |m: &AWSElasticBlockStoreVolumeSource| { &m.partition },
            |m: &mut AWSElasticBlockStoreVolumeSource| { &mut m.partition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &AWSElasticBlockStoreVolumeSource| { &m.readOnly },
            |m: &mut AWSElasticBlockStoreVolumeSource| { &mut m.readOnly },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AWSElasticBlockStoreVolumeSource>(
            "AWSElasticBlockStoreVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AWSElasticBlockStoreVolumeSource {
    const NAME: &'static str = "AWSElasticBlockStoreVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.volumeID = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.fsType = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.partition = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.volumeID.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.partition {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.volumeID.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.fsType.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.partition {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AWSElasticBlockStoreVolumeSource {
        AWSElasticBlockStoreVolumeSource::new()
    }

    fn clear(&mut self) {
        self.volumeID = ::std::option::Option::None;
        self.fsType = ::std::option::Option::None;
        self.partition = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AWSElasticBlockStoreVolumeSource {
        static instance: AWSElasticBlockStoreVolumeSource = AWSElasticBlockStoreVolumeSource {
            volumeID: ::std::option::Option::None,
            fsType: ::std::option::Option::None,
            partition: ::std::option::Option::None,
            readOnly: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AWSElasticBlockStoreVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AWSElasticBlockStoreVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AWSElasticBlockStoreVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AWSElasticBlockStoreVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.Affinity)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Affinity {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Affinity.nodeAffinity)
    pub nodeAffinity: ::protobuf::MessageField<NodeAffinity>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Affinity.podAffinity)
    pub podAffinity: ::protobuf::MessageField<PodAffinity>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Affinity.podAntiAffinity)
    pub podAntiAffinity: ::protobuf::MessageField<PodAntiAffinity>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.Affinity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Affinity {
    fn default() -> &'a Affinity {
        <Affinity as ::protobuf::Message>::default_instance()
    }
}

impl Affinity {
    pub fn new() -> Affinity {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.NodeAffinity nodeAffinity = 1;

    pub fn nodeAffinity(&self) -> &NodeAffinity {
        self.nodeAffinity.as_ref().unwrap_or_else(|| <NodeAffinity as ::protobuf::Message>::default_instance())
    }

    pub fn clear_nodeAffinity(&mut self) {
        self.nodeAffinity.clear();
    }

    pub fn has_nodeAffinity(&self) -> bool {
        self.nodeAffinity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeAffinity(&mut self, v: NodeAffinity) {
        self.nodeAffinity = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeAffinity(&mut self) -> &mut NodeAffinity {
        self.nodeAffinity.mut_or_insert_default()
    }

    // Take field
    pub fn take_nodeAffinity(&mut self) -> NodeAffinity {
        self.nodeAffinity.take().unwrap_or_else(|| NodeAffinity::new())
    }

    // optional .api.core.v1.PodAffinity podAffinity = 2;

    pub fn podAffinity(&self) -> &PodAffinity {
        self.podAffinity.as_ref().unwrap_or_else(|| <PodAffinity as ::protobuf::Message>::default_instance())
    }

    pub fn clear_podAffinity(&mut self) {
        self.podAffinity.clear();
    }

    pub fn has_podAffinity(&self) -> bool {
        self.podAffinity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podAffinity(&mut self, v: PodAffinity) {
        self.podAffinity = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podAffinity(&mut self) -> &mut PodAffinity {
        self.podAffinity.mut_or_insert_default()
    }

    // Take field
    pub fn take_podAffinity(&mut self) -> PodAffinity {
        self.podAffinity.take().unwrap_or_else(|| PodAffinity::new())
    }

    // optional .api.core.v1.PodAntiAffinity podAntiAffinity = 3;

    pub fn podAntiAffinity(&self) -> &PodAntiAffinity {
        self.podAntiAffinity.as_ref().unwrap_or_else(|| <PodAntiAffinity as ::protobuf::Message>::default_instance())
    }

    pub fn clear_podAntiAffinity(&mut self) {
        self.podAntiAffinity.clear();
    }

    pub fn has_podAntiAffinity(&self) -> bool {
        self.podAntiAffinity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podAntiAffinity(&mut self, v: PodAntiAffinity) {
        self.podAntiAffinity = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podAntiAffinity(&mut self) -> &mut PodAntiAffinity {
        self.podAntiAffinity.mut_or_insert_default()
    }

    // Take field
    pub fn take_podAntiAffinity(&mut self) -> PodAntiAffinity {
        self.podAntiAffinity.take().unwrap_or_else(|| PodAntiAffinity::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodeAffinity>(
            "nodeAffinity",
            |m: &Affinity| { &m.nodeAffinity },
            |m: &mut Affinity| { &mut m.nodeAffinity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PodAffinity>(
            "podAffinity",
            |m: &Affinity| { &m.podAffinity },
            |m: &mut Affinity| { &mut m.podAffinity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PodAntiAffinity>(
            "podAntiAffinity",
            |m: &Affinity| { &m.podAntiAffinity },
            |m: &mut Affinity| { &mut m.podAntiAffinity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Affinity>(
            "Affinity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Affinity {
    const NAME: &'static str = "Affinity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.nodeAffinity)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.podAffinity)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.podAntiAffinity)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.nodeAffinity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.podAffinity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.podAntiAffinity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.nodeAffinity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.podAffinity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.podAntiAffinity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Affinity {
        Affinity::new()
    }

    fn clear(&mut self) {
        self.nodeAffinity.clear();
        self.podAffinity.clear();
        self.podAntiAffinity.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Affinity {
        static instance: Affinity = Affinity {
            nodeAffinity: ::protobuf::MessageField::none(),
            podAffinity: ::protobuf::MessageField::none(),
            podAntiAffinity: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Affinity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Affinity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Affinity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Affinity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.AppArmorProfile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AppArmorProfile {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.AppArmorProfile.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.AppArmorProfile.localhostProfile)
    pub localhostProfile: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.AppArmorProfile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppArmorProfile {
    fn default() -> &'a AppArmorProfile {
        <AppArmorProfile as ::protobuf::Message>::default_instance()
    }
}

impl AppArmorProfile {
    pub fn new() -> AppArmorProfile {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string localhostProfile = 2;

    pub fn localhostProfile(&self) -> &str {
        match self.localhostProfile.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_localhostProfile(&mut self) {
        self.localhostProfile = ::std::option::Option::None;
    }

    pub fn has_localhostProfile(&self) -> bool {
        self.localhostProfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localhostProfile(&mut self, v: ::std::string::String) {
        self.localhostProfile = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localhostProfile(&mut self) -> &mut ::std::string::String {
        if self.localhostProfile.is_none() {
            self.localhostProfile = ::std::option::Option::Some(::std::string::String::new());
        }
        self.localhostProfile.as_mut().unwrap()
    }

    // Take field
    pub fn take_localhostProfile(&mut self) -> ::std::string::String {
        self.localhostProfile.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &AppArmorProfile| { &m.type_ },
            |m: &mut AppArmorProfile| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "localhostProfile",
            |m: &AppArmorProfile| { &m.localhostProfile },
            |m: &mut AppArmorProfile| { &mut m.localhostProfile },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppArmorProfile>(
            "AppArmorProfile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppArmorProfile {
    const NAME: &'static str = "AppArmorProfile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.localhostProfile = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.localhostProfile.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.localhostProfile.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppArmorProfile {
        AppArmorProfile::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.localhostProfile = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppArmorProfile {
        static instance: AppArmorProfile = AppArmorProfile {
            type_: ::std::option::Option::None,
            localhostProfile: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppArmorProfile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppArmorProfile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppArmorProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppArmorProfile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.AttachedVolume)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AttachedVolume {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.AttachedVolume.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.AttachedVolume.devicePath)
    pub devicePath: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.AttachedVolume.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AttachedVolume {
    fn default() -> &'a AttachedVolume {
        <AttachedVolume as ::protobuf::Message>::default_instance()
    }
}

impl AttachedVolume {
    pub fn new() -> AttachedVolume {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string devicePath = 2;

    pub fn devicePath(&self) -> &str {
        match self.devicePath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_devicePath(&mut self) {
        self.devicePath = ::std::option::Option::None;
    }

    pub fn has_devicePath(&self) -> bool {
        self.devicePath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_devicePath(&mut self, v: ::std::string::String) {
        self.devicePath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_devicePath(&mut self) -> &mut ::std::string::String {
        if self.devicePath.is_none() {
            self.devicePath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.devicePath.as_mut().unwrap()
    }

    // Take field
    pub fn take_devicePath(&mut self) -> ::std::string::String {
        self.devicePath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &AttachedVolume| { &m.name },
            |m: &mut AttachedVolume| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "devicePath",
            |m: &AttachedVolume| { &m.devicePath },
            |m: &mut AttachedVolume| { &mut m.devicePath },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AttachedVolume>(
            "AttachedVolume",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AttachedVolume {
    const NAME: &'static str = "AttachedVolume";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.devicePath = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.devicePath.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.devicePath.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AttachedVolume {
        AttachedVolume::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.devicePath = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AttachedVolume {
        static instance: AttachedVolume = AttachedVolume {
            name: ::std::option::Option::None,
            devicePath: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AttachedVolume {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AttachedVolume").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AttachedVolume {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttachedVolume {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.AvoidPods)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AvoidPods {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.AvoidPods.preferAvoidPods)
    pub preferAvoidPods: ::std::vec::Vec<PreferAvoidPodsEntry>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.AvoidPods.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AvoidPods {
    fn default() -> &'a AvoidPods {
        <AvoidPods as ::protobuf::Message>::default_instance()
    }
}

impl AvoidPods {
    pub fn new() -> AvoidPods {
        ::std::default::Default::default()
    }

    // repeated .api.core.v1.PreferAvoidPodsEntry preferAvoidPods = 1;

    pub fn preferAvoidPods(&self) -> &[PreferAvoidPodsEntry] {
        &self.preferAvoidPods
    }

    pub fn clear_preferAvoidPods(&mut self) {
        self.preferAvoidPods.clear();
    }

    // Param is passed by value, moved
    pub fn set_preferAvoidPods(&mut self, v: ::std::vec::Vec<PreferAvoidPodsEntry>) {
        self.preferAvoidPods = v;
    }

    // Mutable pointer to the field.
    pub fn mut_preferAvoidPods(&mut self) -> &mut ::std::vec::Vec<PreferAvoidPodsEntry> {
        &mut self.preferAvoidPods
    }

    // Take field
    pub fn take_preferAvoidPods(&mut self) -> ::std::vec::Vec<PreferAvoidPodsEntry> {
        ::std::mem::replace(&mut self.preferAvoidPods, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "preferAvoidPods",
            |m: &AvoidPods| { &m.preferAvoidPods },
            |m: &mut AvoidPods| { &mut m.preferAvoidPods },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AvoidPods>(
            "AvoidPods",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AvoidPods {
    const NAME: &'static str = "AvoidPods";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.preferAvoidPods.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.preferAvoidPods {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.preferAvoidPods {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AvoidPods {
        AvoidPods::new()
    }

    fn clear(&mut self) {
        self.preferAvoidPods.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AvoidPods {
        static instance: AvoidPods = AvoidPods {
            preferAvoidPods: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AvoidPods {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AvoidPods").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AvoidPods {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AvoidPods {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.AzureDiskVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AzureDiskVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.AzureDiskVolumeSource.diskName)
    pub diskName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.AzureDiskVolumeSource.diskURI)
    pub diskURI: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.AzureDiskVolumeSource.cachingMode)
    pub cachingMode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.AzureDiskVolumeSource.fsType)
    pub fsType: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.AzureDiskVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.AzureDiskVolumeSource.kind)
    pub kind: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.AzureDiskVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AzureDiskVolumeSource {
    fn default() -> &'a AzureDiskVolumeSource {
        <AzureDiskVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl AzureDiskVolumeSource {
    pub fn new() -> AzureDiskVolumeSource {
        ::std::default::Default::default()
    }

    // optional string diskName = 1;

    pub fn diskName(&self) -> &str {
        match self.diskName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_diskName(&mut self) {
        self.diskName = ::std::option::Option::None;
    }

    pub fn has_diskName(&self) -> bool {
        self.diskName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diskName(&mut self, v: ::std::string::String) {
        self.diskName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_diskName(&mut self) -> &mut ::std::string::String {
        if self.diskName.is_none() {
            self.diskName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.diskName.as_mut().unwrap()
    }

    // Take field
    pub fn take_diskName(&mut self) -> ::std::string::String {
        self.diskName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string diskURI = 2;

    pub fn diskURI(&self) -> &str {
        match self.diskURI.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_diskURI(&mut self) {
        self.diskURI = ::std::option::Option::None;
    }

    pub fn has_diskURI(&self) -> bool {
        self.diskURI.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diskURI(&mut self, v: ::std::string::String) {
        self.diskURI = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_diskURI(&mut self) -> &mut ::std::string::String {
        if self.diskURI.is_none() {
            self.diskURI = ::std::option::Option::Some(::std::string::String::new());
        }
        self.diskURI.as_mut().unwrap()
    }

    // Take field
    pub fn take_diskURI(&mut self) -> ::std::string::String {
        self.diskURI.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string cachingMode = 3;

    pub fn cachingMode(&self) -> &str {
        match self.cachingMode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cachingMode(&mut self) {
        self.cachingMode = ::std::option::Option::None;
    }

    pub fn has_cachingMode(&self) -> bool {
        self.cachingMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cachingMode(&mut self, v: ::std::string::String) {
        self.cachingMode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cachingMode(&mut self) -> &mut ::std::string::String {
        if self.cachingMode.is_none() {
            self.cachingMode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.cachingMode.as_mut().unwrap()
    }

    // Take field
    pub fn take_cachingMode(&mut self) -> ::std::string::String {
        self.cachingMode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 4;

    pub fn fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fsType(&mut self) {
        self.fsType = ::std::option::Option::None;
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 5;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // optional string kind = 6;

    pub fn kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "diskName",
            |m: &AzureDiskVolumeSource| { &m.diskName },
            |m: &mut AzureDiskVolumeSource| { &mut m.diskName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "diskURI",
            |m: &AzureDiskVolumeSource| { &m.diskURI },
            |m: &mut AzureDiskVolumeSource| { &mut m.diskURI },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cachingMode",
            |m: &AzureDiskVolumeSource| { &m.cachingMode },
            |m: &mut AzureDiskVolumeSource| { &mut m.cachingMode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsType",
            |m: &AzureDiskVolumeSource| { &m.fsType },
            |m: &mut AzureDiskVolumeSource| { &mut m.fsType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &AzureDiskVolumeSource| { &m.readOnly },
            |m: &mut AzureDiskVolumeSource| { &mut m.readOnly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &AzureDiskVolumeSource| { &m.kind },
            |m: &mut AzureDiskVolumeSource| { &mut m.kind },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AzureDiskVolumeSource>(
            "AzureDiskVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AzureDiskVolumeSource {
    const NAME: &'static str = "AzureDiskVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.diskName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.diskURI = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.cachingMode = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.fsType = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                50 => {
                    self.kind = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.diskName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.diskURI.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.cachingMode.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        if let Some(v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.diskName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.diskURI.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.cachingMode.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.fsType.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.kind.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AzureDiskVolumeSource {
        AzureDiskVolumeSource::new()
    }

    fn clear(&mut self) {
        self.diskName = ::std::option::Option::None;
        self.diskURI = ::std::option::Option::None;
        self.cachingMode = ::std::option::Option::None;
        self.fsType = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AzureDiskVolumeSource {
        static instance: AzureDiskVolumeSource = AzureDiskVolumeSource {
            diskName: ::std::option::Option::None,
            diskURI: ::std::option::Option::None,
            cachingMode: ::std::option::Option::None,
            fsType: ::std::option::Option::None,
            readOnly: ::std::option::Option::None,
            kind: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AzureDiskVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AzureDiskVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AzureDiskVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AzureDiskVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.AzureFilePersistentVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AzureFilePersistentVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.AzureFilePersistentVolumeSource.secretName)
    pub secretName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.AzureFilePersistentVolumeSource.shareName)
    pub shareName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.AzureFilePersistentVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.AzureFilePersistentVolumeSource.secretNamespace)
    pub secretNamespace: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.AzureFilePersistentVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AzureFilePersistentVolumeSource {
    fn default() -> &'a AzureFilePersistentVolumeSource {
        <AzureFilePersistentVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl AzureFilePersistentVolumeSource {
    pub fn new() -> AzureFilePersistentVolumeSource {
        ::std::default::Default::default()
    }

    // optional string secretName = 1;

    pub fn secretName(&self) -> &str {
        match self.secretName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_secretName(&mut self) {
        self.secretName = ::std::option::Option::None;
    }

    pub fn has_secretName(&self) -> bool {
        self.secretName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretName(&mut self, v: ::std::string::String) {
        self.secretName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretName(&mut self) -> &mut ::std::string::String {
        if self.secretName.is_none() {
            self.secretName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.secretName.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretName(&mut self) -> ::std::string::String {
        self.secretName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string shareName = 2;

    pub fn shareName(&self) -> &str {
        match self.shareName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_shareName(&mut self) {
        self.shareName = ::std::option::Option::None;
    }

    pub fn has_shareName(&self) -> bool {
        self.shareName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shareName(&mut self, v: ::std::string::String) {
        self.shareName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shareName(&mut self) -> &mut ::std::string::String {
        if self.shareName.is_none() {
            self.shareName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.shareName.as_mut().unwrap()
    }

    // Take field
    pub fn take_shareName(&mut self) -> ::std::string::String {
        self.shareName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 3;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // optional string secretNamespace = 4;

    pub fn secretNamespace(&self) -> &str {
        match self.secretNamespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_secretNamespace(&mut self) {
        self.secretNamespace = ::std::option::Option::None;
    }

    pub fn has_secretNamespace(&self) -> bool {
        self.secretNamespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretNamespace(&mut self, v: ::std::string::String) {
        self.secretNamespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretNamespace(&mut self) -> &mut ::std::string::String {
        if self.secretNamespace.is_none() {
            self.secretNamespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.secretNamespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretNamespace(&mut self) -> ::std::string::String {
        self.secretNamespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "secretName",
            |m: &AzureFilePersistentVolumeSource| { &m.secretName },
            |m: &mut AzureFilePersistentVolumeSource| { &mut m.secretName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shareName",
            |m: &AzureFilePersistentVolumeSource| { &m.shareName },
            |m: &mut AzureFilePersistentVolumeSource| { &mut m.shareName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &AzureFilePersistentVolumeSource| { &m.readOnly },
            |m: &mut AzureFilePersistentVolumeSource| { &mut m.readOnly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "secretNamespace",
            |m: &AzureFilePersistentVolumeSource| { &m.secretNamespace },
            |m: &mut AzureFilePersistentVolumeSource| { &mut m.secretNamespace },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AzureFilePersistentVolumeSource>(
            "AzureFilePersistentVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AzureFilePersistentVolumeSource {
    const NAME: &'static str = "AzureFilePersistentVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.secretName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.shareName = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.secretNamespace = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.secretName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.shareName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        if let Some(v) = self.secretNamespace.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.secretName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.shareName.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.secretNamespace.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AzureFilePersistentVolumeSource {
        AzureFilePersistentVolumeSource::new()
    }

    fn clear(&mut self) {
        self.secretName = ::std::option::Option::None;
        self.shareName = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.secretNamespace = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AzureFilePersistentVolumeSource {
        static instance: AzureFilePersistentVolumeSource = AzureFilePersistentVolumeSource {
            secretName: ::std::option::Option::None,
            shareName: ::std::option::Option::None,
            readOnly: ::std::option::Option::None,
            secretNamespace: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AzureFilePersistentVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AzureFilePersistentVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AzureFilePersistentVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AzureFilePersistentVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.AzureFileVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AzureFileVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.AzureFileVolumeSource.secretName)
    pub secretName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.AzureFileVolumeSource.shareName)
    pub shareName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.AzureFileVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.AzureFileVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AzureFileVolumeSource {
    fn default() -> &'a AzureFileVolumeSource {
        <AzureFileVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl AzureFileVolumeSource {
    pub fn new() -> AzureFileVolumeSource {
        ::std::default::Default::default()
    }

    // optional string secretName = 1;

    pub fn secretName(&self) -> &str {
        match self.secretName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_secretName(&mut self) {
        self.secretName = ::std::option::Option::None;
    }

    pub fn has_secretName(&self) -> bool {
        self.secretName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretName(&mut self, v: ::std::string::String) {
        self.secretName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretName(&mut self) -> &mut ::std::string::String {
        if self.secretName.is_none() {
            self.secretName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.secretName.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretName(&mut self) -> ::std::string::String {
        self.secretName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string shareName = 2;

    pub fn shareName(&self) -> &str {
        match self.shareName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_shareName(&mut self) {
        self.shareName = ::std::option::Option::None;
    }

    pub fn has_shareName(&self) -> bool {
        self.shareName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shareName(&mut self, v: ::std::string::String) {
        self.shareName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shareName(&mut self) -> &mut ::std::string::String {
        if self.shareName.is_none() {
            self.shareName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.shareName.as_mut().unwrap()
    }

    // Take field
    pub fn take_shareName(&mut self) -> ::std::string::String {
        self.shareName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 3;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "secretName",
            |m: &AzureFileVolumeSource| { &m.secretName },
            |m: &mut AzureFileVolumeSource| { &mut m.secretName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shareName",
            |m: &AzureFileVolumeSource| { &m.shareName },
            |m: &mut AzureFileVolumeSource| { &mut m.shareName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &AzureFileVolumeSource| { &m.readOnly },
            |m: &mut AzureFileVolumeSource| { &mut m.readOnly },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AzureFileVolumeSource>(
            "AzureFileVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AzureFileVolumeSource {
    const NAME: &'static str = "AzureFileVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.secretName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.shareName = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.secretName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.shareName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.secretName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.shareName.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AzureFileVolumeSource {
        AzureFileVolumeSource::new()
    }

    fn clear(&mut self) {
        self.secretName = ::std::option::Option::None;
        self.shareName = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AzureFileVolumeSource {
        static instance: AzureFileVolumeSource = AzureFileVolumeSource {
            secretName: ::std::option::Option::None,
            shareName: ::std::option::Option::None,
            readOnly: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AzureFileVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AzureFileVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AzureFileVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AzureFileVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.Binding)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Binding {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Binding.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Binding.target)
    pub target: ::protobuf::MessageField<ObjectReference>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.Binding.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Binding {
    fn default() -> &'a Binding {
        <Binding as ::protobuf::Message>::default_instance()
    }
}

impl Binding {
    pub fn new() -> Binding {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.core.v1.ObjectReference target = 2;

    pub fn target(&self) -> &ObjectReference {
        self.target.as_ref().unwrap_or_else(|| <ObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_target(&mut self) {
        self.target.clear();
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: ObjectReference) {
        self.target = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut ObjectReference {
        self.target.mut_or_insert_default()
    }

    // Take field
    pub fn take_target(&mut self) -> ObjectReference {
        self.target.take().unwrap_or_else(|| ObjectReference::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &Binding| { &m.metadata },
            |m: &mut Binding| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ObjectReference>(
            "target",
            |m: &Binding| { &m.target },
            |m: &mut Binding| { &mut m.target },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Binding>(
            "Binding",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Binding {
    const NAME: &'static str = "Binding";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.target)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.target.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.target.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Binding {
        Binding::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.target.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Binding {
        static instance: Binding = Binding {
            metadata: ::protobuf::MessageField::none(),
            target: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Binding {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Binding").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Binding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Binding {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.CSIPersistentVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSIPersistentVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.CSIPersistentVolumeSource.driver)
    pub driver: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.CSIPersistentVolumeSource.volumeHandle)
    pub volumeHandle: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.CSIPersistentVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.CSIPersistentVolumeSource.fsType)
    pub fsType: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.CSIPersistentVolumeSource.volumeAttributes)
    pub volumeAttributes: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.CSIPersistentVolumeSource.controllerPublishSecretRef)
    pub controllerPublishSecretRef: ::protobuf::MessageField<SecretReference>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.CSIPersistentVolumeSource.nodeStageSecretRef)
    pub nodeStageSecretRef: ::protobuf::MessageField<SecretReference>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.CSIPersistentVolumeSource.nodePublishSecretRef)
    pub nodePublishSecretRef: ::protobuf::MessageField<SecretReference>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.CSIPersistentVolumeSource.controllerExpandSecretRef)
    pub controllerExpandSecretRef: ::protobuf::MessageField<SecretReference>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.CSIPersistentVolumeSource.nodeExpandSecretRef)
    pub nodeExpandSecretRef: ::protobuf::MessageField<SecretReference>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.CSIPersistentVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSIPersistentVolumeSource {
    fn default() -> &'a CSIPersistentVolumeSource {
        <CSIPersistentVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl CSIPersistentVolumeSource {
    pub fn new() -> CSIPersistentVolumeSource {
        ::std::default::Default::default()
    }

    // optional string driver = 1;

    pub fn driver(&self) -> &str {
        match self.driver.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_driver(&mut self) {
        self.driver = ::std::option::Option::None;
    }

    pub fn has_driver(&self) -> bool {
        self.driver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driver(&mut self, v: ::std::string::String) {
        self.driver = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver(&mut self) -> &mut ::std::string::String {
        if self.driver.is_none() {
            self.driver = ::std::option::Option::Some(::std::string::String::new());
        }
        self.driver.as_mut().unwrap()
    }

    // Take field
    pub fn take_driver(&mut self) -> ::std::string::String {
        self.driver.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string volumeHandle = 2;

    pub fn volumeHandle(&self) -> &str {
        match self.volumeHandle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_volumeHandle(&mut self) {
        self.volumeHandle = ::std::option::Option::None;
    }

    pub fn has_volumeHandle(&self) -> bool {
        self.volumeHandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeHandle(&mut self, v: ::std::string::String) {
        self.volumeHandle = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeHandle(&mut self) -> &mut ::std::string::String {
        if self.volumeHandle.is_none() {
            self.volumeHandle = ::std::option::Option::Some(::std::string::String::new());
        }
        self.volumeHandle.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeHandle(&mut self) -> ::std::string::String {
        self.volumeHandle.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 3;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // optional string fsType = 4;

    pub fn fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fsType(&mut self) {
        self.fsType = ::std::option::Option::None;
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.core.v1.CSIPersistentVolumeSource.VolumeAttributesEntry volumeAttributes = 5;

    pub fn volumeAttributes(&self) -> &::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &self.volumeAttributes
    }

    pub fn clear_volumeAttributes(&mut self) {
        self.volumeAttributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumeAttributes(&mut self, v: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
        self.volumeAttributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumeAttributes(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &mut self.volumeAttributes
    }

    // Take field
    pub fn take_volumeAttributes(&mut self) -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.volumeAttributes, ::std::collections::BTreeMap::new())
    }

    // optional .api.core.v1.SecretReference controllerPublishSecretRef = 6;

    pub fn controllerPublishSecretRef(&self) -> &SecretReference {
        self.controllerPublishSecretRef.as_ref().unwrap_or_else(|| <SecretReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_controllerPublishSecretRef(&mut self) {
        self.controllerPublishSecretRef.clear();
    }

    pub fn has_controllerPublishSecretRef(&self) -> bool {
        self.controllerPublishSecretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controllerPublishSecretRef(&mut self, v: SecretReference) {
        self.controllerPublishSecretRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controllerPublishSecretRef(&mut self) -> &mut SecretReference {
        self.controllerPublishSecretRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_controllerPublishSecretRef(&mut self) -> SecretReference {
        self.controllerPublishSecretRef.take().unwrap_or_else(|| SecretReference::new())
    }

    // optional .api.core.v1.SecretReference nodeStageSecretRef = 7;

    pub fn nodeStageSecretRef(&self) -> &SecretReference {
        self.nodeStageSecretRef.as_ref().unwrap_or_else(|| <SecretReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_nodeStageSecretRef(&mut self) {
        self.nodeStageSecretRef.clear();
    }

    pub fn has_nodeStageSecretRef(&self) -> bool {
        self.nodeStageSecretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeStageSecretRef(&mut self, v: SecretReference) {
        self.nodeStageSecretRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeStageSecretRef(&mut self) -> &mut SecretReference {
        self.nodeStageSecretRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_nodeStageSecretRef(&mut self) -> SecretReference {
        self.nodeStageSecretRef.take().unwrap_or_else(|| SecretReference::new())
    }

    // optional .api.core.v1.SecretReference nodePublishSecretRef = 8;

    pub fn nodePublishSecretRef(&self) -> &SecretReference {
        self.nodePublishSecretRef.as_ref().unwrap_or_else(|| <SecretReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_nodePublishSecretRef(&mut self) {
        self.nodePublishSecretRef.clear();
    }

    pub fn has_nodePublishSecretRef(&self) -> bool {
        self.nodePublishSecretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodePublishSecretRef(&mut self, v: SecretReference) {
        self.nodePublishSecretRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodePublishSecretRef(&mut self) -> &mut SecretReference {
        self.nodePublishSecretRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_nodePublishSecretRef(&mut self) -> SecretReference {
        self.nodePublishSecretRef.take().unwrap_or_else(|| SecretReference::new())
    }

    // optional .api.core.v1.SecretReference controllerExpandSecretRef = 9;

    pub fn controllerExpandSecretRef(&self) -> &SecretReference {
        self.controllerExpandSecretRef.as_ref().unwrap_or_else(|| <SecretReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_controllerExpandSecretRef(&mut self) {
        self.controllerExpandSecretRef.clear();
    }

    pub fn has_controllerExpandSecretRef(&self) -> bool {
        self.controllerExpandSecretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controllerExpandSecretRef(&mut self, v: SecretReference) {
        self.controllerExpandSecretRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controllerExpandSecretRef(&mut self) -> &mut SecretReference {
        self.controllerExpandSecretRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_controllerExpandSecretRef(&mut self) -> SecretReference {
        self.controllerExpandSecretRef.take().unwrap_or_else(|| SecretReference::new())
    }

    // optional .api.core.v1.SecretReference nodeExpandSecretRef = 10;

    pub fn nodeExpandSecretRef(&self) -> &SecretReference {
        self.nodeExpandSecretRef.as_ref().unwrap_or_else(|| <SecretReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_nodeExpandSecretRef(&mut self) {
        self.nodeExpandSecretRef.clear();
    }

    pub fn has_nodeExpandSecretRef(&self) -> bool {
        self.nodeExpandSecretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeExpandSecretRef(&mut self, v: SecretReference) {
        self.nodeExpandSecretRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeExpandSecretRef(&mut self) -> &mut SecretReference {
        self.nodeExpandSecretRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_nodeExpandSecretRef(&mut self) -> SecretReference {
        self.nodeExpandSecretRef.take().unwrap_or_else(|| SecretReference::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "driver",
            |m: &CSIPersistentVolumeSource| { &m.driver },
            |m: &mut CSIPersistentVolumeSource| { &mut m.driver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volumeHandle",
            |m: &CSIPersistentVolumeSource| { &m.volumeHandle },
            |m: &mut CSIPersistentVolumeSource| { &mut m.volumeHandle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &CSIPersistentVolumeSource| { &m.readOnly },
            |m: &mut CSIPersistentVolumeSource| { &mut m.readOnly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsType",
            |m: &CSIPersistentVolumeSource| { &m.fsType },
            |m: &mut CSIPersistentVolumeSource| { &mut m.fsType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "volumeAttributes",
            |m: &CSIPersistentVolumeSource| { &m.volumeAttributes },
            |m: &mut CSIPersistentVolumeSource| { &mut m.volumeAttributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SecretReference>(
            "controllerPublishSecretRef",
            |m: &CSIPersistentVolumeSource| { &m.controllerPublishSecretRef },
            |m: &mut CSIPersistentVolumeSource| { &mut m.controllerPublishSecretRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SecretReference>(
            "nodeStageSecretRef",
            |m: &CSIPersistentVolumeSource| { &m.nodeStageSecretRef },
            |m: &mut CSIPersistentVolumeSource| { &mut m.nodeStageSecretRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SecretReference>(
            "nodePublishSecretRef",
            |m: &CSIPersistentVolumeSource| { &m.nodePublishSecretRef },
            |m: &mut CSIPersistentVolumeSource| { &mut m.nodePublishSecretRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SecretReference>(
            "controllerExpandSecretRef",
            |m: &CSIPersistentVolumeSource| { &m.controllerExpandSecretRef },
            |m: &mut CSIPersistentVolumeSource| { &mut m.controllerExpandSecretRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SecretReference>(
            "nodeExpandSecretRef",
            |m: &CSIPersistentVolumeSource| { &m.nodeExpandSecretRef },
            |m: &mut CSIPersistentVolumeSource| { &mut m.nodeExpandSecretRef },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSIPersistentVolumeSource>(
            "CSIPersistentVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSIPersistentVolumeSource {
    const NAME: &'static str = "CSIPersistentVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.driver = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.volumeHandle = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.fsType = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.volumeAttributes.insert(key, value);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.controllerPublishSecretRef)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.nodeStageSecretRef)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.nodePublishSecretRef)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.controllerExpandSecretRef)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.nodeExpandSecretRef)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.driver.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.volumeHandle.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        if let Some(v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for (k, v) in &self.volumeAttributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.controllerPublishSecretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.nodeStageSecretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.nodePublishSecretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.controllerExpandSecretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.nodeExpandSecretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.driver.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.volumeHandle.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.fsType.as_ref() {
            os.write_string(4, v)?;
        }
        for (k, v) in &self.volumeAttributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.controllerPublishSecretRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.nodeStageSecretRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.nodePublishSecretRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.controllerExpandSecretRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.nodeExpandSecretRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSIPersistentVolumeSource {
        CSIPersistentVolumeSource::new()
    }

    fn clear(&mut self) {
        self.driver = ::std::option::Option::None;
        self.volumeHandle = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.fsType = ::std::option::Option::None;
        self.volumeAttributes.clear();
        self.controllerPublishSecretRef.clear();
        self.nodeStageSecretRef.clear();
        self.nodePublishSecretRef.clear();
        self.controllerExpandSecretRef.clear();
        self.nodeExpandSecretRef.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSIPersistentVolumeSource {
        static instance: ::protobuf::rt::Lazy<CSIPersistentVolumeSource> = ::protobuf::rt::Lazy::new();
        instance.get(CSIPersistentVolumeSource::new)
    }
}

impl ::protobuf::MessageFull for CSIPersistentVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSIPersistentVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSIPersistentVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSIPersistentVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.CSIVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSIVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.CSIVolumeSource.driver)
    pub driver: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.CSIVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.CSIVolumeSource.fsType)
    pub fsType: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.CSIVolumeSource.volumeAttributes)
    pub volumeAttributes: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.CSIVolumeSource.nodePublishSecretRef)
    pub nodePublishSecretRef: ::protobuf::MessageField<LocalObjectReference>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.CSIVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSIVolumeSource {
    fn default() -> &'a CSIVolumeSource {
        <CSIVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl CSIVolumeSource {
    pub fn new() -> CSIVolumeSource {
        ::std::default::Default::default()
    }

    // optional string driver = 1;

    pub fn driver(&self) -> &str {
        match self.driver.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_driver(&mut self) {
        self.driver = ::std::option::Option::None;
    }

    pub fn has_driver(&self) -> bool {
        self.driver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driver(&mut self, v: ::std::string::String) {
        self.driver = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver(&mut self) -> &mut ::std::string::String {
        if self.driver.is_none() {
            self.driver = ::std::option::Option::Some(::std::string::String::new());
        }
        self.driver.as_mut().unwrap()
    }

    // Take field
    pub fn take_driver(&mut self) -> ::std::string::String {
        self.driver.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 2;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // optional string fsType = 3;

    pub fn fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fsType(&mut self) {
        self.fsType = ::std::option::Option::None;
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.core.v1.CSIVolumeSource.VolumeAttributesEntry volumeAttributes = 4;

    pub fn volumeAttributes(&self) -> &::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &self.volumeAttributes
    }

    pub fn clear_volumeAttributes(&mut self) {
        self.volumeAttributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumeAttributes(&mut self, v: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
        self.volumeAttributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumeAttributes(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &mut self.volumeAttributes
    }

    // Take field
    pub fn take_volumeAttributes(&mut self) -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.volumeAttributes, ::std::collections::BTreeMap::new())
    }

    // optional .api.core.v1.LocalObjectReference nodePublishSecretRef = 5;

    pub fn nodePublishSecretRef(&self) -> &LocalObjectReference {
        self.nodePublishSecretRef.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_nodePublishSecretRef(&mut self) {
        self.nodePublishSecretRef.clear();
    }

    pub fn has_nodePublishSecretRef(&self) -> bool {
        self.nodePublishSecretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodePublishSecretRef(&mut self, v: LocalObjectReference) {
        self.nodePublishSecretRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodePublishSecretRef(&mut self) -> &mut LocalObjectReference {
        self.nodePublishSecretRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_nodePublishSecretRef(&mut self) -> LocalObjectReference {
        self.nodePublishSecretRef.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "driver",
            |m: &CSIVolumeSource| { &m.driver },
            |m: &mut CSIVolumeSource| { &mut m.driver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &CSIVolumeSource| { &m.readOnly },
            |m: &mut CSIVolumeSource| { &mut m.readOnly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsType",
            |m: &CSIVolumeSource| { &m.fsType },
            |m: &mut CSIVolumeSource| { &mut m.fsType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "volumeAttributes",
            |m: &CSIVolumeSource| { &m.volumeAttributes },
            |m: &mut CSIVolumeSource| { &mut m.volumeAttributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LocalObjectReference>(
            "nodePublishSecretRef",
            |m: &CSIVolumeSource| { &m.nodePublishSecretRef },
            |m: &mut CSIVolumeSource| { &mut m.nodePublishSecretRef },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSIVolumeSource>(
            "CSIVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSIVolumeSource {
    const NAME: &'static str = "CSIVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.driver = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.fsType = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.volumeAttributes.insert(key, value);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.nodePublishSecretRef)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.driver.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        if let Some(v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for (k, v) in &self.volumeAttributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.nodePublishSecretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.driver.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.fsType.as_ref() {
            os.write_string(3, v)?;
        }
        for (k, v) in &self.volumeAttributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(34)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.nodePublishSecretRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSIVolumeSource {
        CSIVolumeSource::new()
    }

    fn clear(&mut self) {
        self.driver = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.fsType = ::std::option::Option::None;
        self.volumeAttributes.clear();
        self.nodePublishSecretRef.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSIVolumeSource {
        static instance: ::protobuf::rt::Lazy<CSIVolumeSource> = ::protobuf::rt::Lazy::new();
        instance.get(CSIVolumeSource::new)
    }
}

impl ::protobuf::MessageFull for CSIVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSIVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSIVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSIVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.Capabilities)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Capabilities {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Capabilities.add)
    pub add: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Capabilities.drop)
    pub drop: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.Capabilities.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Capabilities {
    fn default() -> &'a Capabilities {
        <Capabilities as ::protobuf::Message>::default_instance()
    }
}

impl Capabilities {
    pub fn new() -> Capabilities {
        ::std::default::Default::default()
    }

    // repeated string add = 1;

    pub fn add(&self) -> &[::std::string::String] {
        &self.add
    }

    pub fn clear_add(&mut self) {
        self.add.clear();
    }

    // Param is passed by value, moved
    pub fn set_add(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.add = v;
    }

    // Mutable pointer to the field.
    pub fn mut_add(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.add
    }

    // Take field
    pub fn take_add(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.add, ::std::vec::Vec::new())
    }

    // repeated string drop = 2;

    pub fn drop(&self) -> &[::std::string::String] {
        &self.drop
    }

    pub fn clear_drop(&mut self) {
        self.drop.clear();
    }

    // Param is passed by value, moved
    pub fn set_drop(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.drop = v;
    }

    // Mutable pointer to the field.
    pub fn mut_drop(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.drop
    }

    // Take field
    pub fn take_drop(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.drop, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "add",
            |m: &Capabilities| { &m.add },
            |m: &mut Capabilities| { &mut m.add },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "drop",
            |m: &Capabilities| { &m.drop },
            |m: &mut Capabilities| { &mut m.drop },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Capabilities>(
            "Capabilities",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Capabilities {
    const NAME: &'static str = "Capabilities";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.add.push(is.read_string()?);
                },
                18 => {
                    self.drop.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.add {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.drop {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.add {
            os.write_string(1, &v)?;
        };
        for v in &self.drop {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Capabilities {
        Capabilities::new()
    }

    fn clear(&mut self) {
        self.add.clear();
        self.drop.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Capabilities {
        static instance: Capabilities = Capabilities {
            add: ::std::vec::Vec::new(),
            drop: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Capabilities {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Capabilities").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Capabilities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Capabilities {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.CephFSPersistentVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CephFSPersistentVolumeSource {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.CephFSPersistentVolumeSource.monitors)
    pub monitors: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.CephFSPersistentVolumeSource.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.CephFSPersistentVolumeSource.user)
    pub user: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.CephFSPersistentVolumeSource.secretFile)
    pub secretFile: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.CephFSPersistentVolumeSource.secretRef)
    pub secretRef: ::protobuf::MessageField<SecretReference>,
    // @@protoc_insertion_point(field:api.core.v1.CephFSPersistentVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.CephFSPersistentVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CephFSPersistentVolumeSource {
    fn default() -> &'a CephFSPersistentVolumeSource {
        <CephFSPersistentVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl CephFSPersistentVolumeSource {
    pub fn new() -> CephFSPersistentVolumeSource {
        ::std::default::Default::default()
    }

    // repeated string monitors = 1;

    pub fn monitors(&self) -> &[::std::string::String] {
        &self.monitors
    }

    pub fn clear_monitors(&mut self) {
        self.monitors.clear();
    }

    // Param is passed by value, moved
    pub fn set_monitors(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.monitors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_monitors(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.monitors
    }

    // Take field
    pub fn take_monitors(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.monitors, ::std::vec::Vec::new())
    }

    // optional string path = 2;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string user = 3;

    pub fn user(&self) -> &str {
        match self.user.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_user(&mut self) {
        self.user = ::std::option::Option::None;
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        if self.user.is_none() {
            self.user = ::std::option::Option::Some(::std::string::String::new());
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string secretFile = 4;

    pub fn secretFile(&self) -> &str {
        match self.secretFile.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_secretFile(&mut self) {
        self.secretFile = ::std::option::Option::None;
    }

    pub fn has_secretFile(&self) -> bool {
        self.secretFile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretFile(&mut self, v: ::std::string::String) {
        self.secretFile = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretFile(&mut self) -> &mut ::std::string::String {
        if self.secretFile.is_none() {
            self.secretFile = ::std::option::Option::Some(::std::string::String::new());
        }
        self.secretFile.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretFile(&mut self) -> ::std::string::String {
        self.secretFile.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.SecretReference secretRef = 5;

    pub fn secretRef(&self) -> &SecretReference {
        self.secretRef.as_ref().unwrap_or_else(|| <SecretReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: SecretReference) {
        self.secretRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut SecretReference {
        self.secretRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> SecretReference {
        self.secretRef.take().unwrap_or_else(|| SecretReference::new())
    }

    // optional bool readOnly = 6;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "monitors",
            |m: &CephFSPersistentVolumeSource| { &m.monitors },
            |m: &mut CephFSPersistentVolumeSource| { &mut m.monitors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &CephFSPersistentVolumeSource| { &m.path },
            |m: &mut CephFSPersistentVolumeSource| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user",
            |m: &CephFSPersistentVolumeSource| { &m.user },
            |m: &mut CephFSPersistentVolumeSource| { &mut m.user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "secretFile",
            |m: &CephFSPersistentVolumeSource| { &m.secretFile },
            |m: &mut CephFSPersistentVolumeSource| { &mut m.secretFile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SecretReference>(
            "secretRef",
            |m: &CephFSPersistentVolumeSource| { &m.secretRef },
            |m: &mut CephFSPersistentVolumeSource| { &mut m.secretRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &CephFSPersistentVolumeSource| { &m.readOnly },
            |m: &mut CephFSPersistentVolumeSource| { &mut m.readOnly },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CephFSPersistentVolumeSource>(
            "CephFSPersistentVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CephFSPersistentVolumeSource {
    const NAME: &'static str = "CephFSPersistentVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.monitors.push(is.read_string()?);
                },
                18 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.user = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.secretFile = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.secretRef)?;
                },
                48 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.monitors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.user.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.secretFile.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.monitors {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.path.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.user.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.secretFile.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.secretRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CephFSPersistentVolumeSource {
        CephFSPersistentVolumeSource::new()
    }

    fn clear(&mut self) {
        self.monitors.clear();
        self.path = ::std::option::Option::None;
        self.user = ::std::option::Option::None;
        self.secretFile = ::std::option::Option::None;
        self.secretRef.clear();
        self.readOnly = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CephFSPersistentVolumeSource {
        static instance: CephFSPersistentVolumeSource = CephFSPersistentVolumeSource {
            monitors: ::std::vec::Vec::new(),
            path: ::std::option::Option::None,
            user: ::std::option::Option::None,
            secretFile: ::std::option::Option::None,
            secretRef: ::protobuf::MessageField::none(),
            readOnly: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CephFSPersistentVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CephFSPersistentVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CephFSPersistentVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CephFSPersistentVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.CephFSVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CephFSVolumeSource {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.CephFSVolumeSource.monitors)
    pub monitors: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.CephFSVolumeSource.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.CephFSVolumeSource.user)
    pub user: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.CephFSVolumeSource.secretFile)
    pub secretFile: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.CephFSVolumeSource.secretRef)
    pub secretRef: ::protobuf::MessageField<LocalObjectReference>,
    // @@protoc_insertion_point(field:api.core.v1.CephFSVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.CephFSVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CephFSVolumeSource {
    fn default() -> &'a CephFSVolumeSource {
        <CephFSVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl CephFSVolumeSource {
    pub fn new() -> CephFSVolumeSource {
        ::std::default::Default::default()
    }

    // repeated string monitors = 1;

    pub fn monitors(&self) -> &[::std::string::String] {
        &self.monitors
    }

    pub fn clear_monitors(&mut self) {
        self.monitors.clear();
    }

    // Param is passed by value, moved
    pub fn set_monitors(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.monitors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_monitors(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.monitors
    }

    // Take field
    pub fn take_monitors(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.monitors, ::std::vec::Vec::new())
    }

    // optional string path = 2;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string user = 3;

    pub fn user(&self) -> &str {
        match self.user.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_user(&mut self) {
        self.user = ::std::option::Option::None;
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        if self.user.is_none() {
            self.user = ::std::option::Option::Some(::std::string::String::new());
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string secretFile = 4;

    pub fn secretFile(&self) -> &str {
        match self.secretFile.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_secretFile(&mut self) {
        self.secretFile = ::std::option::Option::None;
    }

    pub fn has_secretFile(&self) -> bool {
        self.secretFile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretFile(&mut self, v: ::std::string::String) {
        self.secretFile = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretFile(&mut self) -> &mut ::std::string::String {
        if self.secretFile.is_none() {
            self.secretFile = ::std::option::Option::Some(::std::string::String::new());
        }
        self.secretFile.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretFile(&mut self) -> ::std::string::String {
        self.secretFile.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.LocalObjectReference secretRef = 5;

    pub fn secretRef(&self) -> &LocalObjectReference {
        self.secretRef.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: LocalObjectReference) {
        self.secretRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut LocalObjectReference {
        self.secretRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> LocalObjectReference {
        self.secretRef.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    // optional bool readOnly = 6;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "monitors",
            |m: &CephFSVolumeSource| { &m.monitors },
            |m: &mut CephFSVolumeSource| { &mut m.monitors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &CephFSVolumeSource| { &m.path },
            |m: &mut CephFSVolumeSource| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user",
            |m: &CephFSVolumeSource| { &m.user },
            |m: &mut CephFSVolumeSource| { &mut m.user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "secretFile",
            |m: &CephFSVolumeSource| { &m.secretFile },
            |m: &mut CephFSVolumeSource| { &mut m.secretFile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LocalObjectReference>(
            "secretRef",
            |m: &CephFSVolumeSource| { &m.secretRef },
            |m: &mut CephFSVolumeSource| { &mut m.secretRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &CephFSVolumeSource| { &m.readOnly },
            |m: &mut CephFSVolumeSource| { &mut m.readOnly },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CephFSVolumeSource>(
            "CephFSVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CephFSVolumeSource {
    const NAME: &'static str = "CephFSVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.monitors.push(is.read_string()?);
                },
                18 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.user = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.secretFile = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.secretRef)?;
                },
                48 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.monitors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.user.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.secretFile.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.monitors {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.path.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.user.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.secretFile.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.secretRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CephFSVolumeSource {
        CephFSVolumeSource::new()
    }

    fn clear(&mut self) {
        self.monitors.clear();
        self.path = ::std::option::Option::None;
        self.user = ::std::option::Option::None;
        self.secretFile = ::std::option::Option::None;
        self.secretRef.clear();
        self.readOnly = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CephFSVolumeSource {
        static instance: CephFSVolumeSource = CephFSVolumeSource {
            monitors: ::std::vec::Vec::new(),
            path: ::std::option::Option::None,
            user: ::std::option::Option::None,
            secretFile: ::std::option::Option::None,
            secretRef: ::protobuf::MessageField::none(),
            readOnly: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CephFSVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CephFSVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CephFSVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CephFSVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.CinderPersistentVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CinderPersistentVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.CinderPersistentVolumeSource.volumeID)
    pub volumeID: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.CinderPersistentVolumeSource.fsType)
    pub fsType: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.CinderPersistentVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.CinderPersistentVolumeSource.secretRef)
    pub secretRef: ::protobuf::MessageField<SecretReference>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.CinderPersistentVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CinderPersistentVolumeSource {
    fn default() -> &'a CinderPersistentVolumeSource {
        <CinderPersistentVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl CinderPersistentVolumeSource {
    pub fn new() -> CinderPersistentVolumeSource {
        ::std::default::Default::default()
    }

    // optional string volumeID = 1;

    pub fn volumeID(&self) -> &str {
        match self.volumeID.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_volumeID(&mut self) {
        self.volumeID = ::std::option::Option::None;
    }

    pub fn has_volumeID(&self) -> bool {
        self.volumeID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeID(&mut self, v: ::std::string::String) {
        self.volumeID = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeID(&mut self) -> &mut ::std::string::String {
        if self.volumeID.is_none() {
            self.volumeID = ::std::option::Option::Some(::std::string::String::new());
        }
        self.volumeID.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeID(&mut self) -> ::std::string::String {
        self.volumeID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 2;

    pub fn fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fsType(&mut self) {
        self.fsType = ::std::option::Option::None;
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 3;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // optional .api.core.v1.SecretReference secretRef = 4;

    pub fn secretRef(&self) -> &SecretReference {
        self.secretRef.as_ref().unwrap_or_else(|| <SecretReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: SecretReference) {
        self.secretRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut SecretReference {
        self.secretRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> SecretReference {
        self.secretRef.take().unwrap_or_else(|| SecretReference::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volumeID",
            |m: &CinderPersistentVolumeSource| { &m.volumeID },
            |m: &mut CinderPersistentVolumeSource| { &mut m.volumeID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsType",
            |m: &CinderPersistentVolumeSource| { &m.fsType },
            |m: &mut CinderPersistentVolumeSource| { &mut m.fsType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &CinderPersistentVolumeSource| { &m.readOnly },
            |m: &mut CinderPersistentVolumeSource| { &mut m.readOnly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SecretReference>(
            "secretRef",
            |m: &CinderPersistentVolumeSource| { &m.secretRef },
            |m: &mut CinderPersistentVolumeSource| { &mut m.secretRef },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CinderPersistentVolumeSource>(
            "CinderPersistentVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CinderPersistentVolumeSource {
    const NAME: &'static str = "CinderPersistentVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.volumeID = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.fsType = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.secretRef)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.volumeID.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        if let Some(v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.volumeID.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.fsType.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.secretRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CinderPersistentVolumeSource {
        CinderPersistentVolumeSource::new()
    }

    fn clear(&mut self) {
        self.volumeID = ::std::option::Option::None;
        self.fsType = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.secretRef.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CinderPersistentVolumeSource {
        static instance: CinderPersistentVolumeSource = CinderPersistentVolumeSource {
            volumeID: ::std::option::Option::None,
            fsType: ::std::option::Option::None,
            readOnly: ::std::option::Option::None,
            secretRef: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CinderPersistentVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CinderPersistentVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CinderPersistentVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CinderPersistentVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.CinderVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CinderVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.CinderVolumeSource.volumeID)
    pub volumeID: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.CinderVolumeSource.fsType)
    pub fsType: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.CinderVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.CinderVolumeSource.secretRef)
    pub secretRef: ::protobuf::MessageField<LocalObjectReference>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.CinderVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CinderVolumeSource {
    fn default() -> &'a CinderVolumeSource {
        <CinderVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl CinderVolumeSource {
    pub fn new() -> CinderVolumeSource {
        ::std::default::Default::default()
    }

    // optional string volumeID = 1;

    pub fn volumeID(&self) -> &str {
        match self.volumeID.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_volumeID(&mut self) {
        self.volumeID = ::std::option::Option::None;
    }

    pub fn has_volumeID(&self) -> bool {
        self.volumeID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeID(&mut self, v: ::std::string::String) {
        self.volumeID = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeID(&mut self) -> &mut ::std::string::String {
        if self.volumeID.is_none() {
            self.volumeID = ::std::option::Option::Some(::std::string::String::new());
        }
        self.volumeID.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeID(&mut self) -> ::std::string::String {
        self.volumeID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 2;

    pub fn fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fsType(&mut self) {
        self.fsType = ::std::option::Option::None;
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 3;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // optional .api.core.v1.LocalObjectReference secretRef = 4;

    pub fn secretRef(&self) -> &LocalObjectReference {
        self.secretRef.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: LocalObjectReference) {
        self.secretRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut LocalObjectReference {
        self.secretRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> LocalObjectReference {
        self.secretRef.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volumeID",
            |m: &CinderVolumeSource| { &m.volumeID },
            |m: &mut CinderVolumeSource| { &mut m.volumeID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsType",
            |m: &CinderVolumeSource| { &m.fsType },
            |m: &mut CinderVolumeSource| { &mut m.fsType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &CinderVolumeSource| { &m.readOnly },
            |m: &mut CinderVolumeSource| { &mut m.readOnly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LocalObjectReference>(
            "secretRef",
            |m: &CinderVolumeSource| { &m.secretRef },
            |m: &mut CinderVolumeSource| { &mut m.secretRef },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CinderVolumeSource>(
            "CinderVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CinderVolumeSource {
    const NAME: &'static str = "CinderVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.volumeID = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.fsType = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.secretRef)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.volumeID.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        if let Some(v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.volumeID.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.fsType.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.secretRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CinderVolumeSource {
        CinderVolumeSource::new()
    }

    fn clear(&mut self) {
        self.volumeID = ::std::option::Option::None;
        self.fsType = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.secretRef.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CinderVolumeSource {
        static instance: CinderVolumeSource = CinderVolumeSource {
            volumeID: ::std::option::Option::None,
            fsType: ::std::option::Option::None,
            readOnly: ::std::option::Option::None,
            secretRef: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CinderVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CinderVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CinderVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CinderVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ClaimSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClaimSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ClaimSource.resourceClaimName)
    pub resourceClaimName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ClaimSource.resourceClaimTemplateName)
    pub resourceClaimTemplateName: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ClaimSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClaimSource {
    fn default() -> &'a ClaimSource {
        <ClaimSource as ::protobuf::Message>::default_instance()
    }
}

impl ClaimSource {
    pub fn new() -> ClaimSource {
        ::std::default::Default::default()
    }

    // optional string resourceClaimName = 1;

    pub fn resourceClaimName(&self) -> &str {
        match self.resourceClaimName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resourceClaimName(&mut self) {
        self.resourceClaimName = ::std::option::Option::None;
    }

    pub fn has_resourceClaimName(&self) -> bool {
        self.resourceClaimName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceClaimName(&mut self, v: ::std::string::String) {
        self.resourceClaimName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceClaimName(&mut self) -> &mut ::std::string::String {
        if self.resourceClaimName.is_none() {
            self.resourceClaimName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resourceClaimName.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceClaimName(&mut self) -> ::std::string::String {
        self.resourceClaimName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resourceClaimTemplateName = 2;

    pub fn resourceClaimTemplateName(&self) -> &str {
        match self.resourceClaimTemplateName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resourceClaimTemplateName(&mut self) {
        self.resourceClaimTemplateName = ::std::option::Option::None;
    }

    pub fn has_resourceClaimTemplateName(&self) -> bool {
        self.resourceClaimTemplateName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceClaimTemplateName(&mut self, v: ::std::string::String) {
        self.resourceClaimTemplateName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceClaimTemplateName(&mut self) -> &mut ::std::string::String {
        if self.resourceClaimTemplateName.is_none() {
            self.resourceClaimTemplateName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resourceClaimTemplateName.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceClaimTemplateName(&mut self) -> ::std::string::String {
        self.resourceClaimTemplateName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resourceClaimName",
            |m: &ClaimSource| { &m.resourceClaimName },
            |m: &mut ClaimSource| { &mut m.resourceClaimName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resourceClaimTemplateName",
            |m: &ClaimSource| { &m.resourceClaimTemplateName },
            |m: &mut ClaimSource| { &mut m.resourceClaimTemplateName },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClaimSource>(
            "ClaimSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClaimSource {
    const NAME: &'static str = "ClaimSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.resourceClaimName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.resourceClaimTemplateName = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.resourceClaimName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.resourceClaimTemplateName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.resourceClaimName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.resourceClaimTemplateName.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClaimSource {
        ClaimSource::new()
    }

    fn clear(&mut self) {
        self.resourceClaimName = ::std::option::Option::None;
        self.resourceClaimTemplateName = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClaimSource {
        static instance: ClaimSource = ClaimSource {
            resourceClaimName: ::std::option::Option::None,
            resourceClaimTemplateName: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClaimSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClaimSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClaimSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClaimSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ClientIPConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClientIPConfig {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ClientIPConfig.timeoutSeconds)
    pub timeoutSeconds: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ClientIPConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientIPConfig {
    fn default() -> &'a ClientIPConfig {
        <ClientIPConfig as ::protobuf::Message>::default_instance()
    }
}

impl ClientIPConfig {
    pub fn new() -> ClientIPConfig {
        ::std::default::Default::default()
    }

    // optional int32 timeoutSeconds = 1;

    pub fn timeoutSeconds(&self) -> i32 {
        self.timeoutSeconds.unwrap_or(0)
    }

    pub fn clear_timeoutSeconds(&mut self) {
        self.timeoutSeconds = ::std::option::Option::None;
    }

    pub fn has_timeoutSeconds(&self) -> bool {
        self.timeoutSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeoutSeconds(&mut self, v: i32) {
        self.timeoutSeconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timeoutSeconds",
            |m: &ClientIPConfig| { &m.timeoutSeconds },
            |m: &mut ClientIPConfig| { &mut m.timeoutSeconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientIPConfig>(
            "ClientIPConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientIPConfig {
    const NAME: &'static str = "ClientIPConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.timeoutSeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timeoutSeconds {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.timeoutSeconds {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientIPConfig {
        ClientIPConfig::new()
    }

    fn clear(&mut self) {
        self.timeoutSeconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientIPConfig {
        static instance: ClientIPConfig = ClientIPConfig {
            timeoutSeconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientIPConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientIPConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientIPConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientIPConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ClusterTrustBundleProjection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClusterTrustBundleProjection {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ClusterTrustBundleProjection.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ClusterTrustBundleProjection.signerName)
    pub signerName: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ClusterTrustBundleProjection.labelSelector)
    pub labelSelector: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    // @@protoc_insertion_point(field:api.core.v1.ClusterTrustBundleProjection.optional)
    pub optional: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.ClusterTrustBundleProjection.path)
    pub path: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ClusterTrustBundleProjection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClusterTrustBundleProjection {
    fn default() -> &'a ClusterTrustBundleProjection {
        <ClusterTrustBundleProjection as ::protobuf::Message>::default_instance()
    }
}

impl ClusterTrustBundleProjection {
    pub fn new() -> ClusterTrustBundleProjection {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string signerName = 2;

    pub fn signerName(&self) -> &str {
        match self.signerName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_signerName(&mut self) {
        self.signerName = ::std::option::Option::None;
    }

    pub fn has_signerName(&self) -> bool {
        self.signerName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signerName(&mut self, v: ::std::string::String) {
        self.signerName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signerName(&mut self) -> &mut ::std::string::String {
        if self.signerName.is_none() {
            self.signerName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.signerName.as_mut().unwrap()
    }

    // Take field
    pub fn take_signerName(&mut self) -> ::std::string::String {
        self.signerName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 3;

    pub fn labelSelector(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.labelSelector.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_labelSelector(&mut self) {
        self.labelSelector.clear();
    }

    pub fn has_labelSelector(&self) -> bool {
        self.labelSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labelSelector(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.labelSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labelSelector(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.labelSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_labelSelector(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.labelSelector.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional bool optional = 5;

    pub fn optional(&self) -> bool {
        self.optional.unwrap_or(false)
    }

    pub fn clear_optional(&mut self) {
        self.optional = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        self.optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = ::std::option::Option::Some(v);
    }

    // optional string path = 4;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ClusterTrustBundleProjection| { &m.name },
            |m: &mut ClusterTrustBundleProjection| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signerName",
            |m: &ClusterTrustBundleProjection| { &m.signerName },
            |m: &mut ClusterTrustBundleProjection| { &mut m.signerName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "labelSelector",
            |m: &ClusterTrustBundleProjection| { &m.labelSelector },
            |m: &mut ClusterTrustBundleProjection| { &mut m.labelSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "optional",
            |m: &ClusterTrustBundleProjection| { &m.optional },
            |m: &mut ClusterTrustBundleProjection| { &mut m.optional },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &ClusterTrustBundleProjection| { &m.path },
            |m: &mut ClusterTrustBundleProjection| { &mut m.path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClusterTrustBundleProjection>(
            "ClusterTrustBundleProjection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClusterTrustBundleProjection {
    const NAME: &'static str = "ClusterTrustBundleProjection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.signerName = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.labelSelector)?;
                },
                40 => {
                    self.optional = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.signerName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.labelSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.optional {
            my_size += 1 + 1;
        }
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.signerName.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.labelSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.optional {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClusterTrustBundleProjection {
        ClusterTrustBundleProjection::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.signerName = ::std::option::Option::None;
        self.labelSelector.clear();
        self.optional = ::std::option::Option::None;
        self.path = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClusterTrustBundleProjection {
        static instance: ClusterTrustBundleProjection = ClusterTrustBundleProjection {
            name: ::std::option::Option::None,
            signerName: ::std::option::Option::None,
            labelSelector: ::protobuf::MessageField::none(),
            optional: ::std::option::Option::None,
            path: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClusterTrustBundleProjection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClusterTrustBundleProjection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClusterTrustBundleProjection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClusterTrustBundleProjection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ComponentCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ComponentCondition {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ComponentCondition.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ComponentCondition.status)
    pub status: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ComponentCondition.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ComponentCondition.error)
    pub error: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ComponentCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ComponentCondition {
    fn default() -> &'a ComponentCondition {
        <ComponentCondition as ::protobuf::Message>::default_instance()
    }
}

impl ComponentCondition {
    pub fn new() -> ComponentCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 3;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string error = 4;

    pub fn error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &ComponentCondition| { &m.type_ },
            |m: &mut ComponentCondition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &ComponentCondition| { &m.status },
            |m: &mut ComponentCondition| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &ComponentCondition| { &m.message },
            |m: &mut ComponentCondition| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error",
            |m: &ComponentCondition| { &m.error },
            |m: &mut ComponentCondition| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ComponentCondition>(
            "ComponentCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ComponentCondition {
    const NAME: &'static str = "ComponentCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.error = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.error.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ComponentCondition {
        ComponentCondition::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ComponentCondition {
        static instance: ComponentCondition = ComponentCondition {
            type_: ::std::option::Option::None,
            status: ::std::option::Option::None,
            message: ::std::option::Option::None,
            error: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ComponentCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ComponentCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ComponentCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComponentCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ComponentStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ComponentStatus {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ComponentStatus.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ComponentStatus.conditions)
    pub conditions: ::std::vec::Vec<ComponentCondition>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ComponentStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ComponentStatus {
    fn default() -> &'a ComponentStatus {
        <ComponentStatus as ::protobuf::Message>::default_instance()
    }
}

impl ComponentStatus {
    pub fn new() -> ComponentStatus {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // repeated .api.core.v1.ComponentCondition conditions = 2;

    pub fn conditions(&self) -> &[ComponentCondition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<ComponentCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<ComponentCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<ComponentCondition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ComponentStatus| { &m.metadata },
            |m: &mut ComponentStatus| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &ComponentStatus| { &m.conditions },
            |m: &mut ComponentStatus| { &mut m.conditions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ComponentStatus>(
            "ComponentStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ComponentStatus {
    const NAME: &'static str = "ComponentStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.conditions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ComponentStatus {
        ComponentStatus::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.conditions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ComponentStatus {
        static instance: ComponentStatus = ComponentStatus {
            metadata: ::protobuf::MessageField::none(),
            conditions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ComponentStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ComponentStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ComponentStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComponentStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ComponentStatusList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ComponentStatusList {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ComponentStatusList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ComponentStatusList.items)
    pub items: ::std::vec::Vec<ComponentStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ComponentStatusList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ComponentStatusList {
    fn default() -> &'a ComponentStatusList {
        <ComponentStatusList as ::protobuf::Message>::default_instance()
    }
}

impl ComponentStatusList {
    pub fn new() -> ComponentStatusList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.core.v1.ComponentStatus items = 2;

    pub fn items(&self) -> &[ComponentStatus] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ComponentStatus>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ComponentStatus> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ComponentStatus> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ComponentStatusList| { &m.metadata },
            |m: &mut ComponentStatusList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ComponentStatusList| { &m.items },
            |m: &mut ComponentStatusList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ComponentStatusList>(
            "ComponentStatusList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ComponentStatusList {
    const NAME: &'static str = "ComponentStatusList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ComponentStatusList {
        ComponentStatusList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ComponentStatusList {
        static instance: ComponentStatusList = ComponentStatusList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ComponentStatusList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ComponentStatusList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ComponentStatusList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComponentStatusList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ConfigMap)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConfigMap {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ConfigMap.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    // @@protoc_insertion_point(field:api.core.v1.ConfigMap.immutable)
    pub immutable: ::std::option::Option<bool>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ConfigMap.data)
    pub data: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ConfigMap.binaryData)
    pub binaryData: ::std::collections::BTreeMap<::std::string::String, ::std::vec::Vec<u8>>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ConfigMap.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConfigMap {
    fn default() -> &'a ConfigMap {
        <ConfigMap as ::protobuf::Message>::default_instance()
    }
}

impl ConfigMap {
    pub fn new() -> ConfigMap {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional bool immutable = 4;

    pub fn immutable(&self) -> bool {
        self.immutable.unwrap_or(false)
    }

    pub fn clear_immutable(&mut self) {
        self.immutable = ::std::option::Option::None;
    }

    pub fn has_immutable(&self) -> bool {
        self.immutable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_immutable(&mut self, v: bool) {
        self.immutable = ::std::option::Option::Some(v);
    }

    // repeated .api.core.v1.ConfigMap.DataEntry data = 2;

    pub fn data(&self) -> &::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &self.data
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.data, ::std::collections::BTreeMap::new())
    }

    // repeated .api.core.v1.ConfigMap.BinaryDataEntry binaryData = 3;

    pub fn binaryData(&self) -> &::std::collections::BTreeMap<::std::string::String, ::std::vec::Vec<u8>> {
        &self.binaryData
    }

    pub fn clear_binaryData(&mut self) {
        self.binaryData.clear();
    }

    // Param is passed by value, moved
    pub fn set_binaryData(&mut self, v: ::std::collections::BTreeMap<::std::string::String, ::std::vec::Vec<u8>>) {
        self.binaryData = v;
    }

    // Mutable pointer to the field.
    pub fn mut_binaryData(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, ::std::vec::Vec<u8>> {
        &mut self.binaryData
    }

    // Take field
    pub fn take_binaryData(&mut self) -> ::std::collections::BTreeMap<::std::string::String, ::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.binaryData, ::std::collections::BTreeMap::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ConfigMap| { &m.metadata },
            |m: &mut ConfigMap| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "immutable",
            |m: &ConfigMap| { &m.immutable },
            |m: &mut ConfigMap| { &mut m.immutable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "data",
            |m: &ConfigMap| { &m.data },
            |m: &mut ConfigMap| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "binaryData",
            |m: &ConfigMap| { &m.binaryData },
            |m: &mut ConfigMap| { &mut m.binaryData },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConfigMap>(
            "ConfigMap",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConfigMap {
    const NAME: &'static str = "ConfigMap";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                32 => {
                    self.immutable = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.data.insert(key, value);
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_bytes()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.binaryData.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.immutable {
            my_size += 1 + 1;
        }
        for (k, v) in &self.data {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.binaryData {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.immutable {
            os.write_bool(4, v)?;
        }
        for (k, v) in &self.data {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for (k, v) in &self.binaryData {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConfigMap {
        ConfigMap::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.immutable = ::std::option::Option::None;
        self.data.clear();
        self.binaryData.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConfigMap {
        static instance: ::protobuf::rt::Lazy<ConfigMap> = ::protobuf::rt::Lazy::new();
        instance.get(ConfigMap::new)
    }
}

impl ::protobuf::MessageFull for ConfigMap {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConfigMap").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConfigMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigMap {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ConfigMapEnvSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConfigMapEnvSource {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ConfigMapEnvSource.localObjectReference)
    pub localObjectReference: ::protobuf::MessageField<LocalObjectReference>,
    // @@protoc_insertion_point(field:api.core.v1.ConfigMapEnvSource.optional)
    pub optional: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ConfigMapEnvSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConfigMapEnvSource {
    fn default() -> &'a ConfigMapEnvSource {
        <ConfigMapEnvSource as ::protobuf::Message>::default_instance()
    }
}

impl ConfigMapEnvSource {
    pub fn new() -> ConfigMapEnvSource {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.LocalObjectReference localObjectReference = 1;

    pub fn localObjectReference(&self) -> &LocalObjectReference {
        self.localObjectReference.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_localObjectReference(&mut self) {
        self.localObjectReference.clear();
    }

    pub fn has_localObjectReference(&self) -> bool {
        self.localObjectReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localObjectReference(&mut self, v: LocalObjectReference) {
        self.localObjectReference = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localObjectReference(&mut self) -> &mut LocalObjectReference {
        self.localObjectReference.mut_or_insert_default()
    }

    // Take field
    pub fn take_localObjectReference(&mut self) -> LocalObjectReference {
        self.localObjectReference.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    // optional bool optional = 2;

    pub fn optional(&self) -> bool {
        self.optional.unwrap_or(false)
    }

    pub fn clear_optional(&mut self) {
        self.optional = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        self.optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LocalObjectReference>(
            "localObjectReference",
            |m: &ConfigMapEnvSource| { &m.localObjectReference },
            |m: &mut ConfigMapEnvSource| { &mut m.localObjectReference },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "optional",
            |m: &ConfigMapEnvSource| { &m.optional },
            |m: &mut ConfigMapEnvSource| { &mut m.optional },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConfigMapEnvSource>(
            "ConfigMapEnvSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConfigMapEnvSource {
    const NAME: &'static str = "ConfigMapEnvSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.localObjectReference)?;
                },
                16 => {
                    self.optional = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.localObjectReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.optional {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.localObjectReference.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.optional {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConfigMapEnvSource {
        ConfigMapEnvSource::new()
    }

    fn clear(&mut self) {
        self.localObjectReference.clear();
        self.optional = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConfigMapEnvSource {
        static instance: ConfigMapEnvSource = ConfigMapEnvSource {
            localObjectReference: ::protobuf::MessageField::none(),
            optional: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConfigMapEnvSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConfigMapEnvSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConfigMapEnvSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigMapEnvSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ConfigMapKeySelector)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConfigMapKeySelector {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ConfigMapKeySelector.localObjectReference)
    pub localObjectReference: ::protobuf::MessageField<LocalObjectReference>,
    // @@protoc_insertion_point(field:api.core.v1.ConfigMapKeySelector.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ConfigMapKeySelector.optional)
    pub optional: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ConfigMapKeySelector.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConfigMapKeySelector {
    fn default() -> &'a ConfigMapKeySelector {
        <ConfigMapKeySelector as ::protobuf::Message>::default_instance()
    }
}

impl ConfigMapKeySelector {
    pub fn new() -> ConfigMapKeySelector {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.LocalObjectReference localObjectReference = 1;

    pub fn localObjectReference(&self) -> &LocalObjectReference {
        self.localObjectReference.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_localObjectReference(&mut self) {
        self.localObjectReference.clear();
    }

    pub fn has_localObjectReference(&self) -> bool {
        self.localObjectReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localObjectReference(&mut self, v: LocalObjectReference) {
        self.localObjectReference = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localObjectReference(&mut self) -> &mut LocalObjectReference {
        self.localObjectReference.mut_or_insert_default()
    }

    // Take field
    pub fn take_localObjectReference(&mut self) -> LocalObjectReference {
        self.localObjectReference.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    // optional string key = 2;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool optional = 3;

    pub fn optional(&self) -> bool {
        self.optional.unwrap_or(false)
    }

    pub fn clear_optional(&mut self) {
        self.optional = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        self.optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LocalObjectReference>(
            "localObjectReference",
            |m: &ConfigMapKeySelector| { &m.localObjectReference },
            |m: &mut ConfigMapKeySelector| { &mut m.localObjectReference },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &ConfigMapKeySelector| { &m.key },
            |m: &mut ConfigMapKeySelector| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "optional",
            |m: &ConfigMapKeySelector| { &m.optional },
            |m: &mut ConfigMapKeySelector| { &mut m.optional },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConfigMapKeySelector>(
            "ConfigMapKeySelector",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConfigMapKeySelector {
    const NAME: &'static str = "ConfigMapKeySelector";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.localObjectReference)?;
                },
                18 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.optional = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.localObjectReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.optional {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.localObjectReference.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.key.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.optional {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConfigMapKeySelector {
        ConfigMapKeySelector::new()
    }

    fn clear(&mut self) {
        self.localObjectReference.clear();
        self.key = ::std::option::Option::None;
        self.optional = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConfigMapKeySelector {
        static instance: ConfigMapKeySelector = ConfigMapKeySelector {
            localObjectReference: ::protobuf::MessageField::none(),
            key: ::std::option::Option::None,
            optional: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConfigMapKeySelector {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConfigMapKeySelector").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConfigMapKeySelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigMapKeySelector {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ConfigMapList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConfigMapList {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ConfigMapList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ConfigMapList.items)
    pub items: ::std::vec::Vec<ConfigMap>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ConfigMapList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConfigMapList {
    fn default() -> &'a ConfigMapList {
        <ConfigMapList as ::protobuf::Message>::default_instance()
    }
}

impl ConfigMapList {
    pub fn new() -> ConfigMapList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.core.v1.ConfigMap items = 2;

    pub fn items(&self) -> &[ConfigMap] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ConfigMap>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ConfigMap> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ConfigMap> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ConfigMapList| { &m.metadata },
            |m: &mut ConfigMapList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ConfigMapList| { &m.items },
            |m: &mut ConfigMapList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConfigMapList>(
            "ConfigMapList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConfigMapList {
    const NAME: &'static str = "ConfigMapList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConfigMapList {
        ConfigMapList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConfigMapList {
        static instance: ConfigMapList = ConfigMapList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConfigMapList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConfigMapList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConfigMapList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigMapList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ConfigMapNodeConfigSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConfigMapNodeConfigSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ConfigMapNodeConfigSource.namespace)
    pub namespace: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ConfigMapNodeConfigSource.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ConfigMapNodeConfigSource.uid)
    pub uid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ConfigMapNodeConfigSource.resourceVersion)
    pub resourceVersion: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ConfigMapNodeConfigSource.kubeletConfigKey)
    pub kubeletConfigKey: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ConfigMapNodeConfigSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConfigMapNodeConfigSource {
    fn default() -> &'a ConfigMapNodeConfigSource {
        <ConfigMapNodeConfigSource as ::protobuf::Message>::default_instance()
    }
}

impl ConfigMapNodeConfigSource {
    pub fn new() -> ConfigMapNodeConfigSource {
        ::std::default::Default::default()
    }

    // optional string namespace = 1;

    pub fn namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_namespace(&mut self) {
        self.namespace = ::std::option::Option::None;
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string uid = 3;

    pub fn uid(&self) -> &str {
        match self.uid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_uid(&mut self) {
        self.uid = ::std::option::Option::None;
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if self.uid.is_none() {
            self.uid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        self.uid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resourceVersion = 4;

    pub fn resourceVersion(&self) -> &str {
        match self.resourceVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resourceVersion(&mut self) {
        self.resourceVersion = ::std::option::Option::None;
    }

    pub fn has_resourceVersion(&self) -> bool {
        self.resourceVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceVersion(&mut self, v: ::std::string::String) {
        self.resourceVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceVersion(&mut self) -> &mut ::std::string::String {
        if self.resourceVersion.is_none() {
            self.resourceVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resourceVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceVersion(&mut self) -> ::std::string::String {
        self.resourceVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kubeletConfigKey = 5;

    pub fn kubeletConfigKey(&self) -> &str {
        match self.kubeletConfigKey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kubeletConfigKey(&mut self) {
        self.kubeletConfigKey = ::std::option::Option::None;
    }

    pub fn has_kubeletConfigKey(&self) -> bool {
        self.kubeletConfigKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kubeletConfigKey(&mut self, v: ::std::string::String) {
        self.kubeletConfigKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kubeletConfigKey(&mut self) -> &mut ::std::string::String {
        if self.kubeletConfigKey.is_none() {
            self.kubeletConfigKey = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kubeletConfigKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_kubeletConfigKey(&mut self) -> ::std::string::String {
        self.kubeletConfigKey.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "namespace",
            |m: &ConfigMapNodeConfigSource| { &m.namespace },
            |m: &mut ConfigMapNodeConfigSource| { &mut m.namespace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ConfigMapNodeConfigSource| { &m.name },
            |m: &mut ConfigMapNodeConfigSource| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uid",
            |m: &ConfigMapNodeConfigSource| { &m.uid },
            |m: &mut ConfigMapNodeConfigSource| { &mut m.uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resourceVersion",
            |m: &ConfigMapNodeConfigSource| { &m.resourceVersion },
            |m: &mut ConfigMapNodeConfigSource| { &mut m.resourceVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kubeletConfigKey",
            |m: &ConfigMapNodeConfigSource| { &m.kubeletConfigKey },
            |m: &mut ConfigMapNodeConfigSource| { &mut m.kubeletConfigKey },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConfigMapNodeConfigSource>(
            "ConfigMapNodeConfigSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConfigMapNodeConfigSource {
    const NAME: &'static str = "ConfigMapNodeConfigSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.namespace = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.uid = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.resourceVersion = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.kubeletConfigKey = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.uid.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.resourceVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.kubeletConfigKey.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.namespace.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.uid.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.resourceVersion.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.kubeletConfigKey.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConfigMapNodeConfigSource {
        ConfigMapNodeConfigSource::new()
    }

    fn clear(&mut self) {
        self.namespace = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.uid = ::std::option::Option::None;
        self.resourceVersion = ::std::option::Option::None;
        self.kubeletConfigKey = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConfigMapNodeConfigSource {
        static instance: ConfigMapNodeConfigSource = ConfigMapNodeConfigSource {
            namespace: ::std::option::Option::None,
            name: ::std::option::Option::None,
            uid: ::std::option::Option::None,
            resourceVersion: ::std::option::Option::None,
            kubeletConfigKey: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConfigMapNodeConfigSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConfigMapNodeConfigSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConfigMapNodeConfigSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigMapNodeConfigSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ConfigMapProjection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConfigMapProjection {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ConfigMapProjection.localObjectReference)
    pub localObjectReference: ::protobuf::MessageField<LocalObjectReference>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ConfigMapProjection.items)
    pub items: ::std::vec::Vec<KeyToPath>,
    // @@protoc_insertion_point(field:api.core.v1.ConfigMapProjection.optional)
    pub optional: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ConfigMapProjection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConfigMapProjection {
    fn default() -> &'a ConfigMapProjection {
        <ConfigMapProjection as ::protobuf::Message>::default_instance()
    }
}

impl ConfigMapProjection {
    pub fn new() -> ConfigMapProjection {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.LocalObjectReference localObjectReference = 1;

    pub fn localObjectReference(&self) -> &LocalObjectReference {
        self.localObjectReference.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_localObjectReference(&mut self) {
        self.localObjectReference.clear();
    }

    pub fn has_localObjectReference(&self) -> bool {
        self.localObjectReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localObjectReference(&mut self, v: LocalObjectReference) {
        self.localObjectReference = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localObjectReference(&mut self) -> &mut LocalObjectReference {
        self.localObjectReference.mut_or_insert_default()
    }

    // Take field
    pub fn take_localObjectReference(&mut self) -> LocalObjectReference {
        self.localObjectReference.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    // repeated .api.core.v1.KeyToPath items = 2;

    pub fn items(&self) -> &[KeyToPath] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<KeyToPath>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<KeyToPath> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<KeyToPath> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    // optional bool optional = 4;

    pub fn optional(&self) -> bool {
        self.optional.unwrap_or(false)
    }

    pub fn clear_optional(&mut self) {
        self.optional = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        self.optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LocalObjectReference>(
            "localObjectReference",
            |m: &ConfigMapProjection| { &m.localObjectReference },
            |m: &mut ConfigMapProjection| { &mut m.localObjectReference },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ConfigMapProjection| { &m.items },
            |m: &mut ConfigMapProjection| { &mut m.items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "optional",
            |m: &ConfigMapProjection| { &m.optional },
            |m: &mut ConfigMapProjection| { &mut m.optional },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConfigMapProjection>(
            "ConfigMapProjection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConfigMapProjection {
    const NAME: &'static str = "ConfigMapProjection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.localObjectReference)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                32 => {
                    self.optional = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.localObjectReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.optional {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.localObjectReference.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.optional {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConfigMapProjection {
        ConfigMapProjection::new()
    }

    fn clear(&mut self) {
        self.localObjectReference.clear();
        self.items.clear();
        self.optional = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConfigMapProjection {
        static instance: ConfigMapProjection = ConfigMapProjection {
            localObjectReference: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            optional: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConfigMapProjection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConfigMapProjection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConfigMapProjection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigMapProjection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ConfigMapVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConfigMapVolumeSource {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ConfigMapVolumeSource.localObjectReference)
    pub localObjectReference: ::protobuf::MessageField<LocalObjectReference>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ConfigMapVolumeSource.items)
    pub items: ::std::vec::Vec<KeyToPath>,
    // @@protoc_insertion_point(field:api.core.v1.ConfigMapVolumeSource.defaultMode)
    pub defaultMode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.ConfigMapVolumeSource.optional)
    pub optional: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ConfigMapVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConfigMapVolumeSource {
    fn default() -> &'a ConfigMapVolumeSource {
        <ConfigMapVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl ConfigMapVolumeSource {
    pub fn new() -> ConfigMapVolumeSource {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.LocalObjectReference localObjectReference = 1;

    pub fn localObjectReference(&self) -> &LocalObjectReference {
        self.localObjectReference.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_localObjectReference(&mut self) {
        self.localObjectReference.clear();
    }

    pub fn has_localObjectReference(&self) -> bool {
        self.localObjectReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localObjectReference(&mut self, v: LocalObjectReference) {
        self.localObjectReference = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localObjectReference(&mut self) -> &mut LocalObjectReference {
        self.localObjectReference.mut_or_insert_default()
    }

    // Take field
    pub fn take_localObjectReference(&mut self) -> LocalObjectReference {
        self.localObjectReference.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    // repeated .api.core.v1.KeyToPath items = 2;

    pub fn items(&self) -> &[KeyToPath] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<KeyToPath>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<KeyToPath> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<KeyToPath> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    // optional int32 defaultMode = 3;

    pub fn defaultMode(&self) -> i32 {
        self.defaultMode.unwrap_or(0)
    }

    pub fn clear_defaultMode(&mut self) {
        self.defaultMode = ::std::option::Option::None;
    }

    pub fn has_defaultMode(&self) -> bool {
        self.defaultMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defaultMode(&mut self, v: i32) {
        self.defaultMode = ::std::option::Option::Some(v);
    }

    // optional bool optional = 4;

    pub fn optional(&self) -> bool {
        self.optional.unwrap_or(false)
    }

    pub fn clear_optional(&mut self) {
        self.optional = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        self.optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LocalObjectReference>(
            "localObjectReference",
            |m: &ConfigMapVolumeSource| { &m.localObjectReference },
            |m: &mut ConfigMapVolumeSource| { &mut m.localObjectReference },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ConfigMapVolumeSource| { &m.items },
            |m: &mut ConfigMapVolumeSource| { &mut m.items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "defaultMode",
            |m: &ConfigMapVolumeSource| { &m.defaultMode },
            |m: &mut ConfigMapVolumeSource| { &mut m.defaultMode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "optional",
            |m: &ConfigMapVolumeSource| { &m.optional },
            |m: &mut ConfigMapVolumeSource| { &mut m.optional },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConfigMapVolumeSource>(
            "ConfigMapVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConfigMapVolumeSource {
    const NAME: &'static str = "ConfigMapVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.localObjectReference)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                24 => {
                    self.defaultMode = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.optional = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.localObjectReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.defaultMode {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.optional {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.localObjectReference.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.defaultMode {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.optional {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConfigMapVolumeSource {
        ConfigMapVolumeSource::new()
    }

    fn clear(&mut self) {
        self.localObjectReference.clear();
        self.items.clear();
        self.defaultMode = ::std::option::Option::None;
        self.optional = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConfigMapVolumeSource {
        static instance: ConfigMapVolumeSource = ConfigMapVolumeSource {
            localObjectReference: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            defaultMode: ::std::option::Option::None,
            optional: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConfigMapVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConfigMapVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConfigMapVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigMapVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.Container)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Container {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.Container.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.Container.image)
    pub image: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Container.command)
    pub command: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Container.args)
    pub args: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.Container.workingDir)
    pub workingDir: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Container.ports)
    pub ports: ::std::vec::Vec<ContainerPort>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Container.envFrom)
    pub envFrom: ::std::vec::Vec<EnvFromSource>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Container.env)
    pub env: ::std::vec::Vec<EnvVar>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Container.resources)
    pub resources: ::protobuf::MessageField<ResourceRequirements>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Container.resizePolicy)
    pub resizePolicy: ::std::vec::Vec<ContainerResizePolicy>,
    // @@protoc_insertion_point(field:api.core.v1.Container.restartPolicy)
    pub restartPolicy: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Container.volumeMounts)
    pub volumeMounts: ::std::vec::Vec<VolumeMount>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Container.volumeDevices)
    pub volumeDevices: ::std::vec::Vec<VolumeDevice>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Container.livenessProbe)
    pub livenessProbe: ::protobuf::MessageField<Probe>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Container.readinessProbe)
    pub readinessProbe: ::protobuf::MessageField<Probe>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Container.startupProbe)
    pub startupProbe: ::protobuf::MessageField<Probe>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Container.lifecycle)
    pub lifecycle: ::protobuf::MessageField<Lifecycle>,
    // @@protoc_insertion_point(field:api.core.v1.Container.terminationMessagePath)
    pub terminationMessagePath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.Container.terminationMessagePolicy)
    pub terminationMessagePolicy: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.Container.imagePullPolicy)
    pub imagePullPolicy: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Container.securityContext)
    pub securityContext: ::protobuf::MessageField<SecurityContext>,
    // @@protoc_insertion_point(field:api.core.v1.Container.stdin)
    pub stdin: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.Container.stdinOnce)
    pub stdinOnce: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.Container.tty)
    pub tty: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.Container.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Container {
    fn default() -> &'a Container {
        <Container as ::protobuf::Message>::default_instance()
    }
}

impl Container {
    pub fn new() -> Container {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string image = 2;

    pub fn image(&self) -> &str {
        match self.image.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_image(&mut self) {
        self.image = ::std::option::Option::None;
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        if self.image.is_none() {
            self.image = ::std::option::Option::Some(::std::string::String::new());
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        self.image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string command = 3;

    pub fn command(&self) -> &[::std::string::String] {
        &self.command
    }

    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.command = v;
    }

    // Mutable pointer to the field.
    pub fn mut_command(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.command
    }

    // Take field
    pub fn take_command(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.command, ::std::vec::Vec::new())
    }

    // repeated string args = 4;

    pub fn args(&self) -> &[::std::string::String] {
        &self.args
    }

    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.args, ::std::vec::Vec::new())
    }

    // optional string workingDir = 5;

    pub fn workingDir(&self) -> &str {
        match self.workingDir.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_workingDir(&mut self) {
        self.workingDir = ::std::option::Option::None;
    }

    pub fn has_workingDir(&self) -> bool {
        self.workingDir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workingDir(&mut self, v: ::std::string::String) {
        self.workingDir = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workingDir(&mut self) -> &mut ::std::string::String {
        if self.workingDir.is_none() {
            self.workingDir = ::std::option::Option::Some(::std::string::String::new());
        }
        self.workingDir.as_mut().unwrap()
    }

    // Take field
    pub fn take_workingDir(&mut self) -> ::std::string::String {
        self.workingDir.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.core.v1.ContainerPort ports = 6;

    pub fn ports(&self) -> &[ContainerPort] {
        &self.ports
    }

    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::std::vec::Vec<ContainerPort>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::std::vec::Vec<ContainerPort> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::std::vec::Vec<ContainerPort> {
        ::std::mem::replace(&mut self.ports, ::std::vec::Vec::new())
    }

    // repeated .api.core.v1.EnvFromSource envFrom = 19;

    pub fn envFrom(&self) -> &[EnvFromSource] {
        &self.envFrom
    }

    pub fn clear_envFrom(&mut self) {
        self.envFrom.clear();
    }

    // Param is passed by value, moved
    pub fn set_envFrom(&mut self, v: ::std::vec::Vec<EnvFromSource>) {
        self.envFrom = v;
    }

    // Mutable pointer to the field.
    pub fn mut_envFrom(&mut self) -> &mut ::std::vec::Vec<EnvFromSource> {
        &mut self.envFrom
    }

    // Take field
    pub fn take_envFrom(&mut self) -> ::std::vec::Vec<EnvFromSource> {
        ::std::mem::replace(&mut self.envFrom, ::std::vec::Vec::new())
    }

    // repeated .api.core.v1.EnvVar env = 7;

    pub fn env(&self) -> &[EnvVar] {
        &self.env
    }

    pub fn clear_env(&mut self) {
        self.env.clear();
    }

    // Param is passed by value, moved
    pub fn set_env(&mut self, v: ::std::vec::Vec<EnvVar>) {
        self.env = v;
    }

    // Mutable pointer to the field.
    pub fn mut_env(&mut self) -> &mut ::std::vec::Vec<EnvVar> {
        &mut self.env
    }

    // Take field
    pub fn take_env(&mut self) -> ::std::vec::Vec<EnvVar> {
        ::std::mem::replace(&mut self.env, ::std::vec::Vec::new())
    }

    // optional .api.core.v1.ResourceRequirements resources = 8;

    pub fn resources(&self) -> &ResourceRequirements {
        self.resources.as_ref().unwrap_or_else(|| <ResourceRequirements as ::protobuf::Message>::default_instance())
    }

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    pub fn has_resources(&self) -> bool {
        self.resources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ResourceRequirements) {
        self.resources = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resources(&mut self) -> &mut ResourceRequirements {
        self.resources.mut_or_insert_default()
    }

    // Take field
    pub fn take_resources(&mut self) -> ResourceRequirements {
        self.resources.take().unwrap_or_else(|| ResourceRequirements::new())
    }

    // repeated .api.core.v1.ContainerResizePolicy resizePolicy = 23;

    pub fn resizePolicy(&self) -> &[ContainerResizePolicy] {
        &self.resizePolicy
    }

    pub fn clear_resizePolicy(&mut self) {
        self.resizePolicy.clear();
    }

    // Param is passed by value, moved
    pub fn set_resizePolicy(&mut self, v: ::std::vec::Vec<ContainerResizePolicy>) {
        self.resizePolicy = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resizePolicy(&mut self) -> &mut ::std::vec::Vec<ContainerResizePolicy> {
        &mut self.resizePolicy
    }

    // Take field
    pub fn take_resizePolicy(&mut self) -> ::std::vec::Vec<ContainerResizePolicy> {
        ::std::mem::replace(&mut self.resizePolicy, ::std::vec::Vec::new())
    }

    // optional string restartPolicy = 24;

    pub fn restartPolicy(&self) -> &str {
        match self.restartPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_restartPolicy(&mut self) {
        self.restartPolicy = ::std::option::Option::None;
    }

    pub fn has_restartPolicy(&self) -> bool {
        self.restartPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_restartPolicy(&mut self, v: ::std::string::String) {
        self.restartPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_restartPolicy(&mut self) -> &mut ::std::string::String {
        if self.restartPolicy.is_none() {
            self.restartPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.restartPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_restartPolicy(&mut self) -> ::std::string::String {
        self.restartPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.core.v1.VolumeMount volumeMounts = 9;

    pub fn volumeMounts(&self) -> &[VolumeMount] {
        &self.volumeMounts
    }

    pub fn clear_volumeMounts(&mut self) {
        self.volumeMounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumeMounts(&mut self, v: ::std::vec::Vec<VolumeMount>) {
        self.volumeMounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumeMounts(&mut self) -> &mut ::std::vec::Vec<VolumeMount> {
        &mut self.volumeMounts
    }

    // Take field
    pub fn take_volumeMounts(&mut self) -> ::std::vec::Vec<VolumeMount> {
        ::std::mem::replace(&mut self.volumeMounts, ::std::vec::Vec::new())
    }

    // repeated .api.core.v1.VolumeDevice volumeDevices = 21;

    pub fn volumeDevices(&self) -> &[VolumeDevice] {
        &self.volumeDevices
    }

    pub fn clear_volumeDevices(&mut self) {
        self.volumeDevices.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumeDevices(&mut self, v: ::std::vec::Vec<VolumeDevice>) {
        self.volumeDevices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumeDevices(&mut self) -> &mut ::std::vec::Vec<VolumeDevice> {
        &mut self.volumeDevices
    }

    // Take field
    pub fn take_volumeDevices(&mut self) -> ::std::vec::Vec<VolumeDevice> {
        ::std::mem::replace(&mut self.volumeDevices, ::std::vec::Vec::new())
    }

    // optional .api.core.v1.Probe livenessProbe = 10;

    pub fn livenessProbe(&self) -> &Probe {
        self.livenessProbe.as_ref().unwrap_or_else(|| <Probe as ::protobuf::Message>::default_instance())
    }

    pub fn clear_livenessProbe(&mut self) {
        self.livenessProbe.clear();
    }

    pub fn has_livenessProbe(&self) -> bool {
        self.livenessProbe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_livenessProbe(&mut self, v: Probe) {
        self.livenessProbe = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_livenessProbe(&mut self) -> &mut Probe {
        self.livenessProbe.mut_or_insert_default()
    }

    // Take field
    pub fn take_livenessProbe(&mut self) -> Probe {
        self.livenessProbe.take().unwrap_or_else(|| Probe::new())
    }

    // optional .api.core.v1.Probe readinessProbe = 11;

    pub fn readinessProbe(&self) -> &Probe {
        self.readinessProbe.as_ref().unwrap_or_else(|| <Probe as ::protobuf::Message>::default_instance())
    }

    pub fn clear_readinessProbe(&mut self) {
        self.readinessProbe.clear();
    }

    pub fn has_readinessProbe(&self) -> bool {
        self.readinessProbe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readinessProbe(&mut self, v: Probe) {
        self.readinessProbe = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_readinessProbe(&mut self) -> &mut Probe {
        self.readinessProbe.mut_or_insert_default()
    }

    // Take field
    pub fn take_readinessProbe(&mut self) -> Probe {
        self.readinessProbe.take().unwrap_or_else(|| Probe::new())
    }

    // optional .api.core.v1.Probe startupProbe = 22;

    pub fn startupProbe(&self) -> &Probe {
        self.startupProbe.as_ref().unwrap_or_else(|| <Probe as ::protobuf::Message>::default_instance())
    }

    pub fn clear_startupProbe(&mut self) {
        self.startupProbe.clear();
    }

    pub fn has_startupProbe(&self) -> bool {
        self.startupProbe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startupProbe(&mut self, v: Probe) {
        self.startupProbe = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startupProbe(&mut self) -> &mut Probe {
        self.startupProbe.mut_or_insert_default()
    }

    // Take field
    pub fn take_startupProbe(&mut self) -> Probe {
        self.startupProbe.take().unwrap_or_else(|| Probe::new())
    }

    // optional .api.core.v1.Lifecycle lifecycle = 12;

    pub fn lifecycle(&self) -> &Lifecycle {
        self.lifecycle.as_ref().unwrap_or_else(|| <Lifecycle as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lifecycle(&mut self) {
        self.lifecycle.clear();
    }

    pub fn has_lifecycle(&self) -> bool {
        self.lifecycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lifecycle(&mut self, v: Lifecycle) {
        self.lifecycle = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lifecycle(&mut self) -> &mut Lifecycle {
        self.lifecycle.mut_or_insert_default()
    }

    // Take field
    pub fn take_lifecycle(&mut self) -> Lifecycle {
        self.lifecycle.take().unwrap_or_else(|| Lifecycle::new())
    }

    // optional string terminationMessagePath = 13;

    pub fn terminationMessagePath(&self) -> &str {
        match self.terminationMessagePath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_terminationMessagePath(&mut self) {
        self.terminationMessagePath = ::std::option::Option::None;
    }

    pub fn has_terminationMessagePath(&self) -> bool {
        self.terminationMessagePath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_terminationMessagePath(&mut self, v: ::std::string::String) {
        self.terminationMessagePath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_terminationMessagePath(&mut self) -> &mut ::std::string::String {
        if self.terminationMessagePath.is_none() {
            self.terminationMessagePath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.terminationMessagePath.as_mut().unwrap()
    }

    // Take field
    pub fn take_terminationMessagePath(&mut self) -> ::std::string::String {
        self.terminationMessagePath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string terminationMessagePolicy = 20;

    pub fn terminationMessagePolicy(&self) -> &str {
        match self.terminationMessagePolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_terminationMessagePolicy(&mut self) {
        self.terminationMessagePolicy = ::std::option::Option::None;
    }

    pub fn has_terminationMessagePolicy(&self) -> bool {
        self.terminationMessagePolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_terminationMessagePolicy(&mut self, v: ::std::string::String) {
        self.terminationMessagePolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_terminationMessagePolicy(&mut self) -> &mut ::std::string::String {
        if self.terminationMessagePolicy.is_none() {
            self.terminationMessagePolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.terminationMessagePolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_terminationMessagePolicy(&mut self) -> ::std::string::String {
        self.terminationMessagePolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string imagePullPolicy = 14;

    pub fn imagePullPolicy(&self) -> &str {
        match self.imagePullPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_imagePullPolicy(&mut self) {
        self.imagePullPolicy = ::std::option::Option::None;
    }

    pub fn has_imagePullPolicy(&self) -> bool {
        self.imagePullPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_imagePullPolicy(&mut self, v: ::std::string::String) {
        self.imagePullPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_imagePullPolicy(&mut self) -> &mut ::std::string::String {
        if self.imagePullPolicy.is_none() {
            self.imagePullPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.imagePullPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_imagePullPolicy(&mut self) -> ::std::string::String {
        self.imagePullPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.SecurityContext securityContext = 15;

    pub fn securityContext(&self) -> &SecurityContext {
        self.securityContext.as_ref().unwrap_or_else(|| <SecurityContext as ::protobuf::Message>::default_instance())
    }

    pub fn clear_securityContext(&mut self) {
        self.securityContext.clear();
    }

    pub fn has_securityContext(&self) -> bool {
        self.securityContext.is_some()
    }

    // Param is passed by value, moved
    pub fn set_securityContext(&mut self, v: SecurityContext) {
        self.securityContext = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_securityContext(&mut self) -> &mut SecurityContext {
        self.securityContext.mut_or_insert_default()
    }

    // Take field
    pub fn take_securityContext(&mut self) -> SecurityContext {
        self.securityContext.take().unwrap_or_else(|| SecurityContext::new())
    }

    // optional bool stdin = 16;

    pub fn stdin(&self) -> bool {
        self.stdin.unwrap_or(false)
    }

    pub fn clear_stdin(&mut self) {
        self.stdin = ::std::option::Option::None;
    }

    pub fn has_stdin(&self) -> bool {
        self.stdin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdin(&mut self, v: bool) {
        self.stdin = ::std::option::Option::Some(v);
    }

    // optional bool stdinOnce = 17;

    pub fn stdinOnce(&self) -> bool {
        self.stdinOnce.unwrap_or(false)
    }

    pub fn clear_stdinOnce(&mut self) {
        self.stdinOnce = ::std::option::Option::None;
    }

    pub fn has_stdinOnce(&self) -> bool {
        self.stdinOnce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdinOnce(&mut self, v: bool) {
        self.stdinOnce = ::std::option::Option::Some(v);
    }

    // optional bool tty = 18;

    pub fn tty(&self) -> bool {
        self.tty.unwrap_or(false)
    }

    pub fn clear_tty(&mut self) {
        self.tty = ::std::option::Option::None;
    }

    pub fn has_tty(&self) -> bool {
        self.tty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tty(&mut self, v: bool) {
        self.tty = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(24);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Container| { &m.name },
            |m: &mut Container| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "image",
            |m: &Container| { &m.image },
            |m: &mut Container| { &mut m.image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "command",
            |m: &Container| { &m.command },
            |m: &mut Container| { &mut m.command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "args",
            |m: &Container| { &m.args },
            |m: &mut Container| { &mut m.args },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "workingDir",
            |m: &Container| { &m.workingDir },
            |m: &mut Container| { &mut m.workingDir },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ports",
            |m: &Container| { &m.ports },
            |m: &mut Container| { &mut m.ports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "envFrom",
            |m: &Container| { &m.envFrom },
            |m: &mut Container| { &mut m.envFrom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "env",
            |m: &Container| { &m.env },
            |m: &mut Container| { &mut m.env },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceRequirements>(
            "resources",
            |m: &Container| { &m.resources },
            |m: &mut Container| { &mut m.resources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resizePolicy",
            |m: &Container| { &m.resizePolicy },
            |m: &mut Container| { &mut m.resizePolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "restartPolicy",
            |m: &Container| { &m.restartPolicy },
            |m: &mut Container| { &mut m.restartPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "volumeMounts",
            |m: &Container| { &m.volumeMounts },
            |m: &mut Container| { &mut m.volumeMounts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "volumeDevices",
            |m: &Container| { &m.volumeDevices },
            |m: &mut Container| { &mut m.volumeDevices },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Probe>(
            "livenessProbe",
            |m: &Container| { &m.livenessProbe },
            |m: &mut Container| { &mut m.livenessProbe },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Probe>(
            "readinessProbe",
            |m: &Container| { &m.readinessProbe },
            |m: &mut Container| { &mut m.readinessProbe },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Probe>(
            "startupProbe",
            |m: &Container| { &m.startupProbe },
            |m: &mut Container| { &mut m.startupProbe },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Lifecycle>(
            "lifecycle",
            |m: &Container| { &m.lifecycle },
            |m: &mut Container| { &mut m.lifecycle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "terminationMessagePath",
            |m: &Container| { &m.terminationMessagePath },
            |m: &mut Container| { &mut m.terminationMessagePath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "terminationMessagePolicy",
            |m: &Container| { &m.terminationMessagePolicy },
            |m: &mut Container| { &mut m.terminationMessagePolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "imagePullPolicy",
            |m: &Container| { &m.imagePullPolicy },
            |m: &mut Container| { &mut m.imagePullPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SecurityContext>(
            "securityContext",
            |m: &Container| { &m.securityContext },
            |m: &mut Container| { &mut m.securityContext },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stdin",
            |m: &Container| { &m.stdin },
            |m: &mut Container| { &mut m.stdin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stdinOnce",
            |m: &Container| { &m.stdinOnce },
            |m: &mut Container| { &mut m.stdinOnce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tty",
            |m: &Container| { &m.tty },
            |m: &mut Container| { &mut m.tty },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Container>(
            "Container",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Container {
    const NAME: &'static str = "Container";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.image = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.command.push(is.read_string()?);
                },
                34 => {
                    self.args.push(is.read_string()?);
                },
                42 => {
                    self.workingDir = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.ports.push(is.read_message()?);
                },
                154 => {
                    self.envFrom.push(is.read_message()?);
                },
                58 => {
                    self.env.push(is.read_message()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resources)?;
                },
                186 => {
                    self.resizePolicy.push(is.read_message()?);
                },
                194 => {
                    self.restartPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.volumeMounts.push(is.read_message()?);
                },
                170 => {
                    self.volumeDevices.push(is.read_message()?);
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.livenessProbe)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.readinessProbe)?;
                },
                178 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.startupProbe)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lifecycle)?;
                },
                106 => {
                    self.terminationMessagePath = ::std::option::Option::Some(is.read_string()?);
                },
                162 => {
                    self.terminationMessagePolicy = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    self.imagePullPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.securityContext)?;
                },
                128 => {
                    self.stdin = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.stdinOnce = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.tty = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.image.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.command {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.args {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.workingDir.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.envFrom {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.env {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.resources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.resizePolicy {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.restartPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(24, &v);
        }
        for value in &self.volumeMounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.volumeDevices {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.livenessProbe.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.readinessProbe.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.startupProbe.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.lifecycle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.terminationMessagePath.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.terminationMessagePolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.imagePullPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.securityContext.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stdin {
            my_size += 2 + 1;
        }
        if let Some(v) = self.stdinOnce {
            my_size += 2 + 1;
        }
        if let Some(v) = self.tty {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.image.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.command {
            os.write_string(3, &v)?;
        };
        for v in &self.args {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.workingDir.as_ref() {
            os.write_string(5, v)?;
        }
        for v in &self.ports {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.envFrom {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        };
        for v in &self.env {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.resources.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        for v in &self.resizePolicy {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        };
        if let Some(v) = self.restartPolicy.as_ref() {
            os.write_string(24, v)?;
        }
        for v in &self.volumeMounts {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        for v in &self.volumeDevices {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        };
        if let Some(v) = self.livenessProbe.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.readinessProbe.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.startupProbe.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.lifecycle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.terminationMessagePath.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.terminationMessagePolicy.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.imagePullPolicy.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.securityContext.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.stdin {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.stdinOnce {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.tty {
            os.write_bool(18, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Container {
        Container::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.image = ::std::option::Option::None;
        self.command.clear();
        self.args.clear();
        self.workingDir = ::std::option::Option::None;
        self.ports.clear();
        self.envFrom.clear();
        self.env.clear();
        self.resources.clear();
        self.resizePolicy.clear();
        self.restartPolicy = ::std::option::Option::None;
        self.volumeMounts.clear();
        self.volumeDevices.clear();
        self.livenessProbe.clear();
        self.readinessProbe.clear();
        self.startupProbe.clear();
        self.lifecycle.clear();
        self.terminationMessagePath = ::std::option::Option::None;
        self.terminationMessagePolicy = ::std::option::Option::None;
        self.imagePullPolicy = ::std::option::Option::None;
        self.securityContext.clear();
        self.stdin = ::std::option::Option::None;
        self.stdinOnce = ::std::option::Option::None;
        self.tty = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Container {
        static instance: Container = Container {
            name: ::std::option::Option::None,
            image: ::std::option::Option::None,
            command: ::std::vec::Vec::new(),
            args: ::std::vec::Vec::new(),
            workingDir: ::std::option::Option::None,
            ports: ::std::vec::Vec::new(),
            envFrom: ::std::vec::Vec::new(),
            env: ::std::vec::Vec::new(),
            resources: ::protobuf::MessageField::none(),
            resizePolicy: ::std::vec::Vec::new(),
            restartPolicy: ::std::option::Option::None,
            volumeMounts: ::std::vec::Vec::new(),
            volumeDevices: ::std::vec::Vec::new(),
            livenessProbe: ::protobuf::MessageField::none(),
            readinessProbe: ::protobuf::MessageField::none(),
            startupProbe: ::protobuf::MessageField::none(),
            lifecycle: ::protobuf::MessageField::none(),
            terminationMessagePath: ::std::option::Option::None,
            terminationMessagePolicy: ::std::option::Option::None,
            imagePullPolicy: ::std::option::Option::None,
            securityContext: ::protobuf::MessageField::none(),
            stdin: ::std::option::Option::None,
            stdinOnce: ::std::option::Option::None,
            tty: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Container {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Container").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Container {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Container {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ContainerImage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ContainerImage {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ContainerImage.names)
    pub names: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ContainerImage.sizeBytes)
    pub sizeBytes: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ContainerImage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContainerImage {
    fn default() -> &'a ContainerImage {
        <ContainerImage as ::protobuf::Message>::default_instance()
    }
}

impl ContainerImage {
    pub fn new() -> ContainerImage {
        ::std::default::Default::default()
    }

    // repeated string names = 1;

    pub fn names(&self) -> &[::std::string::String] {
        &self.names
    }

    pub fn clear_names(&mut self) {
        self.names.clear();
    }

    // Param is passed by value, moved
    pub fn set_names(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_names(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.names
    }

    // Take field
    pub fn take_names(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.names, ::std::vec::Vec::new())
    }

    // optional int64 sizeBytes = 2;

    pub fn sizeBytes(&self) -> i64 {
        self.sizeBytes.unwrap_or(0)
    }

    pub fn clear_sizeBytes(&mut self) {
        self.sizeBytes = ::std::option::Option::None;
    }

    pub fn has_sizeBytes(&self) -> bool {
        self.sizeBytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sizeBytes(&mut self, v: i64) {
        self.sizeBytes = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "names",
            |m: &ContainerImage| { &m.names },
            |m: &mut ContainerImage| { &mut m.names },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sizeBytes",
            |m: &ContainerImage| { &m.sizeBytes },
            |m: &mut ContainerImage| { &mut m.sizeBytes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContainerImage>(
            "ContainerImage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContainerImage {
    const NAME: &'static str = "ContainerImage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.names.push(is.read_string()?);
                },
                16 => {
                    self.sizeBytes = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.names {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.sizeBytes {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.names {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.sizeBytes {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContainerImage {
        ContainerImage::new()
    }

    fn clear(&mut self) {
        self.names.clear();
        self.sizeBytes = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContainerImage {
        static instance: ContainerImage = ContainerImage {
            names: ::std::vec::Vec::new(),
            sizeBytes: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContainerImage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContainerImage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContainerImage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerImage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ContainerPort)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ContainerPort {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ContainerPort.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ContainerPort.hostPort)
    pub hostPort: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.ContainerPort.containerPort)
    pub containerPort: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.ContainerPort.protocol)
    pub protocol: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ContainerPort.hostIP)
    pub hostIP: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ContainerPort.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContainerPort {
    fn default() -> &'a ContainerPort {
        <ContainerPort as ::protobuf::Message>::default_instance()
    }
}

impl ContainerPort {
    pub fn new() -> ContainerPort {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 hostPort = 2;

    pub fn hostPort(&self) -> i32 {
        self.hostPort.unwrap_or(0)
    }

    pub fn clear_hostPort(&mut self) {
        self.hostPort = ::std::option::Option::None;
    }

    pub fn has_hostPort(&self) -> bool {
        self.hostPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostPort(&mut self, v: i32) {
        self.hostPort = ::std::option::Option::Some(v);
    }

    // optional int32 containerPort = 3;

    pub fn containerPort(&self) -> i32 {
        self.containerPort.unwrap_or(0)
    }

    pub fn clear_containerPort(&mut self) {
        self.containerPort = ::std::option::Option::None;
    }

    pub fn has_containerPort(&self) -> bool {
        self.containerPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_containerPort(&mut self, v: i32) {
        self.containerPort = ::std::option::Option::Some(v);
    }

    // optional string protocol = 4;

    pub fn protocol(&self) -> &str {
        match self.protocol.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_protocol(&mut self) {
        self.protocol = ::std::option::Option::None;
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol = ::std::option::Option::Some(::std::string::String::new());
        }
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string hostIP = 5;

    pub fn hostIP(&self) -> &str {
        match self.hostIP.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hostIP(&mut self) {
        self.hostIP = ::std::option::Option::None;
    }

    pub fn has_hostIP(&self) -> bool {
        self.hostIP.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostIP(&mut self, v: ::std::string::String) {
        self.hostIP = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostIP(&mut self) -> &mut ::std::string::String {
        if self.hostIP.is_none() {
            self.hostIP = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hostIP.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostIP(&mut self) -> ::std::string::String {
        self.hostIP.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ContainerPort| { &m.name },
            |m: &mut ContainerPort| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hostPort",
            |m: &ContainerPort| { &m.hostPort },
            |m: &mut ContainerPort| { &mut m.hostPort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "containerPort",
            |m: &ContainerPort| { &m.containerPort },
            |m: &mut ContainerPort| { &mut m.containerPort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol",
            |m: &ContainerPort| { &m.protocol },
            |m: &mut ContainerPort| { &mut m.protocol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hostIP",
            |m: &ContainerPort| { &m.hostIP },
            |m: &mut ContainerPort| { &mut m.hostIP },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContainerPort>(
            "ContainerPort",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContainerPort {
    const NAME: &'static str = "ContainerPort";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.hostPort = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.containerPort = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.protocol = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.hostIP = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.hostPort {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.containerPort {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.protocol.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.hostIP.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.hostPort {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.containerPort {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.protocol.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.hostIP.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContainerPort {
        ContainerPort::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.hostPort = ::std::option::Option::None;
        self.containerPort = ::std::option::Option::None;
        self.protocol = ::std::option::Option::None;
        self.hostIP = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContainerPort {
        static instance: ContainerPort = ContainerPort {
            name: ::std::option::Option::None,
            hostPort: ::std::option::Option::None,
            containerPort: ::std::option::Option::None,
            protocol: ::std::option::Option::None,
            hostIP: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContainerPort {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContainerPort").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContainerPort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerPort {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ContainerResizePolicy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ContainerResizePolicy {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ContainerResizePolicy.resourceName)
    pub resourceName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ContainerResizePolicy.restartPolicy)
    pub restartPolicy: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ContainerResizePolicy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContainerResizePolicy {
    fn default() -> &'a ContainerResizePolicy {
        <ContainerResizePolicy as ::protobuf::Message>::default_instance()
    }
}

impl ContainerResizePolicy {
    pub fn new() -> ContainerResizePolicy {
        ::std::default::Default::default()
    }

    // optional string resourceName = 1;

    pub fn resourceName(&self) -> &str {
        match self.resourceName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resourceName(&mut self) {
        self.resourceName = ::std::option::Option::None;
    }

    pub fn has_resourceName(&self) -> bool {
        self.resourceName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceName(&mut self, v: ::std::string::String) {
        self.resourceName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceName(&mut self) -> &mut ::std::string::String {
        if self.resourceName.is_none() {
            self.resourceName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resourceName.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceName(&mut self) -> ::std::string::String {
        self.resourceName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string restartPolicy = 2;

    pub fn restartPolicy(&self) -> &str {
        match self.restartPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_restartPolicy(&mut self) {
        self.restartPolicy = ::std::option::Option::None;
    }

    pub fn has_restartPolicy(&self) -> bool {
        self.restartPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_restartPolicy(&mut self, v: ::std::string::String) {
        self.restartPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_restartPolicy(&mut self) -> &mut ::std::string::String {
        if self.restartPolicy.is_none() {
            self.restartPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.restartPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_restartPolicy(&mut self) -> ::std::string::String {
        self.restartPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resourceName",
            |m: &ContainerResizePolicy| { &m.resourceName },
            |m: &mut ContainerResizePolicy| { &mut m.resourceName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "restartPolicy",
            |m: &ContainerResizePolicy| { &m.restartPolicy },
            |m: &mut ContainerResizePolicy| { &mut m.restartPolicy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContainerResizePolicy>(
            "ContainerResizePolicy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContainerResizePolicy {
    const NAME: &'static str = "ContainerResizePolicy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.resourceName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.restartPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.resourceName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.restartPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.resourceName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.restartPolicy.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContainerResizePolicy {
        ContainerResizePolicy::new()
    }

    fn clear(&mut self) {
        self.resourceName = ::std::option::Option::None;
        self.restartPolicy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContainerResizePolicy {
        static instance: ContainerResizePolicy = ContainerResizePolicy {
            resourceName: ::std::option::Option::None,
            restartPolicy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContainerResizePolicy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContainerResizePolicy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContainerResizePolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerResizePolicy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ContainerState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ContainerState {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ContainerState.waiting)
    pub waiting: ::protobuf::MessageField<ContainerStateWaiting>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ContainerState.running)
    pub running: ::protobuf::MessageField<ContainerStateRunning>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ContainerState.terminated)
    pub terminated: ::protobuf::MessageField<ContainerStateTerminated>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ContainerState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContainerState {
    fn default() -> &'a ContainerState {
        <ContainerState as ::protobuf::Message>::default_instance()
    }
}

impl ContainerState {
    pub fn new() -> ContainerState {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.ContainerStateWaiting waiting = 1;

    pub fn waiting(&self) -> &ContainerStateWaiting {
        self.waiting.as_ref().unwrap_or_else(|| <ContainerStateWaiting as ::protobuf::Message>::default_instance())
    }

    pub fn clear_waiting(&mut self) {
        self.waiting.clear();
    }

    pub fn has_waiting(&self) -> bool {
        self.waiting.is_some()
    }

    // Param is passed by value, moved
    pub fn set_waiting(&mut self, v: ContainerStateWaiting) {
        self.waiting = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_waiting(&mut self) -> &mut ContainerStateWaiting {
        self.waiting.mut_or_insert_default()
    }

    // Take field
    pub fn take_waiting(&mut self) -> ContainerStateWaiting {
        self.waiting.take().unwrap_or_else(|| ContainerStateWaiting::new())
    }

    // optional .api.core.v1.ContainerStateRunning running = 2;

    pub fn running(&self) -> &ContainerStateRunning {
        self.running.as_ref().unwrap_or_else(|| <ContainerStateRunning as ::protobuf::Message>::default_instance())
    }

    pub fn clear_running(&mut self) {
        self.running.clear();
    }

    pub fn has_running(&self) -> bool {
        self.running.is_some()
    }

    // Param is passed by value, moved
    pub fn set_running(&mut self, v: ContainerStateRunning) {
        self.running = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_running(&mut self) -> &mut ContainerStateRunning {
        self.running.mut_or_insert_default()
    }

    // Take field
    pub fn take_running(&mut self) -> ContainerStateRunning {
        self.running.take().unwrap_or_else(|| ContainerStateRunning::new())
    }

    // optional .api.core.v1.ContainerStateTerminated terminated = 3;

    pub fn terminated(&self) -> &ContainerStateTerminated {
        self.terminated.as_ref().unwrap_or_else(|| <ContainerStateTerminated as ::protobuf::Message>::default_instance())
    }

    pub fn clear_terminated(&mut self) {
        self.terminated.clear();
    }

    pub fn has_terminated(&self) -> bool {
        self.terminated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_terminated(&mut self, v: ContainerStateTerminated) {
        self.terminated = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_terminated(&mut self) -> &mut ContainerStateTerminated {
        self.terminated.mut_or_insert_default()
    }

    // Take field
    pub fn take_terminated(&mut self) -> ContainerStateTerminated {
        self.terminated.take().unwrap_or_else(|| ContainerStateTerminated::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContainerStateWaiting>(
            "waiting",
            |m: &ContainerState| { &m.waiting },
            |m: &mut ContainerState| { &mut m.waiting },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContainerStateRunning>(
            "running",
            |m: &ContainerState| { &m.running },
            |m: &mut ContainerState| { &mut m.running },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContainerStateTerminated>(
            "terminated",
            |m: &ContainerState| { &m.terminated },
            |m: &mut ContainerState| { &mut m.terminated },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContainerState>(
            "ContainerState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContainerState {
    const NAME: &'static str = "ContainerState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.waiting)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.running)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.terminated)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.waiting.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.running.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.terminated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.waiting.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.running.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.terminated.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContainerState {
        ContainerState::new()
    }

    fn clear(&mut self) {
        self.waiting.clear();
        self.running.clear();
        self.terminated.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContainerState {
        static instance: ContainerState = ContainerState {
            waiting: ::protobuf::MessageField::none(),
            running: ::protobuf::MessageField::none(),
            terminated: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContainerState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContainerState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContainerState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ContainerStateRunning)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ContainerStateRunning {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ContainerStateRunning.startedAt)
    pub startedAt: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ContainerStateRunning.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContainerStateRunning {
    fn default() -> &'a ContainerStateRunning {
        <ContainerStateRunning as ::protobuf::Message>::default_instance()
    }
}

impl ContainerStateRunning {
    pub fn new() -> ContainerStateRunning {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time startedAt = 1;

    pub fn startedAt(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.startedAt.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_startedAt(&mut self) {
        self.startedAt.clear();
    }

    pub fn has_startedAt(&self) -> bool {
        self.startedAt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startedAt(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::Time) {
        self.startedAt = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startedAt(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.startedAt.mut_or_insert_default()
    }

    // Take field
    pub fn take_startedAt(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.startedAt.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>(
            "startedAt",
            |m: &ContainerStateRunning| { &m.startedAt },
            |m: &mut ContainerStateRunning| { &mut m.startedAt },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContainerStateRunning>(
            "ContainerStateRunning",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContainerStateRunning {
    const NAME: &'static str = "ContainerStateRunning";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.startedAt)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.startedAt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.startedAt.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContainerStateRunning {
        ContainerStateRunning::new()
    }

    fn clear(&mut self) {
        self.startedAt.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContainerStateRunning {
        static instance: ContainerStateRunning = ContainerStateRunning {
            startedAt: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContainerStateRunning {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContainerStateRunning").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContainerStateRunning {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerStateRunning {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ContainerStateTerminated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ContainerStateTerminated {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ContainerStateTerminated.exitCode)
    pub exitCode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.ContainerStateTerminated.signal)
    pub signal: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.ContainerStateTerminated.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ContainerStateTerminated.message)
    pub message: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ContainerStateTerminated.startedAt)
    pub startedAt: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ContainerStateTerminated.finishedAt)
    pub finishedAt: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:api.core.v1.ContainerStateTerminated.containerID)
    pub containerID: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ContainerStateTerminated.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContainerStateTerminated {
    fn default() -> &'a ContainerStateTerminated {
        <ContainerStateTerminated as ::protobuf::Message>::default_instance()
    }
}

impl ContainerStateTerminated {
    pub fn new() -> ContainerStateTerminated {
        ::std::default::Default::default()
    }

    // optional int32 exitCode = 1;

    pub fn exitCode(&self) -> i32 {
        self.exitCode.unwrap_or(0)
    }

    pub fn clear_exitCode(&mut self) {
        self.exitCode = ::std::option::Option::None;
    }

    pub fn has_exitCode(&self) -> bool {
        self.exitCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exitCode(&mut self, v: i32) {
        self.exitCode = ::std::option::Option::Some(v);
    }

    // optional int32 signal = 2;

    pub fn signal(&self) -> i32 {
        self.signal.unwrap_or(0)
    }

    pub fn clear_signal(&mut self) {
        self.signal = ::std::option::Option::None;
    }

    pub fn has_signal(&self) -> bool {
        self.signal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signal(&mut self, v: i32) {
        self.signal = ::std::option::Option::Some(v);
    }

    // optional string reason = 3;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 4;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time startedAt = 5;

    pub fn startedAt(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.startedAt.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_startedAt(&mut self) {
        self.startedAt.clear();
    }

    pub fn has_startedAt(&self) -> bool {
        self.startedAt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startedAt(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::Time) {
        self.startedAt = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startedAt(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.startedAt.mut_or_insert_default()
    }

    // Take field
    pub fn take_startedAt(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.startedAt.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time finishedAt = 6;

    pub fn finishedAt(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.finishedAt.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_finishedAt(&mut self) {
        self.finishedAt.clear();
    }

    pub fn has_finishedAt(&self) -> bool {
        self.finishedAt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_finishedAt(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::Time) {
        self.finishedAt = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_finishedAt(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.finishedAt.mut_or_insert_default()
    }

    // Take field
    pub fn take_finishedAt(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.finishedAt.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional string containerID = 7;

    pub fn containerID(&self) -> &str {
        match self.containerID.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_containerID(&mut self) {
        self.containerID = ::std::option::Option::None;
    }

    pub fn has_containerID(&self) -> bool {
        self.containerID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_containerID(&mut self, v: ::std::string::String) {
        self.containerID = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_containerID(&mut self) -> &mut ::std::string::String {
        if self.containerID.is_none() {
            self.containerID = ::std::option::Option::Some(::std::string::String::new());
        }
        self.containerID.as_mut().unwrap()
    }

    // Take field
    pub fn take_containerID(&mut self) -> ::std::string::String {
        self.containerID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "exitCode",
            |m: &ContainerStateTerminated| { &m.exitCode },
            |m: &mut ContainerStateTerminated| { &mut m.exitCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signal",
            |m: &ContainerStateTerminated| { &m.signal },
            |m: &mut ContainerStateTerminated| { &mut m.signal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &ContainerStateTerminated| { &m.reason },
            |m: &mut ContainerStateTerminated| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &ContainerStateTerminated| { &m.message },
            |m: &mut ContainerStateTerminated| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>(
            "startedAt",
            |m: &ContainerStateTerminated| { &m.startedAt },
            |m: &mut ContainerStateTerminated| { &mut m.startedAt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>(
            "finishedAt",
            |m: &ContainerStateTerminated| { &m.finishedAt },
            |m: &mut ContainerStateTerminated| { &mut m.finishedAt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "containerID",
            |m: &ContainerStateTerminated| { &m.containerID },
            |m: &mut ContainerStateTerminated| { &mut m.containerID },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContainerStateTerminated>(
            "ContainerStateTerminated",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContainerStateTerminated {
    const NAME: &'static str = "ContainerStateTerminated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.exitCode = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.signal = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.startedAt)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.finishedAt)?;
                },
                58 => {
                    self.containerID = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.exitCode {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.signal {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.startedAt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.finishedAt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.containerID.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.exitCode {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.signal {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.startedAt.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.finishedAt.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.containerID.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContainerStateTerminated {
        ContainerStateTerminated::new()
    }

    fn clear(&mut self) {
        self.exitCode = ::std::option::Option::None;
        self.signal = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.startedAt.clear();
        self.finishedAt.clear();
        self.containerID = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContainerStateTerminated {
        static instance: ContainerStateTerminated = ContainerStateTerminated {
            exitCode: ::std::option::Option::None,
            signal: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            startedAt: ::protobuf::MessageField::none(),
            finishedAt: ::protobuf::MessageField::none(),
            containerID: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContainerStateTerminated {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContainerStateTerminated").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContainerStateTerminated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerStateTerminated {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ContainerStateWaiting)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ContainerStateWaiting {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ContainerStateWaiting.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ContainerStateWaiting.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ContainerStateWaiting.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContainerStateWaiting {
    fn default() -> &'a ContainerStateWaiting {
        <ContainerStateWaiting as ::protobuf::Message>::default_instance()
    }
}

impl ContainerStateWaiting {
    pub fn new() -> ContainerStateWaiting {
        ::std::default::Default::default()
    }

    // optional string reason = 1;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &ContainerStateWaiting| { &m.reason },
            |m: &mut ContainerStateWaiting| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &ContainerStateWaiting| { &m.message },
            |m: &mut ContainerStateWaiting| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContainerStateWaiting>(
            "ContainerStateWaiting",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContainerStateWaiting {
    const NAME: &'static str = "ContainerStateWaiting";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reason.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContainerStateWaiting {
        ContainerStateWaiting::new()
    }

    fn clear(&mut self) {
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContainerStateWaiting {
        static instance: ContainerStateWaiting = ContainerStateWaiting {
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContainerStateWaiting {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContainerStateWaiting").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContainerStateWaiting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerStateWaiting {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ContainerStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ContainerStatus {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ContainerStatus.name)
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ContainerStatus.state)
    pub state: ::protobuf::MessageField<ContainerState>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ContainerStatus.lastState)
    pub lastState: ::protobuf::MessageField<ContainerState>,
    // @@protoc_insertion_point(field:api.core.v1.ContainerStatus.ready)
    pub ready: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.ContainerStatus.restartCount)
    pub restartCount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.ContainerStatus.image)
    pub image: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ContainerStatus.imageID)
    pub imageID: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ContainerStatus.containerID)
    pub containerID: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ContainerStatus.started)
    pub started: ::std::option::Option<bool>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ContainerStatus.allocatedResources)
    pub allocatedResources: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ContainerStatus.resources)
    pub resources: ::protobuf::MessageField<ResourceRequirements>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ContainerStatus.volumeMounts)
    pub volumeMounts: ::std::vec::Vec<VolumeMountStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ContainerStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContainerStatus {
    fn default() -> &'a ContainerStatus {
        <ContainerStatus as ::protobuf::Message>::default_instance()
    }
}

impl ContainerStatus {
    pub fn new() -> ContainerStatus {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.ContainerState state = 2;

    pub fn state(&self) -> &ContainerState {
        self.state.as_ref().unwrap_or_else(|| <ContainerState as ::protobuf::Message>::default_instance())
    }

    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ContainerState) {
        self.state = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ContainerState {
        self.state.mut_or_insert_default()
    }

    // Take field
    pub fn take_state(&mut self) -> ContainerState {
        self.state.take().unwrap_or_else(|| ContainerState::new())
    }

    // optional .api.core.v1.ContainerState lastState = 3;

    pub fn lastState(&self) -> &ContainerState {
        self.lastState.as_ref().unwrap_or_else(|| <ContainerState as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastState(&mut self) {
        self.lastState.clear();
    }

    pub fn has_lastState(&self) -> bool {
        self.lastState.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastState(&mut self, v: ContainerState) {
        self.lastState = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastState(&mut self) -> &mut ContainerState {
        self.lastState.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastState(&mut self) -> ContainerState {
        self.lastState.take().unwrap_or_else(|| ContainerState::new())
    }

    // optional bool ready = 4;

    pub fn ready(&self) -> bool {
        self.ready.unwrap_or(false)
    }

    pub fn clear_ready(&mut self) {
        self.ready = ::std::option::Option::None;
    }

    pub fn has_ready(&self) -> bool {
        self.ready.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ready(&mut self, v: bool) {
        self.ready = ::std::option::Option::Some(v);
    }

    // optional int32 restartCount = 5;

    pub fn restartCount(&self) -> i32 {
        self.restartCount.unwrap_or(0)
    }

    pub fn clear_restartCount(&mut self) {
        self.restartCount = ::std::option::Option::None;
    }

    pub fn has_restartCount(&self) -> bool {
        self.restartCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_restartCount(&mut self, v: i32) {
        self.restartCount = ::std::option::Option::Some(v);
    }

    // optional string image = 6;

    pub fn image(&self) -> &str {
        match self.image.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_image(&mut self) {
        self.image = ::std::option::Option::None;
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        if self.image.is_none() {
            self.image = ::std::option::Option::Some(::std::string::String::new());
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        self.image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string imageID = 7;

    pub fn imageID(&self) -> &str {
        match self.imageID.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_imageID(&mut self) {
        self.imageID = ::std::option::Option::None;
    }

    pub fn has_imageID(&self) -> bool {
        self.imageID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_imageID(&mut self, v: ::std::string::String) {
        self.imageID = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_imageID(&mut self) -> &mut ::std::string::String {
        if self.imageID.is_none() {
            self.imageID = ::std::option::Option::Some(::std::string::String::new());
        }
        self.imageID.as_mut().unwrap()
    }

    // Take field
    pub fn take_imageID(&mut self) -> ::std::string::String {
        self.imageID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string containerID = 8;

    pub fn containerID(&self) -> &str {
        match self.containerID.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_containerID(&mut self) {
        self.containerID = ::std::option::Option::None;
    }

    pub fn has_containerID(&self) -> bool {
        self.containerID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_containerID(&mut self, v: ::std::string::String) {
        self.containerID = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_containerID(&mut self) -> &mut ::std::string::String {
        if self.containerID.is_none() {
            self.containerID = ::std::option::Option::Some(::std::string::String::new());
        }
        self.containerID.as_mut().unwrap()
    }

    // Take field
    pub fn take_containerID(&mut self) -> ::std::string::String {
        self.containerID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool started = 9;

    pub fn started(&self) -> bool {
        self.started.unwrap_or(false)
    }

    pub fn clear_started(&mut self) {
        self.started = ::std::option::Option::None;
    }

    pub fn has_started(&self) -> bool {
        self.started.is_some()
    }

    // Param is passed by value, moved
    pub fn set_started(&mut self, v: bool) {
        self.started = ::std::option::Option::Some(v);
    }

    // repeated .api.core.v1.ContainerStatus.AllocatedResourcesEntry allocatedResources = 10;

    pub fn allocatedResources(&self) -> &::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &self.allocatedResources
    }

    pub fn clear_allocatedResources(&mut self) {
        self.allocatedResources.clear();
    }

    // Param is passed by value, moved
    pub fn set_allocatedResources(&mut self, v: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>) {
        self.allocatedResources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allocatedResources(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &mut self.allocatedResources
    }

    // Take field
    pub fn take_allocatedResources(&mut self) -> ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        ::std::mem::replace(&mut self.allocatedResources, ::std::collections::BTreeMap::new())
    }

    // optional .api.core.v1.ResourceRequirements resources = 11;

    pub fn resources(&self) -> &ResourceRequirements {
        self.resources.as_ref().unwrap_or_else(|| <ResourceRequirements as ::protobuf::Message>::default_instance())
    }

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    pub fn has_resources(&self) -> bool {
        self.resources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ResourceRequirements) {
        self.resources = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resources(&mut self) -> &mut ResourceRequirements {
        self.resources.mut_or_insert_default()
    }

    // Take field
    pub fn take_resources(&mut self) -> ResourceRequirements {
        self.resources.take().unwrap_or_else(|| ResourceRequirements::new())
    }

    // repeated .api.core.v1.VolumeMountStatus volumeMounts = 12;

    pub fn volumeMounts(&self) -> &[VolumeMountStatus] {
        &self.volumeMounts
    }

    pub fn clear_volumeMounts(&mut self) {
        self.volumeMounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumeMounts(&mut self, v: ::std::vec::Vec<VolumeMountStatus>) {
        self.volumeMounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumeMounts(&mut self) -> &mut ::std::vec::Vec<VolumeMountStatus> {
        &mut self.volumeMounts
    }

    // Take field
    pub fn take_volumeMounts(&mut self) -> ::std::vec::Vec<VolumeMountStatus> {
        ::std::mem::replace(&mut self.volumeMounts, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ContainerStatus| { &m.name },
            |m: &mut ContainerStatus| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContainerState>(
            "state",
            |m: &ContainerStatus| { &m.state },
            |m: &mut ContainerStatus| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContainerState>(
            "lastState",
            |m: &ContainerStatus| { &m.lastState },
            |m: &mut ContainerStatus| { &mut m.lastState },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ready",
            |m: &ContainerStatus| { &m.ready },
            |m: &mut ContainerStatus| { &mut m.ready },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "restartCount",
            |m: &ContainerStatus| { &m.restartCount },
            |m: &mut ContainerStatus| { &mut m.restartCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "image",
            |m: &ContainerStatus| { &m.image },
            |m: &mut ContainerStatus| { &mut m.image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "imageID",
            |m: &ContainerStatus| { &m.imageID },
            |m: &mut ContainerStatus| { &mut m.imageID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "containerID",
            |m: &ContainerStatus| { &m.containerID },
            |m: &mut ContainerStatus| { &mut m.containerID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "started",
            |m: &ContainerStatus| { &m.started },
            |m: &mut ContainerStatus| { &mut m.started },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "allocatedResources",
            |m: &ContainerStatus| { &m.allocatedResources },
            |m: &mut ContainerStatus| { &mut m.allocatedResources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceRequirements>(
            "resources",
            |m: &ContainerStatus| { &m.resources },
            |m: &mut ContainerStatus| { &mut m.resources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "volumeMounts",
            |m: &ContainerStatus| { &m.volumeMounts },
            |m: &mut ContainerStatus| { &mut m.volumeMounts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContainerStatus>(
            "ContainerStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContainerStatus {
    const NAME: &'static str = "ContainerStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.state)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastState)?;
                },
                32 => {
                    self.ready = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.restartCount = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    self.image = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.imageID = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.containerID = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.started = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.allocatedResources.insert(key, value);
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resources)?;
                },
                98 => {
                    self.volumeMounts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.lastState.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ready {
            my_size += 1 + 1;
        }
        if let Some(v) = self.restartCount {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.image.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.imageID.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.containerID.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.started {
            my_size += 1 + 1;
        }
        for (k, v) in &self.allocatedResources {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.resources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.volumeMounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.lastState.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.ready {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.restartCount {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.image.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.imageID.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.containerID.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.started {
            os.write_bool(9, v)?;
        }
        for (k, v) in &self.allocatedResources {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(82)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.resources.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        for v in &self.volumeMounts {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContainerStatus {
        ContainerStatus::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.state.clear();
        self.lastState.clear();
        self.ready = ::std::option::Option::None;
        self.restartCount = ::std::option::Option::None;
        self.image = ::std::option::Option::None;
        self.imageID = ::std::option::Option::None;
        self.containerID = ::std::option::Option::None;
        self.started = ::std::option::Option::None;
        self.allocatedResources.clear();
        self.resources.clear();
        self.volumeMounts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContainerStatus {
        static instance: ::protobuf::rt::Lazy<ContainerStatus> = ::protobuf::rt::Lazy::new();
        instance.get(ContainerStatus::new)
    }
}

impl ::protobuf::MessageFull for ContainerStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContainerStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContainerStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.DaemonEndpoint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DaemonEndpoint {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.DaemonEndpoint.Port)
    pub Port: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.DaemonEndpoint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DaemonEndpoint {
    fn default() -> &'a DaemonEndpoint {
        <DaemonEndpoint as ::protobuf::Message>::default_instance()
    }
}

impl DaemonEndpoint {
    pub fn new() -> DaemonEndpoint {
        ::std::default::Default::default()
    }

    // optional int32 Port = 1;

    pub fn Port(&self) -> i32 {
        self.Port.unwrap_or(0)
    }

    pub fn clear_Port(&mut self) {
        self.Port = ::std::option::Option::None;
    }

    pub fn has_Port(&self) -> bool {
        self.Port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Port(&mut self, v: i32) {
        self.Port = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "Port",
            |m: &DaemonEndpoint| { &m.Port },
            |m: &mut DaemonEndpoint| { &mut m.Port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DaemonEndpoint>(
            "DaemonEndpoint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DaemonEndpoint {
    const NAME: &'static str = "DaemonEndpoint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.Port = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.Port {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.Port {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DaemonEndpoint {
        DaemonEndpoint::new()
    }

    fn clear(&mut self) {
        self.Port = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DaemonEndpoint {
        static instance: DaemonEndpoint = DaemonEndpoint {
            Port: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DaemonEndpoint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DaemonEndpoint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DaemonEndpoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaemonEndpoint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.DownwardAPIProjection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DownwardAPIProjection {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.DownwardAPIProjection.items)
    pub items: ::std::vec::Vec<DownwardAPIVolumeFile>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.DownwardAPIProjection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DownwardAPIProjection {
    fn default() -> &'a DownwardAPIProjection {
        <DownwardAPIProjection as ::protobuf::Message>::default_instance()
    }
}

impl DownwardAPIProjection {
    pub fn new() -> DownwardAPIProjection {
        ::std::default::Default::default()
    }

    // repeated .api.core.v1.DownwardAPIVolumeFile items = 1;

    pub fn items(&self) -> &[DownwardAPIVolumeFile] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<DownwardAPIVolumeFile>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<DownwardAPIVolumeFile> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<DownwardAPIVolumeFile> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &DownwardAPIProjection| { &m.items },
            |m: &mut DownwardAPIProjection| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DownwardAPIProjection>(
            "DownwardAPIProjection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DownwardAPIProjection {
    const NAME: &'static str = "DownwardAPIProjection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DownwardAPIProjection {
        DownwardAPIProjection::new()
    }

    fn clear(&mut self) {
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DownwardAPIProjection {
        static instance: DownwardAPIProjection = DownwardAPIProjection {
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DownwardAPIProjection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DownwardAPIProjection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DownwardAPIProjection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DownwardAPIProjection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.DownwardAPIVolumeFile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DownwardAPIVolumeFile {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.DownwardAPIVolumeFile.path)
    pub path: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.DownwardAPIVolumeFile.fieldRef)
    pub fieldRef: ::protobuf::MessageField<ObjectFieldSelector>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.DownwardAPIVolumeFile.resourceFieldRef)
    pub resourceFieldRef: ::protobuf::MessageField<ResourceFieldSelector>,
    // @@protoc_insertion_point(field:api.core.v1.DownwardAPIVolumeFile.mode)
    pub mode: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.DownwardAPIVolumeFile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DownwardAPIVolumeFile {
    fn default() -> &'a DownwardAPIVolumeFile {
        <DownwardAPIVolumeFile as ::protobuf::Message>::default_instance()
    }
}

impl DownwardAPIVolumeFile {
    pub fn new() -> DownwardAPIVolumeFile {
        ::std::default::Default::default()
    }

    // optional string path = 1;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.ObjectFieldSelector fieldRef = 2;

    pub fn fieldRef(&self) -> &ObjectFieldSelector {
        self.fieldRef.as_ref().unwrap_or_else(|| <ObjectFieldSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_fieldRef(&mut self) {
        self.fieldRef.clear();
    }

    pub fn has_fieldRef(&self) -> bool {
        self.fieldRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldRef(&mut self, v: ObjectFieldSelector) {
        self.fieldRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldRef(&mut self) -> &mut ObjectFieldSelector {
        self.fieldRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_fieldRef(&mut self) -> ObjectFieldSelector {
        self.fieldRef.take().unwrap_or_else(|| ObjectFieldSelector::new())
    }

    // optional .api.core.v1.ResourceFieldSelector resourceFieldRef = 3;

    pub fn resourceFieldRef(&self) -> &ResourceFieldSelector {
        self.resourceFieldRef.as_ref().unwrap_or_else(|| <ResourceFieldSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_resourceFieldRef(&mut self) {
        self.resourceFieldRef.clear();
    }

    pub fn has_resourceFieldRef(&self) -> bool {
        self.resourceFieldRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceFieldRef(&mut self, v: ResourceFieldSelector) {
        self.resourceFieldRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceFieldRef(&mut self) -> &mut ResourceFieldSelector {
        self.resourceFieldRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_resourceFieldRef(&mut self) -> ResourceFieldSelector {
        self.resourceFieldRef.take().unwrap_or_else(|| ResourceFieldSelector::new())
    }

    // optional int32 mode = 4;

    pub fn mode(&self) -> i32 {
        self.mode.unwrap_or(0)
    }

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: i32) {
        self.mode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &DownwardAPIVolumeFile| { &m.path },
            |m: &mut DownwardAPIVolumeFile| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ObjectFieldSelector>(
            "fieldRef",
            |m: &DownwardAPIVolumeFile| { &m.fieldRef },
            |m: &mut DownwardAPIVolumeFile| { &mut m.fieldRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceFieldSelector>(
            "resourceFieldRef",
            |m: &DownwardAPIVolumeFile| { &m.resourceFieldRef },
            |m: &mut DownwardAPIVolumeFile| { &mut m.resourceFieldRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mode",
            |m: &DownwardAPIVolumeFile| { &m.mode },
            |m: &mut DownwardAPIVolumeFile| { &mut m.mode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DownwardAPIVolumeFile>(
            "DownwardAPIVolumeFile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DownwardAPIVolumeFile {
    const NAME: &'static str = "DownwardAPIVolumeFile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fieldRef)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resourceFieldRef)?;
                },
                32 => {
                    self.mode = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fieldRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.resourceFieldRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.path.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.fieldRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.resourceFieldRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.mode {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DownwardAPIVolumeFile {
        DownwardAPIVolumeFile::new()
    }

    fn clear(&mut self) {
        self.path = ::std::option::Option::None;
        self.fieldRef.clear();
        self.resourceFieldRef.clear();
        self.mode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DownwardAPIVolumeFile {
        static instance: DownwardAPIVolumeFile = DownwardAPIVolumeFile {
            path: ::std::option::Option::None,
            fieldRef: ::protobuf::MessageField::none(),
            resourceFieldRef: ::protobuf::MessageField::none(),
            mode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DownwardAPIVolumeFile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DownwardAPIVolumeFile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DownwardAPIVolumeFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DownwardAPIVolumeFile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.DownwardAPIVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DownwardAPIVolumeSource {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.DownwardAPIVolumeSource.items)
    pub items: ::std::vec::Vec<DownwardAPIVolumeFile>,
    // @@protoc_insertion_point(field:api.core.v1.DownwardAPIVolumeSource.defaultMode)
    pub defaultMode: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.DownwardAPIVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DownwardAPIVolumeSource {
    fn default() -> &'a DownwardAPIVolumeSource {
        <DownwardAPIVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl DownwardAPIVolumeSource {
    pub fn new() -> DownwardAPIVolumeSource {
        ::std::default::Default::default()
    }

    // repeated .api.core.v1.DownwardAPIVolumeFile items = 1;

    pub fn items(&self) -> &[DownwardAPIVolumeFile] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<DownwardAPIVolumeFile>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<DownwardAPIVolumeFile> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<DownwardAPIVolumeFile> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    // optional int32 defaultMode = 2;

    pub fn defaultMode(&self) -> i32 {
        self.defaultMode.unwrap_or(0)
    }

    pub fn clear_defaultMode(&mut self) {
        self.defaultMode = ::std::option::Option::None;
    }

    pub fn has_defaultMode(&self) -> bool {
        self.defaultMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defaultMode(&mut self, v: i32) {
        self.defaultMode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &DownwardAPIVolumeSource| { &m.items },
            |m: &mut DownwardAPIVolumeSource| { &mut m.items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "defaultMode",
            |m: &DownwardAPIVolumeSource| { &m.defaultMode },
            |m: &mut DownwardAPIVolumeSource| { &mut m.defaultMode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DownwardAPIVolumeSource>(
            "DownwardAPIVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DownwardAPIVolumeSource {
    const NAME: &'static str = "DownwardAPIVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.items.push(is.read_message()?);
                },
                16 => {
                    self.defaultMode = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.defaultMode {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.defaultMode {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DownwardAPIVolumeSource {
        DownwardAPIVolumeSource::new()
    }

    fn clear(&mut self) {
        self.items.clear();
        self.defaultMode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DownwardAPIVolumeSource {
        static instance: DownwardAPIVolumeSource = DownwardAPIVolumeSource {
            items: ::std::vec::Vec::new(),
            defaultMode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DownwardAPIVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DownwardAPIVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DownwardAPIVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DownwardAPIVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.EmptyDirVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EmptyDirVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.EmptyDirVolumeSource.medium)
    pub medium: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EmptyDirVolumeSource.sizeLimit)
    pub sizeLimit: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::api::resource::Quantity>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.EmptyDirVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EmptyDirVolumeSource {
    fn default() -> &'a EmptyDirVolumeSource {
        <EmptyDirVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl EmptyDirVolumeSource {
    pub fn new() -> EmptyDirVolumeSource {
        ::std::default::Default::default()
    }

    // optional string medium = 1;

    pub fn medium(&self) -> &str {
        match self.medium.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_medium(&mut self) {
        self.medium = ::std::option::Option::None;
    }

    pub fn has_medium(&self) -> bool {
        self.medium.is_some()
    }

    // Param is passed by value, moved
    pub fn set_medium(&mut self, v: ::std::string::String) {
        self.medium = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_medium(&mut self) -> &mut ::std::string::String {
        if self.medium.is_none() {
            self.medium = ::std::option::Option::Some(::std::string::String::new());
        }
        self.medium.as_mut().unwrap()
    }

    // Take field
    pub fn take_medium(&mut self) -> ::std::string::String {
        self.medium.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.api.resource.Quantity sizeLimit = 2;

    pub fn sizeLimit(&self) -> &crate::v1_30::apimachinery::pkg::api::resource::Quantity {
        self.sizeLimit.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::api::resource::Quantity as ::protobuf::Message>::default_instance())
    }

    pub fn clear_sizeLimit(&mut self) {
        self.sizeLimit.clear();
    }

    pub fn has_sizeLimit(&self) -> bool {
        self.sizeLimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sizeLimit(&mut self, v: crate::v1_30::apimachinery::pkg::api::resource::Quantity) {
        self.sizeLimit = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sizeLimit(&mut self) -> &mut crate::v1_30::apimachinery::pkg::api::resource::Quantity {
        self.sizeLimit.mut_or_insert_default()
    }

    // Take field
    pub fn take_sizeLimit(&mut self) -> crate::v1_30::apimachinery::pkg::api::resource::Quantity {
        self.sizeLimit.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::api::resource::Quantity::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "medium",
            |m: &EmptyDirVolumeSource| { &m.medium },
            |m: &mut EmptyDirVolumeSource| { &mut m.medium },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::api::resource::Quantity>(
            "sizeLimit",
            |m: &EmptyDirVolumeSource| { &m.sizeLimit },
            |m: &mut EmptyDirVolumeSource| { &mut m.sizeLimit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EmptyDirVolumeSource>(
            "EmptyDirVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EmptyDirVolumeSource {
    const NAME: &'static str = "EmptyDirVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.medium = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sizeLimit)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.medium.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.sizeLimit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.medium.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.sizeLimit.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EmptyDirVolumeSource {
        EmptyDirVolumeSource::new()
    }

    fn clear(&mut self) {
        self.medium = ::std::option::Option::None;
        self.sizeLimit.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EmptyDirVolumeSource {
        static instance: EmptyDirVolumeSource = EmptyDirVolumeSource {
            medium: ::std::option::Option::None,
            sizeLimit: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EmptyDirVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EmptyDirVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EmptyDirVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EmptyDirVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.EndpointAddress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EndpointAddress {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.EndpointAddress.ip)
    pub ip: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.EndpointAddress.hostname)
    pub hostname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.EndpointAddress.nodeName)
    pub nodeName: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EndpointAddress.targetRef)
    pub targetRef: ::protobuf::MessageField<ObjectReference>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.EndpointAddress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EndpointAddress {
    fn default() -> &'a EndpointAddress {
        <EndpointAddress as ::protobuf::Message>::default_instance()
    }
}

impl EndpointAddress {
    pub fn new() -> EndpointAddress {
        ::std::default::Default::default()
    }

    // optional string ip = 1;

    pub fn ip(&self) -> &str {
        match self.ip.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        if self.ip.is_none() {
            self.ip = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        self.ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string hostname = 3;

    pub fn hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hostname(&mut self) {
        self.hostname = ::std::option::Option::None;
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string nodeName = 4;

    pub fn nodeName(&self) -> &str {
        match self.nodeName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nodeName(&mut self) {
        self.nodeName = ::std::option::Option::None;
    }

    pub fn has_nodeName(&self) -> bool {
        self.nodeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeName(&mut self, v: ::std::string::String) {
        self.nodeName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeName(&mut self) -> &mut ::std::string::String {
        if self.nodeName.is_none() {
            self.nodeName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.nodeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodeName(&mut self) -> ::std::string::String {
        self.nodeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.ObjectReference targetRef = 2;

    pub fn targetRef(&self) -> &ObjectReference {
        self.targetRef.as_ref().unwrap_or_else(|| <ObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_targetRef(&mut self) {
        self.targetRef.clear();
    }

    pub fn has_targetRef(&self) -> bool {
        self.targetRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetRef(&mut self, v: ObjectReference) {
        self.targetRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetRef(&mut self) -> &mut ObjectReference {
        self.targetRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_targetRef(&mut self) -> ObjectReference {
        self.targetRef.take().unwrap_or_else(|| ObjectReference::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip",
            |m: &EndpointAddress| { &m.ip },
            |m: &mut EndpointAddress| { &mut m.ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hostname",
            |m: &EndpointAddress| { &m.hostname },
            |m: &mut EndpointAddress| { &mut m.hostname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nodeName",
            |m: &EndpointAddress| { &m.nodeName },
            |m: &mut EndpointAddress| { &mut m.nodeName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ObjectReference>(
            "targetRef",
            |m: &EndpointAddress| { &m.targetRef },
            |m: &mut EndpointAddress| { &mut m.targetRef },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EndpointAddress>(
            "EndpointAddress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EndpointAddress {
    const NAME: &'static str = "EndpointAddress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ip = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.hostname = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.nodeName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.targetRef)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ip.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.nodeName.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.targetRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ip.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.hostname.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.nodeName.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.targetRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EndpointAddress {
        EndpointAddress::new()
    }

    fn clear(&mut self) {
        self.ip = ::std::option::Option::None;
        self.hostname = ::std::option::Option::None;
        self.nodeName = ::std::option::Option::None;
        self.targetRef.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EndpointAddress {
        static instance: EndpointAddress = EndpointAddress {
            ip: ::std::option::Option::None,
            hostname: ::std::option::Option::None,
            nodeName: ::std::option::Option::None,
            targetRef: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EndpointAddress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EndpointAddress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EndpointAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EndpointAddress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.EndpointPort)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EndpointPort {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.EndpointPort.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.EndpointPort.port)
    pub port: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.EndpointPort.protocol)
    pub protocol: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.EndpointPort.appProtocol)
    pub appProtocol: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.EndpointPort.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EndpointPort {
    fn default() -> &'a EndpointPort {
        <EndpointPort as ::protobuf::Message>::default_instance()
    }
}

impl EndpointPort {
    pub fn new() -> EndpointPort {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 port = 2;

    pub fn port(&self) -> i32 {
        self.port.unwrap_or(0)
    }

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Option::Some(v);
    }

    // optional string protocol = 3;

    pub fn protocol(&self) -> &str {
        match self.protocol.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_protocol(&mut self) {
        self.protocol = ::std::option::Option::None;
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol = ::std::option::Option::Some(::std::string::String::new());
        }
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string appProtocol = 4;

    pub fn appProtocol(&self) -> &str {
        match self.appProtocol.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_appProtocol(&mut self) {
        self.appProtocol = ::std::option::Option::None;
    }

    pub fn has_appProtocol(&self) -> bool {
        self.appProtocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appProtocol(&mut self, v: ::std::string::String) {
        self.appProtocol = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appProtocol(&mut self) -> &mut ::std::string::String {
        if self.appProtocol.is_none() {
            self.appProtocol = ::std::option::Option::Some(::std::string::String::new());
        }
        self.appProtocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_appProtocol(&mut self) -> ::std::string::String {
        self.appProtocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &EndpointPort| { &m.name },
            |m: &mut EndpointPort| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "port",
            |m: &EndpointPort| { &m.port },
            |m: &mut EndpointPort| { &mut m.port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol",
            |m: &EndpointPort| { &m.protocol },
            |m: &mut EndpointPort| { &mut m.protocol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appProtocol",
            |m: &EndpointPort| { &m.appProtocol },
            |m: &mut EndpointPort| { &mut m.appProtocol },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EndpointPort>(
            "EndpointPort",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EndpointPort {
    const NAME: &'static str = "EndpointPort";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.port = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.protocol = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.appProtocol = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.protocol.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.appProtocol.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.port {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.protocol.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.appProtocol.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EndpointPort {
        EndpointPort::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.port = ::std::option::Option::None;
        self.protocol = ::std::option::Option::None;
        self.appProtocol = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EndpointPort {
        static instance: EndpointPort = EndpointPort {
            name: ::std::option::Option::None,
            port: ::std::option::Option::None,
            protocol: ::std::option::Option::None,
            appProtocol: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EndpointPort {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EndpointPort").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EndpointPort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EndpointPort {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.EndpointSubset)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EndpointSubset {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EndpointSubset.addresses)
    pub addresses: ::std::vec::Vec<EndpointAddress>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EndpointSubset.notReadyAddresses)
    pub notReadyAddresses: ::std::vec::Vec<EndpointAddress>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EndpointSubset.ports)
    pub ports: ::std::vec::Vec<EndpointPort>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.EndpointSubset.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EndpointSubset {
    fn default() -> &'a EndpointSubset {
        <EndpointSubset as ::protobuf::Message>::default_instance()
    }
}

impl EndpointSubset {
    pub fn new() -> EndpointSubset {
        ::std::default::Default::default()
    }

    // repeated .api.core.v1.EndpointAddress addresses = 1;

    pub fn addresses(&self) -> &[EndpointAddress] {
        &self.addresses
    }

    pub fn clear_addresses(&mut self) {
        self.addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses(&mut self, v: ::std::vec::Vec<EndpointAddress>) {
        self.addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses(&mut self) -> &mut ::std::vec::Vec<EndpointAddress> {
        &mut self.addresses
    }

    // Take field
    pub fn take_addresses(&mut self) -> ::std::vec::Vec<EndpointAddress> {
        ::std::mem::replace(&mut self.addresses, ::std::vec::Vec::new())
    }

    // repeated .api.core.v1.EndpointAddress notReadyAddresses = 2;

    pub fn notReadyAddresses(&self) -> &[EndpointAddress] {
        &self.notReadyAddresses
    }

    pub fn clear_notReadyAddresses(&mut self) {
        self.notReadyAddresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_notReadyAddresses(&mut self, v: ::std::vec::Vec<EndpointAddress>) {
        self.notReadyAddresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_notReadyAddresses(&mut self) -> &mut ::std::vec::Vec<EndpointAddress> {
        &mut self.notReadyAddresses
    }

    // Take field
    pub fn take_notReadyAddresses(&mut self) -> ::std::vec::Vec<EndpointAddress> {
        ::std::mem::replace(&mut self.notReadyAddresses, ::std::vec::Vec::new())
    }

    // repeated .api.core.v1.EndpointPort ports = 3;

    pub fn ports(&self) -> &[EndpointPort] {
        &self.ports
    }

    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::std::vec::Vec<EndpointPort>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::std::vec::Vec<EndpointPort> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::std::vec::Vec<EndpointPort> {
        ::std::mem::replace(&mut self.ports, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "addresses",
            |m: &EndpointSubset| { &m.addresses },
            |m: &mut EndpointSubset| { &mut m.addresses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "notReadyAddresses",
            |m: &EndpointSubset| { &m.notReadyAddresses },
            |m: &mut EndpointSubset| { &mut m.notReadyAddresses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ports",
            |m: &EndpointSubset| { &m.ports },
            |m: &mut EndpointSubset| { &mut m.ports },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EndpointSubset>(
            "EndpointSubset",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EndpointSubset {
    const NAME: &'static str = "EndpointSubset";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.addresses.push(is.read_message()?);
                },
                18 => {
                    self.notReadyAddresses.push(is.read_message()?);
                },
                26 => {
                    self.ports.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.notReadyAddresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.addresses {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.notReadyAddresses {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.ports {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EndpointSubset {
        EndpointSubset::new()
    }

    fn clear(&mut self) {
        self.addresses.clear();
        self.notReadyAddresses.clear();
        self.ports.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EndpointSubset {
        static instance: EndpointSubset = EndpointSubset {
            addresses: ::std::vec::Vec::new(),
            notReadyAddresses: ::std::vec::Vec::new(),
            ports: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EndpointSubset {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EndpointSubset").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EndpointSubset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EndpointSubset {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.Endpoints)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Endpoints {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Endpoints.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Endpoints.subsets)
    pub subsets: ::std::vec::Vec<EndpointSubset>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.Endpoints.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Endpoints {
    fn default() -> &'a Endpoints {
        <Endpoints as ::protobuf::Message>::default_instance()
    }
}

impl Endpoints {
    pub fn new() -> Endpoints {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // repeated .api.core.v1.EndpointSubset subsets = 2;

    pub fn subsets(&self) -> &[EndpointSubset] {
        &self.subsets
    }

    pub fn clear_subsets(&mut self) {
        self.subsets.clear();
    }

    // Param is passed by value, moved
    pub fn set_subsets(&mut self, v: ::std::vec::Vec<EndpointSubset>) {
        self.subsets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subsets(&mut self) -> &mut ::std::vec::Vec<EndpointSubset> {
        &mut self.subsets
    }

    // Take field
    pub fn take_subsets(&mut self) -> ::std::vec::Vec<EndpointSubset> {
        ::std::mem::replace(&mut self.subsets, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &Endpoints| { &m.metadata },
            |m: &mut Endpoints| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subsets",
            |m: &Endpoints| { &m.subsets },
            |m: &mut Endpoints| { &mut m.subsets },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Endpoints>(
            "Endpoints",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Endpoints {
    const NAME: &'static str = "Endpoints";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.subsets.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.subsets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.subsets {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Endpoints {
        Endpoints::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.subsets.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Endpoints {
        static instance: Endpoints = Endpoints {
            metadata: ::protobuf::MessageField::none(),
            subsets: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Endpoints {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Endpoints").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Endpoints {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Endpoints {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.EndpointsList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EndpointsList {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EndpointsList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EndpointsList.items)
    pub items: ::std::vec::Vec<Endpoints>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.EndpointsList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EndpointsList {
    fn default() -> &'a EndpointsList {
        <EndpointsList as ::protobuf::Message>::default_instance()
    }
}

impl EndpointsList {
    pub fn new() -> EndpointsList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.core.v1.Endpoints items = 2;

    pub fn items(&self) -> &[Endpoints] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<Endpoints>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<Endpoints> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<Endpoints> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &EndpointsList| { &m.metadata },
            |m: &mut EndpointsList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &EndpointsList| { &m.items },
            |m: &mut EndpointsList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EndpointsList>(
            "EndpointsList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EndpointsList {
    const NAME: &'static str = "EndpointsList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EndpointsList {
        EndpointsList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EndpointsList {
        static instance: EndpointsList = EndpointsList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EndpointsList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EndpointsList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EndpointsList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EndpointsList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.EnvFromSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EnvFromSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.EnvFromSource.prefix)
    pub prefix: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EnvFromSource.configMapRef)
    pub configMapRef: ::protobuf::MessageField<ConfigMapEnvSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EnvFromSource.secretRef)
    pub secretRef: ::protobuf::MessageField<SecretEnvSource>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.EnvFromSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnvFromSource {
    fn default() -> &'a EnvFromSource {
        <EnvFromSource as ::protobuf::Message>::default_instance()
    }
}

impl EnvFromSource {
    pub fn new() -> EnvFromSource {
        ::std::default::Default::default()
    }

    // optional string prefix = 1;

    pub fn prefix(&self) -> &str {
        match self.prefix.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_prefix(&mut self) {
        self.prefix = ::std::option::Option::None;
    }

    pub fn has_prefix(&self) -> bool {
        self.prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.prefix = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        if self.prefix.is_none() {
            self.prefix = ::std::option::Option::Some(::std::string::String::new());
        }
        self.prefix.as_mut().unwrap()
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        self.prefix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.ConfigMapEnvSource configMapRef = 2;

    pub fn configMapRef(&self) -> &ConfigMapEnvSource {
        self.configMapRef.as_ref().unwrap_or_else(|| <ConfigMapEnvSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_configMapRef(&mut self) {
        self.configMapRef.clear();
    }

    pub fn has_configMapRef(&self) -> bool {
        self.configMapRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configMapRef(&mut self, v: ConfigMapEnvSource) {
        self.configMapRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configMapRef(&mut self) -> &mut ConfigMapEnvSource {
        self.configMapRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_configMapRef(&mut self) -> ConfigMapEnvSource {
        self.configMapRef.take().unwrap_or_else(|| ConfigMapEnvSource::new())
    }

    // optional .api.core.v1.SecretEnvSource secretRef = 3;

    pub fn secretRef(&self) -> &SecretEnvSource {
        self.secretRef.as_ref().unwrap_or_else(|| <SecretEnvSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: SecretEnvSource) {
        self.secretRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut SecretEnvSource {
        self.secretRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> SecretEnvSource {
        self.secretRef.take().unwrap_or_else(|| SecretEnvSource::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prefix",
            |m: &EnvFromSource| { &m.prefix },
            |m: &mut EnvFromSource| { &mut m.prefix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConfigMapEnvSource>(
            "configMapRef",
            |m: &EnvFromSource| { &m.configMapRef },
            |m: &mut EnvFromSource| { &mut m.configMapRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SecretEnvSource>(
            "secretRef",
            |m: &EnvFromSource| { &m.secretRef },
            |m: &mut EnvFromSource| { &mut m.secretRef },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EnvFromSource>(
            "EnvFromSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EnvFromSource {
    const NAME: &'static str = "EnvFromSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.prefix = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.configMapRef)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.secretRef)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.prefix.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.configMapRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.prefix.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.configMapRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.secretRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnvFromSource {
        EnvFromSource::new()
    }

    fn clear(&mut self) {
        self.prefix = ::std::option::Option::None;
        self.configMapRef.clear();
        self.secretRef.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnvFromSource {
        static instance: EnvFromSource = EnvFromSource {
            prefix: ::std::option::Option::None,
            configMapRef: ::protobuf::MessageField::none(),
            secretRef: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EnvFromSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EnvFromSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EnvFromSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnvFromSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.EnvVar)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EnvVar {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.EnvVar.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.EnvVar.value)
    pub value: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EnvVar.valueFrom)
    pub valueFrom: ::protobuf::MessageField<EnvVarSource>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.EnvVar.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnvVar {
    fn default() -> &'a EnvVar {
        <EnvVar as ::protobuf::Message>::default_instance()
    }
}

impl EnvVar {
    pub fn new() -> EnvVar {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.EnvVarSource valueFrom = 3;

    pub fn valueFrom(&self) -> &EnvVarSource {
        self.valueFrom.as_ref().unwrap_or_else(|| <EnvVarSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_valueFrom(&mut self) {
        self.valueFrom.clear();
    }

    pub fn has_valueFrom(&self) -> bool {
        self.valueFrom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_valueFrom(&mut self, v: EnvVarSource) {
        self.valueFrom = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_valueFrom(&mut self) -> &mut EnvVarSource {
        self.valueFrom.mut_or_insert_default()
    }

    // Take field
    pub fn take_valueFrom(&mut self) -> EnvVarSource {
        self.valueFrom.take().unwrap_or_else(|| EnvVarSource::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &EnvVar| { &m.name },
            |m: &mut EnvVar| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &EnvVar| { &m.value },
            |m: &mut EnvVar| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EnvVarSource>(
            "valueFrom",
            |m: &EnvVar| { &m.valueFrom },
            |m: &mut EnvVar| { &mut m.valueFrom },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EnvVar>(
            "EnvVar",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EnvVar {
    const NAME: &'static str = "EnvVar";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.valueFrom)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.valueFrom.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.valueFrom.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnvVar {
        EnvVar::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.valueFrom.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnvVar {
        static instance: EnvVar = EnvVar {
            name: ::std::option::Option::None,
            value: ::std::option::Option::None,
            valueFrom: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EnvVar {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EnvVar").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EnvVar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnvVar {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.EnvVarSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EnvVarSource {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EnvVarSource.fieldRef)
    pub fieldRef: ::protobuf::MessageField<ObjectFieldSelector>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EnvVarSource.resourceFieldRef)
    pub resourceFieldRef: ::protobuf::MessageField<ResourceFieldSelector>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EnvVarSource.configMapKeyRef)
    pub configMapKeyRef: ::protobuf::MessageField<ConfigMapKeySelector>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EnvVarSource.secretKeyRef)
    pub secretKeyRef: ::protobuf::MessageField<SecretKeySelector>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.EnvVarSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnvVarSource {
    fn default() -> &'a EnvVarSource {
        <EnvVarSource as ::protobuf::Message>::default_instance()
    }
}

impl EnvVarSource {
    pub fn new() -> EnvVarSource {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.ObjectFieldSelector fieldRef = 1;

    pub fn fieldRef(&self) -> &ObjectFieldSelector {
        self.fieldRef.as_ref().unwrap_or_else(|| <ObjectFieldSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_fieldRef(&mut self) {
        self.fieldRef.clear();
    }

    pub fn has_fieldRef(&self) -> bool {
        self.fieldRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldRef(&mut self, v: ObjectFieldSelector) {
        self.fieldRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldRef(&mut self) -> &mut ObjectFieldSelector {
        self.fieldRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_fieldRef(&mut self) -> ObjectFieldSelector {
        self.fieldRef.take().unwrap_or_else(|| ObjectFieldSelector::new())
    }

    // optional .api.core.v1.ResourceFieldSelector resourceFieldRef = 2;

    pub fn resourceFieldRef(&self) -> &ResourceFieldSelector {
        self.resourceFieldRef.as_ref().unwrap_or_else(|| <ResourceFieldSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_resourceFieldRef(&mut self) {
        self.resourceFieldRef.clear();
    }

    pub fn has_resourceFieldRef(&self) -> bool {
        self.resourceFieldRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceFieldRef(&mut self, v: ResourceFieldSelector) {
        self.resourceFieldRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceFieldRef(&mut self) -> &mut ResourceFieldSelector {
        self.resourceFieldRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_resourceFieldRef(&mut self) -> ResourceFieldSelector {
        self.resourceFieldRef.take().unwrap_or_else(|| ResourceFieldSelector::new())
    }

    // optional .api.core.v1.ConfigMapKeySelector configMapKeyRef = 3;

    pub fn configMapKeyRef(&self) -> &ConfigMapKeySelector {
        self.configMapKeyRef.as_ref().unwrap_or_else(|| <ConfigMapKeySelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_configMapKeyRef(&mut self) {
        self.configMapKeyRef.clear();
    }

    pub fn has_configMapKeyRef(&self) -> bool {
        self.configMapKeyRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configMapKeyRef(&mut self, v: ConfigMapKeySelector) {
        self.configMapKeyRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configMapKeyRef(&mut self) -> &mut ConfigMapKeySelector {
        self.configMapKeyRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_configMapKeyRef(&mut self) -> ConfigMapKeySelector {
        self.configMapKeyRef.take().unwrap_or_else(|| ConfigMapKeySelector::new())
    }

    // optional .api.core.v1.SecretKeySelector secretKeyRef = 4;

    pub fn secretKeyRef(&self) -> &SecretKeySelector {
        self.secretKeyRef.as_ref().unwrap_or_else(|| <SecretKeySelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_secretKeyRef(&mut self) {
        self.secretKeyRef.clear();
    }

    pub fn has_secretKeyRef(&self) -> bool {
        self.secretKeyRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretKeyRef(&mut self, v: SecretKeySelector) {
        self.secretKeyRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretKeyRef(&mut self) -> &mut SecretKeySelector {
        self.secretKeyRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_secretKeyRef(&mut self) -> SecretKeySelector {
        self.secretKeyRef.take().unwrap_or_else(|| SecretKeySelector::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ObjectFieldSelector>(
            "fieldRef",
            |m: &EnvVarSource| { &m.fieldRef },
            |m: &mut EnvVarSource| { &mut m.fieldRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceFieldSelector>(
            "resourceFieldRef",
            |m: &EnvVarSource| { &m.resourceFieldRef },
            |m: &mut EnvVarSource| { &mut m.resourceFieldRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConfigMapKeySelector>(
            "configMapKeyRef",
            |m: &EnvVarSource| { &m.configMapKeyRef },
            |m: &mut EnvVarSource| { &mut m.configMapKeyRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SecretKeySelector>(
            "secretKeyRef",
            |m: &EnvVarSource| { &m.secretKeyRef },
            |m: &mut EnvVarSource| { &mut m.secretKeyRef },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EnvVarSource>(
            "EnvVarSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EnvVarSource {
    const NAME: &'static str = "EnvVarSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fieldRef)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resourceFieldRef)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.configMapKeyRef)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.secretKeyRef)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.fieldRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.resourceFieldRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.configMapKeyRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.secretKeyRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.fieldRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.resourceFieldRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.configMapKeyRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.secretKeyRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnvVarSource {
        EnvVarSource::new()
    }

    fn clear(&mut self) {
        self.fieldRef.clear();
        self.resourceFieldRef.clear();
        self.configMapKeyRef.clear();
        self.secretKeyRef.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnvVarSource {
        static instance: EnvVarSource = EnvVarSource {
            fieldRef: ::protobuf::MessageField::none(),
            resourceFieldRef: ::protobuf::MessageField::none(),
            configMapKeyRef: ::protobuf::MessageField::none(),
            secretKeyRef: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EnvVarSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EnvVarSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EnvVarSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnvVarSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.EphemeralContainer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EphemeralContainer {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainer.ephemeralContainerCommon)
    pub ephemeralContainerCommon: ::protobuf::MessageField<EphemeralContainerCommon>,
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainer.targetContainerName)
    pub targetContainerName: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.EphemeralContainer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EphemeralContainer {
    fn default() -> &'a EphemeralContainer {
        <EphemeralContainer as ::protobuf::Message>::default_instance()
    }
}

impl EphemeralContainer {
    pub fn new() -> EphemeralContainer {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.EphemeralContainerCommon ephemeralContainerCommon = 1;

    pub fn ephemeralContainerCommon(&self) -> &EphemeralContainerCommon {
        self.ephemeralContainerCommon.as_ref().unwrap_or_else(|| <EphemeralContainerCommon as ::protobuf::Message>::default_instance())
    }

    pub fn clear_ephemeralContainerCommon(&mut self) {
        self.ephemeralContainerCommon.clear();
    }

    pub fn has_ephemeralContainerCommon(&self) -> bool {
        self.ephemeralContainerCommon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralContainerCommon(&mut self, v: EphemeralContainerCommon) {
        self.ephemeralContainerCommon = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ephemeralContainerCommon(&mut self) -> &mut EphemeralContainerCommon {
        self.ephemeralContainerCommon.mut_or_insert_default()
    }

    // Take field
    pub fn take_ephemeralContainerCommon(&mut self) -> EphemeralContainerCommon {
        self.ephemeralContainerCommon.take().unwrap_or_else(|| EphemeralContainerCommon::new())
    }

    // optional string targetContainerName = 2;

    pub fn targetContainerName(&self) -> &str {
        match self.targetContainerName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_targetContainerName(&mut self) {
        self.targetContainerName = ::std::option::Option::None;
    }

    pub fn has_targetContainerName(&self) -> bool {
        self.targetContainerName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetContainerName(&mut self, v: ::std::string::String) {
        self.targetContainerName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetContainerName(&mut self) -> &mut ::std::string::String {
        if self.targetContainerName.is_none() {
            self.targetContainerName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.targetContainerName.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetContainerName(&mut self) -> ::std::string::String {
        self.targetContainerName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EphemeralContainerCommon>(
            "ephemeralContainerCommon",
            |m: &EphemeralContainer| { &m.ephemeralContainerCommon },
            |m: &mut EphemeralContainer| { &mut m.ephemeralContainerCommon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "targetContainerName",
            |m: &EphemeralContainer| { &m.targetContainerName },
            |m: &mut EphemeralContainer| { &mut m.targetContainerName },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EphemeralContainer>(
            "EphemeralContainer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EphemeralContainer {
    const NAME: &'static str = "EphemeralContainer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ephemeralContainerCommon)?;
                },
                18 => {
                    self.targetContainerName = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ephemeralContainerCommon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.targetContainerName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ephemeralContainerCommon.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.targetContainerName.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EphemeralContainer {
        EphemeralContainer::new()
    }

    fn clear(&mut self) {
        self.ephemeralContainerCommon.clear();
        self.targetContainerName = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EphemeralContainer {
        static instance: EphemeralContainer = EphemeralContainer {
            ephemeralContainerCommon: ::protobuf::MessageField::none(),
            targetContainerName: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EphemeralContainer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EphemeralContainer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EphemeralContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EphemeralContainer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.EphemeralContainerCommon)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EphemeralContainerCommon {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainerCommon.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainerCommon.image)
    pub image: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainerCommon.command)
    pub command: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainerCommon.args)
    pub args: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainerCommon.workingDir)
    pub workingDir: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainerCommon.ports)
    pub ports: ::std::vec::Vec<ContainerPort>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainerCommon.envFrom)
    pub envFrom: ::std::vec::Vec<EnvFromSource>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainerCommon.env)
    pub env: ::std::vec::Vec<EnvVar>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainerCommon.resources)
    pub resources: ::protobuf::MessageField<ResourceRequirements>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainerCommon.resizePolicy)
    pub resizePolicy: ::std::vec::Vec<ContainerResizePolicy>,
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainerCommon.restartPolicy)
    pub restartPolicy: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainerCommon.volumeMounts)
    pub volumeMounts: ::std::vec::Vec<VolumeMount>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainerCommon.volumeDevices)
    pub volumeDevices: ::std::vec::Vec<VolumeDevice>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainerCommon.livenessProbe)
    pub livenessProbe: ::protobuf::MessageField<Probe>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainerCommon.readinessProbe)
    pub readinessProbe: ::protobuf::MessageField<Probe>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainerCommon.startupProbe)
    pub startupProbe: ::protobuf::MessageField<Probe>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainerCommon.lifecycle)
    pub lifecycle: ::protobuf::MessageField<Lifecycle>,
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainerCommon.terminationMessagePath)
    pub terminationMessagePath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainerCommon.terminationMessagePolicy)
    pub terminationMessagePolicy: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainerCommon.imagePullPolicy)
    pub imagePullPolicy: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainerCommon.securityContext)
    pub securityContext: ::protobuf::MessageField<SecurityContext>,
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainerCommon.stdin)
    pub stdin: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainerCommon.stdinOnce)
    pub stdinOnce: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.EphemeralContainerCommon.tty)
    pub tty: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.EphemeralContainerCommon.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EphemeralContainerCommon {
    fn default() -> &'a EphemeralContainerCommon {
        <EphemeralContainerCommon as ::protobuf::Message>::default_instance()
    }
}

impl EphemeralContainerCommon {
    pub fn new() -> EphemeralContainerCommon {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string image = 2;

    pub fn image(&self) -> &str {
        match self.image.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_image(&mut self) {
        self.image = ::std::option::Option::None;
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        if self.image.is_none() {
            self.image = ::std::option::Option::Some(::std::string::String::new());
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        self.image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string command = 3;

    pub fn command(&self) -> &[::std::string::String] {
        &self.command
    }

    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.command = v;
    }

    // Mutable pointer to the field.
    pub fn mut_command(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.command
    }

    // Take field
    pub fn take_command(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.command, ::std::vec::Vec::new())
    }

    // repeated string args = 4;

    pub fn args(&self) -> &[::std::string::String] {
        &self.args
    }

    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.args, ::std::vec::Vec::new())
    }

    // optional string workingDir = 5;

    pub fn workingDir(&self) -> &str {
        match self.workingDir.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_workingDir(&mut self) {
        self.workingDir = ::std::option::Option::None;
    }

    pub fn has_workingDir(&self) -> bool {
        self.workingDir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workingDir(&mut self, v: ::std::string::String) {
        self.workingDir = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workingDir(&mut self) -> &mut ::std::string::String {
        if self.workingDir.is_none() {
            self.workingDir = ::std::option::Option::Some(::std::string::String::new());
        }
        self.workingDir.as_mut().unwrap()
    }

    // Take field
    pub fn take_workingDir(&mut self) -> ::std::string::String {
        self.workingDir.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.core.v1.ContainerPort ports = 6;

    pub fn ports(&self) -> &[ContainerPort] {
        &self.ports
    }

    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::std::vec::Vec<ContainerPort>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::std::vec::Vec<ContainerPort> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::std::vec::Vec<ContainerPort> {
        ::std::mem::replace(&mut self.ports, ::std::vec::Vec::new())
    }

    // repeated .api.core.v1.EnvFromSource envFrom = 19;

    pub fn envFrom(&self) -> &[EnvFromSource] {
        &self.envFrom
    }

    pub fn clear_envFrom(&mut self) {
        self.envFrom.clear();
    }

    // Param is passed by value, moved
    pub fn set_envFrom(&mut self, v: ::std::vec::Vec<EnvFromSource>) {
        self.envFrom = v;
    }

    // Mutable pointer to the field.
    pub fn mut_envFrom(&mut self) -> &mut ::std::vec::Vec<EnvFromSource> {
        &mut self.envFrom
    }

    // Take field
    pub fn take_envFrom(&mut self) -> ::std::vec::Vec<EnvFromSource> {
        ::std::mem::replace(&mut self.envFrom, ::std::vec::Vec::new())
    }

    // repeated .api.core.v1.EnvVar env = 7;

    pub fn env(&self) -> &[EnvVar] {
        &self.env
    }

    pub fn clear_env(&mut self) {
        self.env.clear();
    }

    // Param is passed by value, moved
    pub fn set_env(&mut self, v: ::std::vec::Vec<EnvVar>) {
        self.env = v;
    }

    // Mutable pointer to the field.
    pub fn mut_env(&mut self) -> &mut ::std::vec::Vec<EnvVar> {
        &mut self.env
    }

    // Take field
    pub fn take_env(&mut self) -> ::std::vec::Vec<EnvVar> {
        ::std::mem::replace(&mut self.env, ::std::vec::Vec::new())
    }

    // optional .api.core.v1.ResourceRequirements resources = 8;

    pub fn resources(&self) -> &ResourceRequirements {
        self.resources.as_ref().unwrap_or_else(|| <ResourceRequirements as ::protobuf::Message>::default_instance())
    }

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    pub fn has_resources(&self) -> bool {
        self.resources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ResourceRequirements) {
        self.resources = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resources(&mut self) -> &mut ResourceRequirements {
        self.resources.mut_or_insert_default()
    }

    // Take field
    pub fn take_resources(&mut self) -> ResourceRequirements {
        self.resources.take().unwrap_or_else(|| ResourceRequirements::new())
    }

    // repeated .api.core.v1.ContainerResizePolicy resizePolicy = 23;

    pub fn resizePolicy(&self) -> &[ContainerResizePolicy] {
        &self.resizePolicy
    }

    pub fn clear_resizePolicy(&mut self) {
        self.resizePolicy.clear();
    }

    // Param is passed by value, moved
    pub fn set_resizePolicy(&mut self, v: ::std::vec::Vec<ContainerResizePolicy>) {
        self.resizePolicy = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resizePolicy(&mut self) -> &mut ::std::vec::Vec<ContainerResizePolicy> {
        &mut self.resizePolicy
    }

    // Take field
    pub fn take_resizePolicy(&mut self) -> ::std::vec::Vec<ContainerResizePolicy> {
        ::std::mem::replace(&mut self.resizePolicy, ::std::vec::Vec::new())
    }

    // optional string restartPolicy = 24;

    pub fn restartPolicy(&self) -> &str {
        match self.restartPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_restartPolicy(&mut self) {
        self.restartPolicy = ::std::option::Option::None;
    }

    pub fn has_restartPolicy(&self) -> bool {
        self.restartPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_restartPolicy(&mut self, v: ::std::string::String) {
        self.restartPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_restartPolicy(&mut self) -> &mut ::std::string::String {
        if self.restartPolicy.is_none() {
            self.restartPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.restartPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_restartPolicy(&mut self) -> ::std::string::String {
        self.restartPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.core.v1.VolumeMount volumeMounts = 9;

    pub fn volumeMounts(&self) -> &[VolumeMount] {
        &self.volumeMounts
    }

    pub fn clear_volumeMounts(&mut self) {
        self.volumeMounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumeMounts(&mut self, v: ::std::vec::Vec<VolumeMount>) {
        self.volumeMounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumeMounts(&mut self) -> &mut ::std::vec::Vec<VolumeMount> {
        &mut self.volumeMounts
    }

    // Take field
    pub fn take_volumeMounts(&mut self) -> ::std::vec::Vec<VolumeMount> {
        ::std::mem::replace(&mut self.volumeMounts, ::std::vec::Vec::new())
    }

    // repeated .api.core.v1.VolumeDevice volumeDevices = 21;

    pub fn volumeDevices(&self) -> &[VolumeDevice] {
        &self.volumeDevices
    }

    pub fn clear_volumeDevices(&mut self) {
        self.volumeDevices.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumeDevices(&mut self, v: ::std::vec::Vec<VolumeDevice>) {
        self.volumeDevices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumeDevices(&mut self) -> &mut ::std::vec::Vec<VolumeDevice> {
        &mut self.volumeDevices
    }

    // Take field
    pub fn take_volumeDevices(&mut self) -> ::std::vec::Vec<VolumeDevice> {
        ::std::mem::replace(&mut self.volumeDevices, ::std::vec::Vec::new())
    }

    // optional .api.core.v1.Probe livenessProbe = 10;

    pub fn livenessProbe(&self) -> &Probe {
        self.livenessProbe.as_ref().unwrap_or_else(|| <Probe as ::protobuf::Message>::default_instance())
    }

    pub fn clear_livenessProbe(&mut self) {
        self.livenessProbe.clear();
    }

    pub fn has_livenessProbe(&self) -> bool {
        self.livenessProbe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_livenessProbe(&mut self, v: Probe) {
        self.livenessProbe = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_livenessProbe(&mut self) -> &mut Probe {
        self.livenessProbe.mut_or_insert_default()
    }

    // Take field
    pub fn take_livenessProbe(&mut self) -> Probe {
        self.livenessProbe.take().unwrap_or_else(|| Probe::new())
    }

    // optional .api.core.v1.Probe readinessProbe = 11;

    pub fn readinessProbe(&self) -> &Probe {
        self.readinessProbe.as_ref().unwrap_or_else(|| <Probe as ::protobuf::Message>::default_instance())
    }

    pub fn clear_readinessProbe(&mut self) {
        self.readinessProbe.clear();
    }

    pub fn has_readinessProbe(&self) -> bool {
        self.readinessProbe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readinessProbe(&mut self, v: Probe) {
        self.readinessProbe = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_readinessProbe(&mut self) -> &mut Probe {
        self.readinessProbe.mut_or_insert_default()
    }

    // Take field
    pub fn take_readinessProbe(&mut self) -> Probe {
        self.readinessProbe.take().unwrap_or_else(|| Probe::new())
    }

    // optional .api.core.v1.Probe startupProbe = 22;

    pub fn startupProbe(&self) -> &Probe {
        self.startupProbe.as_ref().unwrap_or_else(|| <Probe as ::protobuf::Message>::default_instance())
    }

    pub fn clear_startupProbe(&mut self) {
        self.startupProbe.clear();
    }

    pub fn has_startupProbe(&self) -> bool {
        self.startupProbe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startupProbe(&mut self, v: Probe) {
        self.startupProbe = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startupProbe(&mut self) -> &mut Probe {
        self.startupProbe.mut_or_insert_default()
    }

    // Take field
    pub fn take_startupProbe(&mut self) -> Probe {
        self.startupProbe.take().unwrap_or_else(|| Probe::new())
    }

    // optional .api.core.v1.Lifecycle lifecycle = 12;

    pub fn lifecycle(&self) -> &Lifecycle {
        self.lifecycle.as_ref().unwrap_or_else(|| <Lifecycle as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lifecycle(&mut self) {
        self.lifecycle.clear();
    }

    pub fn has_lifecycle(&self) -> bool {
        self.lifecycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lifecycle(&mut self, v: Lifecycle) {
        self.lifecycle = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lifecycle(&mut self) -> &mut Lifecycle {
        self.lifecycle.mut_or_insert_default()
    }

    // Take field
    pub fn take_lifecycle(&mut self) -> Lifecycle {
        self.lifecycle.take().unwrap_or_else(|| Lifecycle::new())
    }

    // optional string terminationMessagePath = 13;

    pub fn terminationMessagePath(&self) -> &str {
        match self.terminationMessagePath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_terminationMessagePath(&mut self) {
        self.terminationMessagePath = ::std::option::Option::None;
    }

    pub fn has_terminationMessagePath(&self) -> bool {
        self.terminationMessagePath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_terminationMessagePath(&mut self, v: ::std::string::String) {
        self.terminationMessagePath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_terminationMessagePath(&mut self) -> &mut ::std::string::String {
        if self.terminationMessagePath.is_none() {
            self.terminationMessagePath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.terminationMessagePath.as_mut().unwrap()
    }

    // Take field
    pub fn take_terminationMessagePath(&mut self) -> ::std::string::String {
        self.terminationMessagePath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string terminationMessagePolicy = 20;

    pub fn terminationMessagePolicy(&self) -> &str {
        match self.terminationMessagePolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_terminationMessagePolicy(&mut self) {
        self.terminationMessagePolicy = ::std::option::Option::None;
    }

    pub fn has_terminationMessagePolicy(&self) -> bool {
        self.terminationMessagePolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_terminationMessagePolicy(&mut self, v: ::std::string::String) {
        self.terminationMessagePolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_terminationMessagePolicy(&mut self) -> &mut ::std::string::String {
        if self.terminationMessagePolicy.is_none() {
            self.terminationMessagePolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.terminationMessagePolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_terminationMessagePolicy(&mut self) -> ::std::string::String {
        self.terminationMessagePolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string imagePullPolicy = 14;

    pub fn imagePullPolicy(&self) -> &str {
        match self.imagePullPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_imagePullPolicy(&mut self) {
        self.imagePullPolicy = ::std::option::Option::None;
    }

    pub fn has_imagePullPolicy(&self) -> bool {
        self.imagePullPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_imagePullPolicy(&mut self, v: ::std::string::String) {
        self.imagePullPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_imagePullPolicy(&mut self) -> &mut ::std::string::String {
        if self.imagePullPolicy.is_none() {
            self.imagePullPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.imagePullPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_imagePullPolicy(&mut self) -> ::std::string::String {
        self.imagePullPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.SecurityContext securityContext = 15;

    pub fn securityContext(&self) -> &SecurityContext {
        self.securityContext.as_ref().unwrap_or_else(|| <SecurityContext as ::protobuf::Message>::default_instance())
    }

    pub fn clear_securityContext(&mut self) {
        self.securityContext.clear();
    }

    pub fn has_securityContext(&self) -> bool {
        self.securityContext.is_some()
    }

    // Param is passed by value, moved
    pub fn set_securityContext(&mut self, v: SecurityContext) {
        self.securityContext = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_securityContext(&mut self) -> &mut SecurityContext {
        self.securityContext.mut_or_insert_default()
    }

    // Take field
    pub fn take_securityContext(&mut self) -> SecurityContext {
        self.securityContext.take().unwrap_or_else(|| SecurityContext::new())
    }

    // optional bool stdin = 16;

    pub fn stdin(&self) -> bool {
        self.stdin.unwrap_or(false)
    }

    pub fn clear_stdin(&mut self) {
        self.stdin = ::std::option::Option::None;
    }

    pub fn has_stdin(&self) -> bool {
        self.stdin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdin(&mut self, v: bool) {
        self.stdin = ::std::option::Option::Some(v);
    }

    // optional bool stdinOnce = 17;

    pub fn stdinOnce(&self) -> bool {
        self.stdinOnce.unwrap_or(false)
    }

    pub fn clear_stdinOnce(&mut self) {
        self.stdinOnce = ::std::option::Option::None;
    }

    pub fn has_stdinOnce(&self) -> bool {
        self.stdinOnce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdinOnce(&mut self, v: bool) {
        self.stdinOnce = ::std::option::Option::Some(v);
    }

    // optional bool tty = 18;

    pub fn tty(&self) -> bool {
        self.tty.unwrap_or(false)
    }

    pub fn clear_tty(&mut self) {
        self.tty = ::std::option::Option::None;
    }

    pub fn has_tty(&self) -> bool {
        self.tty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tty(&mut self, v: bool) {
        self.tty = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(24);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &EphemeralContainerCommon| { &m.name },
            |m: &mut EphemeralContainerCommon| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "image",
            |m: &EphemeralContainerCommon| { &m.image },
            |m: &mut EphemeralContainerCommon| { &mut m.image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "command",
            |m: &EphemeralContainerCommon| { &m.command },
            |m: &mut EphemeralContainerCommon| { &mut m.command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "args",
            |m: &EphemeralContainerCommon| { &m.args },
            |m: &mut EphemeralContainerCommon| { &mut m.args },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "workingDir",
            |m: &EphemeralContainerCommon| { &m.workingDir },
            |m: &mut EphemeralContainerCommon| { &mut m.workingDir },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ports",
            |m: &EphemeralContainerCommon| { &m.ports },
            |m: &mut EphemeralContainerCommon| { &mut m.ports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "envFrom",
            |m: &EphemeralContainerCommon| { &m.envFrom },
            |m: &mut EphemeralContainerCommon| { &mut m.envFrom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "env",
            |m: &EphemeralContainerCommon| { &m.env },
            |m: &mut EphemeralContainerCommon| { &mut m.env },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceRequirements>(
            "resources",
            |m: &EphemeralContainerCommon| { &m.resources },
            |m: &mut EphemeralContainerCommon| { &mut m.resources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resizePolicy",
            |m: &EphemeralContainerCommon| { &m.resizePolicy },
            |m: &mut EphemeralContainerCommon| { &mut m.resizePolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "restartPolicy",
            |m: &EphemeralContainerCommon| { &m.restartPolicy },
            |m: &mut EphemeralContainerCommon| { &mut m.restartPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "volumeMounts",
            |m: &EphemeralContainerCommon| { &m.volumeMounts },
            |m: &mut EphemeralContainerCommon| { &mut m.volumeMounts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "volumeDevices",
            |m: &EphemeralContainerCommon| { &m.volumeDevices },
            |m: &mut EphemeralContainerCommon| { &mut m.volumeDevices },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Probe>(
            "livenessProbe",
            |m: &EphemeralContainerCommon| { &m.livenessProbe },
            |m: &mut EphemeralContainerCommon| { &mut m.livenessProbe },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Probe>(
            "readinessProbe",
            |m: &EphemeralContainerCommon| { &m.readinessProbe },
            |m: &mut EphemeralContainerCommon| { &mut m.readinessProbe },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Probe>(
            "startupProbe",
            |m: &EphemeralContainerCommon| { &m.startupProbe },
            |m: &mut EphemeralContainerCommon| { &mut m.startupProbe },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Lifecycle>(
            "lifecycle",
            |m: &EphemeralContainerCommon| { &m.lifecycle },
            |m: &mut EphemeralContainerCommon| { &mut m.lifecycle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "terminationMessagePath",
            |m: &EphemeralContainerCommon| { &m.terminationMessagePath },
            |m: &mut EphemeralContainerCommon| { &mut m.terminationMessagePath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "terminationMessagePolicy",
            |m: &EphemeralContainerCommon| { &m.terminationMessagePolicy },
            |m: &mut EphemeralContainerCommon| { &mut m.terminationMessagePolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "imagePullPolicy",
            |m: &EphemeralContainerCommon| { &m.imagePullPolicy },
            |m: &mut EphemeralContainerCommon| { &mut m.imagePullPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SecurityContext>(
            "securityContext",
            |m: &EphemeralContainerCommon| { &m.securityContext },
            |m: &mut EphemeralContainerCommon| { &mut m.securityContext },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stdin",
            |m: &EphemeralContainerCommon| { &m.stdin },
            |m: &mut EphemeralContainerCommon| { &mut m.stdin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stdinOnce",
            |m: &EphemeralContainerCommon| { &m.stdinOnce },
            |m: &mut EphemeralContainerCommon| { &mut m.stdinOnce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tty",
            |m: &EphemeralContainerCommon| { &m.tty },
            |m: &mut EphemeralContainerCommon| { &mut m.tty },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EphemeralContainerCommon>(
            "EphemeralContainerCommon",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EphemeralContainerCommon {
    const NAME: &'static str = "EphemeralContainerCommon";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.image = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.command.push(is.read_string()?);
                },
                34 => {
                    self.args.push(is.read_string()?);
                },
                42 => {
                    self.workingDir = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.ports.push(is.read_message()?);
                },
                154 => {
                    self.envFrom.push(is.read_message()?);
                },
                58 => {
                    self.env.push(is.read_message()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resources)?;
                },
                186 => {
                    self.resizePolicy.push(is.read_message()?);
                },
                194 => {
                    self.restartPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.volumeMounts.push(is.read_message()?);
                },
                170 => {
                    self.volumeDevices.push(is.read_message()?);
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.livenessProbe)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.readinessProbe)?;
                },
                178 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.startupProbe)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lifecycle)?;
                },
                106 => {
                    self.terminationMessagePath = ::std::option::Option::Some(is.read_string()?);
                },
                162 => {
                    self.terminationMessagePolicy = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    self.imagePullPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.securityContext)?;
                },
                128 => {
                    self.stdin = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.stdinOnce = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.tty = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.image.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.command {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.args {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.workingDir.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.envFrom {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.env {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.resources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.resizePolicy {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.restartPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(24, &v);
        }
        for value in &self.volumeMounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.volumeDevices {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.livenessProbe.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.readinessProbe.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.startupProbe.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.lifecycle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.terminationMessagePath.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.terminationMessagePolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.imagePullPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.securityContext.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stdin {
            my_size += 2 + 1;
        }
        if let Some(v) = self.stdinOnce {
            my_size += 2 + 1;
        }
        if let Some(v) = self.tty {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.image.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.command {
            os.write_string(3, &v)?;
        };
        for v in &self.args {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.workingDir.as_ref() {
            os.write_string(5, v)?;
        }
        for v in &self.ports {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.envFrom {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        };
        for v in &self.env {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.resources.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        for v in &self.resizePolicy {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        };
        if let Some(v) = self.restartPolicy.as_ref() {
            os.write_string(24, v)?;
        }
        for v in &self.volumeMounts {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        for v in &self.volumeDevices {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        };
        if let Some(v) = self.livenessProbe.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.readinessProbe.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.startupProbe.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.lifecycle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.terminationMessagePath.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.terminationMessagePolicy.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.imagePullPolicy.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.securityContext.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.stdin {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.stdinOnce {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.tty {
            os.write_bool(18, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EphemeralContainerCommon {
        EphemeralContainerCommon::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.image = ::std::option::Option::None;
        self.command.clear();
        self.args.clear();
        self.workingDir = ::std::option::Option::None;
        self.ports.clear();
        self.envFrom.clear();
        self.env.clear();
        self.resources.clear();
        self.resizePolicy.clear();
        self.restartPolicy = ::std::option::Option::None;
        self.volumeMounts.clear();
        self.volumeDevices.clear();
        self.livenessProbe.clear();
        self.readinessProbe.clear();
        self.startupProbe.clear();
        self.lifecycle.clear();
        self.terminationMessagePath = ::std::option::Option::None;
        self.terminationMessagePolicy = ::std::option::Option::None;
        self.imagePullPolicy = ::std::option::Option::None;
        self.securityContext.clear();
        self.stdin = ::std::option::Option::None;
        self.stdinOnce = ::std::option::Option::None;
        self.tty = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EphemeralContainerCommon {
        static instance: EphemeralContainerCommon = EphemeralContainerCommon {
            name: ::std::option::Option::None,
            image: ::std::option::Option::None,
            command: ::std::vec::Vec::new(),
            args: ::std::vec::Vec::new(),
            workingDir: ::std::option::Option::None,
            ports: ::std::vec::Vec::new(),
            envFrom: ::std::vec::Vec::new(),
            env: ::std::vec::Vec::new(),
            resources: ::protobuf::MessageField::none(),
            resizePolicy: ::std::vec::Vec::new(),
            restartPolicy: ::std::option::Option::None,
            volumeMounts: ::std::vec::Vec::new(),
            volumeDevices: ::std::vec::Vec::new(),
            livenessProbe: ::protobuf::MessageField::none(),
            readinessProbe: ::protobuf::MessageField::none(),
            startupProbe: ::protobuf::MessageField::none(),
            lifecycle: ::protobuf::MessageField::none(),
            terminationMessagePath: ::std::option::Option::None,
            terminationMessagePolicy: ::std::option::Option::None,
            imagePullPolicy: ::std::option::Option::None,
            securityContext: ::protobuf::MessageField::none(),
            stdin: ::std::option::Option::None,
            stdinOnce: ::std::option::Option::None,
            tty: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EphemeralContainerCommon {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EphemeralContainerCommon").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EphemeralContainerCommon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EphemeralContainerCommon {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.EphemeralVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EphemeralVolumeSource {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EphemeralVolumeSource.volumeClaimTemplate)
    pub volumeClaimTemplate: ::protobuf::MessageField<PersistentVolumeClaimTemplate>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.EphemeralVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EphemeralVolumeSource {
    fn default() -> &'a EphemeralVolumeSource {
        <EphemeralVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl EphemeralVolumeSource {
    pub fn new() -> EphemeralVolumeSource {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.PersistentVolumeClaimTemplate volumeClaimTemplate = 1;

    pub fn volumeClaimTemplate(&self) -> &PersistentVolumeClaimTemplate {
        self.volumeClaimTemplate.as_ref().unwrap_or_else(|| <PersistentVolumeClaimTemplate as ::protobuf::Message>::default_instance())
    }

    pub fn clear_volumeClaimTemplate(&mut self) {
        self.volumeClaimTemplate.clear();
    }

    pub fn has_volumeClaimTemplate(&self) -> bool {
        self.volumeClaimTemplate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeClaimTemplate(&mut self, v: PersistentVolumeClaimTemplate) {
        self.volumeClaimTemplate = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeClaimTemplate(&mut self) -> &mut PersistentVolumeClaimTemplate {
        self.volumeClaimTemplate.mut_or_insert_default()
    }

    // Take field
    pub fn take_volumeClaimTemplate(&mut self) -> PersistentVolumeClaimTemplate {
        self.volumeClaimTemplate.take().unwrap_or_else(|| PersistentVolumeClaimTemplate::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PersistentVolumeClaimTemplate>(
            "volumeClaimTemplate",
            |m: &EphemeralVolumeSource| { &m.volumeClaimTemplate },
            |m: &mut EphemeralVolumeSource| { &mut m.volumeClaimTemplate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EphemeralVolumeSource>(
            "EphemeralVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EphemeralVolumeSource {
    const NAME: &'static str = "EphemeralVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.volumeClaimTemplate)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.volumeClaimTemplate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.volumeClaimTemplate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EphemeralVolumeSource {
        EphemeralVolumeSource::new()
    }

    fn clear(&mut self) {
        self.volumeClaimTemplate.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EphemeralVolumeSource {
        static instance: EphemeralVolumeSource = EphemeralVolumeSource {
            volumeClaimTemplate: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EphemeralVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EphemeralVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EphemeralVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EphemeralVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.Event)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Event {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Event.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Event.involvedObject)
    pub involvedObject: ::protobuf::MessageField<ObjectReference>,
    // @@protoc_insertion_point(field:api.core.v1.Event.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.Event.message)
    pub message: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Event.source)
    pub source: ::protobuf::MessageField<EventSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Event.firstTimestamp)
    pub firstTimestamp: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Event.lastTimestamp)
    pub lastTimestamp: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:api.core.v1.Event.count)
    pub count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.Event.type)
    pub type_: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Event.eventTime)
    pub eventTime: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Event.series)
    pub series: ::protobuf::MessageField<EventSeries>,
    // @@protoc_insertion_point(field:api.core.v1.Event.action)
    pub action: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Event.related)
    pub related: ::protobuf::MessageField<ObjectReference>,
    // @@protoc_insertion_point(field:api.core.v1.Event.reportingComponent)
    pub reportingComponent: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.Event.reportingInstance)
    pub reportingInstance: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.Event.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Event {
    fn default() -> &'a Event {
        <Event as ::protobuf::Message>::default_instance()
    }
}

impl Event {
    pub fn new() -> Event {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.core.v1.ObjectReference involvedObject = 2;

    pub fn involvedObject(&self) -> &ObjectReference {
        self.involvedObject.as_ref().unwrap_or_else(|| <ObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_involvedObject(&mut self) {
        self.involvedObject.clear();
    }

    pub fn has_involvedObject(&self) -> bool {
        self.involvedObject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_involvedObject(&mut self, v: ObjectReference) {
        self.involvedObject = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_involvedObject(&mut self) -> &mut ObjectReference {
        self.involvedObject.mut_or_insert_default()
    }

    // Take field
    pub fn take_involvedObject(&mut self) -> ObjectReference {
        self.involvedObject.take().unwrap_or_else(|| ObjectReference::new())
    }

    // optional string reason = 3;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 4;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.EventSource source = 5;

    pub fn source(&self) -> &EventSource {
        self.source.as_ref().unwrap_or_else(|| <EventSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: EventSource) {
        self.source = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut EventSource {
        self.source.mut_or_insert_default()
    }

    // Take field
    pub fn take_source(&mut self) -> EventSource {
        self.source.take().unwrap_or_else(|| EventSource::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time firstTimestamp = 6;

    pub fn firstTimestamp(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.firstTimestamp.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_firstTimestamp(&mut self) {
        self.firstTimestamp.clear();
    }

    pub fn has_firstTimestamp(&self) -> bool {
        self.firstTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firstTimestamp(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::Time) {
        self.firstTimestamp = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_firstTimestamp(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.firstTimestamp.mut_or_insert_default()
    }

    // Take field
    pub fn take_firstTimestamp(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.firstTimestamp.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastTimestamp = 7;

    pub fn lastTimestamp(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTimestamp.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastTimestamp(&mut self) {
        self.lastTimestamp.clear();
    }

    pub fn has_lastTimestamp(&self) -> bool {
        self.lastTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTimestamp(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastTimestamp = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTimestamp(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTimestamp.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastTimestamp(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTimestamp.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional int32 count = 8;

    pub fn count(&self) -> i32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional string type = 9;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.MicroTime eventTime = 10;

    pub fn eventTime(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.eventTime.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_eventTime(&mut self) {
        self.eventTime.clear();
    }

    pub fn has_eventTime(&self) -> bool {
        self.eventTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventTime(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::Time) {
        self.eventTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eventTime(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.eventTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_eventTime(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.eventTime.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional .api.core.v1.EventSeries series = 11;

    pub fn series(&self) -> &EventSeries {
        self.series.as_ref().unwrap_or_else(|| <EventSeries as ::protobuf::Message>::default_instance())
    }

    pub fn clear_series(&mut self) {
        self.series.clear();
    }

    pub fn has_series(&self) -> bool {
        self.series.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series(&mut self, v: EventSeries) {
        self.series = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_series(&mut self) -> &mut EventSeries {
        self.series.mut_or_insert_default()
    }

    // Take field
    pub fn take_series(&mut self) -> EventSeries {
        self.series.take().unwrap_or_else(|| EventSeries::new())
    }

    // optional string action = 12;

    pub fn action(&self) -> &str {
        match self.action.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        if self.action.is_none() {
            self.action = ::std::option::Option::Some(::std::string::String::new());
        }
        self.action.as_mut().unwrap()
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        self.action.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.ObjectReference related = 13;

    pub fn related(&self) -> &ObjectReference {
        self.related.as_ref().unwrap_or_else(|| <ObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_related(&mut self) {
        self.related.clear();
    }

    pub fn has_related(&self) -> bool {
        self.related.is_some()
    }

    // Param is passed by value, moved
    pub fn set_related(&mut self, v: ObjectReference) {
        self.related = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_related(&mut self) -> &mut ObjectReference {
        self.related.mut_or_insert_default()
    }

    // Take field
    pub fn take_related(&mut self) -> ObjectReference {
        self.related.take().unwrap_or_else(|| ObjectReference::new())
    }

    // optional string reportingComponent = 14;

    pub fn reportingComponent(&self) -> &str {
        match self.reportingComponent.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reportingComponent(&mut self) {
        self.reportingComponent = ::std::option::Option::None;
    }

    pub fn has_reportingComponent(&self) -> bool {
        self.reportingComponent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reportingComponent(&mut self, v: ::std::string::String) {
        self.reportingComponent = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reportingComponent(&mut self) -> &mut ::std::string::String {
        if self.reportingComponent.is_none() {
            self.reportingComponent = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reportingComponent.as_mut().unwrap()
    }

    // Take field
    pub fn take_reportingComponent(&mut self) -> ::std::string::String {
        self.reportingComponent.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reportingInstance = 15;

    pub fn reportingInstance(&self) -> &str {
        match self.reportingInstance.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reportingInstance(&mut self) {
        self.reportingInstance = ::std::option::Option::None;
    }

    pub fn has_reportingInstance(&self) -> bool {
        self.reportingInstance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reportingInstance(&mut self, v: ::std::string::String) {
        self.reportingInstance = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reportingInstance(&mut self) -> &mut ::std::string::String {
        if self.reportingInstance.is_none() {
            self.reportingInstance = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reportingInstance.as_mut().unwrap()
    }

    // Take field
    pub fn take_reportingInstance(&mut self) -> ::std::string::String {
        self.reportingInstance.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &Event| { &m.metadata },
            |m: &mut Event| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ObjectReference>(
            "involvedObject",
            |m: &Event| { &m.involvedObject },
            |m: &mut Event| { &mut m.involvedObject },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &Event| { &m.reason },
            |m: &mut Event| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &Event| { &m.message },
            |m: &mut Event| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EventSource>(
            "source",
            |m: &Event| { &m.source },
            |m: &mut Event| { &mut m.source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>(
            "firstTimestamp",
            |m: &Event| { &m.firstTimestamp },
            |m: &mut Event| { &mut m.firstTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>(
            "lastTimestamp",
            |m: &Event| { &m.lastTimestamp },
            |m: &mut Event| { &mut m.lastTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &Event| { &m.count },
            |m: &mut Event| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &Event| { &m.type_ },
            |m: &mut Event| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>(
            "eventTime",
            |m: &Event| { &m.eventTime },
            |m: &mut Event| { &mut m.eventTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EventSeries>(
            "series",
            |m: &Event| { &m.series },
            |m: &mut Event| { &mut m.series },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "action",
            |m: &Event| { &m.action },
            |m: &mut Event| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ObjectReference>(
            "related",
            |m: &Event| { &m.related },
            |m: &mut Event| { &mut m.related },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reportingComponent",
            |m: &Event| { &m.reportingComponent },
            |m: &mut Event| { &mut m.reportingComponent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reportingInstance",
            |m: &Event| { &m.reportingInstance },
            |m: &mut Event| { &mut m.reportingInstance },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Event>(
            "Event",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Event {
    const NAME: &'static str = "Event";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.involvedObject)?;
                },
                26 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.source)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.firstTimestamp)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTimestamp)?;
                },
                64 => {
                    self.count = ::std::option::Option::Some(is.read_int32()?);
                },
                74 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.eventTime)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.series)?;
                },
                98 => {
                    self.action = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.related)?;
                },
                114 => {
                    self.reportingComponent = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    self.reportingInstance = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.involvedObject.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.firstTimestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.lastTimestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.eventTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.series.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.action.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.related.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reportingComponent.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.reportingInstance.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.involvedObject.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.source.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.firstTimestamp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.lastTimestamp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.count {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.type_.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.eventTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.series.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.action.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.related.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.reportingComponent.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.reportingInstance.as_ref() {
            os.write_string(15, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Event {
        Event::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.involvedObject.clear();
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.source.clear();
        self.firstTimestamp.clear();
        self.lastTimestamp.clear();
        self.count = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.eventTime.clear();
        self.series.clear();
        self.action = ::std::option::Option::None;
        self.related.clear();
        self.reportingComponent = ::std::option::Option::None;
        self.reportingInstance = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Event {
        static instance: Event = Event {
            metadata: ::protobuf::MessageField::none(),
            involvedObject: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            source: ::protobuf::MessageField::none(),
            firstTimestamp: ::protobuf::MessageField::none(),
            lastTimestamp: ::protobuf::MessageField::none(),
            count: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            eventTime: ::protobuf::MessageField::none(),
            series: ::protobuf::MessageField::none(),
            action: ::std::option::Option::None,
            related: ::protobuf::MessageField::none(),
            reportingComponent: ::std::option::Option::None,
            reportingInstance: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Event {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Event").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Event {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Event {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.EventList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventList {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EventList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EventList.items)
    pub items: ::std::vec::Vec<Event>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.EventList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EventList {
    fn default() -> &'a EventList {
        <EventList as ::protobuf::Message>::default_instance()
    }
}

impl EventList {
    pub fn new() -> EventList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.core.v1.Event items = 2;

    pub fn items(&self) -> &[Event] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<Event>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<Event> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<Event> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &EventList| { &m.metadata },
            |m: &mut EventList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &EventList| { &m.items },
            |m: &mut EventList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EventList>(
            "EventList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EventList {
    const NAME: &'static str = "EventList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EventList {
        EventList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EventList {
        static instance: EventList = EventList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EventList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EventList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EventList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.EventSeries)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventSeries {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.EventSeries.count)
    pub count: ::std::option::Option<i32>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.EventSeries.lastObservedTime)
    pub lastObservedTime: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.EventSeries.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EventSeries {
    fn default() -> &'a EventSeries {
        <EventSeries as ::protobuf::Message>::default_instance()
    }
}

impl EventSeries {
    pub fn new() -> EventSeries {
        ::std::default::Default::default()
    }

    // optional int32 count = 1;

    pub fn count(&self) -> i32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional .apimachinery.pkg.apis.meta.v1.MicroTime lastObservedTime = 2;

    pub fn lastObservedTime(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastObservedTime.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastObservedTime(&mut self) {
        self.lastObservedTime.clear();
    }

    pub fn has_lastObservedTime(&self) -> bool {
        self.lastObservedTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastObservedTime(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastObservedTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastObservedTime(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastObservedTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastObservedTime(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastObservedTime.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &EventSeries| { &m.count },
            |m: &mut EventSeries| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>(
            "lastObservedTime",
            |m: &EventSeries| { &m.lastObservedTime },
            |m: &mut EventSeries| { &mut m.lastObservedTime },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EventSeries>(
            "EventSeries",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EventSeries {
    const NAME: &'static str = "EventSeries";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.count = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastObservedTime)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.lastObservedTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.count {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.lastObservedTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EventSeries {
        EventSeries::new()
    }

    fn clear(&mut self) {
        self.count = ::std::option::Option::None;
        self.lastObservedTime.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EventSeries {
        static instance: EventSeries = EventSeries {
            count: ::std::option::Option::None,
            lastObservedTime: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EventSeries {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EventSeries").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EventSeries {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventSeries {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.EventSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.EventSource.component)
    pub component: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.EventSource.host)
    pub host: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.EventSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EventSource {
    fn default() -> &'a EventSource {
        <EventSource as ::protobuf::Message>::default_instance()
    }
}

impl EventSource {
    pub fn new() -> EventSource {
        ::std::default::Default::default()
    }

    // optional string component = 1;

    pub fn component(&self) -> &str {
        match self.component.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_component(&mut self) {
        self.component = ::std::option::Option::None;
    }

    pub fn has_component(&self) -> bool {
        self.component.is_some()
    }

    // Param is passed by value, moved
    pub fn set_component(&mut self, v: ::std::string::String) {
        self.component = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_component(&mut self) -> &mut ::std::string::String {
        if self.component.is_none() {
            self.component = ::std::option::Option::Some(::std::string::String::new());
        }
        self.component.as_mut().unwrap()
    }

    // Take field
    pub fn take_component(&mut self) -> ::std::string::String {
        self.component.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string host = 2;

    pub fn host(&self) -> &str {
        match self.host.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_host(&mut self) {
        self.host = ::std::option::Option::None;
    }

    pub fn has_host(&self) -> bool {
        self.host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        if self.host.is_none() {
            self.host = ::std::option::Option::Some(::std::string::String::new());
        }
        self.host.as_mut().unwrap()
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        self.host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "component",
            |m: &EventSource| { &m.component },
            |m: &mut EventSource| { &mut m.component },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "host",
            |m: &EventSource| { &m.host },
            |m: &mut EventSource| { &mut m.host },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EventSource>(
            "EventSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EventSource {
    const NAME: &'static str = "EventSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.component = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.host = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.component.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.host.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.component.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.host.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EventSource {
        EventSource::new()
    }

    fn clear(&mut self) {
        self.component = ::std::option::Option::None;
        self.host = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EventSource {
        static instance: EventSource = EventSource {
            component: ::std::option::Option::None,
            host: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EventSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EventSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EventSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ExecAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExecAction {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ExecAction.command)
    pub command: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ExecAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExecAction {
    fn default() -> &'a ExecAction {
        <ExecAction as ::protobuf::Message>::default_instance()
    }
}

impl ExecAction {
    pub fn new() -> ExecAction {
        ::std::default::Default::default()
    }

    // repeated string command = 1;

    pub fn command(&self) -> &[::std::string::String] {
        &self.command
    }

    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.command = v;
    }

    // Mutable pointer to the field.
    pub fn mut_command(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.command
    }

    // Take field
    pub fn take_command(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.command, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "command",
            |m: &ExecAction| { &m.command },
            |m: &mut ExecAction| { &mut m.command },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExecAction>(
            "ExecAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExecAction {
    const NAME: &'static str = "ExecAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.command.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.command {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.command {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExecAction {
        ExecAction::new()
    }

    fn clear(&mut self) {
        self.command.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExecAction {
        static instance: ExecAction = ExecAction {
            command: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExecAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExecAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExecAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.FCVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FCVolumeSource {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.FCVolumeSource.targetWWNs)
    pub targetWWNs: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.FCVolumeSource.lun)
    pub lun: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.FCVolumeSource.fsType)
    pub fsType: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.FCVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.FCVolumeSource.wwids)
    pub wwids: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.FCVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FCVolumeSource {
    fn default() -> &'a FCVolumeSource {
        <FCVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl FCVolumeSource {
    pub fn new() -> FCVolumeSource {
        ::std::default::Default::default()
    }

    // repeated string targetWWNs = 1;

    pub fn targetWWNs(&self) -> &[::std::string::String] {
        &self.targetWWNs
    }

    pub fn clear_targetWWNs(&mut self) {
        self.targetWWNs.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetWWNs(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.targetWWNs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targetWWNs(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.targetWWNs
    }

    // Take field
    pub fn take_targetWWNs(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.targetWWNs, ::std::vec::Vec::new())
    }

    // optional int32 lun = 2;

    pub fn lun(&self) -> i32 {
        self.lun.unwrap_or(0)
    }

    pub fn clear_lun(&mut self) {
        self.lun = ::std::option::Option::None;
    }

    pub fn has_lun(&self) -> bool {
        self.lun.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lun(&mut self, v: i32) {
        self.lun = ::std::option::Option::Some(v);
    }

    // optional string fsType = 3;

    pub fn fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fsType(&mut self) {
        self.fsType = ::std::option::Option::None;
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 4;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // repeated string wwids = 5;

    pub fn wwids(&self) -> &[::std::string::String] {
        &self.wwids
    }

    pub fn clear_wwids(&mut self) {
        self.wwids.clear();
    }

    // Param is passed by value, moved
    pub fn set_wwids(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.wwids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_wwids(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.wwids
    }

    // Take field
    pub fn take_wwids(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.wwids, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "targetWWNs",
            |m: &FCVolumeSource| { &m.targetWWNs },
            |m: &mut FCVolumeSource| { &mut m.targetWWNs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lun",
            |m: &FCVolumeSource| { &m.lun },
            |m: &mut FCVolumeSource| { &mut m.lun },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsType",
            |m: &FCVolumeSource| { &m.fsType },
            |m: &mut FCVolumeSource| { &mut m.fsType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &FCVolumeSource| { &m.readOnly },
            |m: &mut FCVolumeSource| { &mut m.readOnly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "wwids",
            |m: &FCVolumeSource| { &m.wwids },
            |m: &mut FCVolumeSource| { &mut m.wwids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FCVolumeSource>(
            "FCVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FCVolumeSource {
    const NAME: &'static str = "FCVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.targetWWNs.push(is.read_string()?);
                },
                16 => {
                    self.lun = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.fsType = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.wwids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.targetWWNs {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.lun {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        for value in &self.wwids {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.targetWWNs {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.lun {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.fsType.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(4, v)?;
        }
        for v in &self.wwids {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FCVolumeSource {
        FCVolumeSource::new()
    }

    fn clear(&mut self) {
        self.targetWWNs.clear();
        self.lun = ::std::option::Option::None;
        self.fsType = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.wwids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FCVolumeSource {
        static instance: FCVolumeSource = FCVolumeSource {
            targetWWNs: ::std::vec::Vec::new(),
            lun: ::std::option::Option::None,
            fsType: ::std::option::Option::None,
            readOnly: ::std::option::Option::None,
            wwids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FCVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FCVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FCVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FCVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.FlexPersistentVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FlexPersistentVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.FlexPersistentVolumeSource.driver)
    pub driver: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.FlexPersistentVolumeSource.fsType)
    pub fsType: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.FlexPersistentVolumeSource.secretRef)
    pub secretRef: ::protobuf::MessageField<SecretReference>,
    // @@protoc_insertion_point(field:api.core.v1.FlexPersistentVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.FlexPersistentVolumeSource.options)
    pub options: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.FlexPersistentVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FlexPersistentVolumeSource {
    fn default() -> &'a FlexPersistentVolumeSource {
        <FlexPersistentVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl FlexPersistentVolumeSource {
    pub fn new() -> FlexPersistentVolumeSource {
        ::std::default::Default::default()
    }

    // optional string driver = 1;

    pub fn driver(&self) -> &str {
        match self.driver.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_driver(&mut self) {
        self.driver = ::std::option::Option::None;
    }

    pub fn has_driver(&self) -> bool {
        self.driver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driver(&mut self, v: ::std::string::String) {
        self.driver = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver(&mut self) -> &mut ::std::string::String {
        if self.driver.is_none() {
            self.driver = ::std::option::Option::Some(::std::string::String::new());
        }
        self.driver.as_mut().unwrap()
    }

    // Take field
    pub fn take_driver(&mut self) -> ::std::string::String {
        self.driver.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 2;

    pub fn fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fsType(&mut self) {
        self.fsType = ::std::option::Option::None;
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.SecretReference secretRef = 3;

    pub fn secretRef(&self) -> &SecretReference {
        self.secretRef.as_ref().unwrap_or_else(|| <SecretReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: SecretReference) {
        self.secretRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut SecretReference {
        self.secretRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> SecretReference {
        self.secretRef.take().unwrap_or_else(|| SecretReference::new())
    }

    // optional bool readOnly = 4;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // repeated .api.core.v1.FlexPersistentVolumeSource.OptionsEntry options = 5;

    pub fn options(&self) -> &::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &self.options
    }

    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
        self.options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_options(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &mut self.options
    }

    // Take field
    pub fn take_options(&mut self) -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.options, ::std::collections::BTreeMap::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "driver",
            |m: &FlexPersistentVolumeSource| { &m.driver },
            |m: &mut FlexPersistentVolumeSource| { &mut m.driver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsType",
            |m: &FlexPersistentVolumeSource| { &m.fsType },
            |m: &mut FlexPersistentVolumeSource| { &mut m.fsType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SecretReference>(
            "secretRef",
            |m: &FlexPersistentVolumeSource| { &m.secretRef },
            |m: &mut FlexPersistentVolumeSource| { &mut m.secretRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &FlexPersistentVolumeSource| { &m.readOnly },
            |m: &mut FlexPersistentVolumeSource| { &mut m.readOnly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "options",
            |m: &FlexPersistentVolumeSource| { &m.options },
            |m: &mut FlexPersistentVolumeSource| { &mut m.options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FlexPersistentVolumeSource>(
            "FlexPersistentVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FlexPersistentVolumeSource {
    const NAME: &'static str = "FlexPersistentVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.driver = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.fsType = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.secretRef)?;
                },
                32 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.options.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.driver.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        for (k, v) in &self.options {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.driver.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.fsType.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.secretRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(4, v)?;
        }
        for (k, v) in &self.options {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FlexPersistentVolumeSource {
        FlexPersistentVolumeSource::new()
    }

    fn clear(&mut self) {
        self.driver = ::std::option::Option::None;
        self.fsType = ::std::option::Option::None;
        self.secretRef.clear();
        self.readOnly = ::std::option::Option::None;
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FlexPersistentVolumeSource {
        static instance: ::protobuf::rt::Lazy<FlexPersistentVolumeSource> = ::protobuf::rt::Lazy::new();
        instance.get(FlexPersistentVolumeSource::new)
    }
}

impl ::protobuf::MessageFull for FlexPersistentVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FlexPersistentVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FlexPersistentVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlexPersistentVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.FlexVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FlexVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.FlexVolumeSource.driver)
    pub driver: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.FlexVolumeSource.fsType)
    pub fsType: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.FlexVolumeSource.secretRef)
    pub secretRef: ::protobuf::MessageField<LocalObjectReference>,
    // @@protoc_insertion_point(field:api.core.v1.FlexVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.FlexVolumeSource.options)
    pub options: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.FlexVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FlexVolumeSource {
    fn default() -> &'a FlexVolumeSource {
        <FlexVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl FlexVolumeSource {
    pub fn new() -> FlexVolumeSource {
        ::std::default::Default::default()
    }

    // optional string driver = 1;

    pub fn driver(&self) -> &str {
        match self.driver.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_driver(&mut self) {
        self.driver = ::std::option::Option::None;
    }

    pub fn has_driver(&self) -> bool {
        self.driver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driver(&mut self, v: ::std::string::String) {
        self.driver = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver(&mut self) -> &mut ::std::string::String {
        if self.driver.is_none() {
            self.driver = ::std::option::Option::Some(::std::string::String::new());
        }
        self.driver.as_mut().unwrap()
    }

    // Take field
    pub fn take_driver(&mut self) -> ::std::string::String {
        self.driver.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 2;

    pub fn fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fsType(&mut self) {
        self.fsType = ::std::option::Option::None;
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.LocalObjectReference secretRef = 3;

    pub fn secretRef(&self) -> &LocalObjectReference {
        self.secretRef.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: LocalObjectReference) {
        self.secretRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut LocalObjectReference {
        self.secretRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> LocalObjectReference {
        self.secretRef.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    // optional bool readOnly = 4;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // repeated .api.core.v1.FlexVolumeSource.OptionsEntry options = 5;

    pub fn options(&self) -> &::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &self.options
    }

    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
        self.options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_options(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &mut self.options
    }

    // Take field
    pub fn take_options(&mut self) -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.options, ::std::collections::BTreeMap::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "driver",
            |m: &FlexVolumeSource| { &m.driver },
            |m: &mut FlexVolumeSource| { &mut m.driver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsType",
            |m: &FlexVolumeSource| { &m.fsType },
            |m: &mut FlexVolumeSource| { &mut m.fsType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LocalObjectReference>(
            "secretRef",
            |m: &FlexVolumeSource| { &m.secretRef },
            |m: &mut FlexVolumeSource| { &mut m.secretRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &FlexVolumeSource| { &m.readOnly },
            |m: &mut FlexVolumeSource| { &mut m.readOnly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "options",
            |m: &FlexVolumeSource| { &m.options },
            |m: &mut FlexVolumeSource| { &mut m.options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FlexVolumeSource>(
            "FlexVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FlexVolumeSource {
    const NAME: &'static str = "FlexVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.driver = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.fsType = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.secretRef)?;
                },
                32 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.options.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.driver.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        for (k, v) in &self.options {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.driver.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.fsType.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.secretRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(4, v)?;
        }
        for (k, v) in &self.options {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FlexVolumeSource {
        FlexVolumeSource::new()
    }

    fn clear(&mut self) {
        self.driver = ::std::option::Option::None;
        self.fsType = ::std::option::Option::None;
        self.secretRef.clear();
        self.readOnly = ::std::option::Option::None;
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FlexVolumeSource {
        static instance: ::protobuf::rt::Lazy<FlexVolumeSource> = ::protobuf::rt::Lazy::new();
        instance.get(FlexVolumeSource::new)
    }
}

impl ::protobuf::MessageFull for FlexVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FlexVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FlexVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlexVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.FlockerVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FlockerVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.FlockerVolumeSource.datasetName)
    pub datasetName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.FlockerVolumeSource.datasetUUID)
    pub datasetUUID: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.FlockerVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FlockerVolumeSource {
    fn default() -> &'a FlockerVolumeSource {
        <FlockerVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl FlockerVolumeSource {
    pub fn new() -> FlockerVolumeSource {
        ::std::default::Default::default()
    }

    // optional string datasetName = 1;

    pub fn datasetName(&self) -> &str {
        match self.datasetName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_datasetName(&mut self) {
        self.datasetName = ::std::option::Option::None;
    }

    pub fn has_datasetName(&self) -> bool {
        self.datasetName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datasetName(&mut self, v: ::std::string::String) {
        self.datasetName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_datasetName(&mut self) -> &mut ::std::string::String {
        if self.datasetName.is_none() {
            self.datasetName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.datasetName.as_mut().unwrap()
    }

    // Take field
    pub fn take_datasetName(&mut self) -> ::std::string::String {
        self.datasetName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string datasetUUID = 2;

    pub fn datasetUUID(&self) -> &str {
        match self.datasetUUID.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_datasetUUID(&mut self) {
        self.datasetUUID = ::std::option::Option::None;
    }

    pub fn has_datasetUUID(&self) -> bool {
        self.datasetUUID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datasetUUID(&mut self, v: ::std::string::String) {
        self.datasetUUID = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_datasetUUID(&mut self) -> &mut ::std::string::String {
        if self.datasetUUID.is_none() {
            self.datasetUUID = ::std::option::Option::Some(::std::string::String::new());
        }
        self.datasetUUID.as_mut().unwrap()
    }

    // Take field
    pub fn take_datasetUUID(&mut self) -> ::std::string::String {
        self.datasetUUID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "datasetName",
            |m: &FlockerVolumeSource| { &m.datasetName },
            |m: &mut FlockerVolumeSource| { &mut m.datasetName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "datasetUUID",
            |m: &FlockerVolumeSource| { &m.datasetUUID },
            |m: &mut FlockerVolumeSource| { &mut m.datasetUUID },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FlockerVolumeSource>(
            "FlockerVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FlockerVolumeSource {
    const NAME: &'static str = "FlockerVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.datasetName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.datasetUUID = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.datasetName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.datasetUUID.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.datasetName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.datasetUUID.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FlockerVolumeSource {
        FlockerVolumeSource::new()
    }

    fn clear(&mut self) {
        self.datasetName = ::std::option::Option::None;
        self.datasetUUID = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FlockerVolumeSource {
        static instance: FlockerVolumeSource = FlockerVolumeSource {
            datasetName: ::std::option::Option::None,
            datasetUUID: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FlockerVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FlockerVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FlockerVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlockerVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.GCEPersistentDiskVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GCEPersistentDiskVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.GCEPersistentDiskVolumeSource.pdName)
    pub pdName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.GCEPersistentDiskVolumeSource.fsType)
    pub fsType: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.GCEPersistentDiskVolumeSource.partition)
    pub partition: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.GCEPersistentDiskVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.GCEPersistentDiskVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GCEPersistentDiskVolumeSource {
    fn default() -> &'a GCEPersistentDiskVolumeSource {
        <GCEPersistentDiskVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl GCEPersistentDiskVolumeSource {
    pub fn new() -> GCEPersistentDiskVolumeSource {
        ::std::default::Default::default()
    }

    // optional string pdName = 1;

    pub fn pdName(&self) -> &str {
        match self.pdName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pdName(&mut self) {
        self.pdName = ::std::option::Option::None;
    }

    pub fn has_pdName(&self) -> bool {
        self.pdName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pdName(&mut self, v: ::std::string::String) {
        self.pdName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pdName(&mut self) -> &mut ::std::string::String {
        if self.pdName.is_none() {
            self.pdName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pdName.as_mut().unwrap()
    }

    // Take field
    pub fn take_pdName(&mut self) -> ::std::string::String {
        self.pdName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 2;

    pub fn fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fsType(&mut self) {
        self.fsType = ::std::option::Option::None;
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 partition = 3;

    pub fn partition(&self) -> i32 {
        self.partition.unwrap_or(0)
    }

    pub fn clear_partition(&mut self) {
        self.partition = ::std::option::Option::None;
    }

    pub fn has_partition(&self) -> bool {
        self.partition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partition(&mut self, v: i32) {
        self.partition = ::std::option::Option::Some(v);
    }

    // optional bool readOnly = 4;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pdName",
            |m: &GCEPersistentDiskVolumeSource| { &m.pdName },
            |m: &mut GCEPersistentDiskVolumeSource| { &mut m.pdName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsType",
            |m: &GCEPersistentDiskVolumeSource| { &m.fsType },
            |m: &mut GCEPersistentDiskVolumeSource| { &mut m.fsType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "partition",
            |m: &GCEPersistentDiskVolumeSource| { &m.partition },
            |m: &mut GCEPersistentDiskVolumeSource| { &mut m.partition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &GCEPersistentDiskVolumeSource| { &m.readOnly },
            |m: &mut GCEPersistentDiskVolumeSource| { &mut m.readOnly },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GCEPersistentDiskVolumeSource>(
            "GCEPersistentDiskVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GCEPersistentDiskVolumeSource {
    const NAME: &'static str = "GCEPersistentDiskVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pdName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.fsType = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.partition = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pdName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.partition {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pdName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.fsType.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.partition {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GCEPersistentDiskVolumeSource {
        GCEPersistentDiskVolumeSource::new()
    }

    fn clear(&mut self) {
        self.pdName = ::std::option::Option::None;
        self.fsType = ::std::option::Option::None;
        self.partition = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GCEPersistentDiskVolumeSource {
        static instance: GCEPersistentDiskVolumeSource = GCEPersistentDiskVolumeSource {
            pdName: ::std::option::Option::None,
            fsType: ::std::option::Option::None,
            partition: ::std::option::Option::None,
            readOnly: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GCEPersistentDiskVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GCEPersistentDiskVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GCEPersistentDiskVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GCEPersistentDiskVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.GRPCAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GRPCAction {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.GRPCAction.port)
    pub port: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.GRPCAction.service)
    pub service: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.GRPCAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GRPCAction {
    fn default() -> &'a GRPCAction {
        <GRPCAction as ::protobuf::Message>::default_instance()
    }
}

impl GRPCAction {
    pub fn new() -> GRPCAction {
        ::std::default::Default::default()
    }

    // optional int32 port = 1;

    pub fn port(&self) -> i32 {
        self.port.unwrap_or(0)
    }

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Option::Some(v);
    }

    // optional string service = 2;

    pub fn service(&self) -> &str {
        match self.service.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_service(&mut self) {
        self.service = ::std::option::Option::None;
    }

    pub fn has_service(&self) -> bool {
        self.service.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        if self.service.is_none() {
            self.service = ::std::option::Option::Some(::std::string::String::new());
        }
        self.service.as_mut().unwrap()
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        self.service.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "port",
            |m: &GRPCAction| { &m.port },
            |m: &mut GRPCAction| { &mut m.port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "service",
            |m: &GRPCAction| { &m.service },
            |m: &mut GRPCAction| { &mut m.service },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GRPCAction>(
            "GRPCAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GRPCAction {
    const NAME: &'static str = "GRPCAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.port = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.service = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.service.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.port {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.service.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GRPCAction {
        GRPCAction::new()
    }

    fn clear(&mut self) {
        self.port = ::std::option::Option::None;
        self.service = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GRPCAction {
        static instance: GRPCAction = GRPCAction {
            port: ::std::option::Option::None,
            service: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GRPCAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GRPCAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GRPCAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GRPCAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.GitRepoVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GitRepoVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.GitRepoVolumeSource.repository)
    pub repository: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.GitRepoVolumeSource.revision)
    pub revision: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.GitRepoVolumeSource.directory)
    pub directory: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.GitRepoVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GitRepoVolumeSource {
    fn default() -> &'a GitRepoVolumeSource {
        <GitRepoVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl GitRepoVolumeSource {
    pub fn new() -> GitRepoVolumeSource {
        ::std::default::Default::default()
    }

    // optional string repository = 1;

    pub fn repository(&self) -> &str {
        match self.repository.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_repository(&mut self) {
        self.repository = ::std::option::Option::None;
    }

    pub fn has_repository(&self) -> bool {
        self.repository.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repository(&mut self, v: ::std::string::String) {
        self.repository = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_repository(&mut self) -> &mut ::std::string::String {
        if self.repository.is_none() {
            self.repository = ::std::option::Option::Some(::std::string::String::new());
        }
        self.repository.as_mut().unwrap()
    }

    // Take field
    pub fn take_repository(&mut self) -> ::std::string::String {
        self.repository.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string revision = 2;

    pub fn revision(&self) -> &str {
        match self.revision.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: ::std::string::String) {
        self.revision = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_revision(&mut self) -> &mut ::std::string::String {
        if self.revision.is_none() {
            self.revision = ::std::option::Option::Some(::std::string::String::new());
        }
        self.revision.as_mut().unwrap()
    }

    // Take field
    pub fn take_revision(&mut self) -> ::std::string::String {
        self.revision.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string directory = 3;

    pub fn directory(&self) -> &str {
        match self.directory.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_directory(&mut self) {
        self.directory = ::std::option::Option::None;
    }

    pub fn has_directory(&self) -> bool {
        self.directory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directory(&mut self, v: ::std::string::String) {
        self.directory = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directory(&mut self) -> &mut ::std::string::String {
        if self.directory.is_none() {
            self.directory = ::std::option::Option::Some(::std::string::String::new());
        }
        self.directory.as_mut().unwrap()
    }

    // Take field
    pub fn take_directory(&mut self) -> ::std::string::String {
        self.directory.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "repository",
            |m: &GitRepoVolumeSource| { &m.repository },
            |m: &mut GitRepoVolumeSource| { &mut m.repository },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revision",
            |m: &GitRepoVolumeSource| { &m.revision },
            |m: &mut GitRepoVolumeSource| { &mut m.revision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "directory",
            |m: &GitRepoVolumeSource| { &m.directory },
            |m: &mut GitRepoVolumeSource| { &mut m.directory },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GitRepoVolumeSource>(
            "GitRepoVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GitRepoVolumeSource {
    const NAME: &'static str = "GitRepoVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.repository = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.revision = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.directory = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.repository.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.revision.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.directory.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.repository.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.revision.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.directory.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GitRepoVolumeSource {
        GitRepoVolumeSource::new()
    }

    fn clear(&mut self) {
        self.repository = ::std::option::Option::None;
        self.revision = ::std::option::Option::None;
        self.directory = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GitRepoVolumeSource {
        static instance: GitRepoVolumeSource = GitRepoVolumeSource {
            repository: ::std::option::Option::None,
            revision: ::std::option::Option::None,
            directory: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GitRepoVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GitRepoVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GitRepoVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GitRepoVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.GlusterfsPersistentVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GlusterfsPersistentVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.GlusterfsPersistentVolumeSource.endpoints)
    pub endpoints: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.GlusterfsPersistentVolumeSource.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.GlusterfsPersistentVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.GlusterfsPersistentVolumeSource.endpointsNamespace)
    pub endpointsNamespace: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.GlusterfsPersistentVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GlusterfsPersistentVolumeSource {
    fn default() -> &'a GlusterfsPersistentVolumeSource {
        <GlusterfsPersistentVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl GlusterfsPersistentVolumeSource {
    pub fn new() -> GlusterfsPersistentVolumeSource {
        ::std::default::Default::default()
    }

    // optional string endpoints = 1;

    pub fn endpoints(&self) -> &str {
        match self.endpoints.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_endpoints(&mut self) {
        self.endpoints = ::std::option::Option::None;
    }

    pub fn has_endpoints(&self) -> bool {
        self.endpoints.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endpoints(&mut self, v: ::std::string::String) {
        self.endpoints = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endpoints(&mut self) -> &mut ::std::string::String {
        if self.endpoints.is_none() {
            self.endpoints = ::std::option::Option::Some(::std::string::String::new());
        }
        self.endpoints.as_mut().unwrap()
    }

    // Take field
    pub fn take_endpoints(&mut self) -> ::std::string::String {
        self.endpoints.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string path = 2;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 3;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // optional string endpointsNamespace = 4;

    pub fn endpointsNamespace(&self) -> &str {
        match self.endpointsNamespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_endpointsNamespace(&mut self) {
        self.endpointsNamespace = ::std::option::Option::None;
    }

    pub fn has_endpointsNamespace(&self) -> bool {
        self.endpointsNamespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endpointsNamespace(&mut self, v: ::std::string::String) {
        self.endpointsNamespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endpointsNamespace(&mut self) -> &mut ::std::string::String {
        if self.endpointsNamespace.is_none() {
            self.endpointsNamespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.endpointsNamespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_endpointsNamespace(&mut self) -> ::std::string::String {
        self.endpointsNamespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "endpoints",
            |m: &GlusterfsPersistentVolumeSource| { &m.endpoints },
            |m: &mut GlusterfsPersistentVolumeSource| { &mut m.endpoints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &GlusterfsPersistentVolumeSource| { &m.path },
            |m: &mut GlusterfsPersistentVolumeSource| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &GlusterfsPersistentVolumeSource| { &m.readOnly },
            |m: &mut GlusterfsPersistentVolumeSource| { &mut m.readOnly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "endpointsNamespace",
            |m: &GlusterfsPersistentVolumeSource| { &m.endpointsNamespace },
            |m: &mut GlusterfsPersistentVolumeSource| { &mut m.endpointsNamespace },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GlusterfsPersistentVolumeSource>(
            "GlusterfsPersistentVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GlusterfsPersistentVolumeSource {
    const NAME: &'static str = "GlusterfsPersistentVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.endpoints = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.endpointsNamespace = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.endpoints.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        if let Some(v) = self.endpointsNamespace.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.endpoints.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.endpointsNamespace.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GlusterfsPersistentVolumeSource {
        GlusterfsPersistentVolumeSource::new()
    }

    fn clear(&mut self) {
        self.endpoints = ::std::option::Option::None;
        self.path = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.endpointsNamespace = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GlusterfsPersistentVolumeSource {
        static instance: GlusterfsPersistentVolumeSource = GlusterfsPersistentVolumeSource {
            endpoints: ::std::option::Option::None,
            path: ::std::option::Option::None,
            readOnly: ::std::option::Option::None,
            endpointsNamespace: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GlusterfsPersistentVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GlusterfsPersistentVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GlusterfsPersistentVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GlusterfsPersistentVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.GlusterfsVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GlusterfsVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.GlusterfsVolumeSource.endpoints)
    pub endpoints: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.GlusterfsVolumeSource.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.GlusterfsVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.GlusterfsVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GlusterfsVolumeSource {
    fn default() -> &'a GlusterfsVolumeSource {
        <GlusterfsVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl GlusterfsVolumeSource {
    pub fn new() -> GlusterfsVolumeSource {
        ::std::default::Default::default()
    }

    // optional string endpoints = 1;

    pub fn endpoints(&self) -> &str {
        match self.endpoints.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_endpoints(&mut self) {
        self.endpoints = ::std::option::Option::None;
    }

    pub fn has_endpoints(&self) -> bool {
        self.endpoints.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endpoints(&mut self, v: ::std::string::String) {
        self.endpoints = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endpoints(&mut self) -> &mut ::std::string::String {
        if self.endpoints.is_none() {
            self.endpoints = ::std::option::Option::Some(::std::string::String::new());
        }
        self.endpoints.as_mut().unwrap()
    }

    // Take field
    pub fn take_endpoints(&mut self) -> ::std::string::String {
        self.endpoints.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string path = 2;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 3;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "endpoints",
            |m: &GlusterfsVolumeSource| { &m.endpoints },
            |m: &mut GlusterfsVolumeSource| { &mut m.endpoints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &GlusterfsVolumeSource| { &m.path },
            |m: &mut GlusterfsVolumeSource| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &GlusterfsVolumeSource| { &m.readOnly },
            |m: &mut GlusterfsVolumeSource| { &mut m.readOnly },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GlusterfsVolumeSource>(
            "GlusterfsVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GlusterfsVolumeSource {
    const NAME: &'static str = "GlusterfsVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.endpoints = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.endpoints.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.endpoints.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GlusterfsVolumeSource {
        GlusterfsVolumeSource::new()
    }

    fn clear(&mut self) {
        self.endpoints = ::std::option::Option::None;
        self.path = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GlusterfsVolumeSource {
        static instance: GlusterfsVolumeSource = GlusterfsVolumeSource {
            endpoints: ::std::option::Option::None,
            path: ::std::option::Option::None,
            readOnly: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GlusterfsVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GlusterfsVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GlusterfsVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GlusterfsVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.HTTPGetAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HTTPGetAction {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.HTTPGetAction.path)
    pub path: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::intorstr")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.HTTPGetAction.port)
    pub port: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::util::intstr::IntOrString>,
    // @@protoc_insertion_point(field:api.core.v1.HTTPGetAction.host)
    pub host: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.HTTPGetAction.scheme)
    pub scheme: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.HTTPGetAction.httpHeaders)
    pub httpHeaders: ::std::vec::Vec<HTTPHeader>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.HTTPGetAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HTTPGetAction {
    fn default() -> &'a HTTPGetAction {
        <HTTPGetAction as ::protobuf::Message>::default_instance()
    }
}

impl HTTPGetAction {
    pub fn new() -> HTTPGetAction {
        ::std::default::Default::default()
    }

    // optional string path = 1;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.util.intstr.IntOrString port = 2;

    pub fn port(&self) -> &crate::v1_30::apimachinery::pkg::util::intstr::IntOrString {
        self.port.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::util::intstr::IntOrString as ::protobuf::Message>::default_instance())
    }

    pub fn clear_port(&mut self) {
        self.port.clear();
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: crate::v1_30::apimachinery::pkg::util::intstr::IntOrString) {
        self.port = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_port(&mut self) -> &mut crate::v1_30::apimachinery::pkg::util::intstr::IntOrString {
        self.port.mut_or_insert_default()
    }

    // Take field
    pub fn take_port(&mut self) -> crate::v1_30::apimachinery::pkg::util::intstr::IntOrString {
        self.port.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::util::intstr::IntOrString::new())
    }

    // optional string host = 3;

    pub fn host(&self) -> &str {
        match self.host.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_host(&mut self) {
        self.host = ::std::option::Option::None;
    }

    pub fn has_host(&self) -> bool {
        self.host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        if self.host.is_none() {
            self.host = ::std::option::Option::Some(::std::string::String::new());
        }
        self.host.as_mut().unwrap()
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        self.host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string scheme = 4;

    pub fn scheme(&self) -> &str {
        match self.scheme.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_scheme(&mut self) {
        self.scheme = ::std::option::Option::None;
    }

    pub fn has_scheme(&self) -> bool {
        self.scheme.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scheme(&mut self, v: ::std::string::String) {
        self.scheme = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scheme(&mut self) -> &mut ::std::string::String {
        if self.scheme.is_none() {
            self.scheme = ::std::option::Option::Some(::std::string::String::new());
        }
        self.scheme.as_mut().unwrap()
    }

    // Take field
    pub fn take_scheme(&mut self) -> ::std::string::String {
        self.scheme.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.core.v1.HTTPHeader httpHeaders = 5;

    pub fn httpHeaders(&self) -> &[HTTPHeader] {
        &self.httpHeaders
    }

    pub fn clear_httpHeaders(&mut self) {
        self.httpHeaders.clear();
    }

    // Param is passed by value, moved
    pub fn set_httpHeaders(&mut self, v: ::std::vec::Vec<HTTPHeader>) {
        self.httpHeaders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_httpHeaders(&mut self) -> &mut ::std::vec::Vec<HTTPHeader> {
        &mut self.httpHeaders
    }

    // Take field
    pub fn take_httpHeaders(&mut self) -> ::std::vec::Vec<HTTPHeader> {
        ::std::mem::replace(&mut self.httpHeaders, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &HTTPGetAction| { &m.path },
            |m: &mut HTTPGetAction| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::util::intstr::IntOrString>(
            "port",
            |m: &HTTPGetAction| { &m.port },
            |m: &mut HTTPGetAction| { &mut m.port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "host",
            |m: &HTTPGetAction| { &m.host },
            |m: &mut HTTPGetAction| { &mut m.host },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scheme",
            |m: &HTTPGetAction| { &m.scheme },
            |m: &mut HTTPGetAction| { &mut m.scheme },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "httpHeaders",
            |m: &HTTPGetAction| { &m.httpHeaders },
            |m: &mut HTTPGetAction| { &mut m.httpHeaders },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HTTPGetAction>(
            "HTTPGetAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HTTPGetAction {
    const NAME: &'static str = "HTTPGetAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.port)?;
                },
                26 => {
                    self.host = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.scheme = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.httpHeaders.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.port.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.host.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.scheme.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.httpHeaders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.path.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.port.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.host.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.scheme.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.httpHeaders {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HTTPGetAction {
        HTTPGetAction::new()
    }

    fn clear(&mut self) {
        self.path = ::std::option::Option::None;
        self.port.clear();
        self.host = ::std::option::Option::None;
        self.scheme = ::std::option::Option::None;
        self.httpHeaders.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HTTPGetAction {
        static instance: HTTPGetAction = HTTPGetAction {
            path: ::std::option::Option::None,
            port: ::protobuf::MessageField::none(),
            host: ::std::option::Option::None,
            scheme: ::std::option::Option::None,
            httpHeaders: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HTTPGetAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HTTPGetAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HTTPGetAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPGetAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.HTTPHeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HTTPHeader {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.HTTPHeader.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.HTTPHeader.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.HTTPHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HTTPHeader {
    fn default() -> &'a HTTPHeader {
        <HTTPHeader as ::protobuf::Message>::default_instance()
    }
}

impl HTTPHeader {
    pub fn new() -> HTTPHeader {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &HTTPHeader| { &m.name },
            |m: &mut HTTPHeader| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &HTTPHeader| { &m.value },
            |m: &mut HTTPHeader| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HTTPHeader>(
            "HTTPHeader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HTTPHeader {
    const NAME: &'static str = "HTTPHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HTTPHeader {
        HTTPHeader::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HTTPHeader {
        static instance: HTTPHeader = HTTPHeader {
            name: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HTTPHeader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HTTPHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HTTPHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPHeader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.HostAlias)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HostAlias {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.HostAlias.ip)
    pub ip: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.HostAlias.hostnames)
    pub hostnames: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.HostAlias.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HostAlias {
    fn default() -> &'a HostAlias {
        <HostAlias as ::protobuf::Message>::default_instance()
    }
}

impl HostAlias {
    pub fn new() -> HostAlias {
        ::std::default::Default::default()
    }

    // optional string ip = 1;

    pub fn ip(&self) -> &str {
        match self.ip.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        if self.ip.is_none() {
            self.ip = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        self.ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string hostnames = 2;

    pub fn hostnames(&self) -> &[::std::string::String] {
        &self.hostnames
    }

    pub fn clear_hostnames(&mut self) {
        self.hostnames.clear();
    }

    // Param is passed by value, moved
    pub fn set_hostnames(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.hostnames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hostnames(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.hostnames
    }

    // Take field
    pub fn take_hostnames(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.hostnames, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip",
            |m: &HostAlias| { &m.ip },
            |m: &mut HostAlias| { &mut m.ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hostnames",
            |m: &HostAlias| { &m.hostnames },
            |m: &mut HostAlias| { &mut m.hostnames },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HostAlias>(
            "HostAlias",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HostAlias {
    const NAME: &'static str = "HostAlias";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ip = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.hostnames.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ip.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.hostnames {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ip.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.hostnames {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HostAlias {
        HostAlias::new()
    }

    fn clear(&mut self) {
        self.ip = ::std::option::Option::None;
        self.hostnames.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HostAlias {
        static instance: HostAlias = HostAlias {
            ip: ::std::option::Option::None,
            hostnames: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HostAlias {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HostAlias").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HostAlias {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HostAlias {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.HostIP)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HostIP {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.HostIP.ip)
    pub ip: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.HostIP.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HostIP {
    fn default() -> &'a HostIP {
        <HostIP as ::protobuf::Message>::default_instance()
    }
}

impl HostIP {
    pub fn new() -> HostIP {
        ::std::default::Default::default()
    }

    // optional string ip = 1;

    pub fn ip(&self) -> &str {
        match self.ip.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        if self.ip.is_none() {
            self.ip = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        self.ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip",
            |m: &HostIP| { &m.ip },
            |m: &mut HostIP| { &mut m.ip },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HostIP>(
            "HostIP",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HostIP {
    const NAME: &'static str = "HostIP";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ip = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ip.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ip.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HostIP {
        HostIP::new()
    }

    fn clear(&mut self) {
        self.ip = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HostIP {
        static instance: HostIP = HostIP {
            ip: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HostIP {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HostIP").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HostIP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HostIP {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.HostPathVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HostPathVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.HostPathVolumeSource.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.HostPathVolumeSource.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.HostPathVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HostPathVolumeSource {
    fn default() -> &'a HostPathVolumeSource {
        <HostPathVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl HostPathVolumeSource {
    pub fn new() -> HostPathVolumeSource {
        ::std::default::Default::default()
    }

    // optional string path = 1;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string type = 2;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &HostPathVolumeSource| { &m.path },
            |m: &mut HostPathVolumeSource| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &HostPathVolumeSource| { &m.type_ },
            |m: &mut HostPathVolumeSource| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HostPathVolumeSource>(
            "HostPathVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HostPathVolumeSource {
    const NAME: &'static str = "HostPathVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.path.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.type_.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HostPathVolumeSource {
        HostPathVolumeSource::new()
    }

    fn clear(&mut self) {
        self.path = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HostPathVolumeSource {
        static instance: HostPathVolumeSource = HostPathVolumeSource {
            path: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HostPathVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HostPathVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HostPathVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HostPathVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ISCSIPersistentVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ISCSIPersistentVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ISCSIPersistentVolumeSource.targetPortal)
    pub targetPortal: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ISCSIPersistentVolumeSource.iqn)
    pub iqn: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ISCSIPersistentVolumeSource.lun)
    pub lun: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.ISCSIPersistentVolumeSource.iscsiInterface)
    pub iscsiInterface: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ISCSIPersistentVolumeSource.fsType)
    pub fsType: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ISCSIPersistentVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ISCSIPersistentVolumeSource.portals)
    pub portals: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ISCSIPersistentVolumeSource.chapAuthDiscovery)
    pub chapAuthDiscovery: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.ISCSIPersistentVolumeSource.chapAuthSession)
    pub chapAuthSession: ::std::option::Option<bool>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ISCSIPersistentVolumeSource.secretRef)
    pub secretRef: ::protobuf::MessageField<SecretReference>,
    // @@protoc_insertion_point(field:api.core.v1.ISCSIPersistentVolumeSource.initiatorName)
    pub initiatorName: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ISCSIPersistentVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ISCSIPersistentVolumeSource {
    fn default() -> &'a ISCSIPersistentVolumeSource {
        <ISCSIPersistentVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl ISCSIPersistentVolumeSource {
    pub fn new() -> ISCSIPersistentVolumeSource {
        ::std::default::Default::default()
    }

    // optional string targetPortal = 1;

    pub fn targetPortal(&self) -> &str {
        match self.targetPortal.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_targetPortal(&mut self) {
        self.targetPortal = ::std::option::Option::None;
    }

    pub fn has_targetPortal(&self) -> bool {
        self.targetPortal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetPortal(&mut self, v: ::std::string::String) {
        self.targetPortal = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetPortal(&mut self) -> &mut ::std::string::String {
        if self.targetPortal.is_none() {
            self.targetPortal = ::std::option::Option::Some(::std::string::String::new());
        }
        self.targetPortal.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetPortal(&mut self) -> ::std::string::String {
        self.targetPortal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string iqn = 2;

    pub fn iqn(&self) -> &str {
        match self.iqn.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_iqn(&mut self) {
        self.iqn = ::std::option::Option::None;
    }

    pub fn has_iqn(&self) -> bool {
        self.iqn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iqn(&mut self, v: ::std::string::String) {
        self.iqn = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iqn(&mut self) -> &mut ::std::string::String {
        if self.iqn.is_none() {
            self.iqn = ::std::option::Option::Some(::std::string::String::new());
        }
        self.iqn.as_mut().unwrap()
    }

    // Take field
    pub fn take_iqn(&mut self) -> ::std::string::String {
        self.iqn.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 lun = 3;

    pub fn lun(&self) -> i32 {
        self.lun.unwrap_or(0)
    }

    pub fn clear_lun(&mut self) {
        self.lun = ::std::option::Option::None;
    }

    pub fn has_lun(&self) -> bool {
        self.lun.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lun(&mut self, v: i32) {
        self.lun = ::std::option::Option::Some(v);
    }

    // optional string iscsiInterface = 4;

    pub fn iscsiInterface(&self) -> &str {
        match self.iscsiInterface.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_iscsiInterface(&mut self) {
        self.iscsiInterface = ::std::option::Option::None;
    }

    pub fn has_iscsiInterface(&self) -> bool {
        self.iscsiInterface.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iscsiInterface(&mut self, v: ::std::string::String) {
        self.iscsiInterface = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iscsiInterface(&mut self) -> &mut ::std::string::String {
        if self.iscsiInterface.is_none() {
            self.iscsiInterface = ::std::option::Option::Some(::std::string::String::new());
        }
        self.iscsiInterface.as_mut().unwrap()
    }

    // Take field
    pub fn take_iscsiInterface(&mut self) -> ::std::string::String {
        self.iscsiInterface.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 5;

    pub fn fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fsType(&mut self) {
        self.fsType = ::std::option::Option::None;
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 6;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // repeated string portals = 7;

    pub fn portals(&self) -> &[::std::string::String] {
        &self.portals
    }

    pub fn clear_portals(&mut self) {
        self.portals.clear();
    }

    // Param is passed by value, moved
    pub fn set_portals(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.portals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_portals(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.portals
    }

    // Take field
    pub fn take_portals(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.portals, ::std::vec::Vec::new())
    }

    // optional bool chapAuthDiscovery = 8;

    pub fn chapAuthDiscovery(&self) -> bool {
        self.chapAuthDiscovery.unwrap_or(false)
    }

    pub fn clear_chapAuthDiscovery(&mut self) {
        self.chapAuthDiscovery = ::std::option::Option::None;
    }

    pub fn has_chapAuthDiscovery(&self) -> bool {
        self.chapAuthDiscovery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chapAuthDiscovery(&mut self, v: bool) {
        self.chapAuthDiscovery = ::std::option::Option::Some(v);
    }

    // optional bool chapAuthSession = 11;

    pub fn chapAuthSession(&self) -> bool {
        self.chapAuthSession.unwrap_or(false)
    }

    pub fn clear_chapAuthSession(&mut self) {
        self.chapAuthSession = ::std::option::Option::None;
    }

    pub fn has_chapAuthSession(&self) -> bool {
        self.chapAuthSession.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chapAuthSession(&mut self, v: bool) {
        self.chapAuthSession = ::std::option::Option::Some(v);
    }

    // optional .api.core.v1.SecretReference secretRef = 10;

    pub fn secretRef(&self) -> &SecretReference {
        self.secretRef.as_ref().unwrap_or_else(|| <SecretReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: SecretReference) {
        self.secretRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut SecretReference {
        self.secretRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> SecretReference {
        self.secretRef.take().unwrap_or_else(|| SecretReference::new())
    }

    // optional string initiatorName = 12;

    pub fn initiatorName(&self) -> &str {
        match self.initiatorName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_initiatorName(&mut self) {
        self.initiatorName = ::std::option::Option::None;
    }

    pub fn has_initiatorName(&self) -> bool {
        self.initiatorName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiatorName(&mut self, v: ::std::string::String) {
        self.initiatorName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initiatorName(&mut self) -> &mut ::std::string::String {
        if self.initiatorName.is_none() {
            self.initiatorName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.initiatorName.as_mut().unwrap()
    }

    // Take field
    pub fn take_initiatorName(&mut self) -> ::std::string::String {
        self.initiatorName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "targetPortal",
            |m: &ISCSIPersistentVolumeSource| { &m.targetPortal },
            |m: &mut ISCSIPersistentVolumeSource| { &mut m.targetPortal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "iqn",
            |m: &ISCSIPersistentVolumeSource| { &m.iqn },
            |m: &mut ISCSIPersistentVolumeSource| { &mut m.iqn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lun",
            |m: &ISCSIPersistentVolumeSource| { &m.lun },
            |m: &mut ISCSIPersistentVolumeSource| { &mut m.lun },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "iscsiInterface",
            |m: &ISCSIPersistentVolumeSource| { &m.iscsiInterface },
            |m: &mut ISCSIPersistentVolumeSource| { &mut m.iscsiInterface },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsType",
            |m: &ISCSIPersistentVolumeSource| { &m.fsType },
            |m: &mut ISCSIPersistentVolumeSource| { &mut m.fsType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &ISCSIPersistentVolumeSource| { &m.readOnly },
            |m: &mut ISCSIPersistentVolumeSource| { &mut m.readOnly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "portals",
            |m: &ISCSIPersistentVolumeSource| { &m.portals },
            |m: &mut ISCSIPersistentVolumeSource| { &mut m.portals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chapAuthDiscovery",
            |m: &ISCSIPersistentVolumeSource| { &m.chapAuthDiscovery },
            |m: &mut ISCSIPersistentVolumeSource| { &mut m.chapAuthDiscovery },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chapAuthSession",
            |m: &ISCSIPersistentVolumeSource| { &m.chapAuthSession },
            |m: &mut ISCSIPersistentVolumeSource| { &mut m.chapAuthSession },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SecretReference>(
            "secretRef",
            |m: &ISCSIPersistentVolumeSource| { &m.secretRef },
            |m: &mut ISCSIPersistentVolumeSource| { &mut m.secretRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initiatorName",
            |m: &ISCSIPersistentVolumeSource| { &m.initiatorName },
            |m: &mut ISCSIPersistentVolumeSource| { &mut m.initiatorName },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ISCSIPersistentVolumeSource>(
            "ISCSIPersistentVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ISCSIPersistentVolumeSource {
    const NAME: &'static str = "ISCSIPersistentVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.targetPortal = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.iqn = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.lun = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.iscsiInterface = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.fsType = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    self.portals.push(is.read_string()?);
                },
                64 => {
                    self.chapAuthDiscovery = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.chapAuthSession = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.secretRef)?;
                },
                98 => {
                    self.initiatorName = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.targetPortal.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.iqn.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lun {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.iscsiInterface.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        for value in &self.portals {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.chapAuthDiscovery {
            my_size += 1 + 1;
        }
        if let Some(v) = self.chapAuthSession {
            my_size += 1 + 1;
        }
        if let Some(v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.initiatorName.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.targetPortal.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.iqn.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lun {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.iscsiInterface.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.fsType.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(6, v)?;
        }
        for v in &self.portals {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.chapAuthDiscovery {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.chapAuthSession {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.secretRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.initiatorName.as_ref() {
            os.write_string(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ISCSIPersistentVolumeSource {
        ISCSIPersistentVolumeSource::new()
    }

    fn clear(&mut self) {
        self.targetPortal = ::std::option::Option::None;
        self.iqn = ::std::option::Option::None;
        self.lun = ::std::option::Option::None;
        self.iscsiInterface = ::std::option::Option::None;
        self.fsType = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.portals.clear();
        self.chapAuthDiscovery = ::std::option::Option::None;
        self.chapAuthSession = ::std::option::Option::None;
        self.secretRef.clear();
        self.initiatorName = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ISCSIPersistentVolumeSource {
        static instance: ISCSIPersistentVolumeSource = ISCSIPersistentVolumeSource {
            targetPortal: ::std::option::Option::None,
            iqn: ::std::option::Option::None,
            lun: ::std::option::Option::None,
            iscsiInterface: ::std::option::Option::None,
            fsType: ::std::option::Option::None,
            readOnly: ::std::option::Option::None,
            portals: ::std::vec::Vec::new(),
            chapAuthDiscovery: ::std::option::Option::None,
            chapAuthSession: ::std::option::Option::None,
            secretRef: ::protobuf::MessageField::none(),
            initiatorName: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ISCSIPersistentVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ISCSIPersistentVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ISCSIPersistentVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ISCSIPersistentVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ISCSIVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ISCSIVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ISCSIVolumeSource.targetPortal)
    pub targetPortal: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ISCSIVolumeSource.iqn)
    pub iqn: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ISCSIVolumeSource.lun)
    pub lun: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.ISCSIVolumeSource.iscsiInterface)
    pub iscsiInterface: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ISCSIVolumeSource.fsType)
    pub fsType: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ISCSIVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ISCSIVolumeSource.portals)
    pub portals: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ISCSIVolumeSource.chapAuthDiscovery)
    pub chapAuthDiscovery: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.ISCSIVolumeSource.chapAuthSession)
    pub chapAuthSession: ::std::option::Option<bool>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ISCSIVolumeSource.secretRef)
    pub secretRef: ::protobuf::MessageField<LocalObjectReference>,
    // @@protoc_insertion_point(field:api.core.v1.ISCSIVolumeSource.initiatorName)
    pub initiatorName: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ISCSIVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ISCSIVolumeSource {
    fn default() -> &'a ISCSIVolumeSource {
        <ISCSIVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl ISCSIVolumeSource {
    pub fn new() -> ISCSIVolumeSource {
        ::std::default::Default::default()
    }

    // optional string targetPortal = 1;

    pub fn targetPortal(&self) -> &str {
        match self.targetPortal.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_targetPortal(&mut self) {
        self.targetPortal = ::std::option::Option::None;
    }

    pub fn has_targetPortal(&self) -> bool {
        self.targetPortal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetPortal(&mut self, v: ::std::string::String) {
        self.targetPortal = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetPortal(&mut self) -> &mut ::std::string::String {
        if self.targetPortal.is_none() {
            self.targetPortal = ::std::option::Option::Some(::std::string::String::new());
        }
        self.targetPortal.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetPortal(&mut self) -> ::std::string::String {
        self.targetPortal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string iqn = 2;

    pub fn iqn(&self) -> &str {
        match self.iqn.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_iqn(&mut self) {
        self.iqn = ::std::option::Option::None;
    }

    pub fn has_iqn(&self) -> bool {
        self.iqn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iqn(&mut self, v: ::std::string::String) {
        self.iqn = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iqn(&mut self) -> &mut ::std::string::String {
        if self.iqn.is_none() {
            self.iqn = ::std::option::Option::Some(::std::string::String::new());
        }
        self.iqn.as_mut().unwrap()
    }

    // Take field
    pub fn take_iqn(&mut self) -> ::std::string::String {
        self.iqn.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 lun = 3;

    pub fn lun(&self) -> i32 {
        self.lun.unwrap_or(0)
    }

    pub fn clear_lun(&mut self) {
        self.lun = ::std::option::Option::None;
    }

    pub fn has_lun(&self) -> bool {
        self.lun.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lun(&mut self, v: i32) {
        self.lun = ::std::option::Option::Some(v);
    }

    // optional string iscsiInterface = 4;

    pub fn iscsiInterface(&self) -> &str {
        match self.iscsiInterface.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_iscsiInterface(&mut self) {
        self.iscsiInterface = ::std::option::Option::None;
    }

    pub fn has_iscsiInterface(&self) -> bool {
        self.iscsiInterface.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iscsiInterface(&mut self, v: ::std::string::String) {
        self.iscsiInterface = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iscsiInterface(&mut self) -> &mut ::std::string::String {
        if self.iscsiInterface.is_none() {
            self.iscsiInterface = ::std::option::Option::Some(::std::string::String::new());
        }
        self.iscsiInterface.as_mut().unwrap()
    }

    // Take field
    pub fn take_iscsiInterface(&mut self) -> ::std::string::String {
        self.iscsiInterface.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 5;

    pub fn fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fsType(&mut self) {
        self.fsType = ::std::option::Option::None;
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 6;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // repeated string portals = 7;

    pub fn portals(&self) -> &[::std::string::String] {
        &self.portals
    }

    pub fn clear_portals(&mut self) {
        self.portals.clear();
    }

    // Param is passed by value, moved
    pub fn set_portals(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.portals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_portals(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.portals
    }

    // Take field
    pub fn take_portals(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.portals, ::std::vec::Vec::new())
    }

    // optional bool chapAuthDiscovery = 8;

    pub fn chapAuthDiscovery(&self) -> bool {
        self.chapAuthDiscovery.unwrap_or(false)
    }

    pub fn clear_chapAuthDiscovery(&mut self) {
        self.chapAuthDiscovery = ::std::option::Option::None;
    }

    pub fn has_chapAuthDiscovery(&self) -> bool {
        self.chapAuthDiscovery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chapAuthDiscovery(&mut self, v: bool) {
        self.chapAuthDiscovery = ::std::option::Option::Some(v);
    }

    // optional bool chapAuthSession = 11;

    pub fn chapAuthSession(&self) -> bool {
        self.chapAuthSession.unwrap_or(false)
    }

    pub fn clear_chapAuthSession(&mut self) {
        self.chapAuthSession = ::std::option::Option::None;
    }

    pub fn has_chapAuthSession(&self) -> bool {
        self.chapAuthSession.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chapAuthSession(&mut self, v: bool) {
        self.chapAuthSession = ::std::option::Option::Some(v);
    }

    // optional .api.core.v1.LocalObjectReference secretRef = 10;

    pub fn secretRef(&self) -> &LocalObjectReference {
        self.secretRef.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: LocalObjectReference) {
        self.secretRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut LocalObjectReference {
        self.secretRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> LocalObjectReference {
        self.secretRef.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    // optional string initiatorName = 12;

    pub fn initiatorName(&self) -> &str {
        match self.initiatorName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_initiatorName(&mut self) {
        self.initiatorName = ::std::option::Option::None;
    }

    pub fn has_initiatorName(&self) -> bool {
        self.initiatorName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiatorName(&mut self, v: ::std::string::String) {
        self.initiatorName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initiatorName(&mut self) -> &mut ::std::string::String {
        if self.initiatorName.is_none() {
            self.initiatorName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.initiatorName.as_mut().unwrap()
    }

    // Take field
    pub fn take_initiatorName(&mut self) -> ::std::string::String {
        self.initiatorName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "targetPortal",
            |m: &ISCSIVolumeSource| { &m.targetPortal },
            |m: &mut ISCSIVolumeSource| { &mut m.targetPortal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "iqn",
            |m: &ISCSIVolumeSource| { &m.iqn },
            |m: &mut ISCSIVolumeSource| { &mut m.iqn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lun",
            |m: &ISCSIVolumeSource| { &m.lun },
            |m: &mut ISCSIVolumeSource| { &mut m.lun },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "iscsiInterface",
            |m: &ISCSIVolumeSource| { &m.iscsiInterface },
            |m: &mut ISCSIVolumeSource| { &mut m.iscsiInterface },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsType",
            |m: &ISCSIVolumeSource| { &m.fsType },
            |m: &mut ISCSIVolumeSource| { &mut m.fsType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &ISCSIVolumeSource| { &m.readOnly },
            |m: &mut ISCSIVolumeSource| { &mut m.readOnly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "portals",
            |m: &ISCSIVolumeSource| { &m.portals },
            |m: &mut ISCSIVolumeSource| { &mut m.portals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chapAuthDiscovery",
            |m: &ISCSIVolumeSource| { &m.chapAuthDiscovery },
            |m: &mut ISCSIVolumeSource| { &mut m.chapAuthDiscovery },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chapAuthSession",
            |m: &ISCSIVolumeSource| { &m.chapAuthSession },
            |m: &mut ISCSIVolumeSource| { &mut m.chapAuthSession },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LocalObjectReference>(
            "secretRef",
            |m: &ISCSIVolumeSource| { &m.secretRef },
            |m: &mut ISCSIVolumeSource| { &mut m.secretRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initiatorName",
            |m: &ISCSIVolumeSource| { &m.initiatorName },
            |m: &mut ISCSIVolumeSource| { &mut m.initiatorName },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ISCSIVolumeSource>(
            "ISCSIVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ISCSIVolumeSource {
    const NAME: &'static str = "ISCSIVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.targetPortal = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.iqn = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.lun = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.iscsiInterface = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.fsType = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    self.portals.push(is.read_string()?);
                },
                64 => {
                    self.chapAuthDiscovery = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.chapAuthSession = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.secretRef)?;
                },
                98 => {
                    self.initiatorName = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.targetPortal.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.iqn.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lun {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.iscsiInterface.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        for value in &self.portals {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.chapAuthDiscovery {
            my_size += 1 + 1;
        }
        if let Some(v) = self.chapAuthSession {
            my_size += 1 + 1;
        }
        if let Some(v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.initiatorName.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.targetPortal.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.iqn.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lun {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.iscsiInterface.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.fsType.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(6, v)?;
        }
        for v in &self.portals {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.chapAuthDiscovery {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.chapAuthSession {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.secretRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.initiatorName.as_ref() {
            os.write_string(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ISCSIVolumeSource {
        ISCSIVolumeSource::new()
    }

    fn clear(&mut self) {
        self.targetPortal = ::std::option::Option::None;
        self.iqn = ::std::option::Option::None;
        self.lun = ::std::option::Option::None;
        self.iscsiInterface = ::std::option::Option::None;
        self.fsType = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.portals.clear();
        self.chapAuthDiscovery = ::std::option::Option::None;
        self.chapAuthSession = ::std::option::Option::None;
        self.secretRef.clear();
        self.initiatorName = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ISCSIVolumeSource {
        static instance: ISCSIVolumeSource = ISCSIVolumeSource {
            targetPortal: ::std::option::Option::None,
            iqn: ::std::option::Option::None,
            lun: ::std::option::Option::None,
            iscsiInterface: ::std::option::Option::None,
            fsType: ::std::option::Option::None,
            readOnly: ::std::option::Option::None,
            portals: ::std::vec::Vec::new(),
            chapAuthDiscovery: ::std::option::Option::None,
            chapAuthSession: ::std::option::Option::None,
            secretRef: ::protobuf::MessageField::none(),
            initiatorName: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ISCSIVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ISCSIVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ISCSIVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ISCSIVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.KeyToPath)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KeyToPath {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.KeyToPath.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.KeyToPath.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.KeyToPath.mode)
    pub mode: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.KeyToPath.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeyToPath {
    fn default() -> &'a KeyToPath {
        <KeyToPath as ::protobuf::Message>::default_instance()
    }
}

impl KeyToPath {
    pub fn new() -> KeyToPath {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string path = 2;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 mode = 3;

    pub fn mode(&self) -> i32 {
        self.mode.unwrap_or(0)
    }

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: i32) {
        self.mode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &KeyToPath| { &m.key },
            |m: &mut KeyToPath| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &KeyToPath| { &m.path },
            |m: &mut KeyToPath| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mode",
            |m: &KeyToPath| { &m.mode },
            |m: &mut KeyToPath| { &mut m.mode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeyToPath>(
            "KeyToPath",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeyToPath {
    const NAME: &'static str = "KeyToPath";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.mode = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.mode {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeyToPath {
        KeyToPath::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.path = ::std::option::Option::None;
        self.mode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeyToPath {
        static instance: KeyToPath = KeyToPath {
            key: ::std::option::Option::None,
            path: ::std::option::Option::None,
            mode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeyToPath {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeyToPath").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeyToPath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyToPath {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.Lifecycle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Lifecycle {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Lifecycle.postStart)
    pub postStart: ::protobuf::MessageField<LifecycleHandler>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Lifecycle.preStop)
    pub preStop: ::protobuf::MessageField<LifecycleHandler>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.Lifecycle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Lifecycle {
    fn default() -> &'a Lifecycle {
        <Lifecycle as ::protobuf::Message>::default_instance()
    }
}

impl Lifecycle {
    pub fn new() -> Lifecycle {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.LifecycleHandler postStart = 1;

    pub fn postStart(&self) -> &LifecycleHandler {
        self.postStart.as_ref().unwrap_or_else(|| <LifecycleHandler as ::protobuf::Message>::default_instance())
    }

    pub fn clear_postStart(&mut self) {
        self.postStart.clear();
    }

    pub fn has_postStart(&self) -> bool {
        self.postStart.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postStart(&mut self, v: LifecycleHandler) {
        self.postStart = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postStart(&mut self) -> &mut LifecycleHandler {
        self.postStart.mut_or_insert_default()
    }

    // Take field
    pub fn take_postStart(&mut self) -> LifecycleHandler {
        self.postStart.take().unwrap_or_else(|| LifecycleHandler::new())
    }

    // optional .api.core.v1.LifecycleHandler preStop = 2;

    pub fn preStop(&self) -> &LifecycleHandler {
        self.preStop.as_ref().unwrap_or_else(|| <LifecycleHandler as ::protobuf::Message>::default_instance())
    }

    pub fn clear_preStop(&mut self) {
        self.preStop.clear();
    }

    pub fn has_preStop(&self) -> bool {
        self.preStop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preStop(&mut self, v: LifecycleHandler) {
        self.preStop = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preStop(&mut self) -> &mut LifecycleHandler {
        self.preStop.mut_or_insert_default()
    }

    // Take field
    pub fn take_preStop(&mut self) -> LifecycleHandler {
        self.preStop.take().unwrap_or_else(|| LifecycleHandler::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LifecycleHandler>(
            "postStart",
            |m: &Lifecycle| { &m.postStart },
            |m: &mut Lifecycle| { &mut m.postStart },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LifecycleHandler>(
            "preStop",
            |m: &Lifecycle| { &m.preStop },
            |m: &mut Lifecycle| { &mut m.preStop },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Lifecycle>(
            "Lifecycle",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Lifecycle {
    const NAME: &'static str = "Lifecycle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.postStart)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.preStop)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.postStart.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.preStop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.postStart.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.preStop.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Lifecycle {
        Lifecycle::new()
    }

    fn clear(&mut self) {
        self.postStart.clear();
        self.preStop.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Lifecycle {
        static instance: Lifecycle = Lifecycle {
            postStart: ::protobuf::MessageField::none(),
            preStop: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Lifecycle {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Lifecycle").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Lifecycle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Lifecycle {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.LifecycleHandler)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LifecycleHandler {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.LifecycleHandler.exec)
    pub exec: ::protobuf::MessageField<ExecAction>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.LifecycleHandler.httpGet)
    pub httpGet: ::protobuf::MessageField<HTTPGetAction>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.LifecycleHandler.tcpSocket)
    pub tcpSocket: ::protobuf::MessageField<TCPSocketAction>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.LifecycleHandler.sleep)
    pub sleep: ::protobuf::MessageField<SleepAction>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.LifecycleHandler.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LifecycleHandler {
    fn default() -> &'a LifecycleHandler {
        <LifecycleHandler as ::protobuf::Message>::default_instance()
    }
}

impl LifecycleHandler {
    pub fn new() -> LifecycleHandler {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.ExecAction exec = 1;

    pub fn exec(&self) -> &ExecAction {
        self.exec.as_ref().unwrap_or_else(|| <ExecAction as ::protobuf::Message>::default_instance())
    }

    pub fn clear_exec(&mut self) {
        self.exec.clear();
    }

    pub fn has_exec(&self) -> bool {
        self.exec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exec(&mut self, v: ExecAction) {
        self.exec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec(&mut self) -> &mut ExecAction {
        self.exec.mut_or_insert_default()
    }

    // Take field
    pub fn take_exec(&mut self) -> ExecAction {
        self.exec.take().unwrap_or_else(|| ExecAction::new())
    }

    // optional .api.core.v1.HTTPGetAction httpGet = 2;

    pub fn httpGet(&self) -> &HTTPGetAction {
        self.httpGet.as_ref().unwrap_or_else(|| <HTTPGetAction as ::protobuf::Message>::default_instance())
    }

    pub fn clear_httpGet(&mut self) {
        self.httpGet.clear();
    }

    pub fn has_httpGet(&self) -> bool {
        self.httpGet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_httpGet(&mut self, v: HTTPGetAction) {
        self.httpGet = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_httpGet(&mut self) -> &mut HTTPGetAction {
        self.httpGet.mut_or_insert_default()
    }

    // Take field
    pub fn take_httpGet(&mut self) -> HTTPGetAction {
        self.httpGet.take().unwrap_or_else(|| HTTPGetAction::new())
    }

    // optional .api.core.v1.TCPSocketAction tcpSocket = 3;

    pub fn tcpSocket(&self) -> &TCPSocketAction {
        self.tcpSocket.as_ref().unwrap_or_else(|| <TCPSocketAction as ::protobuf::Message>::default_instance())
    }

    pub fn clear_tcpSocket(&mut self) {
        self.tcpSocket.clear();
    }

    pub fn has_tcpSocket(&self) -> bool {
        self.tcpSocket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcpSocket(&mut self, v: TCPSocketAction) {
        self.tcpSocket = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tcpSocket(&mut self) -> &mut TCPSocketAction {
        self.tcpSocket.mut_or_insert_default()
    }

    // Take field
    pub fn take_tcpSocket(&mut self) -> TCPSocketAction {
        self.tcpSocket.take().unwrap_or_else(|| TCPSocketAction::new())
    }

    // optional .api.core.v1.SleepAction sleep = 4;

    pub fn sleep(&self) -> &SleepAction {
        self.sleep.as_ref().unwrap_or_else(|| <SleepAction as ::protobuf::Message>::default_instance())
    }

    pub fn clear_sleep(&mut self) {
        self.sleep.clear();
    }

    pub fn has_sleep(&self) -> bool {
        self.sleep.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sleep(&mut self, v: SleepAction) {
        self.sleep = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sleep(&mut self) -> &mut SleepAction {
        self.sleep.mut_or_insert_default()
    }

    // Take field
    pub fn take_sleep(&mut self) -> SleepAction {
        self.sleep.take().unwrap_or_else(|| SleepAction::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExecAction>(
            "exec",
            |m: &LifecycleHandler| { &m.exec },
            |m: &mut LifecycleHandler| { &mut m.exec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HTTPGetAction>(
            "httpGet",
            |m: &LifecycleHandler| { &m.httpGet },
            |m: &mut LifecycleHandler| { &mut m.httpGet },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TCPSocketAction>(
            "tcpSocket",
            |m: &LifecycleHandler| { &m.tcpSocket },
            |m: &mut LifecycleHandler| { &mut m.tcpSocket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SleepAction>(
            "sleep",
            |m: &LifecycleHandler| { &m.sleep },
            |m: &mut LifecycleHandler| { &mut m.sleep },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LifecycleHandler>(
            "LifecycleHandler",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LifecycleHandler {
    const NAME: &'static str = "LifecycleHandler";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.exec)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.httpGet)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tcpSocket)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sleep)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.exec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.httpGet.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tcpSocket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sleep.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.exec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.httpGet.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.tcpSocket.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.sleep.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LifecycleHandler {
        LifecycleHandler::new()
    }

    fn clear(&mut self) {
        self.exec.clear();
        self.httpGet.clear();
        self.tcpSocket.clear();
        self.sleep.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LifecycleHandler {
        static instance: LifecycleHandler = LifecycleHandler {
            exec: ::protobuf::MessageField::none(),
            httpGet: ::protobuf::MessageField::none(),
            tcpSocket: ::protobuf::MessageField::none(),
            sleep: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LifecycleHandler {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LifecycleHandler").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LifecycleHandler {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LifecycleHandler {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.LimitRange)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LimitRange {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.LimitRange.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.LimitRange.spec)
    pub spec: ::protobuf::MessageField<LimitRangeSpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.LimitRange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LimitRange {
    fn default() -> &'a LimitRange {
        <LimitRange as ::protobuf::Message>::default_instance()
    }
}

impl LimitRange {
    pub fn new() -> LimitRange {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.core.v1.LimitRangeSpec spec = 2;

    pub fn spec(&self) -> &LimitRangeSpec {
        self.spec.as_ref().unwrap_or_else(|| <LimitRangeSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: LimitRangeSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut LimitRangeSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> LimitRangeSpec {
        self.spec.take().unwrap_or_else(|| LimitRangeSpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &LimitRange| { &m.metadata },
            |m: &mut LimitRange| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LimitRangeSpec>(
            "spec",
            |m: &LimitRange| { &m.spec },
            |m: &mut LimitRange| { &mut m.spec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LimitRange>(
            "LimitRange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LimitRange {
    const NAME: &'static str = "LimitRange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LimitRange {
        LimitRange::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LimitRange {
        static instance: LimitRange = LimitRange {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LimitRange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LimitRange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LimitRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LimitRange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.LimitRangeItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LimitRangeItem {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.LimitRangeItem.type)
    pub type_: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.LimitRangeItem.max)
    pub max: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.LimitRangeItem.min)
    pub min: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.LimitRangeItem.default)
    pub default: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.LimitRangeItem.defaultRequest)
    pub defaultRequest: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.LimitRangeItem.maxLimitRequestRatio)
    pub maxLimitRequestRatio: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.LimitRangeItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LimitRangeItem {
    fn default() -> &'a LimitRangeItem {
        <LimitRangeItem as ::protobuf::Message>::default_instance()
    }
}

impl LimitRangeItem {
    pub fn new() -> LimitRangeItem {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.core.v1.LimitRangeItem.MaxEntry max = 2;

    pub fn max(&self) -> &::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &self.max
    }

    pub fn clear_max(&mut self) {
        self.max.clear();
    }

    // Param is passed by value, moved
    pub fn set_max(&mut self, v: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>) {
        self.max = v;
    }

    // Mutable pointer to the field.
    pub fn mut_max(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &mut self.max
    }

    // Take field
    pub fn take_max(&mut self) -> ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        ::std::mem::replace(&mut self.max, ::std::collections::BTreeMap::new())
    }

    // repeated .api.core.v1.LimitRangeItem.MinEntry min = 3;

    pub fn min(&self) -> &::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &self.min
    }

    pub fn clear_min(&mut self) {
        self.min.clear();
    }

    // Param is passed by value, moved
    pub fn set_min(&mut self, v: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>) {
        self.min = v;
    }

    // Mutable pointer to the field.
    pub fn mut_min(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &mut self.min
    }

    // Take field
    pub fn take_min(&mut self) -> ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        ::std::mem::replace(&mut self.min, ::std::collections::BTreeMap::new())
    }

    // repeated .api.core.v1.LimitRangeItem.DefaultEntry default = 4;

    pub fn default(&self) -> &::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &self.default
    }

    pub fn clear_default(&mut self) {
        self.default.clear();
    }

    // Param is passed by value, moved
    pub fn set_default(&mut self, v: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>) {
        self.default = v;
    }

    // Mutable pointer to the field.
    pub fn mut_default(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &mut self.default
    }

    // Take field
    pub fn take_default(&mut self) -> ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        ::std::mem::replace(&mut self.default, ::std::collections::BTreeMap::new())
    }

    // repeated .api.core.v1.LimitRangeItem.DefaultRequestEntry defaultRequest = 5;

    pub fn defaultRequest(&self) -> &::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &self.defaultRequest
    }

    pub fn clear_defaultRequest(&mut self) {
        self.defaultRequest.clear();
    }

    // Param is passed by value, moved
    pub fn set_defaultRequest(&mut self, v: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>) {
        self.defaultRequest = v;
    }

    // Mutable pointer to the field.
    pub fn mut_defaultRequest(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &mut self.defaultRequest
    }

    // Take field
    pub fn take_defaultRequest(&mut self) -> ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        ::std::mem::replace(&mut self.defaultRequest, ::std::collections::BTreeMap::new())
    }

    // repeated .api.core.v1.LimitRangeItem.MaxLimitRequestRatioEntry maxLimitRequestRatio = 6;

    pub fn maxLimitRequestRatio(&self) -> &::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &self.maxLimitRequestRatio
    }

    pub fn clear_maxLimitRequestRatio(&mut self) {
        self.maxLimitRequestRatio.clear();
    }

    // Param is passed by value, moved
    pub fn set_maxLimitRequestRatio(&mut self, v: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>) {
        self.maxLimitRequestRatio = v;
    }

    // Mutable pointer to the field.
    pub fn mut_maxLimitRequestRatio(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &mut self.maxLimitRequestRatio
    }

    // Take field
    pub fn take_maxLimitRequestRatio(&mut self) -> ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        ::std::mem::replace(&mut self.maxLimitRequestRatio, ::std::collections::BTreeMap::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &LimitRangeItem| { &m.type_ },
            |m: &mut LimitRangeItem| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "max",
            |m: &LimitRangeItem| { &m.max },
            |m: &mut LimitRangeItem| { &mut m.max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "min",
            |m: &LimitRangeItem| { &m.min },
            |m: &mut LimitRangeItem| { &mut m.min },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "default",
            |m: &LimitRangeItem| { &m.default },
            |m: &mut LimitRangeItem| { &mut m.default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "defaultRequest",
            |m: &LimitRangeItem| { &m.defaultRequest },
            |m: &mut LimitRangeItem| { &mut m.defaultRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "maxLimitRequestRatio",
            |m: &LimitRangeItem| { &m.maxLimitRequestRatio },
            |m: &mut LimitRangeItem| { &mut m.maxLimitRequestRatio },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LimitRangeItem>(
            "LimitRangeItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LimitRangeItem {
    const NAME: &'static str = "LimitRangeItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.max.insert(key, value);
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.min.insert(key, value);
                },
                34 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.default.insert(key, value);
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.defaultRequest.insert(key, value);
                },
                50 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.maxLimitRequestRatio.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for (k, v) in &self.max {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.min {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.default {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.defaultRequest {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.maxLimitRequestRatio {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        for (k, v) in &self.max {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.min {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.default {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(34)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.defaultRequest {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.maxLimitRequestRatio {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(50)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LimitRangeItem {
        LimitRangeItem::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.max.clear();
        self.min.clear();
        self.default.clear();
        self.defaultRequest.clear();
        self.maxLimitRequestRatio.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LimitRangeItem {
        static instance: ::protobuf::rt::Lazy<LimitRangeItem> = ::protobuf::rt::Lazy::new();
        instance.get(LimitRangeItem::new)
    }
}

impl ::protobuf::MessageFull for LimitRangeItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LimitRangeItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LimitRangeItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LimitRangeItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.LimitRangeList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LimitRangeList {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.LimitRangeList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.LimitRangeList.items)
    pub items: ::std::vec::Vec<LimitRange>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.LimitRangeList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LimitRangeList {
    fn default() -> &'a LimitRangeList {
        <LimitRangeList as ::protobuf::Message>::default_instance()
    }
}

impl LimitRangeList {
    pub fn new() -> LimitRangeList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.core.v1.LimitRange items = 2;

    pub fn items(&self) -> &[LimitRange] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<LimitRange>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<LimitRange> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<LimitRange> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &LimitRangeList| { &m.metadata },
            |m: &mut LimitRangeList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &LimitRangeList| { &m.items },
            |m: &mut LimitRangeList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LimitRangeList>(
            "LimitRangeList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LimitRangeList {
    const NAME: &'static str = "LimitRangeList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LimitRangeList {
        LimitRangeList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LimitRangeList {
        static instance: LimitRangeList = LimitRangeList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LimitRangeList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LimitRangeList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LimitRangeList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LimitRangeList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.LimitRangeSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LimitRangeSpec {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.LimitRangeSpec.limits)
    pub limits: ::std::vec::Vec<LimitRangeItem>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.LimitRangeSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LimitRangeSpec {
    fn default() -> &'a LimitRangeSpec {
        <LimitRangeSpec as ::protobuf::Message>::default_instance()
    }
}

impl LimitRangeSpec {
    pub fn new() -> LimitRangeSpec {
        ::std::default::Default::default()
    }

    // repeated .api.core.v1.LimitRangeItem limits = 1;

    pub fn limits(&self) -> &[LimitRangeItem] {
        &self.limits
    }

    pub fn clear_limits(&mut self) {
        self.limits.clear();
    }

    // Param is passed by value, moved
    pub fn set_limits(&mut self, v: ::std::vec::Vec<LimitRangeItem>) {
        self.limits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_limits(&mut self) -> &mut ::std::vec::Vec<LimitRangeItem> {
        &mut self.limits
    }

    // Take field
    pub fn take_limits(&mut self) -> ::std::vec::Vec<LimitRangeItem> {
        ::std::mem::replace(&mut self.limits, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "limits",
            |m: &LimitRangeSpec| { &m.limits },
            |m: &mut LimitRangeSpec| { &mut m.limits },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LimitRangeSpec>(
            "LimitRangeSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LimitRangeSpec {
    const NAME: &'static str = "LimitRangeSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.limits.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.limits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.limits {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LimitRangeSpec {
        LimitRangeSpec::new()
    }

    fn clear(&mut self) {
        self.limits.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LimitRangeSpec {
        static instance: LimitRangeSpec = LimitRangeSpec {
            limits: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LimitRangeSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LimitRangeSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LimitRangeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LimitRangeSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.List)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct List {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.List.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.List.items)
    pub items: ::std::vec::Vec<crate::v1_30::apimachinery::pkg::runtime::RawExtension>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.List.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a List {
    fn default() -> &'a List {
        <List as ::protobuf::Message>::default_instance()
    }
}

impl List {
    pub fn new() -> List {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .apimachinery.pkg.runtime.RawExtension items = 2;

    pub fn items(&self) -> &[crate::v1_30::apimachinery::pkg::runtime::RawExtension] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<crate::v1_30::apimachinery::pkg::runtime::RawExtension>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<crate::v1_30::apimachinery::pkg::runtime::RawExtension> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<crate::v1_30::apimachinery::pkg::runtime::RawExtension> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &List| { &m.metadata },
            |m: &mut List| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &List| { &m.items },
            |m: &mut List| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<List>(
            "List",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for List {
    const NAME: &'static str = "List";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> List {
        List::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static List {
        static instance: List = List {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for List {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("List").unwrap()).clone()
    }
}

impl ::std::fmt::Display for List {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for List {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.LoadBalancerIngress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoadBalancerIngress {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.LoadBalancerIngress.ip)
    pub ip: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.LoadBalancerIngress.hostname)
    pub hostname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.LoadBalancerIngress.ipMode)
    pub ipMode: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.LoadBalancerIngress.ports)
    pub ports: ::std::vec::Vec<PortStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.LoadBalancerIngress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoadBalancerIngress {
    fn default() -> &'a LoadBalancerIngress {
        <LoadBalancerIngress as ::protobuf::Message>::default_instance()
    }
}

impl LoadBalancerIngress {
    pub fn new() -> LoadBalancerIngress {
        ::std::default::Default::default()
    }

    // optional string ip = 1;

    pub fn ip(&self) -> &str {
        match self.ip.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        if self.ip.is_none() {
            self.ip = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        self.ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string hostname = 2;

    pub fn hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hostname(&mut self) {
        self.hostname = ::std::option::Option::None;
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string ipMode = 3;

    pub fn ipMode(&self) -> &str {
        match self.ipMode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ipMode(&mut self) {
        self.ipMode = ::std::option::Option::None;
    }

    pub fn has_ipMode(&self) -> bool {
        self.ipMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipMode(&mut self, v: ::std::string::String) {
        self.ipMode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipMode(&mut self) -> &mut ::std::string::String {
        if self.ipMode.is_none() {
            self.ipMode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ipMode.as_mut().unwrap()
    }

    // Take field
    pub fn take_ipMode(&mut self) -> ::std::string::String {
        self.ipMode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.core.v1.PortStatus ports = 4;

    pub fn ports(&self) -> &[PortStatus] {
        &self.ports
    }

    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::std::vec::Vec<PortStatus>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::std::vec::Vec<PortStatus> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::std::vec::Vec<PortStatus> {
        ::std::mem::replace(&mut self.ports, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip",
            |m: &LoadBalancerIngress| { &m.ip },
            |m: &mut LoadBalancerIngress| { &mut m.ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hostname",
            |m: &LoadBalancerIngress| { &m.hostname },
            |m: &mut LoadBalancerIngress| { &mut m.hostname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ipMode",
            |m: &LoadBalancerIngress| { &m.ipMode },
            |m: &mut LoadBalancerIngress| { &mut m.ipMode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ports",
            |m: &LoadBalancerIngress| { &m.ports },
            |m: &mut LoadBalancerIngress| { &mut m.ports },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoadBalancerIngress>(
            "LoadBalancerIngress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoadBalancerIngress {
    const NAME: &'static str = "LoadBalancerIngress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ip = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.hostname = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.ipMode = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.ports.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ip.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.ipMode.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ip.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.hostname.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.ipMode.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.ports {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoadBalancerIngress {
        LoadBalancerIngress::new()
    }

    fn clear(&mut self) {
        self.ip = ::std::option::Option::None;
        self.hostname = ::std::option::Option::None;
        self.ipMode = ::std::option::Option::None;
        self.ports.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoadBalancerIngress {
        static instance: LoadBalancerIngress = LoadBalancerIngress {
            ip: ::std::option::Option::None,
            hostname: ::std::option::Option::None,
            ipMode: ::std::option::Option::None,
            ports: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoadBalancerIngress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoadBalancerIngress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoadBalancerIngress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadBalancerIngress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.LoadBalancerStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoadBalancerStatus {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.LoadBalancerStatus.ingress)
    pub ingress: ::std::vec::Vec<LoadBalancerIngress>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.LoadBalancerStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoadBalancerStatus {
    fn default() -> &'a LoadBalancerStatus {
        <LoadBalancerStatus as ::protobuf::Message>::default_instance()
    }
}

impl LoadBalancerStatus {
    pub fn new() -> LoadBalancerStatus {
        ::std::default::Default::default()
    }

    // repeated .api.core.v1.LoadBalancerIngress ingress = 1;

    pub fn ingress(&self) -> &[LoadBalancerIngress] {
        &self.ingress
    }

    pub fn clear_ingress(&mut self) {
        self.ingress.clear();
    }

    // Param is passed by value, moved
    pub fn set_ingress(&mut self, v: ::std::vec::Vec<LoadBalancerIngress>) {
        self.ingress = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ingress(&mut self) -> &mut ::std::vec::Vec<LoadBalancerIngress> {
        &mut self.ingress
    }

    // Take field
    pub fn take_ingress(&mut self) -> ::std::vec::Vec<LoadBalancerIngress> {
        ::std::mem::replace(&mut self.ingress, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ingress",
            |m: &LoadBalancerStatus| { &m.ingress },
            |m: &mut LoadBalancerStatus| { &mut m.ingress },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoadBalancerStatus>(
            "LoadBalancerStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoadBalancerStatus {
    const NAME: &'static str = "LoadBalancerStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ingress.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ingress {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ingress {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoadBalancerStatus {
        LoadBalancerStatus::new()
    }

    fn clear(&mut self) {
        self.ingress.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoadBalancerStatus {
        static instance: LoadBalancerStatus = LoadBalancerStatus {
            ingress: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoadBalancerStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoadBalancerStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoadBalancerStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadBalancerStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.LocalObjectReference)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LocalObjectReference {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.LocalObjectReference.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.LocalObjectReference.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LocalObjectReference {
    fn default() -> &'a LocalObjectReference {
        <LocalObjectReference as ::protobuf::Message>::default_instance()
    }
}

impl LocalObjectReference {
    pub fn new() -> LocalObjectReference {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &LocalObjectReference| { &m.name },
            |m: &mut LocalObjectReference| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LocalObjectReference>(
            "LocalObjectReference",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LocalObjectReference {
    const NAME: &'static str = "LocalObjectReference";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LocalObjectReference {
        LocalObjectReference::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LocalObjectReference {
        static instance: LocalObjectReference = LocalObjectReference {
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LocalObjectReference {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LocalObjectReference").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LocalObjectReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocalObjectReference {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.LocalVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LocalVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.LocalVolumeSource.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.LocalVolumeSource.fsType)
    pub fsType: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.LocalVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LocalVolumeSource {
    fn default() -> &'a LocalVolumeSource {
        <LocalVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl LocalVolumeSource {
    pub fn new() -> LocalVolumeSource {
        ::std::default::Default::default()
    }

    // optional string path = 1;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 2;

    pub fn fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fsType(&mut self) {
        self.fsType = ::std::option::Option::None;
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &LocalVolumeSource| { &m.path },
            |m: &mut LocalVolumeSource| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsType",
            |m: &LocalVolumeSource| { &m.fsType },
            |m: &mut LocalVolumeSource| { &mut m.fsType },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LocalVolumeSource>(
            "LocalVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LocalVolumeSource {
    const NAME: &'static str = "LocalVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.fsType = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.path.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.fsType.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LocalVolumeSource {
        LocalVolumeSource::new()
    }

    fn clear(&mut self) {
        self.path = ::std::option::Option::None;
        self.fsType = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LocalVolumeSource {
        static instance: LocalVolumeSource = LocalVolumeSource {
            path: ::std::option::Option::None,
            fsType: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LocalVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LocalVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LocalVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocalVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ModifyVolumeStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModifyVolumeStatus {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ModifyVolumeStatus.targetVolumeAttributesClassName)
    pub targetVolumeAttributesClassName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ModifyVolumeStatus.status)
    pub status: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ModifyVolumeStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModifyVolumeStatus {
    fn default() -> &'a ModifyVolumeStatus {
        <ModifyVolumeStatus as ::protobuf::Message>::default_instance()
    }
}

impl ModifyVolumeStatus {
    pub fn new() -> ModifyVolumeStatus {
        ::std::default::Default::default()
    }

    // optional string targetVolumeAttributesClassName = 1;

    pub fn targetVolumeAttributesClassName(&self) -> &str {
        match self.targetVolumeAttributesClassName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_targetVolumeAttributesClassName(&mut self) {
        self.targetVolumeAttributesClassName = ::std::option::Option::None;
    }

    pub fn has_targetVolumeAttributesClassName(&self) -> bool {
        self.targetVolumeAttributesClassName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetVolumeAttributesClassName(&mut self, v: ::std::string::String) {
        self.targetVolumeAttributesClassName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetVolumeAttributesClassName(&mut self) -> &mut ::std::string::String {
        if self.targetVolumeAttributesClassName.is_none() {
            self.targetVolumeAttributesClassName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.targetVolumeAttributesClassName.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetVolumeAttributesClassName(&mut self) -> ::std::string::String {
        self.targetVolumeAttributesClassName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "targetVolumeAttributesClassName",
            |m: &ModifyVolumeStatus| { &m.targetVolumeAttributesClassName },
            |m: &mut ModifyVolumeStatus| { &mut m.targetVolumeAttributesClassName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &ModifyVolumeStatus| { &m.status },
            |m: &mut ModifyVolumeStatus| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModifyVolumeStatus>(
            "ModifyVolumeStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModifyVolumeStatus {
    const NAME: &'static str = "ModifyVolumeStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.targetVolumeAttributesClassName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.targetVolumeAttributesClassName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.targetVolumeAttributesClassName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModifyVolumeStatus {
        ModifyVolumeStatus::new()
    }

    fn clear(&mut self) {
        self.targetVolumeAttributesClassName = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModifyVolumeStatus {
        static instance: ModifyVolumeStatus = ModifyVolumeStatus {
            targetVolumeAttributesClassName: ::std::option::Option::None,
            status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModifyVolumeStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModifyVolumeStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModifyVolumeStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyVolumeStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.NFSVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NFSVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.NFSVolumeSource.server)
    pub server: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.NFSVolumeSource.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.NFSVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.NFSVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NFSVolumeSource {
    fn default() -> &'a NFSVolumeSource {
        <NFSVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl NFSVolumeSource {
    pub fn new() -> NFSVolumeSource {
        ::std::default::Default::default()
    }

    // optional string server = 1;

    pub fn server(&self) -> &str {
        match self.server.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_server(&mut self) {
        self.server = ::std::option::Option::None;
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: ::std::string::String) {
        self.server = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut ::std::string::String {
        if self.server.is_none() {
            self.server = ::std::option::Option::Some(::std::string::String::new());
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> ::std::string::String {
        self.server.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string path = 2;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 3;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server",
            |m: &NFSVolumeSource| { &m.server },
            |m: &mut NFSVolumeSource| { &mut m.server },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &NFSVolumeSource| { &m.path },
            |m: &mut NFSVolumeSource| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &NFSVolumeSource| { &m.readOnly },
            |m: &mut NFSVolumeSource| { &mut m.readOnly },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NFSVolumeSource>(
            "NFSVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NFSVolumeSource {
    const NAME: &'static str = "NFSVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.server = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.server.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NFSVolumeSource {
        NFSVolumeSource::new()
    }

    fn clear(&mut self) {
        self.server = ::std::option::Option::None;
        self.path = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NFSVolumeSource {
        static instance: NFSVolumeSource = NFSVolumeSource {
            server: ::std::option::Option::None,
            path: ::std::option::Option::None,
            readOnly: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NFSVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NFSVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NFSVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NFSVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.Namespace)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Namespace {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Namespace.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Namespace.spec)
    pub spec: ::protobuf::MessageField<NamespaceSpec>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Namespace.status)
    pub status: ::protobuf::MessageField<NamespaceStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.Namespace.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Namespace {
    fn default() -> &'a Namespace {
        <Namespace as ::protobuf::Message>::default_instance()
    }
}

impl Namespace {
    pub fn new() -> Namespace {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.core.v1.NamespaceSpec spec = 2;

    pub fn spec(&self) -> &NamespaceSpec {
        self.spec.as_ref().unwrap_or_else(|| <NamespaceSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: NamespaceSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut NamespaceSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> NamespaceSpec {
        self.spec.take().unwrap_or_else(|| NamespaceSpec::new())
    }

    // optional .api.core.v1.NamespaceStatus status = 3;

    pub fn status(&self) -> &NamespaceStatus {
        self.status.as_ref().unwrap_or_else(|| <NamespaceStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: NamespaceStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut NamespaceStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> NamespaceStatus {
        self.status.take().unwrap_or_else(|| NamespaceStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &Namespace| { &m.metadata },
            |m: &mut Namespace| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NamespaceSpec>(
            "spec",
            |m: &Namespace| { &m.spec },
            |m: &mut Namespace| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NamespaceStatus>(
            "status",
            |m: &Namespace| { &m.status },
            |m: &mut Namespace| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Namespace>(
            "Namespace",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Namespace {
    const NAME: &'static str = "Namespace";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Namespace {
        Namespace::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Namespace {
        static instance: Namespace = Namespace {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Namespace {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Namespace").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Namespace {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Namespace {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.NamespaceCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NamespaceCondition {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.NamespaceCondition.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.NamespaceCondition.status)
    pub status: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NamespaceCondition.lastTransitionTime)
    pub lastTransitionTime: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:api.core.v1.NamespaceCondition.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.NamespaceCondition.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.NamespaceCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NamespaceCondition {
    fn default() -> &'a NamespaceCondition {
        <NamespaceCondition as ::protobuf::Message>::default_instance()
    }
}

impl NamespaceCondition {
    pub fn new() -> NamespaceCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;

    pub fn lastTransitionTime(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastTransitionTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional string reason = 5;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 6;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &NamespaceCondition| { &m.type_ },
            |m: &mut NamespaceCondition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &NamespaceCondition| { &m.status },
            |m: &mut NamespaceCondition| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>(
            "lastTransitionTime",
            |m: &NamespaceCondition| { &m.lastTransitionTime },
            |m: &mut NamespaceCondition| { &mut m.lastTransitionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &NamespaceCondition| { &m.reason },
            |m: &mut NamespaceCondition| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &NamespaceCondition| { &m.message },
            |m: &mut NamespaceCondition| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NamespaceCondition>(
            "NamespaceCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NamespaceCondition {
    const NAME: &'static str = "NamespaceCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTransitionTime)?;
                },
                42 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NamespaceCondition {
        NamespaceCondition::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.lastTransitionTime.clear();
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NamespaceCondition {
        static instance: NamespaceCondition = NamespaceCondition {
            type_: ::std::option::Option::None,
            status: ::std::option::Option::None,
            lastTransitionTime: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NamespaceCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NamespaceCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NamespaceCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamespaceCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.NamespaceList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NamespaceList {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NamespaceList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NamespaceList.items)
    pub items: ::std::vec::Vec<Namespace>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.NamespaceList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NamespaceList {
    fn default() -> &'a NamespaceList {
        <NamespaceList as ::protobuf::Message>::default_instance()
    }
}

impl NamespaceList {
    pub fn new() -> NamespaceList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.core.v1.Namespace items = 2;

    pub fn items(&self) -> &[Namespace] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<Namespace>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<Namespace> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<Namespace> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &NamespaceList| { &m.metadata },
            |m: &mut NamespaceList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &NamespaceList| { &m.items },
            |m: &mut NamespaceList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NamespaceList>(
            "NamespaceList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NamespaceList {
    const NAME: &'static str = "NamespaceList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NamespaceList {
        NamespaceList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NamespaceList {
        static instance: NamespaceList = NamespaceList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NamespaceList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NamespaceList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NamespaceList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamespaceList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.NamespaceSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NamespaceSpec {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NamespaceSpec.finalizers)
    pub finalizers: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.NamespaceSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NamespaceSpec {
    fn default() -> &'a NamespaceSpec {
        <NamespaceSpec as ::protobuf::Message>::default_instance()
    }
}

impl NamespaceSpec {
    pub fn new() -> NamespaceSpec {
        ::std::default::Default::default()
    }

    // repeated string finalizers = 1;

    pub fn finalizers(&self) -> &[::std::string::String] {
        &self.finalizers
    }

    pub fn clear_finalizers(&mut self) {
        self.finalizers.clear();
    }

    // Param is passed by value, moved
    pub fn set_finalizers(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.finalizers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_finalizers(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.finalizers
    }

    // Take field
    pub fn take_finalizers(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.finalizers, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "finalizers",
            |m: &NamespaceSpec| { &m.finalizers },
            |m: &mut NamespaceSpec| { &mut m.finalizers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NamespaceSpec>(
            "NamespaceSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NamespaceSpec {
    const NAME: &'static str = "NamespaceSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.finalizers.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.finalizers {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.finalizers {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NamespaceSpec {
        NamespaceSpec::new()
    }

    fn clear(&mut self) {
        self.finalizers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NamespaceSpec {
        static instance: NamespaceSpec = NamespaceSpec {
            finalizers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NamespaceSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NamespaceSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NamespaceSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamespaceSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.NamespaceStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NamespaceStatus {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.NamespaceStatus.phase)
    pub phase: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NamespaceStatus.conditions)
    pub conditions: ::std::vec::Vec<NamespaceCondition>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.NamespaceStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NamespaceStatus {
    fn default() -> &'a NamespaceStatus {
        <NamespaceStatus as ::protobuf::Message>::default_instance()
    }
}

impl NamespaceStatus {
    pub fn new() -> NamespaceStatus {
        ::std::default::Default::default()
    }

    // optional string phase = 1;

    pub fn phase(&self) -> &str {
        match self.phase.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_phase(&mut self) {
        self.phase = ::std::option::Option::None;
    }

    pub fn has_phase(&self) -> bool {
        self.phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase(&mut self, v: ::std::string::String) {
        self.phase = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phase(&mut self) -> &mut ::std::string::String {
        if self.phase.is_none() {
            self.phase = ::std::option::Option::Some(::std::string::String::new());
        }
        self.phase.as_mut().unwrap()
    }

    // Take field
    pub fn take_phase(&mut self) -> ::std::string::String {
        self.phase.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.core.v1.NamespaceCondition conditions = 2;

    pub fn conditions(&self) -> &[NamespaceCondition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<NamespaceCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<NamespaceCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<NamespaceCondition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "phase",
            |m: &NamespaceStatus| { &m.phase },
            |m: &mut NamespaceStatus| { &mut m.phase },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &NamespaceStatus| { &m.conditions },
            |m: &mut NamespaceStatus| { &mut m.conditions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NamespaceStatus>(
            "NamespaceStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NamespaceStatus {
    const NAME: &'static str = "NamespaceStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.phase = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.conditions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.phase.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.phase.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NamespaceStatus {
        NamespaceStatus::new()
    }

    fn clear(&mut self) {
        self.phase = ::std::option::Option::None;
        self.conditions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NamespaceStatus {
        static instance: NamespaceStatus = NamespaceStatus {
            phase: ::std::option::Option::None,
            conditions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NamespaceStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NamespaceStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NamespaceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamespaceStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.Node)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Node {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Node.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Node.spec)
    pub spec: ::protobuf::MessageField<NodeSpec>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Node.status)
    pub status: ::protobuf::MessageField<NodeStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.Node.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Node {
    fn default() -> &'a Node {
        <Node as ::protobuf::Message>::default_instance()
    }
}

impl Node {
    pub fn new() -> Node {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.core.v1.NodeSpec spec = 2;

    pub fn spec(&self) -> &NodeSpec {
        self.spec.as_ref().unwrap_or_else(|| <NodeSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: NodeSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut NodeSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> NodeSpec {
        self.spec.take().unwrap_or_else(|| NodeSpec::new())
    }

    // optional .api.core.v1.NodeStatus status = 3;

    pub fn status(&self) -> &NodeStatus {
        self.status.as_ref().unwrap_or_else(|| <NodeStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: NodeStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut NodeStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> NodeStatus {
        self.status.take().unwrap_or_else(|| NodeStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &Node| { &m.metadata },
            |m: &mut Node| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodeSpec>(
            "spec",
            |m: &Node| { &m.spec },
            |m: &mut Node| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodeStatus>(
            "status",
            |m: &Node| { &m.status },
            |m: &mut Node| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Node>(
            "Node",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Node {
    const NAME: &'static str = "Node";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Node {
        Node::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Node {
        static instance: Node = Node {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Node {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Node").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Node {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Node {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.NodeAddress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NodeAddress {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.NodeAddress.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.NodeAddress.address)
    pub address: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.NodeAddress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeAddress {
    fn default() -> &'a NodeAddress {
        <NodeAddress as ::protobuf::Message>::default_instance()
    }
}

impl NodeAddress {
    pub fn new() -> NodeAddress {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string address = 2;

    pub fn address(&self) -> &str {
        match self.address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_address(&mut self) {
        self.address = ::std::option::Option::None;
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        if self.address.is_none() {
            self.address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        self.address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &NodeAddress| { &m.type_ },
            |m: &mut NodeAddress| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "address",
            |m: &NodeAddress| { &m.address },
            |m: &mut NodeAddress| { &mut m.address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeAddress>(
            "NodeAddress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeAddress {
    const NAME: &'static str = "NodeAddress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.address = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.address.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.address.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeAddress {
        NodeAddress::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.address = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeAddress {
        static instance: NodeAddress = NodeAddress {
            type_: ::std::option::Option::None,
            address: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeAddress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeAddress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeAddress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.NodeAffinity)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NodeAffinity {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeAffinity.requiredDuringSchedulingIgnoredDuringExecution)
    pub requiredDuringSchedulingIgnoredDuringExecution: ::protobuf::MessageField<NodeSelector>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeAffinity.preferredDuringSchedulingIgnoredDuringExecution)
    pub preferredDuringSchedulingIgnoredDuringExecution: ::std::vec::Vec<PreferredSchedulingTerm>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.NodeAffinity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeAffinity {
    fn default() -> &'a NodeAffinity {
        <NodeAffinity as ::protobuf::Message>::default_instance()
    }
}

impl NodeAffinity {
    pub fn new() -> NodeAffinity {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.NodeSelector requiredDuringSchedulingIgnoredDuringExecution = 1;

    pub fn requiredDuringSchedulingIgnoredDuringExecution(&self) -> &NodeSelector {
        self.requiredDuringSchedulingIgnoredDuringExecution.as_ref().unwrap_or_else(|| <NodeSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_requiredDuringSchedulingIgnoredDuringExecution(&mut self) {
        self.requiredDuringSchedulingIgnoredDuringExecution.clear();
    }

    pub fn has_requiredDuringSchedulingIgnoredDuringExecution(&self) -> bool {
        self.requiredDuringSchedulingIgnoredDuringExecution.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requiredDuringSchedulingIgnoredDuringExecution(&mut self, v: NodeSelector) {
        self.requiredDuringSchedulingIgnoredDuringExecution = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_requiredDuringSchedulingIgnoredDuringExecution(&mut self) -> &mut NodeSelector {
        self.requiredDuringSchedulingIgnoredDuringExecution.mut_or_insert_default()
    }

    // Take field
    pub fn take_requiredDuringSchedulingIgnoredDuringExecution(&mut self) -> NodeSelector {
        self.requiredDuringSchedulingIgnoredDuringExecution.take().unwrap_or_else(|| NodeSelector::new())
    }

    // repeated .api.core.v1.PreferredSchedulingTerm preferredDuringSchedulingIgnoredDuringExecution = 2;

    pub fn preferredDuringSchedulingIgnoredDuringExecution(&self) -> &[PreferredSchedulingTerm] {
        &self.preferredDuringSchedulingIgnoredDuringExecution
    }

    pub fn clear_preferredDuringSchedulingIgnoredDuringExecution(&mut self) {
        self.preferredDuringSchedulingIgnoredDuringExecution.clear();
    }

    // Param is passed by value, moved
    pub fn set_preferredDuringSchedulingIgnoredDuringExecution(&mut self, v: ::std::vec::Vec<PreferredSchedulingTerm>) {
        self.preferredDuringSchedulingIgnoredDuringExecution = v;
    }

    // Mutable pointer to the field.
    pub fn mut_preferredDuringSchedulingIgnoredDuringExecution(&mut self) -> &mut ::std::vec::Vec<PreferredSchedulingTerm> {
        &mut self.preferredDuringSchedulingIgnoredDuringExecution
    }

    // Take field
    pub fn take_preferredDuringSchedulingIgnoredDuringExecution(&mut self) -> ::std::vec::Vec<PreferredSchedulingTerm> {
        ::std::mem::replace(&mut self.preferredDuringSchedulingIgnoredDuringExecution, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodeSelector>(
            "requiredDuringSchedulingIgnoredDuringExecution",
            |m: &NodeAffinity| { &m.requiredDuringSchedulingIgnoredDuringExecution },
            |m: &mut NodeAffinity| { &mut m.requiredDuringSchedulingIgnoredDuringExecution },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "preferredDuringSchedulingIgnoredDuringExecution",
            |m: &NodeAffinity| { &m.preferredDuringSchedulingIgnoredDuringExecution },
            |m: &mut NodeAffinity| { &mut m.preferredDuringSchedulingIgnoredDuringExecution },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeAffinity>(
            "NodeAffinity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeAffinity {
    const NAME: &'static str = "NodeAffinity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.requiredDuringSchedulingIgnoredDuringExecution)?;
                },
                18 => {
                    self.preferredDuringSchedulingIgnoredDuringExecution.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.requiredDuringSchedulingIgnoredDuringExecution.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.preferredDuringSchedulingIgnoredDuringExecution {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.requiredDuringSchedulingIgnoredDuringExecution.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.preferredDuringSchedulingIgnoredDuringExecution {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeAffinity {
        NodeAffinity::new()
    }

    fn clear(&mut self) {
        self.requiredDuringSchedulingIgnoredDuringExecution.clear();
        self.preferredDuringSchedulingIgnoredDuringExecution.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeAffinity {
        static instance: NodeAffinity = NodeAffinity {
            requiredDuringSchedulingIgnoredDuringExecution: ::protobuf::MessageField::none(),
            preferredDuringSchedulingIgnoredDuringExecution: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeAffinity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeAffinity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeAffinity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeAffinity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.NodeCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NodeCondition {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.NodeCondition.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.NodeCondition.status)
    pub status: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeCondition.lastHeartbeatTime)
    pub lastHeartbeatTime: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeCondition.lastTransitionTime)
    pub lastTransitionTime: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:api.core.v1.NodeCondition.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.NodeCondition.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.NodeCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeCondition {
    fn default() -> &'a NodeCondition {
        <NodeCondition as ::protobuf::Message>::default_instance()
    }
}

impl NodeCondition {
    pub fn new() -> NodeCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastHeartbeatTime = 3;

    pub fn lastHeartbeatTime(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastHeartbeatTime.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastHeartbeatTime(&mut self) {
        self.lastHeartbeatTime.clear();
    }

    pub fn has_lastHeartbeatTime(&self) -> bool {
        self.lastHeartbeatTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastHeartbeatTime(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastHeartbeatTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastHeartbeatTime(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastHeartbeatTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastHeartbeatTime(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastHeartbeatTime.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;

    pub fn lastTransitionTime(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastTransitionTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional string reason = 5;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 6;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &NodeCondition| { &m.type_ },
            |m: &mut NodeCondition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &NodeCondition| { &m.status },
            |m: &mut NodeCondition| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>(
            "lastHeartbeatTime",
            |m: &NodeCondition| { &m.lastHeartbeatTime },
            |m: &mut NodeCondition| { &mut m.lastHeartbeatTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>(
            "lastTransitionTime",
            |m: &NodeCondition| { &m.lastTransitionTime },
            |m: &mut NodeCondition| { &mut m.lastTransitionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &NodeCondition| { &m.reason },
            |m: &mut NodeCondition| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &NodeCondition| { &m.message },
            |m: &mut NodeCondition| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeCondition>(
            "NodeCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeCondition {
    const NAME: &'static str = "NodeCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastHeartbeatTime)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTransitionTime)?;
                },
                42 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastHeartbeatTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lastHeartbeatTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeCondition {
        NodeCondition::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.lastHeartbeatTime.clear();
        self.lastTransitionTime.clear();
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeCondition {
        static instance: NodeCondition = NodeCondition {
            type_: ::std::option::Option::None,
            status: ::std::option::Option::None,
            lastHeartbeatTime: ::protobuf::MessageField::none(),
            lastTransitionTime: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.NodeConfigSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NodeConfigSource {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeConfigSource.configMap)
    pub configMap: ::protobuf::MessageField<ConfigMapNodeConfigSource>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.NodeConfigSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeConfigSource {
    fn default() -> &'a NodeConfigSource {
        <NodeConfigSource as ::protobuf::Message>::default_instance()
    }
}

impl NodeConfigSource {
    pub fn new() -> NodeConfigSource {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.ConfigMapNodeConfigSource configMap = 2;

    pub fn configMap(&self) -> &ConfigMapNodeConfigSource {
        self.configMap.as_ref().unwrap_or_else(|| <ConfigMapNodeConfigSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_configMap(&mut self) {
        self.configMap.clear();
    }

    pub fn has_configMap(&self) -> bool {
        self.configMap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configMap(&mut self, v: ConfigMapNodeConfigSource) {
        self.configMap = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configMap(&mut self) -> &mut ConfigMapNodeConfigSource {
        self.configMap.mut_or_insert_default()
    }

    // Take field
    pub fn take_configMap(&mut self) -> ConfigMapNodeConfigSource {
        self.configMap.take().unwrap_or_else(|| ConfigMapNodeConfigSource::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConfigMapNodeConfigSource>(
            "configMap",
            |m: &NodeConfigSource| { &m.configMap },
            |m: &mut NodeConfigSource| { &mut m.configMap },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeConfigSource>(
            "NodeConfigSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeConfigSource {
    const NAME: &'static str = "NodeConfigSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.configMap)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.configMap.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.configMap.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeConfigSource {
        NodeConfigSource::new()
    }

    fn clear(&mut self) {
        self.configMap.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeConfigSource {
        static instance: NodeConfigSource = NodeConfigSource {
            configMap: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeConfigSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeConfigSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeConfigSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeConfigSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.NodeConfigStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NodeConfigStatus {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeConfigStatus.assigned)
    pub assigned: ::protobuf::MessageField<NodeConfigSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeConfigStatus.active)
    pub active: ::protobuf::MessageField<NodeConfigSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeConfigStatus.lastKnownGood)
    pub lastKnownGood: ::protobuf::MessageField<NodeConfigSource>,
    // @@protoc_insertion_point(field:api.core.v1.NodeConfigStatus.error)
    pub error: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.NodeConfigStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeConfigStatus {
    fn default() -> &'a NodeConfigStatus {
        <NodeConfigStatus as ::protobuf::Message>::default_instance()
    }
}

impl NodeConfigStatus {
    pub fn new() -> NodeConfigStatus {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.NodeConfigSource assigned = 1;

    pub fn assigned(&self) -> &NodeConfigSource {
        self.assigned.as_ref().unwrap_or_else(|| <NodeConfigSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_assigned(&mut self) {
        self.assigned.clear();
    }

    pub fn has_assigned(&self) -> bool {
        self.assigned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assigned(&mut self, v: NodeConfigSource) {
        self.assigned = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_assigned(&mut self) -> &mut NodeConfigSource {
        self.assigned.mut_or_insert_default()
    }

    // Take field
    pub fn take_assigned(&mut self) -> NodeConfigSource {
        self.assigned.take().unwrap_or_else(|| NodeConfigSource::new())
    }

    // optional .api.core.v1.NodeConfigSource active = 2;

    pub fn active(&self) -> &NodeConfigSource {
        self.active.as_ref().unwrap_or_else(|| <NodeConfigSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_active(&mut self) {
        self.active.clear();
    }

    pub fn has_active(&self) -> bool {
        self.active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: NodeConfigSource) {
        self.active = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_active(&mut self) -> &mut NodeConfigSource {
        self.active.mut_or_insert_default()
    }

    // Take field
    pub fn take_active(&mut self) -> NodeConfigSource {
        self.active.take().unwrap_or_else(|| NodeConfigSource::new())
    }

    // optional .api.core.v1.NodeConfigSource lastKnownGood = 3;

    pub fn lastKnownGood(&self) -> &NodeConfigSource {
        self.lastKnownGood.as_ref().unwrap_or_else(|| <NodeConfigSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastKnownGood(&mut self) {
        self.lastKnownGood.clear();
    }

    pub fn has_lastKnownGood(&self) -> bool {
        self.lastKnownGood.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastKnownGood(&mut self, v: NodeConfigSource) {
        self.lastKnownGood = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastKnownGood(&mut self) -> &mut NodeConfigSource {
        self.lastKnownGood.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastKnownGood(&mut self) -> NodeConfigSource {
        self.lastKnownGood.take().unwrap_or_else(|| NodeConfigSource::new())
    }

    // optional string error = 4;

    pub fn error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodeConfigSource>(
            "assigned",
            |m: &NodeConfigStatus| { &m.assigned },
            |m: &mut NodeConfigStatus| { &mut m.assigned },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodeConfigSource>(
            "active",
            |m: &NodeConfigStatus| { &m.active },
            |m: &mut NodeConfigStatus| { &mut m.active },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodeConfigSource>(
            "lastKnownGood",
            |m: &NodeConfigStatus| { &m.lastKnownGood },
            |m: &mut NodeConfigStatus| { &mut m.lastKnownGood },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error",
            |m: &NodeConfigStatus| { &m.error },
            |m: &mut NodeConfigStatus| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeConfigStatus>(
            "NodeConfigStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeConfigStatus {
    const NAME: &'static str = "NodeConfigStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.assigned)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.active)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastKnownGood)?;
                },
                34 => {
                    self.error = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.assigned.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.active.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.lastKnownGood.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.assigned.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.active.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.lastKnownGood.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.error.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeConfigStatus {
        NodeConfigStatus::new()
    }

    fn clear(&mut self) {
        self.assigned.clear();
        self.active.clear();
        self.lastKnownGood.clear();
        self.error = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeConfigStatus {
        static instance: NodeConfigStatus = NodeConfigStatus {
            assigned: ::protobuf::MessageField::none(),
            active: ::protobuf::MessageField::none(),
            lastKnownGood: ::protobuf::MessageField::none(),
            error: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeConfigStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeConfigStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeConfigStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeConfigStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.NodeDaemonEndpoints)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NodeDaemonEndpoints {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeDaemonEndpoints.kubeletEndpoint)
    pub kubeletEndpoint: ::protobuf::MessageField<DaemonEndpoint>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.NodeDaemonEndpoints.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeDaemonEndpoints {
    fn default() -> &'a NodeDaemonEndpoints {
        <NodeDaemonEndpoints as ::protobuf::Message>::default_instance()
    }
}

impl NodeDaemonEndpoints {
    pub fn new() -> NodeDaemonEndpoints {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.DaemonEndpoint kubeletEndpoint = 1;

    pub fn kubeletEndpoint(&self) -> &DaemonEndpoint {
        self.kubeletEndpoint.as_ref().unwrap_or_else(|| <DaemonEndpoint as ::protobuf::Message>::default_instance())
    }

    pub fn clear_kubeletEndpoint(&mut self) {
        self.kubeletEndpoint.clear();
    }

    pub fn has_kubeletEndpoint(&self) -> bool {
        self.kubeletEndpoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kubeletEndpoint(&mut self, v: DaemonEndpoint) {
        self.kubeletEndpoint = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kubeletEndpoint(&mut self) -> &mut DaemonEndpoint {
        self.kubeletEndpoint.mut_or_insert_default()
    }

    // Take field
    pub fn take_kubeletEndpoint(&mut self) -> DaemonEndpoint {
        self.kubeletEndpoint.take().unwrap_or_else(|| DaemonEndpoint::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DaemonEndpoint>(
            "kubeletEndpoint",
            |m: &NodeDaemonEndpoints| { &m.kubeletEndpoint },
            |m: &mut NodeDaemonEndpoints| { &mut m.kubeletEndpoint },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeDaemonEndpoints>(
            "NodeDaemonEndpoints",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeDaemonEndpoints {
    const NAME: &'static str = "NodeDaemonEndpoints";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.kubeletEndpoint)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.kubeletEndpoint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.kubeletEndpoint.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeDaemonEndpoints {
        NodeDaemonEndpoints::new()
    }

    fn clear(&mut self) {
        self.kubeletEndpoint.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeDaemonEndpoints {
        static instance: NodeDaemonEndpoints = NodeDaemonEndpoints {
            kubeletEndpoint: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeDaemonEndpoints {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeDaemonEndpoints").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeDaemonEndpoints {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeDaemonEndpoints {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.NodeList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NodeList {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeList.items)
    pub items: ::std::vec::Vec<Node>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.NodeList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeList {
    fn default() -> &'a NodeList {
        <NodeList as ::protobuf::Message>::default_instance()
    }
}

impl NodeList {
    pub fn new() -> NodeList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.core.v1.Node items = 2;

    pub fn items(&self) -> &[Node] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<Node>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<Node> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<Node> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &NodeList| { &m.metadata },
            |m: &mut NodeList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &NodeList| { &m.items },
            |m: &mut NodeList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeList>(
            "NodeList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeList {
    const NAME: &'static str = "NodeList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeList {
        NodeList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeList {
        static instance: NodeList = NodeList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.NodeProxyOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NodeProxyOptions {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.NodeProxyOptions.path)
    pub path: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.NodeProxyOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeProxyOptions {
    fn default() -> &'a NodeProxyOptions {
        <NodeProxyOptions as ::protobuf::Message>::default_instance()
    }
}

impl NodeProxyOptions {
    pub fn new() -> NodeProxyOptions {
        ::std::default::Default::default()
    }

    // optional string path = 1;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &NodeProxyOptions| { &m.path },
            |m: &mut NodeProxyOptions| { &mut m.path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeProxyOptions>(
            "NodeProxyOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeProxyOptions {
    const NAME: &'static str = "NodeProxyOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.path.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeProxyOptions {
        NodeProxyOptions::new()
    }

    fn clear(&mut self) {
        self.path = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeProxyOptions {
        static instance: NodeProxyOptions = NodeProxyOptions {
            path: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeProxyOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeProxyOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeProxyOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeProxyOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.NodeRuntimeHandler)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NodeRuntimeHandler {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.NodeRuntimeHandler.name)
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeRuntimeHandler.features)
    pub features: ::protobuf::MessageField<NodeRuntimeHandlerFeatures>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.NodeRuntimeHandler.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeRuntimeHandler {
    fn default() -> &'a NodeRuntimeHandler {
        <NodeRuntimeHandler as ::protobuf::Message>::default_instance()
    }
}

impl NodeRuntimeHandler {
    pub fn new() -> NodeRuntimeHandler {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.NodeRuntimeHandlerFeatures features = 2;

    pub fn features(&self) -> &NodeRuntimeHandlerFeatures {
        self.features.as_ref().unwrap_or_else(|| <NodeRuntimeHandlerFeatures as ::protobuf::Message>::default_instance())
    }

    pub fn clear_features(&mut self) {
        self.features.clear();
    }

    pub fn has_features(&self) -> bool {
        self.features.is_some()
    }

    // Param is passed by value, moved
    pub fn set_features(&mut self, v: NodeRuntimeHandlerFeatures) {
        self.features = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_features(&mut self) -> &mut NodeRuntimeHandlerFeatures {
        self.features.mut_or_insert_default()
    }

    // Take field
    pub fn take_features(&mut self) -> NodeRuntimeHandlerFeatures {
        self.features.take().unwrap_or_else(|| NodeRuntimeHandlerFeatures::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &NodeRuntimeHandler| { &m.name },
            |m: &mut NodeRuntimeHandler| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodeRuntimeHandlerFeatures>(
            "features",
            |m: &NodeRuntimeHandler| { &m.features },
            |m: &mut NodeRuntimeHandler| { &mut m.features },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeRuntimeHandler>(
            "NodeRuntimeHandler",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeRuntimeHandler {
    const NAME: &'static str = "NodeRuntimeHandler";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.features)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.features.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.features.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeRuntimeHandler {
        NodeRuntimeHandler::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.features.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeRuntimeHandler {
        static instance: NodeRuntimeHandler = NodeRuntimeHandler {
            name: ::std::option::Option::None,
            features: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeRuntimeHandler {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeRuntimeHandler").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeRuntimeHandler {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeRuntimeHandler {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.NodeRuntimeHandlerFeatures)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NodeRuntimeHandlerFeatures {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.NodeRuntimeHandlerFeatures.recursiveReadOnlyMounts)
    pub recursiveReadOnlyMounts: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.NodeRuntimeHandlerFeatures.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeRuntimeHandlerFeatures {
    fn default() -> &'a NodeRuntimeHandlerFeatures {
        <NodeRuntimeHandlerFeatures as ::protobuf::Message>::default_instance()
    }
}

impl NodeRuntimeHandlerFeatures {
    pub fn new() -> NodeRuntimeHandlerFeatures {
        ::std::default::Default::default()
    }

    // optional bool recursiveReadOnlyMounts = 1;

    pub fn recursiveReadOnlyMounts(&self) -> bool {
        self.recursiveReadOnlyMounts.unwrap_or(false)
    }

    pub fn clear_recursiveReadOnlyMounts(&mut self) {
        self.recursiveReadOnlyMounts = ::std::option::Option::None;
    }

    pub fn has_recursiveReadOnlyMounts(&self) -> bool {
        self.recursiveReadOnlyMounts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recursiveReadOnlyMounts(&mut self, v: bool) {
        self.recursiveReadOnlyMounts = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recursiveReadOnlyMounts",
            |m: &NodeRuntimeHandlerFeatures| { &m.recursiveReadOnlyMounts },
            |m: &mut NodeRuntimeHandlerFeatures| { &mut m.recursiveReadOnlyMounts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeRuntimeHandlerFeatures>(
            "NodeRuntimeHandlerFeatures",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeRuntimeHandlerFeatures {
    const NAME: &'static str = "NodeRuntimeHandlerFeatures";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.recursiveReadOnlyMounts = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.recursiveReadOnlyMounts {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.recursiveReadOnlyMounts {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeRuntimeHandlerFeatures {
        NodeRuntimeHandlerFeatures::new()
    }

    fn clear(&mut self) {
        self.recursiveReadOnlyMounts = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeRuntimeHandlerFeatures {
        static instance: NodeRuntimeHandlerFeatures = NodeRuntimeHandlerFeatures {
            recursiveReadOnlyMounts: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeRuntimeHandlerFeatures {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeRuntimeHandlerFeatures").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeRuntimeHandlerFeatures {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeRuntimeHandlerFeatures {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.NodeSelector)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NodeSelector {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeSelector.nodeSelectorTerms)
    pub nodeSelectorTerms: ::std::vec::Vec<NodeSelectorTerm>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.NodeSelector.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeSelector {
    fn default() -> &'a NodeSelector {
        <NodeSelector as ::protobuf::Message>::default_instance()
    }
}

impl NodeSelector {
    pub fn new() -> NodeSelector {
        ::std::default::Default::default()
    }

    // repeated .api.core.v1.NodeSelectorTerm nodeSelectorTerms = 1;

    pub fn nodeSelectorTerms(&self) -> &[NodeSelectorTerm] {
        &self.nodeSelectorTerms
    }

    pub fn clear_nodeSelectorTerms(&mut self) {
        self.nodeSelectorTerms.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodeSelectorTerms(&mut self, v: ::std::vec::Vec<NodeSelectorTerm>) {
        self.nodeSelectorTerms = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodeSelectorTerms(&mut self) -> &mut ::std::vec::Vec<NodeSelectorTerm> {
        &mut self.nodeSelectorTerms
    }

    // Take field
    pub fn take_nodeSelectorTerms(&mut self) -> ::std::vec::Vec<NodeSelectorTerm> {
        ::std::mem::replace(&mut self.nodeSelectorTerms, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nodeSelectorTerms",
            |m: &NodeSelector| { &m.nodeSelectorTerms },
            |m: &mut NodeSelector| { &mut m.nodeSelectorTerms },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeSelector>(
            "NodeSelector",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeSelector {
    const NAME: &'static str = "NodeSelector";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.nodeSelectorTerms.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.nodeSelectorTerms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.nodeSelectorTerms {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeSelector {
        NodeSelector::new()
    }

    fn clear(&mut self) {
        self.nodeSelectorTerms.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeSelector {
        static instance: NodeSelector = NodeSelector {
            nodeSelectorTerms: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeSelector {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeSelector").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeSelector {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.NodeSelectorRequirement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NodeSelectorRequirement {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.NodeSelectorRequirement.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.NodeSelectorRequirement.operator)
    pub operator: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeSelectorRequirement.values)
    pub values: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.NodeSelectorRequirement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeSelectorRequirement {
    fn default() -> &'a NodeSelectorRequirement {
        <NodeSelectorRequirement as ::protobuf::Message>::default_instance()
    }
}

impl NodeSelectorRequirement {
    pub fn new() -> NodeSelectorRequirement {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string operator = 2;

    pub fn operator(&self) -> &str {
        match self.operator.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_operator(&mut self) {
        self.operator = ::std::option::Option::None;
    }

    pub fn has_operator(&self) -> bool {
        self.operator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operator(&mut self, v: ::std::string::String) {
        self.operator = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operator(&mut self) -> &mut ::std::string::String {
        if self.operator.is_none() {
            self.operator = ::std::option::Option::Some(::std::string::String::new());
        }
        self.operator.as_mut().unwrap()
    }

    // Take field
    pub fn take_operator(&mut self) -> ::std::string::String {
        self.operator.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string values = 3;

    pub fn values(&self) -> &[::std::string::String] {
        &self.values
    }

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &NodeSelectorRequirement| { &m.key },
            |m: &mut NodeSelectorRequirement| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "operator",
            |m: &NodeSelectorRequirement| { &m.operator },
            |m: &mut NodeSelectorRequirement| { &mut m.operator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &NodeSelectorRequirement| { &m.values },
            |m: &mut NodeSelectorRequirement| { &mut m.values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeSelectorRequirement>(
            "NodeSelectorRequirement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeSelectorRequirement {
    const NAME: &'static str = "NodeSelectorRequirement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.operator = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.values.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.operator.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.values {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.operator.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.values {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeSelectorRequirement {
        NodeSelectorRequirement::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.operator = ::std::option::Option::None;
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeSelectorRequirement {
        static instance: NodeSelectorRequirement = NodeSelectorRequirement {
            key: ::std::option::Option::None,
            operator: ::std::option::Option::None,
            values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeSelectorRequirement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeSelectorRequirement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeSelectorRequirement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeSelectorRequirement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.NodeSelectorTerm)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NodeSelectorTerm {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeSelectorTerm.matchExpressions)
    pub matchExpressions: ::std::vec::Vec<NodeSelectorRequirement>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeSelectorTerm.matchFields)
    pub matchFields: ::std::vec::Vec<NodeSelectorRequirement>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.NodeSelectorTerm.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeSelectorTerm {
    fn default() -> &'a NodeSelectorTerm {
        <NodeSelectorTerm as ::protobuf::Message>::default_instance()
    }
}

impl NodeSelectorTerm {
    pub fn new() -> NodeSelectorTerm {
        ::std::default::Default::default()
    }

    // repeated .api.core.v1.NodeSelectorRequirement matchExpressions = 1;

    pub fn matchExpressions(&self) -> &[NodeSelectorRequirement] {
        &self.matchExpressions
    }

    pub fn clear_matchExpressions(&mut self) {
        self.matchExpressions.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchExpressions(&mut self, v: ::std::vec::Vec<NodeSelectorRequirement>) {
        self.matchExpressions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchExpressions(&mut self) -> &mut ::std::vec::Vec<NodeSelectorRequirement> {
        &mut self.matchExpressions
    }

    // Take field
    pub fn take_matchExpressions(&mut self) -> ::std::vec::Vec<NodeSelectorRequirement> {
        ::std::mem::replace(&mut self.matchExpressions, ::std::vec::Vec::new())
    }

    // repeated .api.core.v1.NodeSelectorRequirement matchFields = 2;

    pub fn matchFields(&self) -> &[NodeSelectorRequirement] {
        &self.matchFields
    }

    pub fn clear_matchFields(&mut self) {
        self.matchFields.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchFields(&mut self, v: ::std::vec::Vec<NodeSelectorRequirement>) {
        self.matchFields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchFields(&mut self) -> &mut ::std::vec::Vec<NodeSelectorRequirement> {
        &mut self.matchFields
    }

    // Take field
    pub fn take_matchFields(&mut self) -> ::std::vec::Vec<NodeSelectorRequirement> {
        ::std::mem::replace(&mut self.matchFields, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matchExpressions",
            |m: &NodeSelectorTerm| { &m.matchExpressions },
            |m: &mut NodeSelectorTerm| { &mut m.matchExpressions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matchFields",
            |m: &NodeSelectorTerm| { &m.matchFields },
            |m: &mut NodeSelectorTerm| { &mut m.matchFields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeSelectorTerm>(
            "NodeSelectorTerm",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeSelectorTerm {
    const NAME: &'static str = "NodeSelectorTerm";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.matchExpressions.push(is.read_message()?);
                },
                18 => {
                    self.matchFields.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.matchExpressions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.matchFields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.matchExpressions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.matchFields {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeSelectorTerm {
        NodeSelectorTerm::new()
    }

    fn clear(&mut self) {
        self.matchExpressions.clear();
        self.matchFields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeSelectorTerm {
        static instance: NodeSelectorTerm = NodeSelectorTerm {
            matchExpressions: ::std::vec::Vec::new(),
            matchFields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeSelectorTerm {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeSelectorTerm").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeSelectorTerm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeSelectorTerm {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.NodeSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NodeSpec {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.NodeSpec.podCIDR)
    pub podCIDR: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeSpec.podCIDRs)
    pub podCIDRs: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.NodeSpec.providerID)
    pub providerID: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.NodeSpec.unschedulable)
    pub unschedulable: ::std::option::Option<bool>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeSpec.taints)
    pub taints: ::std::vec::Vec<Taint>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeSpec.configSource)
    pub configSource: ::protobuf::MessageField<NodeConfigSource>,
    // @@protoc_insertion_point(field:api.core.v1.NodeSpec.externalID)
    pub externalID: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.NodeSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeSpec {
    fn default() -> &'a NodeSpec {
        <NodeSpec as ::protobuf::Message>::default_instance()
    }
}

impl NodeSpec {
    pub fn new() -> NodeSpec {
        ::std::default::Default::default()
    }

    // optional string podCIDR = 1;

    pub fn podCIDR(&self) -> &str {
        match self.podCIDR.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_podCIDR(&mut self) {
        self.podCIDR = ::std::option::Option::None;
    }

    pub fn has_podCIDR(&self) -> bool {
        self.podCIDR.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podCIDR(&mut self, v: ::std::string::String) {
        self.podCIDR = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podCIDR(&mut self) -> &mut ::std::string::String {
        if self.podCIDR.is_none() {
            self.podCIDR = ::std::option::Option::Some(::std::string::String::new());
        }
        self.podCIDR.as_mut().unwrap()
    }

    // Take field
    pub fn take_podCIDR(&mut self) -> ::std::string::String {
        self.podCIDR.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string podCIDRs = 7;

    pub fn podCIDRs(&self) -> &[::std::string::String] {
        &self.podCIDRs
    }

    pub fn clear_podCIDRs(&mut self) {
        self.podCIDRs.clear();
    }

    // Param is passed by value, moved
    pub fn set_podCIDRs(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.podCIDRs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_podCIDRs(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.podCIDRs
    }

    // Take field
    pub fn take_podCIDRs(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.podCIDRs, ::std::vec::Vec::new())
    }

    // optional string providerID = 3;

    pub fn providerID(&self) -> &str {
        match self.providerID.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_providerID(&mut self) {
        self.providerID = ::std::option::Option::None;
    }

    pub fn has_providerID(&self) -> bool {
        self.providerID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_providerID(&mut self, v: ::std::string::String) {
        self.providerID = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_providerID(&mut self) -> &mut ::std::string::String {
        if self.providerID.is_none() {
            self.providerID = ::std::option::Option::Some(::std::string::String::new());
        }
        self.providerID.as_mut().unwrap()
    }

    // Take field
    pub fn take_providerID(&mut self) -> ::std::string::String {
        self.providerID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool unschedulable = 4;

    pub fn unschedulable(&self) -> bool {
        self.unschedulable.unwrap_or(false)
    }

    pub fn clear_unschedulable(&mut self) {
        self.unschedulable = ::std::option::Option::None;
    }

    pub fn has_unschedulable(&self) -> bool {
        self.unschedulable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unschedulable(&mut self, v: bool) {
        self.unschedulable = ::std::option::Option::Some(v);
    }

    // repeated .api.core.v1.Taint taints = 5;

    pub fn taints(&self) -> &[Taint] {
        &self.taints
    }

    pub fn clear_taints(&mut self) {
        self.taints.clear();
    }

    // Param is passed by value, moved
    pub fn set_taints(&mut self, v: ::std::vec::Vec<Taint>) {
        self.taints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_taints(&mut self) -> &mut ::std::vec::Vec<Taint> {
        &mut self.taints
    }

    // Take field
    pub fn take_taints(&mut self) -> ::std::vec::Vec<Taint> {
        ::std::mem::replace(&mut self.taints, ::std::vec::Vec::new())
    }

    // optional .api.core.v1.NodeConfigSource configSource = 6;

    pub fn configSource(&self) -> &NodeConfigSource {
        self.configSource.as_ref().unwrap_or_else(|| <NodeConfigSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_configSource(&mut self) {
        self.configSource.clear();
    }

    pub fn has_configSource(&self) -> bool {
        self.configSource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configSource(&mut self, v: NodeConfigSource) {
        self.configSource = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configSource(&mut self) -> &mut NodeConfigSource {
        self.configSource.mut_or_insert_default()
    }

    // Take field
    pub fn take_configSource(&mut self) -> NodeConfigSource {
        self.configSource.take().unwrap_or_else(|| NodeConfigSource::new())
    }

    // optional string externalID = 2;

    pub fn externalID(&self) -> &str {
        match self.externalID.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_externalID(&mut self) {
        self.externalID = ::std::option::Option::None;
    }

    pub fn has_externalID(&self) -> bool {
        self.externalID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_externalID(&mut self, v: ::std::string::String) {
        self.externalID = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_externalID(&mut self) -> &mut ::std::string::String {
        if self.externalID.is_none() {
            self.externalID = ::std::option::Option::Some(::std::string::String::new());
        }
        self.externalID.as_mut().unwrap()
    }

    // Take field
    pub fn take_externalID(&mut self) -> ::std::string::String {
        self.externalID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "podCIDR",
            |m: &NodeSpec| { &m.podCIDR },
            |m: &mut NodeSpec| { &mut m.podCIDR },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "podCIDRs",
            |m: &NodeSpec| { &m.podCIDRs },
            |m: &mut NodeSpec| { &mut m.podCIDRs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "providerID",
            |m: &NodeSpec| { &m.providerID },
            |m: &mut NodeSpec| { &mut m.providerID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unschedulable",
            |m: &NodeSpec| { &m.unschedulable },
            |m: &mut NodeSpec| { &mut m.unschedulable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "taints",
            |m: &NodeSpec| { &m.taints },
            |m: &mut NodeSpec| { &mut m.taints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodeConfigSource>(
            "configSource",
            |m: &NodeSpec| { &m.configSource },
            |m: &mut NodeSpec| { &mut m.configSource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "externalID",
            |m: &NodeSpec| { &m.externalID },
            |m: &mut NodeSpec| { &mut m.externalID },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeSpec>(
            "NodeSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeSpec {
    const NAME: &'static str = "NodeSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.podCIDR = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.podCIDRs.push(is.read_string()?);
                },
                26 => {
                    self.providerID = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.unschedulable = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.taints.push(is.read_message()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.configSource)?;
                },
                18 => {
                    self.externalID = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.podCIDR.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.podCIDRs {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.providerID.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.unschedulable {
            my_size += 1 + 1;
        }
        for value in &self.taints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.configSource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.externalID.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.podCIDR.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.podCIDRs {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.providerID.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.unschedulable {
            os.write_bool(4, v)?;
        }
        for v in &self.taints {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.configSource.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.externalID.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeSpec {
        NodeSpec::new()
    }

    fn clear(&mut self) {
        self.podCIDR = ::std::option::Option::None;
        self.podCIDRs.clear();
        self.providerID = ::std::option::Option::None;
        self.unschedulable = ::std::option::Option::None;
        self.taints.clear();
        self.configSource.clear();
        self.externalID = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeSpec {
        static instance: NodeSpec = NodeSpec {
            podCIDR: ::std::option::Option::None,
            podCIDRs: ::std::vec::Vec::new(),
            providerID: ::std::option::Option::None,
            unschedulable: ::std::option::Option::None,
            taints: ::std::vec::Vec::new(),
            configSource: ::protobuf::MessageField::none(),
            externalID: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.NodeStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NodeStatus {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeStatus.capacity)
    pub capacity: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeStatus.allocatable)
    pub allocatable: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>,
    // @@protoc_insertion_point(field:api.core.v1.NodeStatus.phase)
    pub phase: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeStatus.conditions)
    pub conditions: ::std::vec::Vec<NodeCondition>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeStatus.addresses)
    pub addresses: ::std::vec::Vec<NodeAddress>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeStatus.daemonEndpoints)
    pub daemonEndpoints: ::protobuf::MessageField<NodeDaemonEndpoints>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeStatus.nodeInfo)
    pub nodeInfo: ::protobuf::MessageField<NodeSystemInfo>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeStatus.images)
    pub images: ::std::vec::Vec<ContainerImage>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeStatus.volumesInUse)
    pub volumesInUse: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeStatus.volumesAttached)
    pub volumesAttached: ::std::vec::Vec<AttachedVolume>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeStatus.config)
    pub config: ::protobuf::MessageField<NodeConfigStatus>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.NodeStatus.runtimeHandlers)
    pub runtimeHandlers: ::std::vec::Vec<NodeRuntimeHandler>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.NodeStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeStatus {
    fn default() -> &'a NodeStatus {
        <NodeStatus as ::protobuf::Message>::default_instance()
    }
}

impl NodeStatus {
    pub fn new() -> NodeStatus {
        ::std::default::Default::default()
    }

    // repeated .api.core.v1.NodeStatus.CapacityEntry capacity = 1;

    pub fn capacity(&self) -> &::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &self.capacity
    }

    pub fn clear_capacity(&mut self) {
        self.capacity.clear();
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>) {
        self.capacity = v;
    }

    // Mutable pointer to the field.
    pub fn mut_capacity(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &mut self.capacity
    }

    // Take field
    pub fn take_capacity(&mut self) -> ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        ::std::mem::replace(&mut self.capacity, ::std::collections::BTreeMap::new())
    }

    // repeated .api.core.v1.NodeStatus.AllocatableEntry allocatable = 2;

    pub fn allocatable(&self) -> &::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &self.allocatable
    }

    pub fn clear_allocatable(&mut self) {
        self.allocatable.clear();
    }

    // Param is passed by value, moved
    pub fn set_allocatable(&mut self, v: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>) {
        self.allocatable = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allocatable(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &mut self.allocatable
    }

    // Take field
    pub fn take_allocatable(&mut self) -> ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        ::std::mem::replace(&mut self.allocatable, ::std::collections::BTreeMap::new())
    }

    // optional string phase = 3;

    pub fn phase(&self) -> &str {
        match self.phase.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_phase(&mut self) {
        self.phase = ::std::option::Option::None;
    }

    pub fn has_phase(&self) -> bool {
        self.phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase(&mut self, v: ::std::string::String) {
        self.phase = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phase(&mut self) -> &mut ::std::string::String {
        if self.phase.is_none() {
            self.phase = ::std::option::Option::Some(::std::string::String::new());
        }
        self.phase.as_mut().unwrap()
    }

    // Take field
    pub fn take_phase(&mut self) -> ::std::string::String {
        self.phase.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.core.v1.NodeCondition conditions = 4;

    pub fn conditions(&self) -> &[NodeCondition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<NodeCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<NodeCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<NodeCondition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    // repeated .api.core.v1.NodeAddress addresses = 5;

    pub fn addresses(&self) -> &[NodeAddress] {
        &self.addresses
    }

    pub fn clear_addresses(&mut self) {
        self.addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses(&mut self, v: ::std::vec::Vec<NodeAddress>) {
        self.addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses(&mut self) -> &mut ::std::vec::Vec<NodeAddress> {
        &mut self.addresses
    }

    // Take field
    pub fn take_addresses(&mut self) -> ::std::vec::Vec<NodeAddress> {
        ::std::mem::replace(&mut self.addresses, ::std::vec::Vec::new())
    }

    // optional .api.core.v1.NodeDaemonEndpoints daemonEndpoints = 6;

    pub fn daemonEndpoints(&self) -> &NodeDaemonEndpoints {
        self.daemonEndpoints.as_ref().unwrap_or_else(|| <NodeDaemonEndpoints as ::protobuf::Message>::default_instance())
    }

    pub fn clear_daemonEndpoints(&mut self) {
        self.daemonEndpoints.clear();
    }

    pub fn has_daemonEndpoints(&self) -> bool {
        self.daemonEndpoints.is_some()
    }

    // Param is passed by value, moved
    pub fn set_daemonEndpoints(&mut self, v: NodeDaemonEndpoints) {
        self.daemonEndpoints = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_daemonEndpoints(&mut self) -> &mut NodeDaemonEndpoints {
        self.daemonEndpoints.mut_or_insert_default()
    }

    // Take field
    pub fn take_daemonEndpoints(&mut self) -> NodeDaemonEndpoints {
        self.daemonEndpoints.take().unwrap_or_else(|| NodeDaemonEndpoints::new())
    }

    // optional .api.core.v1.NodeSystemInfo nodeInfo = 7;

    pub fn nodeInfo(&self) -> &NodeSystemInfo {
        self.nodeInfo.as_ref().unwrap_or_else(|| <NodeSystemInfo as ::protobuf::Message>::default_instance())
    }

    pub fn clear_nodeInfo(&mut self) {
        self.nodeInfo.clear();
    }

    pub fn has_nodeInfo(&self) -> bool {
        self.nodeInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeInfo(&mut self, v: NodeSystemInfo) {
        self.nodeInfo = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeInfo(&mut self) -> &mut NodeSystemInfo {
        self.nodeInfo.mut_or_insert_default()
    }

    // Take field
    pub fn take_nodeInfo(&mut self) -> NodeSystemInfo {
        self.nodeInfo.take().unwrap_or_else(|| NodeSystemInfo::new())
    }

    // repeated .api.core.v1.ContainerImage images = 8;

    pub fn images(&self) -> &[ContainerImage] {
        &self.images
    }

    pub fn clear_images(&mut self) {
        self.images.clear();
    }

    // Param is passed by value, moved
    pub fn set_images(&mut self, v: ::std::vec::Vec<ContainerImage>) {
        self.images = v;
    }

    // Mutable pointer to the field.
    pub fn mut_images(&mut self) -> &mut ::std::vec::Vec<ContainerImage> {
        &mut self.images
    }

    // Take field
    pub fn take_images(&mut self) -> ::std::vec::Vec<ContainerImage> {
        ::std::mem::replace(&mut self.images, ::std::vec::Vec::new())
    }

    // repeated string volumesInUse = 9;

    pub fn volumesInUse(&self) -> &[::std::string::String] {
        &self.volumesInUse
    }

    pub fn clear_volumesInUse(&mut self) {
        self.volumesInUse.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumesInUse(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.volumesInUse = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumesInUse(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.volumesInUse
    }

    // Take field
    pub fn take_volumesInUse(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.volumesInUse, ::std::vec::Vec::new())
    }

    // repeated .api.core.v1.AttachedVolume volumesAttached = 10;

    pub fn volumesAttached(&self) -> &[AttachedVolume] {
        &self.volumesAttached
    }

    pub fn clear_volumesAttached(&mut self) {
        self.volumesAttached.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumesAttached(&mut self, v: ::std::vec::Vec<AttachedVolume>) {
        self.volumesAttached = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumesAttached(&mut self) -> &mut ::std::vec::Vec<AttachedVolume> {
        &mut self.volumesAttached
    }

    // Take field
    pub fn take_volumesAttached(&mut self) -> ::std::vec::Vec<AttachedVolume> {
        ::std::mem::replace(&mut self.volumesAttached, ::std::vec::Vec::new())
    }

    // optional .api.core.v1.NodeConfigStatus config = 11;

    pub fn config(&self) -> &NodeConfigStatus {
        self.config.as_ref().unwrap_or_else(|| <NodeConfigStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: NodeConfigStatus) {
        self.config = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut NodeConfigStatus {
        self.config.mut_or_insert_default()
    }

    // Take field
    pub fn take_config(&mut self) -> NodeConfigStatus {
        self.config.take().unwrap_or_else(|| NodeConfigStatus::new())
    }

    // repeated .api.core.v1.NodeRuntimeHandler runtimeHandlers = 12;

    pub fn runtimeHandlers(&self) -> &[NodeRuntimeHandler] {
        &self.runtimeHandlers
    }

    pub fn clear_runtimeHandlers(&mut self) {
        self.runtimeHandlers.clear();
    }

    // Param is passed by value, moved
    pub fn set_runtimeHandlers(&mut self, v: ::std::vec::Vec<NodeRuntimeHandler>) {
        self.runtimeHandlers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_runtimeHandlers(&mut self) -> &mut ::std::vec::Vec<NodeRuntimeHandler> {
        &mut self.runtimeHandlers
    }

    // Take field
    pub fn take_runtimeHandlers(&mut self) -> ::std::vec::Vec<NodeRuntimeHandler> {
        ::std::mem::replace(&mut self.runtimeHandlers, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "capacity",
            |m: &NodeStatus| { &m.capacity },
            |m: &mut NodeStatus| { &mut m.capacity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "allocatable",
            |m: &NodeStatus| { &m.allocatable },
            |m: &mut NodeStatus| { &mut m.allocatable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "phase",
            |m: &NodeStatus| { &m.phase },
            |m: &mut NodeStatus| { &mut m.phase },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &NodeStatus| { &m.conditions },
            |m: &mut NodeStatus| { &mut m.conditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "addresses",
            |m: &NodeStatus| { &m.addresses },
            |m: &mut NodeStatus| { &mut m.addresses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodeDaemonEndpoints>(
            "daemonEndpoints",
            |m: &NodeStatus| { &m.daemonEndpoints },
            |m: &mut NodeStatus| { &mut m.daemonEndpoints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodeSystemInfo>(
            "nodeInfo",
            |m: &NodeStatus| { &m.nodeInfo },
            |m: &mut NodeStatus| { &mut m.nodeInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "images",
            |m: &NodeStatus| { &m.images },
            |m: &mut NodeStatus| { &mut m.images },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "volumesInUse",
            |m: &NodeStatus| { &m.volumesInUse },
            |m: &mut NodeStatus| { &mut m.volumesInUse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "volumesAttached",
            |m: &NodeStatus| { &m.volumesAttached },
            |m: &mut NodeStatus| { &mut m.volumesAttached },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodeConfigStatus>(
            "config",
            |m: &NodeStatus| { &m.config },
            |m: &mut NodeStatus| { &mut m.config },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "runtimeHandlers",
            |m: &NodeStatus| { &m.runtimeHandlers },
            |m: &mut NodeStatus| { &mut m.runtimeHandlers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeStatus>(
            "NodeStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeStatus {
    const NAME: &'static str = "NodeStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.capacity.insert(key, value);
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.allocatable.insert(key, value);
                },
                26 => {
                    self.phase = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.conditions.push(is.read_message()?);
                },
                42 => {
                    self.addresses.push(is.read_message()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.daemonEndpoints)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.nodeInfo)?;
                },
                66 => {
                    self.images.push(is.read_message()?);
                },
                74 => {
                    self.volumesInUse.push(is.read_string()?);
                },
                82 => {
                    self.volumesAttached.push(is.read_message()?);
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.config)?;
                },
                98 => {
                    self.runtimeHandlers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.capacity {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.allocatable {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.phase.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.daemonEndpoints.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.nodeInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.images {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.volumesInUse {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.volumesAttached {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.runtimeHandlers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.capacity {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.allocatable {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.phase.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.addresses {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.daemonEndpoints.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.nodeInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.images {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        for v in &self.volumesInUse {
            os.write_string(9, &v)?;
        };
        for v in &self.volumesAttached {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        if let Some(v) = self.config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        for v in &self.runtimeHandlers {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeStatus {
        NodeStatus::new()
    }

    fn clear(&mut self) {
        self.capacity.clear();
        self.allocatable.clear();
        self.phase = ::std::option::Option::None;
        self.conditions.clear();
        self.addresses.clear();
        self.daemonEndpoints.clear();
        self.nodeInfo.clear();
        self.images.clear();
        self.volumesInUse.clear();
        self.volumesAttached.clear();
        self.config.clear();
        self.runtimeHandlers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeStatus {
        static instance: ::protobuf::rt::Lazy<NodeStatus> = ::protobuf::rt::Lazy::new();
        instance.get(NodeStatus::new)
    }
}

impl ::protobuf::MessageFull for NodeStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.NodeSystemInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NodeSystemInfo {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.NodeSystemInfo.machineID)
    pub machineID: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.NodeSystemInfo.systemUUID)
    pub systemUUID: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.NodeSystemInfo.bootID)
    pub bootID: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.NodeSystemInfo.kernelVersion)
    pub kernelVersion: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.NodeSystemInfo.osImage)
    pub osImage: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.NodeSystemInfo.containerRuntimeVersion)
    pub containerRuntimeVersion: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.NodeSystemInfo.kubeletVersion)
    pub kubeletVersion: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.NodeSystemInfo.kubeProxyVersion)
    pub kubeProxyVersion: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.NodeSystemInfo.operatingSystem)
    pub operatingSystem: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.NodeSystemInfo.architecture)
    pub architecture: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.NodeSystemInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeSystemInfo {
    fn default() -> &'a NodeSystemInfo {
        <NodeSystemInfo as ::protobuf::Message>::default_instance()
    }
}

impl NodeSystemInfo {
    pub fn new() -> NodeSystemInfo {
        ::std::default::Default::default()
    }

    // optional string machineID = 1;

    pub fn machineID(&self) -> &str {
        match self.machineID.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_machineID(&mut self) {
        self.machineID = ::std::option::Option::None;
    }

    pub fn has_machineID(&self) -> bool {
        self.machineID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machineID(&mut self, v: ::std::string::String) {
        self.machineID = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machineID(&mut self) -> &mut ::std::string::String {
        if self.machineID.is_none() {
            self.machineID = ::std::option::Option::Some(::std::string::String::new());
        }
        self.machineID.as_mut().unwrap()
    }

    // Take field
    pub fn take_machineID(&mut self) -> ::std::string::String {
        self.machineID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string systemUUID = 2;

    pub fn systemUUID(&self) -> &str {
        match self.systemUUID.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_systemUUID(&mut self) {
        self.systemUUID = ::std::option::Option::None;
    }

    pub fn has_systemUUID(&self) -> bool {
        self.systemUUID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_systemUUID(&mut self, v: ::std::string::String) {
        self.systemUUID = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_systemUUID(&mut self) -> &mut ::std::string::String {
        if self.systemUUID.is_none() {
            self.systemUUID = ::std::option::Option::Some(::std::string::String::new());
        }
        self.systemUUID.as_mut().unwrap()
    }

    // Take field
    pub fn take_systemUUID(&mut self) -> ::std::string::String {
        self.systemUUID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string bootID = 3;

    pub fn bootID(&self) -> &str {
        match self.bootID.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_bootID(&mut self) {
        self.bootID = ::std::option::Option::None;
    }

    pub fn has_bootID(&self) -> bool {
        self.bootID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bootID(&mut self, v: ::std::string::String) {
        self.bootID = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bootID(&mut self) -> &mut ::std::string::String {
        if self.bootID.is_none() {
            self.bootID = ::std::option::Option::Some(::std::string::String::new());
        }
        self.bootID.as_mut().unwrap()
    }

    // Take field
    pub fn take_bootID(&mut self) -> ::std::string::String {
        self.bootID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kernelVersion = 4;

    pub fn kernelVersion(&self) -> &str {
        match self.kernelVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kernelVersion(&mut self) {
        self.kernelVersion = ::std::option::Option::None;
    }

    pub fn has_kernelVersion(&self) -> bool {
        self.kernelVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kernelVersion(&mut self, v: ::std::string::String) {
        self.kernelVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kernelVersion(&mut self) -> &mut ::std::string::String {
        if self.kernelVersion.is_none() {
            self.kernelVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kernelVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_kernelVersion(&mut self) -> ::std::string::String {
        self.kernelVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string osImage = 5;

    pub fn osImage(&self) -> &str {
        match self.osImage.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_osImage(&mut self) {
        self.osImage = ::std::option::Option::None;
    }

    pub fn has_osImage(&self) -> bool {
        self.osImage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osImage(&mut self, v: ::std::string::String) {
        self.osImage = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_osImage(&mut self) -> &mut ::std::string::String {
        if self.osImage.is_none() {
            self.osImage = ::std::option::Option::Some(::std::string::String::new());
        }
        self.osImage.as_mut().unwrap()
    }

    // Take field
    pub fn take_osImage(&mut self) -> ::std::string::String {
        self.osImage.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string containerRuntimeVersion = 6;

    pub fn containerRuntimeVersion(&self) -> &str {
        match self.containerRuntimeVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_containerRuntimeVersion(&mut self) {
        self.containerRuntimeVersion = ::std::option::Option::None;
    }

    pub fn has_containerRuntimeVersion(&self) -> bool {
        self.containerRuntimeVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_containerRuntimeVersion(&mut self, v: ::std::string::String) {
        self.containerRuntimeVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_containerRuntimeVersion(&mut self) -> &mut ::std::string::String {
        if self.containerRuntimeVersion.is_none() {
            self.containerRuntimeVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.containerRuntimeVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_containerRuntimeVersion(&mut self) -> ::std::string::String {
        self.containerRuntimeVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kubeletVersion = 7;

    pub fn kubeletVersion(&self) -> &str {
        match self.kubeletVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kubeletVersion(&mut self) {
        self.kubeletVersion = ::std::option::Option::None;
    }

    pub fn has_kubeletVersion(&self) -> bool {
        self.kubeletVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kubeletVersion(&mut self, v: ::std::string::String) {
        self.kubeletVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kubeletVersion(&mut self) -> &mut ::std::string::String {
        if self.kubeletVersion.is_none() {
            self.kubeletVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kubeletVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_kubeletVersion(&mut self) -> ::std::string::String {
        self.kubeletVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kubeProxyVersion = 8;

    pub fn kubeProxyVersion(&self) -> &str {
        match self.kubeProxyVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kubeProxyVersion(&mut self) {
        self.kubeProxyVersion = ::std::option::Option::None;
    }

    pub fn has_kubeProxyVersion(&self) -> bool {
        self.kubeProxyVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kubeProxyVersion(&mut self, v: ::std::string::String) {
        self.kubeProxyVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kubeProxyVersion(&mut self) -> &mut ::std::string::String {
        if self.kubeProxyVersion.is_none() {
            self.kubeProxyVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kubeProxyVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_kubeProxyVersion(&mut self) -> ::std::string::String {
        self.kubeProxyVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string operatingSystem = 9;

    pub fn operatingSystem(&self) -> &str {
        match self.operatingSystem.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_operatingSystem(&mut self) {
        self.operatingSystem = ::std::option::Option::None;
    }

    pub fn has_operatingSystem(&self) -> bool {
        self.operatingSystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operatingSystem(&mut self, v: ::std::string::String) {
        self.operatingSystem = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operatingSystem(&mut self) -> &mut ::std::string::String {
        if self.operatingSystem.is_none() {
            self.operatingSystem = ::std::option::Option::Some(::std::string::String::new());
        }
        self.operatingSystem.as_mut().unwrap()
    }

    // Take field
    pub fn take_operatingSystem(&mut self) -> ::std::string::String {
        self.operatingSystem.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string architecture = 10;

    pub fn architecture(&self) -> &str {
        match self.architecture.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_architecture(&mut self) {
        self.architecture = ::std::option::Option::None;
    }

    pub fn has_architecture(&self) -> bool {
        self.architecture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_architecture(&mut self, v: ::std::string::String) {
        self.architecture = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_architecture(&mut self) -> &mut ::std::string::String {
        if self.architecture.is_none() {
            self.architecture = ::std::option::Option::Some(::std::string::String::new());
        }
        self.architecture.as_mut().unwrap()
    }

    // Take field
    pub fn take_architecture(&mut self) -> ::std::string::String {
        self.architecture.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "machineID",
            |m: &NodeSystemInfo| { &m.machineID },
            |m: &mut NodeSystemInfo| { &mut m.machineID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "systemUUID",
            |m: &NodeSystemInfo| { &m.systemUUID },
            |m: &mut NodeSystemInfo| { &mut m.systemUUID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bootID",
            |m: &NodeSystemInfo| { &m.bootID },
            |m: &mut NodeSystemInfo| { &mut m.bootID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kernelVersion",
            |m: &NodeSystemInfo| { &m.kernelVersion },
            |m: &mut NodeSystemInfo| { &mut m.kernelVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "osImage",
            |m: &NodeSystemInfo| { &m.osImage },
            |m: &mut NodeSystemInfo| { &mut m.osImage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "containerRuntimeVersion",
            |m: &NodeSystemInfo| { &m.containerRuntimeVersion },
            |m: &mut NodeSystemInfo| { &mut m.containerRuntimeVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kubeletVersion",
            |m: &NodeSystemInfo| { &m.kubeletVersion },
            |m: &mut NodeSystemInfo| { &mut m.kubeletVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kubeProxyVersion",
            |m: &NodeSystemInfo| { &m.kubeProxyVersion },
            |m: &mut NodeSystemInfo| { &mut m.kubeProxyVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "operatingSystem",
            |m: &NodeSystemInfo| { &m.operatingSystem },
            |m: &mut NodeSystemInfo| { &mut m.operatingSystem },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "architecture",
            |m: &NodeSystemInfo| { &m.architecture },
            |m: &mut NodeSystemInfo| { &mut m.architecture },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeSystemInfo>(
            "NodeSystemInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeSystemInfo {
    const NAME: &'static str = "NodeSystemInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.machineID = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.systemUUID = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.bootID = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.kernelVersion = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.osImage = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.containerRuntimeVersion = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.kubeletVersion = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.kubeProxyVersion = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.operatingSystem = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.architecture = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.machineID.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.systemUUID.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.bootID.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.kernelVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.osImage.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.containerRuntimeVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.kubeletVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.kubeProxyVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.operatingSystem.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.architecture.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.machineID.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.systemUUID.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.bootID.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.kernelVersion.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.osImage.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.containerRuntimeVersion.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.kubeletVersion.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.kubeProxyVersion.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.operatingSystem.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.architecture.as_ref() {
            os.write_string(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeSystemInfo {
        NodeSystemInfo::new()
    }

    fn clear(&mut self) {
        self.machineID = ::std::option::Option::None;
        self.systemUUID = ::std::option::Option::None;
        self.bootID = ::std::option::Option::None;
        self.kernelVersion = ::std::option::Option::None;
        self.osImage = ::std::option::Option::None;
        self.containerRuntimeVersion = ::std::option::Option::None;
        self.kubeletVersion = ::std::option::Option::None;
        self.kubeProxyVersion = ::std::option::Option::None;
        self.operatingSystem = ::std::option::Option::None;
        self.architecture = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeSystemInfo {
        static instance: NodeSystemInfo = NodeSystemInfo {
            machineID: ::std::option::Option::None,
            systemUUID: ::std::option::Option::None,
            bootID: ::std::option::Option::None,
            kernelVersion: ::std::option::Option::None,
            osImage: ::std::option::Option::None,
            containerRuntimeVersion: ::std::option::Option::None,
            kubeletVersion: ::std::option::Option::None,
            kubeProxyVersion: ::std::option::Option::None,
            operatingSystem: ::std::option::Option::None,
            architecture: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeSystemInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeSystemInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeSystemInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeSystemInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ObjectFieldSelector)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ObjectFieldSelector {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ObjectFieldSelector.apiVersion)
    pub apiVersion: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ObjectFieldSelector.fieldPath)
    pub fieldPath: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ObjectFieldSelector.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ObjectFieldSelector {
    fn default() -> &'a ObjectFieldSelector {
        <ObjectFieldSelector as ::protobuf::Message>::default_instance()
    }
}

impl ObjectFieldSelector {
    pub fn new() -> ObjectFieldSelector {
        ::std::default::Default::default()
    }

    // optional string apiVersion = 1;

    pub fn apiVersion(&self) -> &str {
        match self.apiVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_apiVersion(&mut self) {
        self.apiVersion = ::std::option::Option::None;
    }

    pub fn has_apiVersion(&self) -> bool {
        self.apiVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiVersion(&mut self, v: ::std::string::String) {
        self.apiVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiVersion(&mut self) -> &mut ::std::string::String {
        if self.apiVersion.is_none() {
            self.apiVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.apiVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiVersion(&mut self) -> ::std::string::String {
        self.apiVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fieldPath = 2;

    pub fn fieldPath(&self) -> &str {
        match self.fieldPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fieldPath(&mut self) {
        self.fieldPath = ::std::option::Option::None;
    }

    pub fn has_fieldPath(&self) -> bool {
        self.fieldPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldPath(&mut self, v: ::std::string::String) {
        self.fieldPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldPath(&mut self) -> &mut ::std::string::String {
        if self.fieldPath.is_none() {
            self.fieldPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fieldPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldPath(&mut self) -> ::std::string::String {
        self.fieldPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "apiVersion",
            |m: &ObjectFieldSelector| { &m.apiVersion },
            |m: &mut ObjectFieldSelector| { &mut m.apiVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fieldPath",
            |m: &ObjectFieldSelector| { &m.fieldPath },
            |m: &mut ObjectFieldSelector| { &mut m.fieldPath },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ObjectFieldSelector>(
            "ObjectFieldSelector",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ObjectFieldSelector {
    const NAME: &'static str = "ObjectFieldSelector";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.apiVersion = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.fieldPath = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.apiVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fieldPath.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.apiVersion.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.fieldPath.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ObjectFieldSelector {
        ObjectFieldSelector::new()
    }

    fn clear(&mut self) {
        self.apiVersion = ::std::option::Option::None;
        self.fieldPath = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ObjectFieldSelector {
        static instance: ObjectFieldSelector = ObjectFieldSelector {
            apiVersion: ::std::option::Option::None,
            fieldPath: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ObjectFieldSelector {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ObjectFieldSelector").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ObjectFieldSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObjectFieldSelector {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ObjectReference)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ObjectReference {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ObjectReference.kind)
    pub kind: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ObjectReference.namespace)
    pub namespace: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ObjectReference.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ObjectReference.uid)
    pub uid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ObjectReference.apiVersion)
    pub apiVersion: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ObjectReference.resourceVersion)
    pub resourceVersion: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ObjectReference.fieldPath)
    pub fieldPath: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ObjectReference.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ObjectReference {
    fn default() -> &'a ObjectReference {
        <ObjectReference as ::protobuf::Message>::default_instance()
    }
}

impl ObjectReference {
    pub fn new() -> ObjectReference {
        ::std::default::Default::default()
    }

    // optional string kind = 1;

    pub fn kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string namespace = 2;

    pub fn namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_namespace(&mut self) {
        self.namespace = ::std::option::Option::None;
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string uid = 4;

    pub fn uid(&self) -> &str {
        match self.uid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_uid(&mut self) {
        self.uid = ::std::option::Option::None;
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if self.uid.is_none() {
            self.uid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        self.uid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string apiVersion = 5;

    pub fn apiVersion(&self) -> &str {
        match self.apiVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_apiVersion(&mut self) {
        self.apiVersion = ::std::option::Option::None;
    }

    pub fn has_apiVersion(&self) -> bool {
        self.apiVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiVersion(&mut self, v: ::std::string::String) {
        self.apiVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiVersion(&mut self) -> &mut ::std::string::String {
        if self.apiVersion.is_none() {
            self.apiVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.apiVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiVersion(&mut self) -> ::std::string::String {
        self.apiVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resourceVersion = 6;

    pub fn resourceVersion(&self) -> &str {
        match self.resourceVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resourceVersion(&mut self) {
        self.resourceVersion = ::std::option::Option::None;
    }

    pub fn has_resourceVersion(&self) -> bool {
        self.resourceVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceVersion(&mut self, v: ::std::string::String) {
        self.resourceVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceVersion(&mut self) -> &mut ::std::string::String {
        if self.resourceVersion.is_none() {
            self.resourceVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resourceVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceVersion(&mut self) -> ::std::string::String {
        self.resourceVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fieldPath = 7;

    pub fn fieldPath(&self) -> &str {
        match self.fieldPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fieldPath(&mut self) {
        self.fieldPath = ::std::option::Option::None;
    }

    pub fn has_fieldPath(&self) -> bool {
        self.fieldPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldPath(&mut self, v: ::std::string::String) {
        self.fieldPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldPath(&mut self) -> &mut ::std::string::String {
        if self.fieldPath.is_none() {
            self.fieldPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fieldPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldPath(&mut self) -> ::std::string::String {
        self.fieldPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &ObjectReference| { &m.kind },
            |m: &mut ObjectReference| { &mut m.kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "namespace",
            |m: &ObjectReference| { &m.namespace },
            |m: &mut ObjectReference| { &mut m.namespace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ObjectReference| { &m.name },
            |m: &mut ObjectReference| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uid",
            |m: &ObjectReference| { &m.uid },
            |m: &mut ObjectReference| { &mut m.uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "apiVersion",
            |m: &ObjectReference| { &m.apiVersion },
            |m: &mut ObjectReference| { &mut m.apiVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resourceVersion",
            |m: &ObjectReference| { &m.resourceVersion },
            |m: &mut ObjectReference| { &mut m.resourceVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fieldPath",
            |m: &ObjectReference| { &m.fieldPath },
            |m: &mut ObjectReference| { &mut m.fieldPath },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ObjectReference>(
            "ObjectReference",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ObjectReference {
    const NAME: &'static str = "ObjectReference";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.kind = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.namespace = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.uid = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.apiVersion = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.resourceVersion = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.fieldPath = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.uid.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.apiVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.resourceVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.fieldPath.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.kind.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.namespace.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.uid.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.apiVersion.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.resourceVersion.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.fieldPath.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ObjectReference {
        ObjectReference::new()
    }

    fn clear(&mut self) {
        self.kind = ::std::option::Option::None;
        self.namespace = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.uid = ::std::option::Option::None;
        self.apiVersion = ::std::option::Option::None;
        self.resourceVersion = ::std::option::Option::None;
        self.fieldPath = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ObjectReference {
        static instance: ObjectReference = ObjectReference {
            kind: ::std::option::Option::None,
            namespace: ::std::option::Option::None,
            name: ::std::option::Option::None,
            uid: ::std::option::Option::None,
            apiVersion: ::std::option::Option::None,
            resourceVersion: ::std::option::Option::None,
            fieldPath: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ObjectReference {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ObjectReference").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ObjectReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObjectReference {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PersistentVolume)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PersistentVolume {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolume.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolume.spec)
    pub spec: ::protobuf::MessageField<PersistentVolumeSpec>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolume.status)
    pub status: ::protobuf::MessageField<PersistentVolumeStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PersistentVolume.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PersistentVolume {
    fn default() -> &'a PersistentVolume {
        <PersistentVolume as ::protobuf::Message>::default_instance()
    }
}

impl PersistentVolume {
    pub fn new() -> PersistentVolume {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.core.v1.PersistentVolumeSpec spec = 2;

    pub fn spec(&self) -> &PersistentVolumeSpec {
        self.spec.as_ref().unwrap_or_else(|| <PersistentVolumeSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: PersistentVolumeSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut PersistentVolumeSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> PersistentVolumeSpec {
        self.spec.take().unwrap_or_else(|| PersistentVolumeSpec::new())
    }

    // optional .api.core.v1.PersistentVolumeStatus status = 3;

    pub fn status(&self) -> &PersistentVolumeStatus {
        self.status.as_ref().unwrap_or_else(|| <PersistentVolumeStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: PersistentVolumeStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut PersistentVolumeStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> PersistentVolumeStatus {
        self.status.take().unwrap_or_else(|| PersistentVolumeStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &PersistentVolume| { &m.metadata },
            |m: &mut PersistentVolume| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PersistentVolumeSpec>(
            "spec",
            |m: &PersistentVolume| { &m.spec },
            |m: &mut PersistentVolume| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PersistentVolumeStatus>(
            "status",
            |m: &PersistentVolume| { &m.status },
            |m: &mut PersistentVolume| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PersistentVolume>(
            "PersistentVolume",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PersistentVolume {
    const NAME: &'static str = "PersistentVolume";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PersistentVolume {
        PersistentVolume::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PersistentVolume {
        static instance: PersistentVolume = PersistentVolume {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PersistentVolume {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PersistentVolume").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PersistentVolume {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolume {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PersistentVolumeClaim)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PersistentVolumeClaim {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaim.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaim.spec)
    pub spec: ::protobuf::MessageField<PersistentVolumeClaimSpec>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaim.status)
    pub status: ::protobuf::MessageField<PersistentVolumeClaimStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PersistentVolumeClaim.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PersistentVolumeClaim {
    fn default() -> &'a PersistentVolumeClaim {
        <PersistentVolumeClaim as ::protobuf::Message>::default_instance()
    }
}

impl PersistentVolumeClaim {
    pub fn new() -> PersistentVolumeClaim {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.core.v1.PersistentVolumeClaimSpec spec = 2;

    pub fn spec(&self) -> &PersistentVolumeClaimSpec {
        self.spec.as_ref().unwrap_or_else(|| <PersistentVolumeClaimSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: PersistentVolumeClaimSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut PersistentVolumeClaimSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> PersistentVolumeClaimSpec {
        self.spec.take().unwrap_or_else(|| PersistentVolumeClaimSpec::new())
    }

    // optional .api.core.v1.PersistentVolumeClaimStatus status = 3;

    pub fn status(&self) -> &PersistentVolumeClaimStatus {
        self.status.as_ref().unwrap_or_else(|| <PersistentVolumeClaimStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: PersistentVolumeClaimStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut PersistentVolumeClaimStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> PersistentVolumeClaimStatus {
        self.status.take().unwrap_or_else(|| PersistentVolumeClaimStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &PersistentVolumeClaim| { &m.metadata },
            |m: &mut PersistentVolumeClaim| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PersistentVolumeClaimSpec>(
            "spec",
            |m: &PersistentVolumeClaim| { &m.spec },
            |m: &mut PersistentVolumeClaim| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PersistentVolumeClaimStatus>(
            "status",
            |m: &PersistentVolumeClaim| { &m.status },
            |m: &mut PersistentVolumeClaim| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PersistentVolumeClaim>(
            "PersistentVolumeClaim",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PersistentVolumeClaim {
    const NAME: &'static str = "PersistentVolumeClaim";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PersistentVolumeClaim {
        PersistentVolumeClaim::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PersistentVolumeClaim {
        static instance: PersistentVolumeClaim = PersistentVolumeClaim {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PersistentVolumeClaim {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PersistentVolumeClaim").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PersistentVolumeClaim {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeClaim {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PersistentVolumeClaimCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PersistentVolumeClaimCondition {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimCondition.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimCondition.status)
    pub status: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimCondition.lastProbeTime)
    pub lastProbeTime: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimCondition.lastTransitionTime)
    pub lastTransitionTime: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimCondition.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimCondition.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PersistentVolumeClaimCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PersistentVolumeClaimCondition {
    fn default() -> &'a PersistentVolumeClaimCondition {
        <PersistentVolumeClaimCondition as ::protobuf::Message>::default_instance()
    }
}

impl PersistentVolumeClaimCondition {
    pub fn new() -> PersistentVolumeClaimCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;

    pub fn lastProbeTime(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastProbeTime.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastProbeTime(&mut self) {
        self.lastProbeTime.clear();
    }

    pub fn has_lastProbeTime(&self) -> bool {
        self.lastProbeTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastProbeTime(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastProbeTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastProbeTime(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastProbeTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastProbeTime(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastProbeTime.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;

    pub fn lastTransitionTime(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastTransitionTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional string reason = 5;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 6;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &PersistentVolumeClaimCondition| { &m.type_ },
            |m: &mut PersistentVolumeClaimCondition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &PersistentVolumeClaimCondition| { &m.status },
            |m: &mut PersistentVolumeClaimCondition| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>(
            "lastProbeTime",
            |m: &PersistentVolumeClaimCondition| { &m.lastProbeTime },
            |m: &mut PersistentVolumeClaimCondition| { &mut m.lastProbeTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>(
            "lastTransitionTime",
            |m: &PersistentVolumeClaimCondition| { &m.lastTransitionTime },
            |m: &mut PersistentVolumeClaimCondition| { &mut m.lastTransitionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &PersistentVolumeClaimCondition| { &m.reason },
            |m: &mut PersistentVolumeClaimCondition| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &PersistentVolumeClaimCondition| { &m.message },
            |m: &mut PersistentVolumeClaimCondition| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PersistentVolumeClaimCondition>(
            "PersistentVolumeClaimCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PersistentVolumeClaimCondition {
    const NAME: &'static str = "PersistentVolumeClaimCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastProbeTime)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTransitionTime)?;
                },
                42 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastProbeTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lastProbeTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PersistentVolumeClaimCondition {
        PersistentVolumeClaimCondition::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.lastProbeTime.clear();
        self.lastTransitionTime.clear();
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PersistentVolumeClaimCondition {
        static instance: PersistentVolumeClaimCondition = PersistentVolumeClaimCondition {
            type_: ::std::option::Option::None,
            status: ::std::option::Option::None,
            lastProbeTime: ::protobuf::MessageField::none(),
            lastTransitionTime: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PersistentVolumeClaimCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PersistentVolumeClaimCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PersistentVolumeClaimCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeClaimCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PersistentVolumeClaimList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PersistentVolumeClaimList {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimList.items)
    pub items: ::std::vec::Vec<PersistentVolumeClaim>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PersistentVolumeClaimList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PersistentVolumeClaimList {
    fn default() -> &'a PersistentVolumeClaimList {
        <PersistentVolumeClaimList as ::protobuf::Message>::default_instance()
    }
}

impl PersistentVolumeClaimList {
    pub fn new() -> PersistentVolumeClaimList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.core.v1.PersistentVolumeClaim items = 2;

    pub fn items(&self) -> &[PersistentVolumeClaim] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<PersistentVolumeClaim>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<PersistentVolumeClaim> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<PersistentVolumeClaim> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &PersistentVolumeClaimList| { &m.metadata },
            |m: &mut PersistentVolumeClaimList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &PersistentVolumeClaimList| { &m.items },
            |m: &mut PersistentVolumeClaimList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PersistentVolumeClaimList>(
            "PersistentVolumeClaimList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PersistentVolumeClaimList {
    const NAME: &'static str = "PersistentVolumeClaimList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PersistentVolumeClaimList {
        PersistentVolumeClaimList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PersistentVolumeClaimList {
        static instance: PersistentVolumeClaimList = PersistentVolumeClaimList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PersistentVolumeClaimList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PersistentVolumeClaimList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PersistentVolumeClaimList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeClaimList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PersistentVolumeClaimSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PersistentVolumeClaimSpec {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimSpec.accessModes)
    pub accessModes: ::std::vec::Vec<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimSpec.selector)
    pub selector: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimSpec.resources)
    pub resources: ::protobuf::MessageField<VolumeResourceRequirements>,
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimSpec.volumeName)
    pub volumeName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimSpec.storageClassName)
    pub storageClassName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimSpec.volumeMode)
    pub volumeMode: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimSpec.dataSource)
    pub dataSource: ::protobuf::MessageField<TypedLocalObjectReference>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimSpec.dataSourceRef)
    pub dataSourceRef: ::protobuf::MessageField<TypedObjectReference>,
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimSpec.volumeAttributesClassName)
    pub volumeAttributesClassName: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PersistentVolumeClaimSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PersistentVolumeClaimSpec {
    fn default() -> &'a PersistentVolumeClaimSpec {
        <PersistentVolumeClaimSpec as ::protobuf::Message>::default_instance()
    }
}

impl PersistentVolumeClaimSpec {
    pub fn new() -> PersistentVolumeClaimSpec {
        ::std::default::Default::default()
    }

    // repeated string accessModes = 1;

    pub fn accessModes(&self) -> &[::std::string::String] {
        &self.accessModes
    }

    pub fn clear_accessModes(&mut self) {
        self.accessModes.clear();
    }

    // Param is passed by value, moved
    pub fn set_accessModes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.accessModes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accessModes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.accessModes
    }

    // Take field
    pub fn take_accessModes(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.accessModes, ::std::vec::Vec::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;

    pub fn selector(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    pub fn has_selector(&self) -> bool {
        self.selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.selector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selector(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.mut_or_insert_default()
    }

    // Take field
    pub fn take_selector(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional .api.core.v1.VolumeResourceRequirements resources = 2;

    pub fn resources(&self) -> &VolumeResourceRequirements {
        self.resources.as_ref().unwrap_or_else(|| <VolumeResourceRequirements as ::protobuf::Message>::default_instance())
    }

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    pub fn has_resources(&self) -> bool {
        self.resources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: VolumeResourceRequirements) {
        self.resources = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resources(&mut self) -> &mut VolumeResourceRequirements {
        self.resources.mut_or_insert_default()
    }

    // Take field
    pub fn take_resources(&mut self) -> VolumeResourceRequirements {
        self.resources.take().unwrap_or_else(|| VolumeResourceRequirements::new())
    }

    // optional string volumeName = 3;

    pub fn volumeName(&self) -> &str {
        match self.volumeName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_volumeName(&mut self) {
        self.volumeName = ::std::option::Option::None;
    }

    pub fn has_volumeName(&self) -> bool {
        self.volumeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeName(&mut self, v: ::std::string::String) {
        self.volumeName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeName(&mut self) -> &mut ::std::string::String {
        if self.volumeName.is_none() {
            self.volumeName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.volumeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeName(&mut self) -> ::std::string::String {
        self.volumeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string storageClassName = 5;

    pub fn storageClassName(&self) -> &str {
        match self.storageClassName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_storageClassName(&mut self) {
        self.storageClassName = ::std::option::Option::None;
    }

    pub fn has_storageClassName(&self) -> bool {
        self.storageClassName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageClassName(&mut self, v: ::std::string::String) {
        self.storageClassName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageClassName(&mut self) -> &mut ::std::string::String {
        if self.storageClassName.is_none() {
            self.storageClassName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.storageClassName.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageClassName(&mut self) -> ::std::string::String {
        self.storageClassName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string volumeMode = 6;

    pub fn volumeMode(&self) -> &str {
        match self.volumeMode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_volumeMode(&mut self) {
        self.volumeMode = ::std::option::Option::None;
    }

    pub fn has_volumeMode(&self) -> bool {
        self.volumeMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeMode(&mut self, v: ::std::string::String) {
        self.volumeMode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeMode(&mut self) -> &mut ::std::string::String {
        if self.volumeMode.is_none() {
            self.volumeMode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.volumeMode.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeMode(&mut self) -> ::std::string::String {
        self.volumeMode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.TypedLocalObjectReference dataSource = 7;

    pub fn dataSource(&self) -> &TypedLocalObjectReference {
        self.dataSource.as_ref().unwrap_or_else(|| <TypedLocalObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_dataSource(&mut self) {
        self.dataSource.clear();
    }

    pub fn has_dataSource(&self) -> bool {
        self.dataSource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dataSource(&mut self, v: TypedLocalObjectReference) {
        self.dataSource = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataSource(&mut self) -> &mut TypedLocalObjectReference {
        self.dataSource.mut_or_insert_default()
    }

    // Take field
    pub fn take_dataSource(&mut self) -> TypedLocalObjectReference {
        self.dataSource.take().unwrap_or_else(|| TypedLocalObjectReference::new())
    }

    // optional .api.core.v1.TypedObjectReference dataSourceRef = 8;

    pub fn dataSourceRef(&self) -> &TypedObjectReference {
        self.dataSourceRef.as_ref().unwrap_or_else(|| <TypedObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_dataSourceRef(&mut self) {
        self.dataSourceRef.clear();
    }

    pub fn has_dataSourceRef(&self) -> bool {
        self.dataSourceRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dataSourceRef(&mut self, v: TypedObjectReference) {
        self.dataSourceRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataSourceRef(&mut self) -> &mut TypedObjectReference {
        self.dataSourceRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_dataSourceRef(&mut self) -> TypedObjectReference {
        self.dataSourceRef.take().unwrap_or_else(|| TypedObjectReference::new())
    }

    // optional string volumeAttributesClassName = 9;

    pub fn volumeAttributesClassName(&self) -> &str {
        match self.volumeAttributesClassName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_volumeAttributesClassName(&mut self) {
        self.volumeAttributesClassName = ::std::option::Option::None;
    }

    pub fn has_volumeAttributesClassName(&self) -> bool {
        self.volumeAttributesClassName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeAttributesClassName(&mut self, v: ::std::string::String) {
        self.volumeAttributesClassName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeAttributesClassName(&mut self) -> &mut ::std::string::String {
        if self.volumeAttributesClassName.is_none() {
            self.volumeAttributesClassName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.volumeAttributesClassName.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeAttributesClassName(&mut self) -> ::std::string::String {
        self.volumeAttributesClassName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accessModes",
            |m: &PersistentVolumeClaimSpec| { &m.accessModes },
            |m: &mut PersistentVolumeClaimSpec| { &mut m.accessModes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "selector",
            |m: &PersistentVolumeClaimSpec| { &m.selector },
            |m: &mut PersistentVolumeClaimSpec| { &mut m.selector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VolumeResourceRequirements>(
            "resources",
            |m: &PersistentVolumeClaimSpec| { &m.resources },
            |m: &mut PersistentVolumeClaimSpec| { &mut m.resources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volumeName",
            |m: &PersistentVolumeClaimSpec| { &m.volumeName },
            |m: &mut PersistentVolumeClaimSpec| { &mut m.volumeName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "storageClassName",
            |m: &PersistentVolumeClaimSpec| { &m.storageClassName },
            |m: &mut PersistentVolumeClaimSpec| { &mut m.storageClassName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volumeMode",
            |m: &PersistentVolumeClaimSpec| { &m.volumeMode },
            |m: &mut PersistentVolumeClaimSpec| { &mut m.volumeMode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TypedLocalObjectReference>(
            "dataSource",
            |m: &PersistentVolumeClaimSpec| { &m.dataSource },
            |m: &mut PersistentVolumeClaimSpec| { &mut m.dataSource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TypedObjectReference>(
            "dataSourceRef",
            |m: &PersistentVolumeClaimSpec| { &m.dataSourceRef },
            |m: &mut PersistentVolumeClaimSpec| { &mut m.dataSourceRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volumeAttributesClassName",
            |m: &PersistentVolumeClaimSpec| { &m.volumeAttributesClassName },
            |m: &mut PersistentVolumeClaimSpec| { &mut m.volumeAttributesClassName },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PersistentVolumeClaimSpec>(
            "PersistentVolumeClaimSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PersistentVolumeClaimSpec {
    const NAME: &'static str = "PersistentVolumeClaimSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.accessModes.push(is.read_string()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.selector)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resources)?;
                },
                26 => {
                    self.volumeName = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.storageClassName = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.volumeMode = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dataSource)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dataSourceRef)?;
                },
                74 => {
                    self.volumeAttributesClassName = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.accessModes {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.resources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.volumeName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.storageClassName.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.volumeMode.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.dataSource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dataSourceRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.volumeAttributesClassName.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.accessModes {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.selector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.resources.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.volumeName.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.storageClassName.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.volumeMode.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.dataSource.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.dataSourceRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.volumeAttributesClassName.as_ref() {
            os.write_string(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PersistentVolumeClaimSpec {
        PersistentVolumeClaimSpec::new()
    }

    fn clear(&mut self) {
        self.accessModes.clear();
        self.selector.clear();
        self.resources.clear();
        self.volumeName = ::std::option::Option::None;
        self.storageClassName = ::std::option::Option::None;
        self.volumeMode = ::std::option::Option::None;
        self.dataSource.clear();
        self.dataSourceRef.clear();
        self.volumeAttributesClassName = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PersistentVolumeClaimSpec {
        static instance: PersistentVolumeClaimSpec = PersistentVolumeClaimSpec {
            accessModes: ::std::vec::Vec::new(),
            selector: ::protobuf::MessageField::none(),
            resources: ::protobuf::MessageField::none(),
            volumeName: ::std::option::Option::None,
            storageClassName: ::std::option::Option::None,
            volumeMode: ::std::option::Option::None,
            dataSource: ::protobuf::MessageField::none(),
            dataSourceRef: ::protobuf::MessageField::none(),
            volumeAttributesClassName: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PersistentVolumeClaimSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PersistentVolumeClaimSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PersistentVolumeClaimSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeClaimSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PersistentVolumeClaimStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PersistentVolumeClaimStatus {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimStatus.phase)
    pub phase: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimStatus.accessModes)
    pub accessModes: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimStatus.capacity)
    pub capacity: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimStatus.conditions)
    pub conditions: ::std::vec::Vec<PersistentVolumeClaimCondition>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimStatus.allocatedResources)
    pub allocatedResources: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimStatus.allocatedResourceStatuses)
    pub allocatedResourceStatuses: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimStatus.currentVolumeAttributesClassName)
    pub currentVolumeAttributesClassName: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimStatus.modifyVolumeStatus)
    pub modifyVolumeStatus: ::protobuf::MessageField<ModifyVolumeStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PersistentVolumeClaimStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PersistentVolumeClaimStatus {
    fn default() -> &'a PersistentVolumeClaimStatus {
        <PersistentVolumeClaimStatus as ::protobuf::Message>::default_instance()
    }
}

impl PersistentVolumeClaimStatus {
    pub fn new() -> PersistentVolumeClaimStatus {
        ::std::default::Default::default()
    }

    // optional string phase = 1;

    pub fn phase(&self) -> &str {
        match self.phase.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_phase(&mut self) {
        self.phase = ::std::option::Option::None;
    }

    pub fn has_phase(&self) -> bool {
        self.phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase(&mut self, v: ::std::string::String) {
        self.phase = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phase(&mut self) -> &mut ::std::string::String {
        if self.phase.is_none() {
            self.phase = ::std::option::Option::Some(::std::string::String::new());
        }
        self.phase.as_mut().unwrap()
    }

    // Take field
    pub fn take_phase(&mut self) -> ::std::string::String {
        self.phase.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string accessModes = 2;

    pub fn accessModes(&self) -> &[::std::string::String] {
        &self.accessModes
    }

    pub fn clear_accessModes(&mut self) {
        self.accessModes.clear();
    }

    // Param is passed by value, moved
    pub fn set_accessModes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.accessModes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accessModes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.accessModes
    }

    // Take field
    pub fn take_accessModes(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.accessModes, ::std::vec::Vec::new())
    }

    // repeated .api.core.v1.PersistentVolumeClaimStatus.CapacityEntry capacity = 3;

    pub fn capacity(&self) -> &::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &self.capacity
    }

    pub fn clear_capacity(&mut self) {
        self.capacity.clear();
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>) {
        self.capacity = v;
    }

    // Mutable pointer to the field.
    pub fn mut_capacity(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &mut self.capacity
    }

    // Take field
    pub fn take_capacity(&mut self) -> ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        ::std::mem::replace(&mut self.capacity, ::std::collections::BTreeMap::new())
    }

    // repeated .api.core.v1.PersistentVolumeClaimCondition conditions = 4;

    pub fn conditions(&self) -> &[PersistentVolumeClaimCondition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<PersistentVolumeClaimCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<PersistentVolumeClaimCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<PersistentVolumeClaimCondition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    // repeated .api.core.v1.PersistentVolumeClaimStatus.AllocatedResourcesEntry allocatedResources = 5;

    pub fn allocatedResources(&self) -> &::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &self.allocatedResources
    }

    pub fn clear_allocatedResources(&mut self) {
        self.allocatedResources.clear();
    }

    // Param is passed by value, moved
    pub fn set_allocatedResources(&mut self, v: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>) {
        self.allocatedResources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allocatedResources(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &mut self.allocatedResources
    }

    // Take field
    pub fn take_allocatedResources(&mut self) -> ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        ::std::mem::replace(&mut self.allocatedResources, ::std::collections::BTreeMap::new())
    }

    // repeated .api.core.v1.PersistentVolumeClaimStatus.AllocatedResourceStatusesEntry allocatedResourceStatuses = 7;

    pub fn allocatedResourceStatuses(&self) -> &::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &self.allocatedResourceStatuses
    }

    pub fn clear_allocatedResourceStatuses(&mut self) {
        self.allocatedResourceStatuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_allocatedResourceStatuses(&mut self, v: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
        self.allocatedResourceStatuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allocatedResourceStatuses(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &mut self.allocatedResourceStatuses
    }

    // Take field
    pub fn take_allocatedResourceStatuses(&mut self) -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.allocatedResourceStatuses, ::std::collections::BTreeMap::new())
    }

    // optional string currentVolumeAttributesClassName = 8;

    pub fn currentVolumeAttributesClassName(&self) -> &str {
        match self.currentVolumeAttributesClassName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_currentVolumeAttributesClassName(&mut self) {
        self.currentVolumeAttributesClassName = ::std::option::Option::None;
    }

    pub fn has_currentVolumeAttributesClassName(&self) -> bool {
        self.currentVolumeAttributesClassName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currentVolumeAttributesClassName(&mut self, v: ::std::string::String) {
        self.currentVolumeAttributesClassName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_currentVolumeAttributesClassName(&mut self) -> &mut ::std::string::String {
        if self.currentVolumeAttributesClassName.is_none() {
            self.currentVolumeAttributesClassName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.currentVolumeAttributesClassName.as_mut().unwrap()
    }

    // Take field
    pub fn take_currentVolumeAttributesClassName(&mut self) -> ::std::string::String {
        self.currentVolumeAttributesClassName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.ModifyVolumeStatus modifyVolumeStatus = 9;

    pub fn modifyVolumeStatus(&self) -> &ModifyVolumeStatus {
        self.modifyVolumeStatus.as_ref().unwrap_or_else(|| <ModifyVolumeStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_modifyVolumeStatus(&mut self) {
        self.modifyVolumeStatus.clear();
    }

    pub fn has_modifyVolumeStatus(&self) -> bool {
        self.modifyVolumeStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifyVolumeStatus(&mut self, v: ModifyVolumeStatus) {
        self.modifyVolumeStatus = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modifyVolumeStatus(&mut self) -> &mut ModifyVolumeStatus {
        self.modifyVolumeStatus.mut_or_insert_default()
    }

    // Take field
    pub fn take_modifyVolumeStatus(&mut self) -> ModifyVolumeStatus {
        self.modifyVolumeStatus.take().unwrap_or_else(|| ModifyVolumeStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "phase",
            |m: &PersistentVolumeClaimStatus| { &m.phase },
            |m: &mut PersistentVolumeClaimStatus| { &mut m.phase },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accessModes",
            |m: &PersistentVolumeClaimStatus| { &m.accessModes },
            |m: &mut PersistentVolumeClaimStatus| { &mut m.accessModes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "capacity",
            |m: &PersistentVolumeClaimStatus| { &m.capacity },
            |m: &mut PersistentVolumeClaimStatus| { &mut m.capacity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &PersistentVolumeClaimStatus| { &m.conditions },
            |m: &mut PersistentVolumeClaimStatus| { &mut m.conditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "allocatedResources",
            |m: &PersistentVolumeClaimStatus| { &m.allocatedResources },
            |m: &mut PersistentVolumeClaimStatus| { &mut m.allocatedResources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "allocatedResourceStatuses",
            |m: &PersistentVolumeClaimStatus| { &m.allocatedResourceStatuses },
            |m: &mut PersistentVolumeClaimStatus| { &mut m.allocatedResourceStatuses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currentVolumeAttributesClassName",
            |m: &PersistentVolumeClaimStatus| { &m.currentVolumeAttributesClassName },
            |m: &mut PersistentVolumeClaimStatus| { &mut m.currentVolumeAttributesClassName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ModifyVolumeStatus>(
            "modifyVolumeStatus",
            |m: &PersistentVolumeClaimStatus| { &m.modifyVolumeStatus },
            |m: &mut PersistentVolumeClaimStatus| { &mut m.modifyVolumeStatus },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PersistentVolumeClaimStatus>(
            "PersistentVolumeClaimStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PersistentVolumeClaimStatus {
    const NAME: &'static str = "PersistentVolumeClaimStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.phase = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.accessModes.push(is.read_string()?);
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.capacity.insert(key, value);
                },
                34 => {
                    self.conditions.push(is.read_message()?);
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.allocatedResources.insert(key, value);
                },
                58 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.allocatedResourceStatuses.insert(key, value);
                },
                66 => {
                    self.currentVolumeAttributesClassName = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modifyVolumeStatus)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.phase.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.accessModes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for (k, v) in &self.capacity {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for (k, v) in &self.allocatedResources {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.allocatedResourceStatuses {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.currentVolumeAttributesClassName.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.modifyVolumeStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.phase.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.accessModes {
            os.write_string(2, &v)?;
        };
        for (k, v) in &self.capacity {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for (k, v) in &self.allocatedResources {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.allocatedResourceStatuses {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(58)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.currentVolumeAttributesClassName.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.modifyVolumeStatus.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PersistentVolumeClaimStatus {
        PersistentVolumeClaimStatus::new()
    }

    fn clear(&mut self) {
        self.phase = ::std::option::Option::None;
        self.accessModes.clear();
        self.capacity.clear();
        self.conditions.clear();
        self.allocatedResources.clear();
        self.allocatedResourceStatuses.clear();
        self.currentVolumeAttributesClassName = ::std::option::Option::None;
        self.modifyVolumeStatus.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PersistentVolumeClaimStatus {
        static instance: ::protobuf::rt::Lazy<PersistentVolumeClaimStatus> = ::protobuf::rt::Lazy::new();
        instance.get(PersistentVolumeClaimStatus::new)
    }
}

impl ::protobuf::MessageFull for PersistentVolumeClaimStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PersistentVolumeClaimStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PersistentVolumeClaimStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeClaimStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PersistentVolumeClaimTemplate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PersistentVolumeClaimTemplate {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimTemplate.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimTemplate.spec)
    pub spec: ::protobuf::MessageField<PersistentVolumeClaimSpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PersistentVolumeClaimTemplate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PersistentVolumeClaimTemplate {
    fn default() -> &'a PersistentVolumeClaimTemplate {
        <PersistentVolumeClaimTemplate as ::protobuf::Message>::default_instance()
    }
}

impl PersistentVolumeClaimTemplate {
    pub fn new() -> PersistentVolumeClaimTemplate {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.core.v1.PersistentVolumeClaimSpec spec = 2;

    pub fn spec(&self) -> &PersistentVolumeClaimSpec {
        self.spec.as_ref().unwrap_or_else(|| <PersistentVolumeClaimSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: PersistentVolumeClaimSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut PersistentVolumeClaimSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> PersistentVolumeClaimSpec {
        self.spec.take().unwrap_or_else(|| PersistentVolumeClaimSpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &PersistentVolumeClaimTemplate| { &m.metadata },
            |m: &mut PersistentVolumeClaimTemplate| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PersistentVolumeClaimSpec>(
            "spec",
            |m: &PersistentVolumeClaimTemplate| { &m.spec },
            |m: &mut PersistentVolumeClaimTemplate| { &mut m.spec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PersistentVolumeClaimTemplate>(
            "PersistentVolumeClaimTemplate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PersistentVolumeClaimTemplate {
    const NAME: &'static str = "PersistentVolumeClaimTemplate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PersistentVolumeClaimTemplate {
        PersistentVolumeClaimTemplate::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PersistentVolumeClaimTemplate {
        static instance: PersistentVolumeClaimTemplate = PersistentVolumeClaimTemplate {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PersistentVolumeClaimTemplate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PersistentVolumeClaimTemplate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PersistentVolumeClaimTemplate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeClaimTemplate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PersistentVolumeClaimVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PersistentVolumeClaimVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimVolumeSource.claimName)
    pub claimName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeClaimVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PersistentVolumeClaimVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PersistentVolumeClaimVolumeSource {
    fn default() -> &'a PersistentVolumeClaimVolumeSource {
        <PersistentVolumeClaimVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl PersistentVolumeClaimVolumeSource {
    pub fn new() -> PersistentVolumeClaimVolumeSource {
        ::std::default::Default::default()
    }

    // optional string claimName = 1;

    pub fn claimName(&self) -> &str {
        match self.claimName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_claimName(&mut self) {
        self.claimName = ::std::option::Option::None;
    }

    pub fn has_claimName(&self) -> bool {
        self.claimName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claimName(&mut self, v: ::std::string::String) {
        self.claimName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_claimName(&mut self) -> &mut ::std::string::String {
        if self.claimName.is_none() {
            self.claimName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.claimName.as_mut().unwrap()
    }

    // Take field
    pub fn take_claimName(&mut self) -> ::std::string::String {
        self.claimName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 2;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "claimName",
            |m: &PersistentVolumeClaimVolumeSource| { &m.claimName },
            |m: &mut PersistentVolumeClaimVolumeSource| { &mut m.claimName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &PersistentVolumeClaimVolumeSource| { &m.readOnly },
            |m: &mut PersistentVolumeClaimVolumeSource| { &mut m.readOnly },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PersistentVolumeClaimVolumeSource>(
            "PersistentVolumeClaimVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PersistentVolumeClaimVolumeSource {
    const NAME: &'static str = "PersistentVolumeClaimVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.claimName = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.claimName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.claimName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PersistentVolumeClaimVolumeSource {
        PersistentVolumeClaimVolumeSource::new()
    }

    fn clear(&mut self) {
        self.claimName = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PersistentVolumeClaimVolumeSource {
        static instance: PersistentVolumeClaimVolumeSource = PersistentVolumeClaimVolumeSource {
            claimName: ::std::option::Option::None,
            readOnly: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PersistentVolumeClaimVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PersistentVolumeClaimVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PersistentVolumeClaimVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeClaimVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PersistentVolumeList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PersistentVolumeList {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeList.items)
    pub items: ::std::vec::Vec<PersistentVolume>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PersistentVolumeList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PersistentVolumeList {
    fn default() -> &'a PersistentVolumeList {
        <PersistentVolumeList as ::protobuf::Message>::default_instance()
    }
}

impl PersistentVolumeList {
    pub fn new() -> PersistentVolumeList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.core.v1.PersistentVolume items = 2;

    pub fn items(&self) -> &[PersistentVolume] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<PersistentVolume>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<PersistentVolume> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<PersistentVolume> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &PersistentVolumeList| { &m.metadata },
            |m: &mut PersistentVolumeList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &PersistentVolumeList| { &m.items },
            |m: &mut PersistentVolumeList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PersistentVolumeList>(
            "PersistentVolumeList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PersistentVolumeList {
    const NAME: &'static str = "PersistentVolumeList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PersistentVolumeList {
        PersistentVolumeList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PersistentVolumeList {
        static instance: PersistentVolumeList = PersistentVolumeList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PersistentVolumeList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PersistentVolumeList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PersistentVolumeList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PersistentVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PersistentVolumeSource {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSource.gcePersistentDisk)
    pub gcePersistentDisk: ::protobuf::MessageField<GCEPersistentDiskVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSource.awsElasticBlockStore)
    pub awsElasticBlockStore: ::protobuf::MessageField<AWSElasticBlockStoreVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSource.hostPath)
    pub hostPath: ::protobuf::MessageField<HostPathVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSource.glusterfs)
    pub glusterfs: ::protobuf::MessageField<GlusterfsPersistentVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSource.nfs)
    pub nfs: ::protobuf::MessageField<NFSVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSource.rbd)
    pub rbd: ::protobuf::MessageField<RBDPersistentVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSource.iscsi)
    pub iscsi: ::protobuf::MessageField<ISCSIPersistentVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSource.cinder)
    pub cinder: ::protobuf::MessageField<CinderPersistentVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSource.cephfs)
    pub cephfs: ::protobuf::MessageField<CephFSPersistentVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSource.fc)
    pub fc: ::protobuf::MessageField<FCVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSource.flocker)
    pub flocker: ::protobuf::MessageField<FlockerVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSource.flexVolume)
    pub flexVolume: ::protobuf::MessageField<FlexPersistentVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSource.azureFile)
    pub azureFile: ::protobuf::MessageField<AzureFilePersistentVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSource.vsphereVolume)
    pub vsphereVolume: ::protobuf::MessageField<VsphereVirtualDiskVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSource.quobyte)
    pub quobyte: ::protobuf::MessageField<QuobyteVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSource.azureDisk)
    pub azureDisk: ::protobuf::MessageField<AzureDiskVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSource.photonPersistentDisk)
    pub photonPersistentDisk: ::protobuf::MessageField<PhotonPersistentDiskVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSource.portworxVolume)
    pub portworxVolume: ::protobuf::MessageField<PortworxVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSource.scaleIO)
    pub scaleIO: ::protobuf::MessageField<ScaleIOPersistentVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSource.local)
    pub local: ::protobuf::MessageField<LocalVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSource.storageos)
    pub storageos: ::protobuf::MessageField<StorageOSPersistentVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSource.csi)
    pub csi: ::protobuf::MessageField<CSIPersistentVolumeSource>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PersistentVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PersistentVolumeSource {
    fn default() -> &'a PersistentVolumeSource {
        <PersistentVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl PersistentVolumeSource {
    pub fn new() -> PersistentVolumeSource {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.GCEPersistentDiskVolumeSource gcePersistentDisk = 1;

    pub fn gcePersistentDisk(&self) -> &GCEPersistentDiskVolumeSource {
        self.gcePersistentDisk.as_ref().unwrap_or_else(|| <GCEPersistentDiskVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_gcePersistentDisk(&mut self) {
        self.gcePersistentDisk.clear();
    }

    pub fn has_gcePersistentDisk(&self) -> bool {
        self.gcePersistentDisk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gcePersistentDisk(&mut self, v: GCEPersistentDiskVolumeSource) {
        self.gcePersistentDisk = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gcePersistentDisk(&mut self) -> &mut GCEPersistentDiskVolumeSource {
        self.gcePersistentDisk.mut_or_insert_default()
    }

    // Take field
    pub fn take_gcePersistentDisk(&mut self) -> GCEPersistentDiskVolumeSource {
        self.gcePersistentDisk.take().unwrap_or_else(|| GCEPersistentDiskVolumeSource::new())
    }

    // optional .api.core.v1.AWSElasticBlockStoreVolumeSource awsElasticBlockStore = 2;

    pub fn awsElasticBlockStore(&self) -> &AWSElasticBlockStoreVolumeSource {
        self.awsElasticBlockStore.as_ref().unwrap_or_else(|| <AWSElasticBlockStoreVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_awsElasticBlockStore(&mut self) {
        self.awsElasticBlockStore.clear();
    }

    pub fn has_awsElasticBlockStore(&self) -> bool {
        self.awsElasticBlockStore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_awsElasticBlockStore(&mut self, v: AWSElasticBlockStoreVolumeSource) {
        self.awsElasticBlockStore = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_awsElasticBlockStore(&mut self) -> &mut AWSElasticBlockStoreVolumeSource {
        self.awsElasticBlockStore.mut_or_insert_default()
    }

    // Take field
    pub fn take_awsElasticBlockStore(&mut self) -> AWSElasticBlockStoreVolumeSource {
        self.awsElasticBlockStore.take().unwrap_or_else(|| AWSElasticBlockStoreVolumeSource::new())
    }

    // optional .api.core.v1.HostPathVolumeSource hostPath = 3;

    pub fn hostPath(&self) -> &HostPathVolumeSource {
        self.hostPath.as_ref().unwrap_or_else(|| <HostPathVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_hostPath(&mut self) {
        self.hostPath.clear();
    }

    pub fn has_hostPath(&self) -> bool {
        self.hostPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostPath(&mut self, v: HostPathVolumeSource) {
        self.hostPath = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostPath(&mut self) -> &mut HostPathVolumeSource {
        self.hostPath.mut_or_insert_default()
    }

    // Take field
    pub fn take_hostPath(&mut self) -> HostPathVolumeSource {
        self.hostPath.take().unwrap_or_else(|| HostPathVolumeSource::new())
    }

    // optional .api.core.v1.GlusterfsPersistentVolumeSource glusterfs = 4;

    pub fn glusterfs(&self) -> &GlusterfsPersistentVolumeSource {
        self.glusterfs.as_ref().unwrap_or_else(|| <GlusterfsPersistentVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_glusterfs(&mut self) {
        self.glusterfs.clear();
    }

    pub fn has_glusterfs(&self) -> bool {
        self.glusterfs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_glusterfs(&mut self, v: GlusterfsPersistentVolumeSource) {
        self.glusterfs = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_glusterfs(&mut self) -> &mut GlusterfsPersistentVolumeSource {
        self.glusterfs.mut_or_insert_default()
    }

    // Take field
    pub fn take_glusterfs(&mut self) -> GlusterfsPersistentVolumeSource {
        self.glusterfs.take().unwrap_or_else(|| GlusterfsPersistentVolumeSource::new())
    }

    // optional .api.core.v1.NFSVolumeSource nfs = 5;

    pub fn nfs(&self) -> &NFSVolumeSource {
        self.nfs.as_ref().unwrap_or_else(|| <NFSVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_nfs(&mut self) {
        self.nfs.clear();
    }

    pub fn has_nfs(&self) -> bool {
        self.nfs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nfs(&mut self, v: NFSVolumeSource) {
        self.nfs = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nfs(&mut self) -> &mut NFSVolumeSource {
        self.nfs.mut_or_insert_default()
    }

    // Take field
    pub fn take_nfs(&mut self) -> NFSVolumeSource {
        self.nfs.take().unwrap_or_else(|| NFSVolumeSource::new())
    }

    // optional .api.core.v1.RBDPersistentVolumeSource rbd = 6;

    pub fn rbd(&self) -> &RBDPersistentVolumeSource {
        self.rbd.as_ref().unwrap_or_else(|| <RBDPersistentVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_rbd(&mut self) {
        self.rbd.clear();
    }

    pub fn has_rbd(&self) -> bool {
        self.rbd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rbd(&mut self, v: RBDPersistentVolumeSource) {
        self.rbd = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rbd(&mut self) -> &mut RBDPersistentVolumeSource {
        self.rbd.mut_or_insert_default()
    }

    // Take field
    pub fn take_rbd(&mut self) -> RBDPersistentVolumeSource {
        self.rbd.take().unwrap_or_else(|| RBDPersistentVolumeSource::new())
    }

    // optional .api.core.v1.ISCSIPersistentVolumeSource iscsi = 7;

    pub fn iscsi(&self) -> &ISCSIPersistentVolumeSource {
        self.iscsi.as_ref().unwrap_or_else(|| <ISCSIPersistentVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_iscsi(&mut self) {
        self.iscsi.clear();
    }

    pub fn has_iscsi(&self) -> bool {
        self.iscsi.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iscsi(&mut self, v: ISCSIPersistentVolumeSource) {
        self.iscsi = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iscsi(&mut self) -> &mut ISCSIPersistentVolumeSource {
        self.iscsi.mut_or_insert_default()
    }

    // Take field
    pub fn take_iscsi(&mut self) -> ISCSIPersistentVolumeSource {
        self.iscsi.take().unwrap_or_else(|| ISCSIPersistentVolumeSource::new())
    }

    // optional .api.core.v1.CinderPersistentVolumeSource cinder = 8;

    pub fn cinder(&self) -> &CinderPersistentVolumeSource {
        self.cinder.as_ref().unwrap_or_else(|| <CinderPersistentVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_cinder(&mut self) {
        self.cinder.clear();
    }

    pub fn has_cinder(&self) -> bool {
        self.cinder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cinder(&mut self, v: CinderPersistentVolumeSource) {
        self.cinder = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cinder(&mut self) -> &mut CinderPersistentVolumeSource {
        self.cinder.mut_or_insert_default()
    }

    // Take field
    pub fn take_cinder(&mut self) -> CinderPersistentVolumeSource {
        self.cinder.take().unwrap_or_else(|| CinderPersistentVolumeSource::new())
    }

    // optional .api.core.v1.CephFSPersistentVolumeSource cephfs = 9;

    pub fn cephfs(&self) -> &CephFSPersistentVolumeSource {
        self.cephfs.as_ref().unwrap_or_else(|| <CephFSPersistentVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_cephfs(&mut self) {
        self.cephfs.clear();
    }

    pub fn has_cephfs(&self) -> bool {
        self.cephfs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cephfs(&mut self, v: CephFSPersistentVolumeSource) {
        self.cephfs = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cephfs(&mut self) -> &mut CephFSPersistentVolumeSource {
        self.cephfs.mut_or_insert_default()
    }

    // Take field
    pub fn take_cephfs(&mut self) -> CephFSPersistentVolumeSource {
        self.cephfs.take().unwrap_or_else(|| CephFSPersistentVolumeSource::new())
    }

    // optional .api.core.v1.FCVolumeSource fc = 10;

    pub fn fc(&self) -> &FCVolumeSource {
        self.fc.as_ref().unwrap_or_else(|| <FCVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_fc(&mut self) {
        self.fc.clear();
    }

    pub fn has_fc(&self) -> bool {
        self.fc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fc(&mut self, v: FCVolumeSource) {
        self.fc = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fc(&mut self) -> &mut FCVolumeSource {
        self.fc.mut_or_insert_default()
    }

    // Take field
    pub fn take_fc(&mut self) -> FCVolumeSource {
        self.fc.take().unwrap_or_else(|| FCVolumeSource::new())
    }

    // optional .api.core.v1.FlockerVolumeSource flocker = 11;

    pub fn flocker(&self) -> &FlockerVolumeSource {
        self.flocker.as_ref().unwrap_or_else(|| <FlockerVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_flocker(&mut self) {
        self.flocker.clear();
    }

    pub fn has_flocker(&self) -> bool {
        self.flocker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flocker(&mut self, v: FlockerVolumeSource) {
        self.flocker = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flocker(&mut self) -> &mut FlockerVolumeSource {
        self.flocker.mut_or_insert_default()
    }

    // Take field
    pub fn take_flocker(&mut self) -> FlockerVolumeSource {
        self.flocker.take().unwrap_or_else(|| FlockerVolumeSource::new())
    }

    // optional .api.core.v1.FlexPersistentVolumeSource flexVolume = 12;

    pub fn flexVolume(&self) -> &FlexPersistentVolumeSource {
        self.flexVolume.as_ref().unwrap_or_else(|| <FlexPersistentVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_flexVolume(&mut self) {
        self.flexVolume.clear();
    }

    pub fn has_flexVolume(&self) -> bool {
        self.flexVolume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flexVolume(&mut self, v: FlexPersistentVolumeSource) {
        self.flexVolume = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flexVolume(&mut self) -> &mut FlexPersistentVolumeSource {
        self.flexVolume.mut_or_insert_default()
    }

    // Take field
    pub fn take_flexVolume(&mut self) -> FlexPersistentVolumeSource {
        self.flexVolume.take().unwrap_or_else(|| FlexPersistentVolumeSource::new())
    }

    // optional .api.core.v1.AzureFilePersistentVolumeSource azureFile = 13;

    pub fn azureFile(&self) -> &AzureFilePersistentVolumeSource {
        self.azureFile.as_ref().unwrap_or_else(|| <AzureFilePersistentVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_azureFile(&mut self) {
        self.azureFile.clear();
    }

    pub fn has_azureFile(&self) -> bool {
        self.azureFile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_azureFile(&mut self, v: AzureFilePersistentVolumeSource) {
        self.azureFile = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_azureFile(&mut self) -> &mut AzureFilePersistentVolumeSource {
        self.azureFile.mut_or_insert_default()
    }

    // Take field
    pub fn take_azureFile(&mut self) -> AzureFilePersistentVolumeSource {
        self.azureFile.take().unwrap_or_else(|| AzureFilePersistentVolumeSource::new())
    }

    // optional .api.core.v1.VsphereVirtualDiskVolumeSource vsphereVolume = 14;

    pub fn vsphereVolume(&self) -> &VsphereVirtualDiskVolumeSource {
        self.vsphereVolume.as_ref().unwrap_or_else(|| <VsphereVirtualDiskVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_vsphereVolume(&mut self) {
        self.vsphereVolume.clear();
    }

    pub fn has_vsphereVolume(&self) -> bool {
        self.vsphereVolume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vsphereVolume(&mut self, v: VsphereVirtualDiskVolumeSource) {
        self.vsphereVolume = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vsphereVolume(&mut self) -> &mut VsphereVirtualDiskVolumeSource {
        self.vsphereVolume.mut_or_insert_default()
    }

    // Take field
    pub fn take_vsphereVolume(&mut self) -> VsphereVirtualDiskVolumeSource {
        self.vsphereVolume.take().unwrap_or_else(|| VsphereVirtualDiskVolumeSource::new())
    }

    // optional .api.core.v1.QuobyteVolumeSource quobyte = 15;

    pub fn quobyte(&self) -> &QuobyteVolumeSource {
        self.quobyte.as_ref().unwrap_or_else(|| <QuobyteVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_quobyte(&mut self) {
        self.quobyte.clear();
    }

    pub fn has_quobyte(&self) -> bool {
        self.quobyte.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quobyte(&mut self, v: QuobyteVolumeSource) {
        self.quobyte = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quobyte(&mut self) -> &mut QuobyteVolumeSource {
        self.quobyte.mut_or_insert_default()
    }

    // Take field
    pub fn take_quobyte(&mut self) -> QuobyteVolumeSource {
        self.quobyte.take().unwrap_or_else(|| QuobyteVolumeSource::new())
    }

    // optional .api.core.v1.AzureDiskVolumeSource azureDisk = 16;

    pub fn azureDisk(&self) -> &AzureDiskVolumeSource {
        self.azureDisk.as_ref().unwrap_or_else(|| <AzureDiskVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_azureDisk(&mut self) {
        self.azureDisk.clear();
    }

    pub fn has_azureDisk(&self) -> bool {
        self.azureDisk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_azureDisk(&mut self, v: AzureDiskVolumeSource) {
        self.azureDisk = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_azureDisk(&mut self) -> &mut AzureDiskVolumeSource {
        self.azureDisk.mut_or_insert_default()
    }

    // Take field
    pub fn take_azureDisk(&mut self) -> AzureDiskVolumeSource {
        self.azureDisk.take().unwrap_or_else(|| AzureDiskVolumeSource::new())
    }

    // optional .api.core.v1.PhotonPersistentDiskVolumeSource photonPersistentDisk = 17;

    pub fn photonPersistentDisk(&self) -> &PhotonPersistentDiskVolumeSource {
        self.photonPersistentDisk.as_ref().unwrap_or_else(|| <PhotonPersistentDiskVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_photonPersistentDisk(&mut self) {
        self.photonPersistentDisk.clear();
    }

    pub fn has_photonPersistentDisk(&self) -> bool {
        self.photonPersistentDisk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_photonPersistentDisk(&mut self, v: PhotonPersistentDiskVolumeSource) {
        self.photonPersistentDisk = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_photonPersistentDisk(&mut self) -> &mut PhotonPersistentDiskVolumeSource {
        self.photonPersistentDisk.mut_or_insert_default()
    }

    // Take field
    pub fn take_photonPersistentDisk(&mut self) -> PhotonPersistentDiskVolumeSource {
        self.photonPersistentDisk.take().unwrap_or_else(|| PhotonPersistentDiskVolumeSource::new())
    }

    // optional .api.core.v1.PortworxVolumeSource portworxVolume = 18;

    pub fn portworxVolume(&self) -> &PortworxVolumeSource {
        self.portworxVolume.as_ref().unwrap_or_else(|| <PortworxVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_portworxVolume(&mut self) {
        self.portworxVolume.clear();
    }

    pub fn has_portworxVolume(&self) -> bool {
        self.portworxVolume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_portworxVolume(&mut self, v: PortworxVolumeSource) {
        self.portworxVolume = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_portworxVolume(&mut self) -> &mut PortworxVolumeSource {
        self.portworxVolume.mut_or_insert_default()
    }

    // Take field
    pub fn take_portworxVolume(&mut self) -> PortworxVolumeSource {
        self.portworxVolume.take().unwrap_or_else(|| PortworxVolumeSource::new())
    }

    // optional .api.core.v1.ScaleIOPersistentVolumeSource scaleIO = 19;

    pub fn scaleIO(&self) -> &ScaleIOPersistentVolumeSource {
        self.scaleIO.as_ref().unwrap_or_else(|| <ScaleIOPersistentVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_scaleIO(&mut self) {
        self.scaleIO.clear();
    }

    pub fn has_scaleIO(&self) -> bool {
        self.scaleIO.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scaleIO(&mut self, v: ScaleIOPersistentVolumeSource) {
        self.scaleIO = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scaleIO(&mut self) -> &mut ScaleIOPersistentVolumeSource {
        self.scaleIO.mut_or_insert_default()
    }

    // Take field
    pub fn take_scaleIO(&mut self) -> ScaleIOPersistentVolumeSource {
        self.scaleIO.take().unwrap_or_else(|| ScaleIOPersistentVolumeSource::new())
    }

    // optional .api.core.v1.LocalVolumeSource local = 20;

    pub fn local(&self) -> &LocalVolumeSource {
        self.local.as_ref().unwrap_or_else(|| <LocalVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_local(&mut self) {
        self.local.clear();
    }

    pub fn has_local(&self) -> bool {
        self.local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local(&mut self, v: LocalVolumeSource) {
        self.local = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local(&mut self) -> &mut LocalVolumeSource {
        self.local.mut_or_insert_default()
    }

    // Take field
    pub fn take_local(&mut self) -> LocalVolumeSource {
        self.local.take().unwrap_or_else(|| LocalVolumeSource::new())
    }

    // optional .api.core.v1.StorageOSPersistentVolumeSource storageos = 21;

    pub fn storageos(&self) -> &StorageOSPersistentVolumeSource {
        self.storageos.as_ref().unwrap_or_else(|| <StorageOSPersistentVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_storageos(&mut self) {
        self.storageos.clear();
    }

    pub fn has_storageos(&self) -> bool {
        self.storageos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageos(&mut self, v: StorageOSPersistentVolumeSource) {
        self.storageos = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageos(&mut self) -> &mut StorageOSPersistentVolumeSource {
        self.storageos.mut_or_insert_default()
    }

    // Take field
    pub fn take_storageos(&mut self) -> StorageOSPersistentVolumeSource {
        self.storageos.take().unwrap_or_else(|| StorageOSPersistentVolumeSource::new())
    }

    // optional .api.core.v1.CSIPersistentVolumeSource csi = 22;

    pub fn csi(&self) -> &CSIPersistentVolumeSource {
        self.csi.as_ref().unwrap_or_else(|| <CSIPersistentVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_csi(&mut self) {
        self.csi.clear();
    }

    pub fn has_csi(&self) -> bool {
        self.csi.is_some()
    }

    // Param is passed by value, moved
    pub fn set_csi(&mut self, v: CSIPersistentVolumeSource) {
        self.csi = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_csi(&mut self) -> &mut CSIPersistentVolumeSource {
        self.csi.mut_or_insert_default()
    }

    // Take field
    pub fn take_csi(&mut self) -> CSIPersistentVolumeSource {
        self.csi.take().unwrap_or_else(|| CSIPersistentVolumeSource::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(22);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GCEPersistentDiskVolumeSource>(
            "gcePersistentDisk",
            |m: &PersistentVolumeSource| { &m.gcePersistentDisk },
            |m: &mut PersistentVolumeSource| { &mut m.gcePersistentDisk },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AWSElasticBlockStoreVolumeSource>(
            "awsElasticBlockStore",
            |m: &PersistentVolumeSource| { &m.awsElasticBlockStore },
            |m: &mut PersistentVolumeSource| { &mut m.awsElasticBlockStore },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HostPathVolumeSource>(
            "hostPath",
            |m: &PersistentVolumeSource| { &m.hostPath },
            |m: &mut PersistentVolumeSource| { &mut m.hostPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GlusterfsPersistentVolumeSource>(
            "glusterfs",
            |m: &PersistentVolumeSource| { &m.glusterfs },
            |m: &mut PersistentVolumeSource| { &mut m.glusterfs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NFSVolumeSource>(
            "nfs",
            |m: &PersistentVolumeSource| { &m.nfs },
            |m: &mut PersistentVolumeSource| { &mut m.nfs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RBDPersistentVolumeSource>(
            "rbd",
            |m: &PersistentVolumeSource| { &m.rbd },
            |m: &mut PersistentVolumeSource| { &mut m.rbd },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ISCSIPersistentVolumeSource>(
            "iscsi",
            |m: &PersistentVolumeSource| { &m.iscsi },
            |m: &mut PersistentVolumeSource| { &mut m.iscsi },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CinderPersistentVolumeSource>(
            "cinder",
            |m: &PersistentVolumeSource| { &m.cinder },
            |m: &mut PersistentVolumeSource| { &mut m.cinder },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CephFSPersistentVolumeSource>(
            "cephfs",
            |m: &PersistentVolumeSource| { &m.cephfs },
            |m: &mut PersistentVolumeSource| { &mut m.cephfs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FCVolumeSource>(
            "fc",
            |m: &PersistentVolumeSource| { &m.fc },
            |m: &mut PersistentVolumeSource| { &mut m.fc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FlockerVolumeSource>(
            "flocker",
            |m: &PersistentVolumeSource| { &m.flocker },
            |m: &mut PersistentVolumeSource| { &mut m.flocker },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FlexPersistentVolumeSource>(
            "flexVolume",
            |m: &PersistentVolumeSource| { &m.flexVolume },
            |m: &mut PersistentVolumeSource| { &mut m.flexVolume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AzureFilePersistentVolumeSource>(
            "azureFile",
            |m: &PersistentVolumeSource| { &m.azureFile },
            |m: &mut PersistentVolumeSource| { &mut m.azureFile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VsphereVirtualDiskVolumeSource>(
            "vsphereVolume",
            |m: &PersistentVolumeSource| { &m.vsphereVolume },
            |m: &mut PersistentVolumeSource| { &mut m.vsphereVolume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, QuobyteVolumeSource>(
            "quobyte",
            |m: &PersistentVolumeSource| { &m.quobyte },
            |m: &mut PersistentVolumeSource| { &mut m.quobyte },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AzureDiskVolumeSource>(
            "azureDisk",
            |m: &PersistentVolumeSource| { &m.azureDisk },
            |m: &mut PersistentVolumeSource| { &mut m.azureDisk },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PhotonPersistentDiskVolumeSource>(
            "photonPersistentDisk",
            |m: &PersistentVolumeSource| { &m.photonPersistentDisk },
            |m: &mut PersistentVolumeSource| { &mut m.photonPersistentDisk },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PortworxVolumeSource>(
            "portworxVolume",
            |m: &PersistentVolumeSource| { &m.portworxVolume },
            |m: &mut PersistentVolumeSource| { &mut m.portworxVolume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ScaleIOPersistentVolumeSource>(
            "scaleIO",
            |m: &PersistentVolumeSource| { &m.scaleIO },
            |m: &mut PersistentVolumeSource| { &mut m.scaleIO },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LocalVolumeSource>(
            "local",
            |m: &PersistentVolumeSource| { &m.local },
            |m: &mut PersistentVolumeSource| { &mut m.local },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StorageOSPersistentVolumeSource>(
            "storageos",
            |m: &PersistentVolumeSource| { &m.storageos },
            |m: &mut PersistentVolumeSource| { &mut m.storageos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CSIPersistentVolumeSource>(
            "csi",
            |m: &PersistentVolumeSource| { &m.csi },
            |m: &mut PersistentVolumeSource| { &mut m.csi },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PersistentVolumeSource>(
            "PersistentVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PersistentVolumeSource {
    const NAME: &'static str = "PersistentVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.gcePersistentDisk)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.awsElasticBlockStore)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hostPath)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.glusterfs)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.nfs)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rbd)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.iscsi)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cinder)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cephfs)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fc)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.flocker)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.flexVolume)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.azureFile)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vsphereVolume)?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quobyte)?;
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.azureDisk)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.photonPersistentDisk)?;
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.portworxVolume)?;
                },
                154 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scaleIO)?;
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.local)?;
                },
                170 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.storageos)?;
                },
                178 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.csi)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gcePersistentDisk.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.awsElasticBlockStore.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.hostPath.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.glusterfs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.nfs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rbd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.iscsi.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cinder.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cephfs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.flocker.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.flexVolume.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.azureFile.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.vsphereVolume.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quobyte.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.azureDisk.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.photonPersistentDisk.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.portworxVolume.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scaleIO.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.local.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.storageos.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.csi.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gcePersistentDisk.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.awsElasticBlockStore.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.hostPath.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.glusterfs.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.nfs.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.rbd.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.iscsi.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.cinder.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.cephfs.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.fc.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.flocker.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.flexVolume.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.azureFile.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.vsphereVolume.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.quobyte.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.azureDisk.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.photonPersistentDisk.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.portworxVolume.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.scaleIO.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.local.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.storageos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if let Some(v) = self.csi.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PersistentVolumeSource {
        PersistentVolumeSource::new()
    }

    fn clear(&mut self) {
        self.gcePersistentDisk.clear();
        self.awsElasticBlockStore.clear();
        self.hostPath.clear();
        self.glusterfs.clear();
        self.nfs.clear();
        self.rbd.clear();
        self.iscsi.clear();
        self.cinder.clear();
        self.cephfs.clear();
        self.fc.clear();
        self.flocker.clear();
        self.flexVolume.clear();
        self.azureFile.clear();
        self.vsphereVolume.clear();
        self.quobyte.clear();
        self.azureDisk.clear();
        self.photonPersistentDisk.clear();
        self.portworxVolume.clear();
        self.scaleIO.clear();
        self.local.clear();
        self.storageos.clear();
        self.csi.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PersistentVolumeSource {
        static instance: PersistentVolumeSource = PersistentVolumeSource {
            gcePersistentDisk: ::protobuf::MessageField::none(),
            awsElasticBlockStore: ::protobuf::MessageField::none(),
            hostPath: ::protobuf::MessageField::none(),
            glusterfs: ::protobuf::MessageField::none(),
            nfs: ::protobuf::MessageField::none(),
            rbd: ::protobuf::MessageField::none(),
            iscsi: ::protobuf::MessageField::none(),
            cinder: ::protobuf::MessageField::none(),
            cephfs: ::protobuf::MessageField::none(),
            fc: ::protobuf::MessageField::none(),
            flocker: ::protobuf::MessageField::none(),
            flexVolume: ::protobuf::MessageField::none(),
            azureFile: ::protobuf::MessageField::none(),
            vsphereVolume: ::protobuf::MessageField::none(),
            quobyte: ::protobuf::MessageField::none(),
            azureDisk: ::protobuf::MessageField::none(),
            photonPersistentDisk: ::protobuf::MessageField::none(),
            portworxVolume: ::protobuf::MessageField::none(),
            scaleIO: ::protobuf::MessageField::none(),
            local: ::protobuf::MessageField::none(),
            storageos: ::protobuf::MessageField::none(),
            csi: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PersistentVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PersistentVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PersistentVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PersistentVolumeSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PersistentVolumeSpec {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSpec.capacity)
    pub capacity: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSpec.persistentVolumeSource)
    pub persistentVolumeSource: ::protobuf::MessageField<PersistentVolumeSource>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSpec.accessModes)
    pub accessModes: ::std::vec::Vec<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSpec.claimRef)
    pub claimRef: ::protobuf::MessageField<ObjectReference>,
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSpec.persistentVolumeReclaimPolicy)
    pub persistentVolumeReclaimPolicy: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSpec.storageClassName)
    pub storageClassName: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSpec.mountOptions)
    pub mountOptions: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSpec.volumeMode)
    pub volumeMode: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSpec.nodeAffinity)
    pub nodeAffinity: ::protobuf::MessageField<VolumeNodeAffinity>,
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeSpec.volumeAttributesClassName)
    pub volumeAttributesClassName: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PersistentVolumeSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PersistentVolumeSpec {
    fn default() -> &'a PersistentVolumeSpec {
        <PersistentVolumeSpec as ::protobuf::Message>::default_instance()
    }
}

impl PersistentVolumeSpec {
    pub fn new() -> PersistentVolumeSpec {
        ::std::default::Default::default()
    }

    // repeated .api.core.v1.PersistentVolumeSpec.CapacityEntry capacity = 1;

    pub fn capacity(&self) -> &::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &self.capacity
    }

    pub fn clear_capacity(&mut self) {
        self.capacity.clear();
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>) {
        self.capacity = v;
    }

    // Mutable pointer to the field.
    pub fn mut_capacity(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &mut self.capacity
    }

    // Take field
    pub fn take_capacity(&mut self) -> ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        ::std::mem::replace(&mut self.capacity, ::std::collections::BTreeMap::new())
    }

    // optional .api.core.v1.PersistentVolumeSource persistentVolumeSource = 2;

    pub fn persistentVolumeSource(&self) -> &PersistentVolumeSource {
        self.persistentVolumeSource.as_ref().unwrap_or_else(|| <PersistentVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_persistentVolumeSource(&mut self) {
        self.persistentVolumeSource.clear();
    }

    pub fn has_persistentVolumeSource(&self) -> bool {
        self.persistentVolumeSource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persistentVolumeSource(&mut self, v: PersistentVolumeSource) {
        self.persistentVolumeSource = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persistentVolumeSource(&mut self) -> &mut PersistentVolumeSource {
        self.persistentVolumeSource.mut_or_insert_default()
    }

    // Take field
    pub fn take_persistentVolumeSource(&mut self) -> PersistentVolumeSource {
        self.persistentVolumeSource.take().unwrap_or_else(|| PersistentVolumeSource::new())
    }

    // repeated string accessModes = 3;

    pub fn accessModes(&self) -> &[::std::string::String] {
        &self.accessModes
    }

    pub fn clear_accessModes(&mut self) {
        self.accessModes.clear();
    }

    // Param is passed by value, moved
    pub fn set_accessModes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.accessModes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accessModes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.accessModes
    }

    // Take field
    pub fn take_accessModes(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.accessModes, ::std::vec::Vec::new())
    }

    // optional .api.core.v1.ObjectReference claimRef = 4;

    pub fn claimRef(&self) -> &ObjectReference {
        self.claimRef.as_ref().unwrap_or_else(|| <ObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_claimRef(&mut self) {
        self.claimRef.clear();
    }

    pub fn has_claimRef(&self) -> bool {
        self.claimRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claimRef(&mut self, v: ObjectReference) {
        self.claimRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_claimRef(&mut self) -> &mut ObjectReference {
        self.claimRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_claimRef(&mut self) -> ObjectReference {
        self.claimRef.take().unwrap_or_else(|| ObjectReference::new())
    }

    // optional string persistentVolumeReclaimPolicy = 5;

    pub fn persistentVolumeReclaimPolicy(&self) -> &str {
        match self.persistentVolumeReclaimPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_persistentVolumeReclaimPolicy(&mut self) {
        self.persistentVolumeReclaimPolicy = ::std::option::Option::None;
    }

    pub fn has_persistentVolumeReclaimPolicy(&self) -> bool {
        self.persistentVolumeReclaimPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persistentVolumeReclaimPolicy(&mut self, v: ::std::string::String) {
        self.persistentVolumeReclaimPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persistentVolumeReclaimPolicy(&mut self) -> &mut ::std::string::String {
        if self.persistentVolumeReclaimPolicy.is_none() {
            self.persistentVolumeReclaimPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.persistentVolumeReclaimPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_persistentVolumeReclaimPolicy(&mut self) -> ::std::string::String {
        self.persistentVolumeReclaimPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string storageClassName = 6;

    pub fn storageClassName(&self) -> &str {
        match self.storageClassName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_storageClassName(&mut self) {
        self.storageClassName = ::std::option::Option::None;
    }

    pub fn has_storageClassName(&self) -> bool {
        self.storageClassName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageClassName(&mut self, v: ::std::string::String) {
        self.storageClassName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageClassName(&mut self) -> &mut ::std::string::String {
        if self.storageClassName.is_none() {
            self.storageClassName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.storageClassName.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageClassName(&mut self) -> ::std::string::String {
        self.storageClassName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string mountOptions = 7;

    pub fn mountOptions(&self) -> &[::std::string::String] {
        &self.mountOptions
    }

    pub fn clear_mountOptions(&mut self) {
        self.mountOptions.clear();
    }

    // Param is passed by value, moved
    pub fn set_mountOptions(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.mountOptions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mountOptions(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.mountOptions
    }

    // Take field
    pub fn take_mountOptions(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.mountOptions, ::std::vec::Vec::new())
    }

    // optional string volumeMode = 8;

    pub fn volumeMode(&self) -> &str {
        match self.volumeMode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_volumeMode(&mut self) {
        self.volumeMode = ::std::option::Option::None;
    }

    pub fn has_volumeMode(&self) -> bool {
        self.volumeMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeMode(&mut self, v: ::std::string::String) {
        self.volumeMode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeMode(&mut self) -> &mut ::std::string::String {
        if self.volumeMode.is_none() {
            self.volumeMode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.volumeMode.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeMode(&mut self) -> ::std::string::String {
        self.volumeMode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.VolumeNodeAffinity nodeAffinity = 9;

    pub fn nodeAffinity(&self) -> &VolumeNodeAffinity {
        self.nodeAffinity.as_ref().unwrap_or_else(|| <VolumeNodeAffinity as ::protobuf::Message>::default_instance())
    }

    pub fn clear_nodeAffinity(&mut self) {
        self.nodeAffinity.clear();
    }

    pub fn has_nodeAffinity(&self) -> bool {
        self.nodeAffinity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeAffinity(&mut self, v: VolumeNodeAffinity) {
        self.nodeAffinity = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeAffinity(&mut self) -> &mut VolumeNodeAffinity {
        self.nodeAffinity.mut_or_insert_default()
    }

    // Take field
    pub fn take_nodeAffinity(&mut self) -> VolumeNodeAffinity {
        self.nodeAffinity.take().unwrap_or_else(|| VolumeNodeAffinity::new())
    }

    // optional string volumeAttributesClassName = 10;

    pub fn volumeAttributesClassName(&self) -> &str {
        match self.volumeAttributesClassName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_volumeAttributesClassName(&mut self) {
        self.volumeAttributesClassName = ::std::option::Option::None;
    }

    pub fn has_volumeAttributesClassName(&self) -> bool {
        self.volumeAttributesClassName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeAttributesClassName(&mut self, v: ::std::string::String) {
        self.volumeAttributesClassName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeAttributesClassName(&mut self) -> &mut ::std::string::String {
        if self.volumeAttributesClassName.is_none() {
            self.volumeAttributesClassName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.volumeAttributesClassName.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeAttributesClassName(&mut self) -> ::std::string::String {
        self.volumeAttributesClassName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "capacity",
            |m: &PersistentVolumeSpec| { &m.capacity },
            |m: &mut PersistentVolumeSpec| { &mut m.capacity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PersistentVolumeSource>(
            "persistentVolumeSource",
            |m: &PersistentVolumeSpec| { &m.persistentVolumeSource },
            |m: &mut PersistentVolumeSpec| { &mut m.persistentVolumeSource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accessModes",
            |m: &PersistentVolumeSpec| { &m.accessModes },
            |m: &mut PersistentVolumeSpec| { &mut m.accessModes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ObjectReference>(
            "claimRef",
            |m: &PersistentVolumeSpec| { &m.claimRef },
            |m: &mut PersistentVolumeSpec| { &mut m.claimRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "persistentVolumeReclaimPolicy",
            |m: &PersistentVolumeSpec| { &m.persistentVolumeReclaimPolicy },
            |m: &mut PersistentVolumeSpec| { &mut m.persistentVolumeReclaimPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "storageClassName",
            |m: &PersistentVolumeSpec| { &m.storageClassName },
            |m: &mut PersistentVolumeSpec| { &mut m.storageClassName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mountOptions",
            |m: &PersistentVolumeSpec| { &m.mountOptions },
            |m: &mut PersistentVolumeSpec| { &mut m.mountOptions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volumeMode",
            |m: &PersistentVolumeSpec| { &m.volumeMode },
            |m: &mut PersistentVolumeSpec| { &mut m.volumeMode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VolumeNodeAffinity>(
            "nodeAffinity",
            |m: &PersistentVolumeSpec| { &m.nodeAffinity },
            |m: &mut PersistentVolumeSpec| { &mut m.nodeAffinity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volumeAttributesClassName",
            |m: &PersistentVolumeSpec| { &m.volumeAttributesClassName },
            |m: &mut PersistentVolumeSpec| { &mut m.volumeAttributesClassName },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PersistentVolumeSpec>(
            "PersistentVolumeSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PersistentVolumeSpec {
    const NAME: &'static str = "PersistentVolumeSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.capacity.insert(key, value);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.persistentVolumeSource)?;
                },
                26 => {
                    self.accessModes.push(is.read_string()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.claimRef)?;
                },
                42 => {
                    self.persistentVolumeReclaimPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.storageClassName = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.mountOptions.push(is.read_string()?);
                },
                66 => {
                    self.volumeMode = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.nodeAffinity)?;
                },
                82 => {
                    self.volumeAttributesClassName = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.capacity {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.persistentVolumeSource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.accessModes {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(v) = self.claimRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.persistentVolumeReclaimPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.storageClassName.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.mountOptions {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.volumeMode.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.nodeAffinity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.volumeAttributesClassName.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.capacity {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.persistentVolumeSource.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.accessModes {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.claimRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.persistentVolumeReclaimPolicy.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.storageClassName.as_ref() {
            os.write_string(6, v)?;
        }
        for v in &self.mountOptions {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.volumeMode.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.nodeAffinity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.volumeAttributesClassName.as_ref() {
            os.write_string(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PersistentVolumeSpec {
        PersistentVolumeSpec::new()
    }

    fn clear(&mut self) {
        self.capacity.clear();
        self.persistentVolumeSource.clear();
        self.accessModes.clear();
        self.claimRef.clear();
        self.persistentVolumeReclaimPolicy = ::std::option::Option::None;
        self.storageClassName = ::std::option::Option::None;
        self.mountOptions.clear();
        self.volumeMode = ::std::option::Option::None;
        self.nodeAffinity.clear();
        self.volumeAttributesClassName = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PersistentVolumeSpec {
        static instance: ::protobuf::rt::Lazy<PersistentVolumeSpec> = ::protobuf::rt::Lazy::new();
        instance.get(PersistentVolumeSpec::new)
    }
}

impl ::protobuf::MessageFull for PersistentVolumeSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PersistentVolumeSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PersistentVolumeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PersistentVolumeStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PersistentVolumeStatus {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeStatus.phase)
    pub phase: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeStatus.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeStatus.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PersistentVolumeStatus.lastPhaseTransitionTime)
    pub lastPhaseTransitionTime: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PersistentVolumeStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PersistentVolumeStatus {
    fn default() -> &'a PersistentVolumeStatus {
        <PersistentVolumeStatus as ::protobuf::Message>::default_instance()
    }
}

impl PersistentVolumeStatus {
    pub fn new() -> PersistentVolumeStatus {
        ::std::default::Default::default()
    }

    // optional string phase = 1;

    pub fn phase(&self) -> &str {
        match self.phase.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_phase(&mut self) {
        self.phase = ::std::option::Option::None;
    }

    pub fn has_phase(&self) -> bool {
        self.phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase(&mut self, v: ::std::string::String) {
        self.phase = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phase(&mut self) -> &mut ::std::string::String {
        if self.phase.is_none() {
            self.phase = ::std::option::Option::Some(::std::string::String::new());
        }
        self.phase.as_mut().unwrap()
    }

    // Take field
    pub fn take_phase(&mut self) -> ::std::string::String {
        self.phase.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reason = 3;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastPhaseTransitionTime = 4;

    pub fn lastPhaseTransitionTime(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastPhaseTransitionTime.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastPhaseTransitionTime(&mut self) {
        self.lastPhaseTransitionTime.clear();
    }

    pub fn has_lastPhaseTransitionTime(&self) -> bool {
        self.lastPhaseTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastPhaseTransitionTime(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastPhaseTransitionTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastPhaseTransitionTime(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastPhaseTransitionTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastPhaseTransitionTime(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastPhaseTransitionTime.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "phase",
            |m: &PersistentVolumeStatus| { &m.phase },
            |m: &mut PersistentVolumeStatus| { &mut m.phase },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &PersistentVolumeStatus| { &m.message },
            |m: &mut PersistentVolumeStatus| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &PersistentVolumeStatus| { &m.reason },
            |m: &mut PersistentVolumeStatus| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>(
            "lastPhaseTransitionTime",
            |m: &PersistentVolumeStatus| { &m.lastPhaseTransitionTime },
            |m: &mut PersistentVolumeStatus| { &mut m.lastPhaseTransitionTime },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PersistentVolumeStatus>(
            "PersistentVolumeStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PersistentVolumeStatus {
    const NAME: &'static str = "PersistentVolumeStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.phase = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastPhaseTransitionTime)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.phase.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.lastPhaseTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.phase.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.lastPhaseTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PersistentVolumeStatus {
        PersistentVolumeStatus::new()
    }

    fn clear(&mut self) {
        self.phase = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.lastPhaseTransitionTime.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PersistentVolumeStatus {
        static instance: PersistentVolumeStatus = PersistentVolumeStatus {
            phase: ::std::option::Option::None,
            message: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            lastPhaseTransitionTime: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PersistentVolumeStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PersistentVolumeStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PersistentVolumeStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PhotonPersistentDiskVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PhotonPersistentDiskVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.PhotonPersistentDiskVolumeSource.pdID)
    pub pdID: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PhotonPersistentDiskVolumeSource.fsType)
    pub fsType: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PhotonPersistentDiskVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PhotonPersistentDiskVolumeSource {
    fn default() -> &'a PhotonPersistentDiskVolumeSource {
        <PhotonPersistentDiskVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl PhotonPersistentDiskVolumeSource {
    pub fn new() -> PhotonPersistentDiskVolumeSource {
        ::std::default::Default::default()
    }

    // optional string pdID = 1;

    pub fn pdID(&self) -> &str {
        match self.pdID.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pdID(&mut self) {
        self.pdID = ::std::option::Option::None;
    }

    pub fn has_pdID(&self) -> bool {
        self.pdID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pdID(&mut self, v: ::std::string::String) {
        self.pdID = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pdID(&mut self) -> &mut ::std::string::String {
        if self.pdID.is_none() {
            self.pdID = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pdID.as_mut().unwrap()
    }

    // Take field
    pub fn take_pdID(&mut self) -> ::std::string::String {
        self.pdID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 2;

    pub fn fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fsType(&mut self) {
        self.fsType = ::std::option::Option::None;
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pdID",
            |m: &PhotonPersistentDiskVolumeSource| { &m.pdID },
            |m: &mut PhotonPersistentDiskVolumeSource| { &mut m.pdID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsType",
            |m: &PhotonPersistentDiskVolumeSource| { &m.fsType },
            |m: &mut PhotonPersistentDiskVolumeSource| { &mut m.fsType },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PhotonPersistentDiskVolumeSource>(
            "PhotonPersistentDiskVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PhotonPersistentDiskVolumeSource {
    const NAME: &'static str = "PhotonPersistentDiskVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pdID = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.fsType = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pdID.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pdID.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.fsType.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PhotonPersistentDiskVolumeSource {
        PhotonPersistentDiskVolumeSource::new()
    }

    fn clear(&mut self) {
        self.pdID = ::std::option::Option::None;
        self.fsType = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PhotonPersistentDiskVolumeSource {
        static instance: PhotonPersistentDiskVolumeSource = PhotonPersistentDiskVolumeSource {
            pdID: ::std::option::Option::None,
            fsType: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PhotonPersistentDiskVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PhotonPersistentDiskVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PhotonPersistentDiskVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhotonPersistentDiskVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.Pod)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pod {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Pod.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Pod.spec)
    pub spec: ::protobuf::MessageField<PodSpec>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Pod.status)
    pub status: ::protobuf::MessageField<PodStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.Pod.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pod {
    fn default() -> &'a Pod {
        <Pod as ::protobuf::Message>::default_instance()
    }
}

impl Pod {
    pub fn new() -> Pod {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.core.v1.PodSpec spec = 2;

    pub fn spec(&self) -> &PodSpec {
        self.spec.as_ref().unwrap_or_else(|| <PodSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: PodSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut PodSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> PodSpec {
        self.spec.take().unwrap_or_else(|| PodSpec::new())
    }

    // optional .api.core.v1.PodStatus status = 3;

    pub fn status(&self) -> &PodStatus {
        self.status.as_ref().unwrap_or_else(|| <PodStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: PodStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut PodStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> PodStatus {
        self.status.take().unwrap_or_else(|| PodStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &Pod| { &m.metadata },
            |m: &mut Pod| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PodSpec>(
            "spec",
            |m: &Pod| { &m.spec },
            |m: &mut Pod| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PodStatus>(
            "status",
            |m: &Pod| { &m.status },
            |m: &mut Pod| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pod>(
            "Pod",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pod {
    const NAME: &'static str = "Pod";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pod {
        Pod::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pod {
        static instance: Pod = Pod {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pod {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Pod").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pod {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodAffinity)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodAffinity {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodAffinity.requiredDuringSchedulingIgnoredDuringExecution)
    pub requiredDuringSchedulingIgnoredDuringExecution: ::std::vec::Vec<PodAffinityTerm>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodAffinity.preferredDuringSchedulingIgnoredDuringExecution)
    pub preferredDuringSchedulingIgnoredDuringExecution: ::std::vec::Vec<WeightedPodAffinityTerm>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodAffinity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodAffinity {
    fn default() -> &'a PodAffinity {
        <PodAffinity as ::protobuf::Message>::default_instance()
    }
}

impl PodAffinity {
    pub fn new() -> PodAffinity {
        ::std::default::Default::default()
    }

    // repeated .api.core.v1.PodAffinityTerm requiredDuringSchedulingIgnoredDuringExecution = 1;

    pub fn requiredDuringSchedulingIgnoredDuringExecution(&self) -> &[PodAffinityTerm] {
        &self.requiredDuringSchedulingIgnoredDuringExecution
    }

    pub fn clear_requiredDuringSchedulingIgnoredDuringExecution(&mut self) {
        self.requiredDuringSchedulingIgnoredDuringExecution.clear();
    }

    // Param is passed by value, moved
    pub fn set_requiredDuringSchedulingIgnoredDuringExecution(&mut self, v: ::std::vec::Vec<PodAffinityTerm>) {
        self.requiredDuringSchedulingIgnoredDuringExecution = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requiredDuringSchedulingIgnoredDuringExecution(&mut self) -> &mut ::std::vec::Vec<PodAffinityTerm> {
        &mut self.requiredDuringSchedulingIgnoredDuringExecution
    }

    // Take field
    pub fn take_requiredDuringSchedulingIgnoredDuringExecution(&mut self) -> ::std::vec::Vec<PodAffinityTerm> {
        ::std::mem::replace(&mut self.requiredDuringSchedulingIgnoredDuringExecution, ::std::vec::Vec::new())
    }

    // repeated .api.core.v1.WeightedPodAffinityTerm preferredDuringSchedulingIgnoredDuringExecution = 2;

    pub fn preferredDuringSchedulingIgnoredDuringExecution(&self) -> &[WeightedPodAffinityTerm] {
        &self.preferredDuringSchedulingIgnoredDuringExecution
    }

    pub fn clear_preferredDuringSchedulingIgnoredDuringExecution(&mut self) {
        self.preferredDuringSchedulingIgnoredDuringExecution.clear();
    }

    // Param is passed by value, moved
    pub fn set_preferredDuringSchedulingIgnoredDuringExecution(&mut self, v: ::std::vec::Vec<WeightedPodAffinityTerm>) {
        self.preferredDuringSchedulingIgnoredDuringExecution = v;
    }

    // Mutable pointer to the field.
    pub fn mut_preferredDuringSchedulingIgnoredDuringExecution(&mut self) -> &mut ::std::vec::Vec<WeightedPodAffinityTerm> {
        &mut self.preferredDuringSchedulingIgnoredDuringExecution
    }

    // Take field
    pub fn take_preferredDuringSchedulingIgnoredDuringExecution(&mut self) -> ::std::vec::Vec<WeightedPodAffinityTerm> {
        ::std::mem::replace(&mut self.preferredDuringSchedulingIgnoredDuringExecution, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "requiredDuringSchedulingIgnoredDuringExecution",
            |m: &PodAffinity| { &m.requiredDuringSchedulingIgnoredDuringExecution },
            |m: &mut PodAffinity| { &mut m.requiredDuringSchedulingIgnoredDuringExecution },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "preferredDuringSchedulingIgnoredDuringExecution",
            |m: &PodAffinity| { &m.preferredDuringSchedulingIgnoredDuringExecution },
            |m: &mut PodAffinity| { &mut m.preferredDuringSchedulingIgnoredDuringExecution },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodAffinity>(
            "PodAffinity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodAffinity {
    const NAME: &'static str = "PodAffinity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.requiredDuringSchedulingIgnoredDuringExecution.push(is.read_message()?);
                },
                18 => {
                    self.preferredDuringSchedulingIgnoredDuringExecution.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.requiredDuringSchedulingIgnoredDuringExecution {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.preferredDuringSchedulingIgnoredDuringExecution {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.requiredDuringSchedulingIgnoredDuringExecution {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.preferredDuringSchedulingIgnoredDuringExecution {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodAffinity {
        PodAffinity::new()
    }

    fn clear(&mut self) {
        self.requiredDuringSchedulingIgnoredDuringExecution.clear();
        self.preferredDuringSchedulingIgnoredDuringExecution.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodAffinity {
        static instance: PodAffinity = PodAffinity {
            requiredDuringSchedulingIgnoredDuringExecution: ::std::vec::Vec::new(),
            preferredDuringSchedulingIgnoredDuringExecution: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodAffinity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodAffinity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodAffinity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodAffinity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodAffinityTerm)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodAffinityTerm {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodAffinityTerm.labelSelector)
    pub labelSelector: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodAffinityTerm.namespaces)
    pub namespaces: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PodAffinityTerm.topologyKey)
    pub topologyKey: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodAffinityTerm.namespaceSelector)
    pub namespaceSelector: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodAffinityTerm.matchLabelKeys)
    pub matchLabelKeys: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodAffinityTerm.mismatchLabelKeys)
    pub mismatchLabelKeys: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodAffinityTerm.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodAffinityTerm {
    fn default() -> &'a PodAffinityTerm {
        <PodAffinityTerm as ::protobuf::Message>::default_instance()
    }
}

impl PodAffinityTerm {
    pub fn new() -> PodAffinityTerm {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 1;

    pub fn labelSelector(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.labelSelector.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_labelSelector(&mut self) {
        self.labelSelector.clear();
    }

    pub fn has_labelSelector(&self) -> bool {
        self.labelSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labelSelector(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.labelSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labelSelector(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.labelSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_labelSelector(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.labelSelector.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // repeated string namespaces = 2;

    pub fn namespaces(&self) -> &[::std::string::String] {
        &self.namespaces
    }

    pub fn clear_namespaces(&mut self) {
        self.namespaces.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespaces(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.namespaces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_namespaces(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.namespaces
    }

    // Take field
    pub fn take_namespaces(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.namespaces, ::std::vec::Vec::new())
    }

    // optional string topologyKey = 3;

    pub fn topologyKey(&self) -> &str {
        match self.topologyKey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_topologyKey(&mut self) {
        self.topologyKey = ::std::option::Option::None;
    }

    pub fn has_topologyKey(&self) -> bool {
        self.topologyKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topologyKey(&mut self, v: ::std::string::String) {
        self.topologyKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topologyKey(&mut self) -> &mut ::std::string::String {
        if self.topologyKey.is_none() {
            self.topologyKey = ::std::option::Option::Some(::std::string::String::new());
        }
        self.topologyKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_topologyKey(&mut self) -> ::std::string::String {
        self.topologyKey.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 4;

    pub fn namespaceSelector(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_namespaceSelector(&mut self) {
        self.namespaceSelector.clear();
    }

    pub fn has_namespaceSelector(&self) -> bool {
        self.namespaceSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespaceSelector(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.namespaceSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespaceSelector(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_namespaceSelector(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // repeated string matchLabelKeys = 5;

    pub fn matchLabelKeys(&self) -> &[::std::string::String] {
        &self.matchLabelKeys
    }

    pub fn clear_matchLabelKeys(&mut self) {
        self.matchLabelKeys.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchLabelKeys(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.matchLabelKeys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchLabelKeys(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.matchLabelKeys
    }

    // Take field
    pub fn take_matchLabelKeys(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.matchLabelKeys, ::std::vec::Vec::new())
    }

    // repeated string mismatchLabelKeys = 6;

    pub fn mismatchLabelKeys(&self) -> &[::std::string::String] {
        &self.mismatchLabelKeys
    }

    pub fn clear_mismatchLabelKeys(&mut self) {
        self.mismatchLabelKeys.clear();
    }

    // Param is passed by value, moved
    pub fn set_mismatchLabelKeys(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.mismatchLabelKeys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mismatchLabelKeys(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.mismatchLabelKeys
    }

    // Take field
    pub fn take_mismatchLabelKeys(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.mismatchLabelKeys, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "labelSelector",
            |m: &PodAffinityTerm| { &m.labelSelector },
            |m: &mut PodAffinityTerm| { &mut m.labelSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "namespaces",
            |m: &PodAffinityTerm| { &m.namespaces },
            |m: &mut PodAffinityTerm| { &mut m.namespaces },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "topologyKey",
            |m: &PodAffinityTerm| { &m.topologyKey },
            |m: &mut PodAffinityTerm| { &mut m.topologyKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "namespaceSelector",
            |m: &PodAffinityTerm| { &m.namespaceSelector },
            |m: &mut PodAffinityTerm| { &mut m.namespaceSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matchLabelKeys",
            |m: &PodAffinityTerm| { &m.matchLabelKeys },
            |m: &mut PodAffinityTerm| { &mut m.matchLabelKeys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mismatchLabelKeys",
            |m: &PodAffinityTerm| { &m.mismatchLabelKeys },
            |m: &mut PodAffinityTerm| { &mut m.mismatchLabelKeys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodAffinityTerm>(
            "PodAffinityTerm",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodAffinityTerm {
    const NAME: &'static str = "PodAffinityTerm";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.labelSelector)?;
                },
                18 => {
                    self.namespaces.push(is.read_string()?);
                },
                26 => {
                    self.topologyKey = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.namespaceSelector)?;
                },
                42 => {
                    self.matchLabelKeys.push(is.read_string()?);
                },
                50 => {
                    self.mismatchLabelKeys.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.labelSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.namespaces {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(v) = self.topologyKey.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.namespaceSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.matchLabelKeys {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.mismatchLabelKeys {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.labelSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.namespaces {
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.topologyKey.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.namespaceSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for v in &self.matchLabelKeys {
            os.write_string(5, &v)?;
        };
        for v in &self.mismatchLabelKeys {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodAffinityTerm {
        PodAffinityTerm::new()
    }

    fn clear(&mut self) {
        self.labelSelector.clear();
        self.namespaces.clear();
        self.topologyKey = ::std::option::Option::None;
        self.namespaceSelector.clear();
        self.matchLabelKeys.clear();
        self.mismatchLabelKeys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodAffinityTerm {
        static instance: PodAffinityTerm = PodAffinityTerm {
            labelSelector: ::protobuf::MessageField::none(),
            namespaces: ::std::vec::Vec::new(),
            topologyKey: ::std::option::Option::None,
            namespaceSelector: ::protobuf::MessageField::none(),
            matchLabelKeys: ::std::vec::Vec::new(),
            mismatchLabelKeys: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodAffinityTerm {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodAffinityTerm").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodAffinityTerm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodAffinityTerm {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodAntiAffinity)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodAntiAffinity {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution)
    pub requiredDuringSchedulingIgnoredDuringExecution: ::std::vec::Vec<PodAffinityTerm>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution)
    pub preferredDuringSchedulingIgnoredDuringExecution: ::std::vec::Vec<WeightedPodAffinityTerm>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodAntiAffinity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodAntiAffinity {
    fn default() -> &'a PodAntiAffinity {
        <PodAntiAffinity as ::protobuf::Message>::default_instance()
    }
}

impl PodAntiAffinity {
    pub fn new() -> PodAntiAffinity {
        ::std::default::Default::default()
    }

    // repeated .api.core.v1.PodAffinityTerm requiredDuringSchedulingIgnoredDuringExecution = 1;

    pub fn requiredDuringSchedulingIgnoredDuringExecution(&self) -> &[PodAffinityTerm] {
        &self.requiredDuringSchedulingIgnoredDuringExecution
    }

    pub fn clear_requiredDuringSchedulingIgnoredDuringExecution(&mut self) {
        self.requiredDuringSchedulingIgnoredDuringExecution.clear();
    }

    // Param is passed by value, moved
    pub fn set_requiredDuringSchedulingIgnoredDuringExecution(&mut self, v: ::std::vec::Vec<PodAffinityTerm>) {
        self.requiredDuringSchedulingIgnoredDuringExecution = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requiredDuringSchedulingIgnoredDuringExecution(&mut self) -> &mut ::std::vec::Vec<PodAffinityTerm> {
        &mut self.requiredDuringSchedulingIgnoredDuringExecution
    }

    // Take field
    pub fn take_requiredDuringSchedulingIgnoredDuringExecution(&mut self) -> ::std::vec::Vec<PodAffinityTerm> {
        ::std::mem::replace(&mut self.requiredDuringSchedulingIgnoredDuringExecution, ::std::vec::Vec::new())
    }

    // repeated .api.core.v1.WeightedPodAffinityTerm preferredDuringSchedulingIgnoredDuringExecution = 2;

    pub fn preferredDuringSchedulingIgnoredDuringExecution(&self) -> &[WeightedPodAffinityTerm] {
        &self.preferredDuringSchedulingIgnoredDuringExecution
    }

    pub fn clear_preferredDuringSchedulingIgnoredDuringExecution(&mut self) {
        self.preferredDuringSchedulingIgnoredDuringExecution.clear();
    }

    // Param is passed by value, moved
    pub fn set_preferredDuringSchedulingIgnoredDuringExecution(&mut self, v: ::std::vec::Vec<WeightedPodAffinityTerm>) {
        self.preferredDuringSchedulingIgnoredDuringExecution = v;
    }

    // Mutable pointer to the field.
    pub fn mut_preferredDuringSchedulingIgnoredDuringExecution(&mut self) -> &mut ::std::vec::Vec<WeightedPodAffinityTerm> {
        &mut self.preferredDuringSchedulingIgnoredDuringExecution
    }

    // Take field
    pub fn take_preferredDuringSchedulingIgnoredDuringExecution(&mut self) -> ::std::vec::Vec<WeightedPodAffinityTerm> {
        ::std::mem::replace(&mut self.preferredDuringSchedulingIgnoredDuringExecution, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "requiredDuringSchedulingIgnoredDuringExecution",
            |m: &PodAntiAffinity| { &m.requiredDuringSchedulingIgnoredDuringExecution },
            |m: &mut PodAntiAffinity| { &mut m.requiredDuringSchedulingIgnoredDuringExecution },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "preferredDuringSchedulingIgnoredDuringExecution",
            |m: &PodAntiAffinity| { &m.preferredDuringSchedulingIgnoredDuringExecution },
            |m: &mut PodAntiAffinity| { &mut m.preferredDuringSchedulingIgnoredDuringExecution },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodAntiAffinity>(
            "PodAntiAffinity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodAntiAffinity {
    const NAME: &'static str = "PodAntiAffinity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.requiredDuringSchedulingIgnoredDuringExecution.push(is.read_message()?);
                },
                18 => {
                    self.preferredDuringSchedulingIgnoredDuringExecution.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.requiredDuringSchedulingIgnoredDuringExecution {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.preferredDuringSchedulingIgnoredDuringExecution {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.requiredDuringSchedulingIgnoredDuringExecution {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.preferredDuringSchedulingIgnoredDuringExecution {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodAntiAffinity {
        PodAntiAffinity::new()
    }

    fn clear(&mut self) {
        self.requiredDuringSchedulingIgnoredDuringExecution.clear();
        self.preferredDuringSchedulingIgnoredDuringExecution.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodAntiAffinity {
        static instance: PodAntiAffinity = PodAntiAffinity {
            requiredDuringSchedulingIgnoredDuringExecution: ::std::vec::Vec::new(),
            preferredDuringSchedulingIgnoredDuringExecution: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodAntiAffinity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodAntiAffinity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodAntiAffinity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodAntiAffinity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodAttachOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodAttachOptions {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.PodAttachOptions.stdin)
    pub stdin: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.PodAttachOptions.stdout)
    pub stdout: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.PodAttachOptions.stderr)
    pub stderr: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.PodAttachOptions.tty)
    pub tty: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.PodAttachOptions.container)
    pub container: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodAttachOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodAttachOptions {
    fn default() -> &'a PodAttachOptions {
        <PodAttachOptions as ::protobuf::Message>::default_instance()
    }
}

impl PodAttachOptions {
    pub fn new() -> PodAttachOptions {
        ::std::default::Default::default()
    }

    // optional bool stdin = 1;

    pub fn stdin(&self) -> bool {
        self.stdin.unwrap_or(false)
    }

    pub fn clear_stdin(&mut self) {
        self.stdin = ::std::option::Option::None;
    }

    pub fn has_stdin(&self) -> bool {
        self.stdin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdin(&mut self, v: bool) {
        self.stdin = ::std::option::Option::Some(v);
    }

    // optional bool stdout = 2;

    pub fn stdout(&self) -> bool {
        self.stdout.unwrap_or(false)
    }

    pub fn clear_stdout(&mut self) {
        self.stdout = ::std::option::Option::None;
    }

    pub fn has_stdout(&self) -> bool {
        self.stdout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdout(&mut self, v: bool) {
        self.stdout = ::std::option::Option::Some(v);
    }

    // optional bool stderr = 3;

    pub fn stderr(&self) -> bool {
        self.stderr.unwrap_or(false)
    }

    pub fn clear_stderr(&mut self) {
        self.stderr = ::std::option::Option::None;
    }

    pub fn has_stderr(&self) -> bool {
        self.stderr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stderr(&mut self, v: bool) {
        self.stderr = ::std::option::Option::Some(v);
    }

    // optional bool tty = 4;

    pub fn tty(&self) -> bool {
        self.tty.unwrap_or(false)
    }

    pub fn clear_tty(&mut self) {
        self.tty = ::std::option::Option::None;
    }

    pub fn has_tty(&self) -> bool {
        self.tty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tty(&mut self, v: bool) {
        self.tty = ::std::option::Option::Some(v);
    }

    // optional string container = 5;

    pub fn container(&self) -> &str {
        match self.container.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_container(&mut self) {
        self.container = ::std::option::Option::None;
    }

    pub fn has_container(&self) -> bool {
        self.container.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container(&mut self, v: ::std::string::String) {
        self.container = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container(&mut self) -> &mut ::std::string::String {
        if self.container.is_none() {
            self.container = ::std::option::Option::Some(::std::string::String::new());
        }
        self.container.as_mut().unwrap()
    }

    // Take field
    pub fn take_container(&mut self) -> ::std::string::String {
        self.container.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stdin",
            |m: &PodAttachOptions| { &m.stdin },
            |m: &mut PodAttachOptions| { &mut m.stdin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stdout",
            |m: &PodAttachOptions| { &m.stdout },
            |m: &mut PodAttachOptions| { &mut m.stdout },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stderr",
            |m: &PodAttachOptions| { &m.stderr },
            |m: &mut PodAttachOptions| { &mut m.stderr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tty",
            |m: &PodAttachOptions| { &m.tty },
            |m: &mut PodAttachOptions| { &mut m.tty },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "container",
            |m: &PodAttachOptions| { &m.container },
            |m: &mut PodAttachOptions| { &mut m.container },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodAttachOptions>(
            "PodAttachOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodAttachOptions {
    const NAME: &'static str = "PodAttachOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.stdin = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.stdout = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.stderr = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.tty = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.container = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stdin {
            my_size += 1 + 1;
        }
        if let Some(v) = self.stdout {
            my_size += 1 + 1;
        }
        if let Some(v) = self.stderr {
            my_size += 1 + 1;
        }
        if let Some(v) = self.tty {
            my_size += 1 + 1;
        }
        if let Some(v) = self.container.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stdin {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.stdout {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.stderr {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.tty {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.container.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodAttachOptions {
        PodAttachOptions::new()
    }

    fn clear(&mut self) {
        self.stdin = ::std::option::Option::None;
        self.stdout = ::std::option::Option::None;
        self.stderr = ::std::option::Option::None;
        self.tty = ::std::option::Option::None;
        self.container = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodAttachOptions {
        static instance: PodAttachOptions = PodAttachOptions {
            stdin: ::std::option::Option::None,
            stdout: ::std::option::Option::None,
            stderr: ::std::option::Option::None,
            tty: ::std::option::Option::None,
            container: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodAttachOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodAttachOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodAttachOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodAttachOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodCondition {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.PodCondition.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PodCondition.status)
    pub status: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodCondition.lastProbeTime)
    pub lastProbeTime: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodCondition.lastTransitionTime)
    pub lastTransitionTime: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:api.core.v1.PodCondition.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PodCondition.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodCondition {
    fn default() -> &'a PodCondition {
        <PodCondition as ::protobuf::Message>::default_instance()
    }
}

impl PodCondition {
    pub fn new() -> PodCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;

    pub fn lastProbeTime(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastProbeTime.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastProbeTime(&mut self) {
        self.lastProbeTime.clear();
    }

    pub fn has_lastProbeTime(&self) -> bool {
        self.lastProbeTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastProbeTime(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastProbeTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastProbeTime(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastProbeTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastProbeTime(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastProbeTime.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;

    pub fn lastTransitionTime(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastTransitionTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional string reason = 5;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 6;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &PodCondition| { &m.type_ },
            |m: &mut PodCondition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &PodCondition| { &m.status },
            |m: &mut PodCondition| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>(
            "lastProbeTime",
            |m: &PodCondition| { &m.lastProbeTime },
            |m: &mut PodCondition| { &mut m.lastProbeTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>(
            "lastTransitionTime",
            |m: &PodCondition| { &m.lastTransitionTime },
            |m: &mut PodCondition| { &mut m.lastTransitionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &PodCondition| { &m.reason },
            |m: &mut PodCondition| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &PodCondition| { &m.message },
            |m: &mut PodCondition| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodCondition>(
            "PodCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodCondition {
    const NAME: &'static str = "PodCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastProbeTime)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTransitionTime)?;
                },
                42 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastProbeTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lastProbeTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodCondition {
        PodCondition::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.lastProbeTime.clear();
        self.lastTransitionTime.clear();
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodCondition {
        static instance: PodCondition = PodCondition {
            type_: ::std::option::Option::None,
            status: ::std::option::Option::None,
            lastProbeTime: ::protobuf::MessageField::none(),
            lastTransitionTime: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodDNSConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodDNSConfig {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodDNSConfig.nameservers)
    pub nameservers: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodDNSConfig.searches)
    pub searches: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodDNSConfig.options)
    pub options: ::std::vec::Vec<PodDNSConfigOption>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodDNSConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodDNSConfig {
    fn default() -> &'a PodDNSConfig {
        <PodDNSConfig as ::protobuf::Message>::default_instance()
    }
}

impl PodDNSConfig {
    pub fn new() -> PodDNSConfig {
        ::std::default::Default::default()
    }

    // repeated string nameservers = 1;

    pub fn nameservers(&self) -> &[::std::string::String] {
        &self.nameservers
    }

    pub fn clear_nameservers(&mut self) {
        self.nameservers.clear();
    }

    // Param is passed by value, moved
    pub fn set_nameservers(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.nameservers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nameservers(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.nameservers
    }

    // Take field
    pub fn take_nameservers(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.nameservers, ::std::vec::Vec::new())
    }

    // repeated string searches = 2;

    pub fn searches(&self) -> &[::std::string::String] {
        &self.searches
    }

    pub fn clear_searches(&mut self) {
        self.searches.clear();
    }

    // Param is passed by value, moved
    pub fn set_searches(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.searches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_searches(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.searches
    }

    // Take field
    pub fn take_searches(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.searches, ::std::vec::Vec::new())
    }

    // repeated .api.core.v1.PodDNSConfigOption options = 3;

    pub fn options(&self) -> &[PodDNSConfigOption] {
        &self.options
    }

    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ::std::vec::Vec<PodDNSConfigOption>) {
        self.options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_options(&mut self) -> &mut ::std::vec::Vec<PodDNSConfigOption> {
        &mut self.options
    }

    // Take field
    pub fn take_options(&mut self) -> ::std::vec::Vec<PodDNSConfigOption> {
        ::std::mem::replace(&mut self.options, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nameservers",
            |m: &PodDNSConfig| { &m.nameservers },
            |m: &mut PodDNSConfig| { &mut m.nameservers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "searches",
            |m: &PodDNSConfig| { &m.searches },
            |m: &mut PodDNSConfig| { &mut m.searches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "options",
            |m: &PodDNSConfig| { &m.options },
            |m: &mut PodDNSConfig| { &mut m.options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodDNSConfig>(
            "PodDNSConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodDNSConfig {
    const NAME: &'static str = "PodDNSConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.nameservers.push(is.read_string()?);
                },
                18 => {
                    self.searches.push(is.read_string()?);
                },
                26 => {
                    self.options.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.nameservers {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.searches {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.options {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.nameservers {
            os.write_string(1, &v)?;
        };
        for v in &self.searches {
            os.write_string(2, &v)?;
        };
        for v in &self.options {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodDNSConfig {
        PodDNSConfig::new()
    }

    fn clear(&mut self) {
        self.nameservers.clear();
        self.searches.clear();
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodDNSConfig {
        static instance: PodDNSConfig = PodDNSConfig {
            nameservers: ::std::vec::Vec::new(),
            searches: ::std::vec::Vec::new(),
            options: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodDNSConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodDNSConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodDNSConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodDNSConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodDNSConfigOption)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodDNSConfigOption {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.PodDNSConfigOption.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PodDNSConfigOption.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodDNSConfigOption.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodDNSConfigOption {
    fn default() -> &'a PodDNSConfigOption {
        <PodDNSConfigOption as ::protobuf::Message>::default_instance()
    }
}

impl PodDNSConfigOption {
    pub fn new() -> PodDNSConfigOption {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &PodDNSConfigOption| { &m.name },
            |m: &mut PodDNSConfigOption| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &PodDNSConfigOption| { &m.value },
            |m: &mut PodDNSConfigOption| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodDNSConfigOption>(
            "PodDNSConfigOption",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodDNSConfigOption {
    const NAME: &'static str = "PodDNSConfigOption";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodDNSConfigOption {
        PodDNSConfigOption::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodDNSConfigOption {
        static instance: PodDNSConfigOption = PodDNSConfigOption {
            name: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodDNSConfigOption {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodDNSConfigOption").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodDNSConfigOption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodDNSConfigOption {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodExecOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodExecOptions {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.PodExecOptions.stdin)
    pub stdin: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.PodExecOptions.stdout)
    pub stdout: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.PodExecOptions.stderr)
    pub stderr: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.PodExecOptions.tty)
    pub tty: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.PodExecOptions.container)
    pub container: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodExecOptions.command)
    pub command: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodExecOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodExecOptions {
    fn default() -> &'a PodExecOptions {
        <PodExecOptions as ::protobuf::Message>::default_instance()
    }
}

impl PodExecOptions {
    pub fn new() -> PodExecOptions {
        ::std::default::Default::default()
    }

    // optional bool stdin = 1;

    pub fn stdin(&self) -> bool {
        self.stdin.unwrap_or(false)
    }

    pub fn clear_stdin(&mut self) {
        self.stdin = ::std::option::Option::None;
    }

    pub fn has_stdin(&self) -> bool {
        self.stdin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdin(&mut self, v: bool) {
        self.stdin = ::std::option::Option::Some(v);
    }

    // optional bool stdout = 2;

    pub fn stdout(&self) -> bool {
        self.stdout.unwrap_or(false)
    }

    pub fn clear_stdout(&mut self) {
        self.stdout = ::std::option::Option::None;
    }

    pub fn has_stdout(&self) -> bool {
        self.stdout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdout(&mut self, v: bool) {
        self.stdout = ::std::option::Option::Some(v);
    }

    // optional bool stderr = 3;

    pub fn stderr(&self) -> bool {
        self.stderr.unwrap_or(false)
    }

    pub fn clear_stderr(&mut self) {
        self.stderr = ::std::option::Option::None;
    }

    pub fn has_stderr(&self) -> bool {
        self.stderr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stderr(&mut self, v: bool) {
        self.stderr = ::std::option::Option::Some(v);
    }

    // optional bool tty = 4;

    pub fn tty(&self) -> bool {
        self.tty.unwrap_or(false)
    }

    pub fn clear_tty(&mut self) {
        self.tty = ::std::option::Option::None;
    }

    pub fn has_tty(&self) -> bool {
        self.tty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tty(&mut self, v: bool) {
        self.tty = ::std::option::Option::Some(v);
    }

    // optional string container = 5;

    pub fn container(&self) -> &str {
        match self.container.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_container(&mut self) {
        self.container = ::std::option::Option::None;
    }

    pub fn has_container(&self) -> bool {
        self.container.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container(&mut self, v: ::std::string::String) {
        self.container = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container(&mut self) -> &mut ::std::string::String {
        if self.container.is_none() {
            self.container = ::std::option::Option::Some(::std::string::String::new());
        }
        self.container.as_mut().unwrap()
    }

    // Take field
    pub fn take_container(&mut self) -> ::std::string::String {
        self.container.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string command = 6;

    pub fn command(&self) -> &[::std::string::String] {
        &self.command
    }

    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.command = v;
    }

    // Mutable pointer to the field.
    pub fn mut_command(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.command
    }

    // Take field
    pub fn take_command(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.command, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stdin",
            |m: &PodExecOptions| { &m.stdin },
            |m: &mut PodExecOptions| { &mut m.stdin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stdout",
            |m: &PodExecOptions| { &m.stdout },
            |m: &mut PodExecOptions| { &mut m.stdout },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stderr",
            |m: &PodExecOptions| { &m.stderr },
            |m: &mut PodExecOptions| { &mut m.stderr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tty",
            |m: &PodExecOptions| { &m.tty },
            |m: &mut PodExecOptions| { &mut m.tty },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "container",
            |m: &PodExecOptions| { &m.container },
            |m: &mut PodExecOptions| { &mut m.container },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "command",
            |m: &PodExecOptions| { &m.command },
            |m: &mut PodExecOptions| { &mut m.command },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodExecOptions>(
            "PodExecOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodExecOptions {
    const NAME: &'static str = "PodExecOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.stdin = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.stdout = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.stderr = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.tty = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.container = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.command.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stdin {
            my_size += 1 + 1;
        }
        if let Some(v) = self.stdout {
            my_size += 1 + 1;
        }
        if let Some(v) = self.stderr {
            my_size += 1 + 1;
        }
        if let Some(v) = self.tty {
            my_size += 1 + 1;
        }
        if let Some(v) = self.container.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.command {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stdin {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.stdout {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.stderr {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.tty {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.container.as_ref() {
            os.write_string(5, v)?;
        }
        for v in &self.command {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodExecOptions {
        PodExecOptions::new()
    }

    fn clear(&mut self) {
        self.stdin = ::std::option::Option::None;
        self.stdout = ::std::option::Option::None;
        self.stderr = ::std::option::Option::None;
        self.tty = ::std::option::Option::None;
        self.container = ::std::option::Option::None;
        self.command.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodExecOptions {
        static instance: PodExecOptions = PodExecOptions {
            stdin: ::std::option::Option::None,
            stdout: ::std::option::Option::None,
            stderr: ::std::option::Option::None,
            tty: ::std::option::Option::None,
            container: ::std::option::Option::None,
            command: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodExecOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodExecOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodExecOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodExecOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodIP)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodIP {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.PodIP.ip)
    pub ip: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodIP.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodIP {
    fn default() -> &'a PodIP {
        <PodIP as ::protobuf::Message>::default_instance()
    }
}

impl PodIP {
    pub fn new() -> PodIP {
        ::std::default::Default::default()
    }

    // optional string ip = 1;

    pub fn ip(&self) -> &str {
        match self.ip.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        if self.ip.is_none() {
            self.ip = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        self.ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip",
            |m: &PodIP| { &m.ip },
            |m: &mut PodIP| { &mut m.ip },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodIP>(
            "PodIP",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodIP {
    const NAME: &'static str = "PodIP";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ip = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ip.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ip.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodIP {
        PodIP::new()
    }

    fn clear(&mut self) {
        self.ip = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodIP {
        static instance: PodIP = PodIP {
            ip: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodIP {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodIP").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodIP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodIP {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodList {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodList.items)
    pub items: ::std::vec::Vec<Pod>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodList {
    fn default() -> &'a PodList {
        <PodList as ::protobuf::Message>::default_instance()
    }
}

impl PodList {
    pub fn new() -> PodList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.core.v1.Pod items = 2;

    pub fn items(&self) -> &[Pod] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<Pod>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<Pod> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<Pod> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &PodList| { &m.metadata },
            |m: &mut PodList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &PodList| { &m.items },
            |m: &mut PodList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodList>(
            "PodList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodList {
    const NAME: &'static str = "PodList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodList {
        PodList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodList {
        static instance: PodList = PodList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodLogOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodLogOptions {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.PodLogOptions.container)
    pub container: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PodLogOptions.follow)
    pub follow: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.PodLogOptions.previous)
    pub previous: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.PodLogOptions.sinceSeconds)
    pub sinceSeconds: ::std::option::Option<i64>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodLogOptions.sinceTime)
    pub sinceTime: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:api.core.v1.PodLogOptions.timestamps)
    pub timestamps: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.PodLogOptions.tailLines)
    pub tailLines: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.core.v1.PodLogOptions.limitBytes)
    pub limitBytes: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.core.v1.PodLogOptions.insecureSkipTLSVerifyBackend)
    pub insecureSkipTLSVerifyBackend: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodLogOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodLogOptions {
    fn default() -> &'a PodLogOptions {
        <PodLogOptions as ::protobuf::Message>::default_instance()
    }
}

impl PodLogOptions {
    pub fn new() -> PodLogOptions {
        ::std::default::Default::default()
    }

    // optional string container = 1;

    pub fn container(&self) -> &str {
        match self.container.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_container(&mut self) {
        self.container = ::std::option::Option::None;
    }

    pub fn has_container(&self) -> bool {
        self.container.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container(&mut self, v: ::std::string::String) {
        self.container = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container(&mut self) -> &mut ::std::string::String {
        if self.container.is_none() {
            self.container = ::std::option::Option::Some(::std::string::String::new());
        }
        self.container.as_mut().unwrap()
    }

    // Take field
    pub fn take_container(&mut self) -> ::std::string::String {
        self.container.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool follow = 2;

    pub fn follow(&self) -> bool {
        self.follow.unwrap_or(false)
    }

    pub fn clear_follow(&mut self) {
        self.follow = ::std::option::Option::None;
    }

    pub fn has_follow(&self) -> bool {
        self.follow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_follow(&mut self, v: bool) {
        self.follow = ::std::option::Option::Some(v);
    }

    // optional bool previous = 3;

    pub fn previous(&self) -> bool {
        self.previous.unwrap_or(false)
    }

    pub fn clear_previous(&mut self) {
        self.previous = ::std::option::Option::None;
    }

    pub fn has_previous(&self) -> bool {
        self.previous.is_some()
    }

    // Param is passed by value, moved
    pub fn set_previous(&mut self, v: bool) {
        self.previous = ::std::option::Option::Some(v);
    }

    // optional int64 sinceSeconds = 4;

    pub fn sinceSeconds(&self) -> i64 {
        self.sinceSeconds.unwrap_or(0)
    }

    pub fn clear_sinceSeconds(&mut self) {
        self.sinceSeconds = ::std::option::Option::None;
    }

    pub fn has_sinceSeconds(&self) -> bool {
        self.sinceSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sinceSeconds(&mut self, v: i64) {
        self.sinceSeconds = ::std::option::Option::Some(v);
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time sinceTime = 5;

    pub fn sinceTime(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.sinceTime.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_sinceTime(&mut self) {
        self.sinceTime.clear();
    }

    pub fn has_sinceTime(&self) -> bool {
        self.sinceTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sinceTime(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::Time) {
        self.sinceTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sinceTime(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.sinceTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_sinceTime(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.sinceTime.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional bool timestamps = 6;

    pub fn timestamps(&self) -> bool {
        self.timestamps.unwrap_or(false)
    }

    pub fn clear_timestamps(&mut self) {
        self.timestamps = ::std::option::Option::None;
    }

    pub fn has_timestamps(&self) -> bool {
        self.timestamps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamps(&mut self, v: bool) {
        self.timestamps = ::std::option::Option::Some(v);
    }

    // optional int64 tailLines = 7;

    pub fn tailLines(&self) -> i64 {
        self.tailLines.unwrap_or(0)
    }

    pub fn clear_tailLines(&mut self) {
        self.tailLines = ::std::option::Option::None;
    }

    pub fn has_tailLines(&self) -> bool {
        self.tailLines.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tailLines(&mut self, v: i64) {
        self.tailLines = ::std::option::Option::Some(v);
    }

    // optional int64 limitBytes = 8;

    pub fn limitBytes(&self) -> i64 {
        self.limitBytes.unwrap_or(0)
    }

    pub fn clear_limitBytes(&mut self) {
        self.limitBytes = ::std::option::Option::None;
    }

    pub fn has_limitBytes(&self) -> bool {
        self.limitBytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limitBytes(&mut self, v: i64) {
        self.limitBytes = ::std::option::Option::Some(v);
    }

    // optional bool insecureSkipTLSVerifyBackend = 9;

    pub fn insecureSkipTLSVerifyBackend(&self) -> bool {
        self.insecureSkipTLSVerifyBackend.unwrap_or(false)
    }

    pub fn clear_insecureSkipTLSVerifyBackend(&mut self) {
        self.insecureSkipTLSVerifyBackend = ::std::option::Option::None;
    }

    pub fn has_insecureSkipTLSVerifyBackend(&self) -> bool {
        self.insecureSkipTLSVerifyBackend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_insecureSkipTLSVerifyBackend(&mut self, v: bool) {
        self.insecureSkipTLSVerifyBackend = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "container",
            |m: &PodLogOptions| { &m.container },
            |m: &mut PodLogOptions| { &mut m.container },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "follow",
            |m: &PodLogOptions| { &m.follow },
            |m: &mut PodLogOptions| { &mut m.follow },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "previous",
            |m: &PodLogOptions| { &m.previous },
            |m: &mut PodLogOptions| { &mut m.previous },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sinceSeconds",
            |m: &PodLogOptions| { &m.sinceSeconds },
            |m: &mut PodLogOptions| { &mut m.sinceSeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>(
            "sinceTime",
            |m: &PodLogOptions| { &m.sinceTime },
            |m: &mut PodLogOptions| { &mut m.sinceTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamps",
            |m: &PodLogOptions| { &m.timestamps },
            |m: &mut PodLogOptions| { &mut m.timestamps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tailLines",
            |m: &PodLogOptions| { &m.tailLines },
            |m: &mut PodLogOptions| { &mut m.tailLines },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "limitBytes",
            |m: &PodLogOptions| { &m.limitBytes },
            |m: &mut PodLogOptions| { &mut m.limitBytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "insecureSkipTLSVerifyBackend",
            |m: &PodLogOptions| { &m.insecureSkipTLSVerifyBackend },
            |m: &mut PodLogOptions| { &mut m.insecureSkipTLSVerifyBackend },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodLogOptions>(
            "PodLogOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodLogOptions {
    const NAME: &'static str = "PodLogOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.container = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.follow = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.previous = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.sinceSeconds = ::std::option::Option::Some(is.read_int64()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sinceTime)?;
                },
                48 => {
                    self.timestamps = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.tailLines = ::std::option::Option::Some(is.read_int64()?);
                },
                64 => {
                    self.limitBytes = ::std::option::Option::Some(is.read_int64()?);
                },
                72 => {
                    self.insecureSkipTLSVerifyBackend = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.container.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.follow {
            my_size += 1 + 1;
        }
        if let Some(v) = self.previous {
            my_size += 1 + 1;
        }
        if let Some(v) = self.sinceSeconds {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.sinceTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.timestamps {
            my_size += 1 + 1;
        }
        if let Some(v) = self.tailLines {
            my_size += ::protobuf::rt::int64_size(7, v);
        }
        if let Some(v) = self.limitBytes {
            my_size += ::protobuf::rt::int64_size(8, v);
        }
        if let Some(v) = self.insecureSkipTLSVerifyBackend {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.container.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.follow {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.previous {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.sinceSeconds {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.sinceTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.timestamps {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.tailLines {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.limitBytes {
            os.write_int64(8, v)?;
        }
        if let Some(v) = self.insecureSkipTLSVerifyBackend {
            os.write_bool(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodLogOptions {
        PodLogOptions::new()
    }

    fn clear(&mut self) {
        self.container = ::std::option::Option::None;
        self.follow = ::std::option::Option::None;
        self.previous = ::std::option::Option::None;
        self.sinceSeconds = ::std::option::Option::None;
        self.sinceTime.clear();
        self.timestamps = ::std::option::Option::None;
        self.tailLines = ::std::option::Option::None;
        self.limitBytes = ::std::option::Option::None;
        self.insecureSkipTLSVerifyBackend = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodLogOptions {
        static instance: PodLogOptions = PodLogOptions {
            container: ::std::option::Option::None,
            follow: ::std::option::Option::None,
            previous: ::std::option::Option::None,
            sinceSeconds: ::std::option::Option::None,
            sinceTime: ::protobuf::MessageField::none(),
            timestamps: ::std::option::Option::None,
            tailLines: ::std::option::Option::None,
            limitBytes: ::std::option::Option::None,
            insecureSkipTLSVerifyBackend: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodLogOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodLogOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodLogOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodLogOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodOS)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodOS {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.PodOS.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodOS.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodOS {
    fn default() -> &'a PodOS {
        <PodOS as ::protobuf::Message>::default_instance()
    }
}

impl PodOS {
    pub fn new() -> PodOS {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &PodOS| { &m.name },
            |m: &mut PodOS| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodOS>(
            "PodOS",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodOS {
    const NAME: &'static str = "PodOS";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodOS {
        PodOS::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodOS {
        static instance: PodOS = PodOS {
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodOS {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodOS").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodOS {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodOS {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodPortForwardOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodPortForwardOptions {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodPortForwardOptions.ports)
    pub ports: ::std::vec::Vec<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodPortForwardOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodPortForwardOptions {
    fn default() -> &'a PodPortForwardOptions {
        <PodPortForwardOptions as ::protobuf::Message>::default_instance()
    }
}

impl PodPortForwardOptions {
    pub fn new() -> PodPortForwardOptions {
        ::std::default::Default::default()
    }

    // repeated int32 ports = 1;

    pub fn ports(&self) -> &[i32] {
        &self.ports
    }

    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::std::vec::Vec<i32>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.ports, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ports",
            |m: &PodPortForwardOptions| { &m.ports },
            |m: &mut PodPortForwardOptions| { &mut m.ports },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodPortForwardOptions>(
            "PodPortForwardOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodPortForwardOptions {
    const NAME: &'static str = "PodPortForwardOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.ports)?;
                },
                8 => {
                    self.ports.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ports {
            my_size += ::protobuf::rt::int32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ports {
            os.write_int32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodPortForwardOptions {
        PodPortForwardOptions::new()
    }

    fn clear(&mut self) {
        self.ports.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodPortForwardOptions {
        static instance: PodPortForwardOptions = PodPortForwardOptions {
            ports: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodPortForwardOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodPortForwardOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodPortForwardOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodPortForwardOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodProxyOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodProxyOptions {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.PodProxyOptions.path)
    pub path: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodProxyOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodProxyOptions {
    fn default() -> &'a PodProxyOptions {
        <PodProxyOptions as ::protobuf::Message>::default_instance()
    }
}

impl PodProxyOptions {
    pub fn new() -> PodProxyOptions {
        ::std::default::Default::default()
    }

    // optional string path = 1;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &PodProxyOptions| { &m.path },
            |m: &mut PodProxyOptions| { &mut m.path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodProxyOptions>(
            "PodProxyOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodProxyOptions {
    const NAME: &'static str = "PodProxyOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.path.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodProxyOptions {
        PodProxyOptions::new()
    }

    fn clear(&mut self) {
        self.path = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodProxyOptions {
        static instance: PodProxyOptions = PodProxyOptions {
            path: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodProxyOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodProxyOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodProxyOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodProxyOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodReadinessGate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodReadinessGate {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.PodReadinessGate.conditionType)
    pub conditionType: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodReadinessGate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodReadinessGate {
    fn default() -> &'a PodReadinessGate {
        <PodReadinessGate as ::protobuf::Message>::default_instance()
    }
}

impl PodReadinessGate {
    pub fn new() -> PodReadinessGate {
        ::std::default::Default::default()
    }

    // optional string conditionType = 1;

    pub fn conditionType(&self) -> &str {
        match self.conditionType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_conditionType(&mut self) {
        self.conditionType = ::std::option::Option::None;
    }

    pub fn has_conditionType(&self) -> bool {
        self.conditionType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conditionType(&mut self, v: ::std::string::String) {
        self.conditionType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conditionType(&mut self) -> &mut ::std::string::String {
        if self.conditionType.is_none() {
            self.conditionType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.conditionType.as_mut().unwrap()
    }

    // Take field
    pub fn take_conditionType(&mut self) -> ::std::string::String {
        self.conditionType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "conditionType",
            |m: &PodReadinessGate| { &m.conditionType },
            |m: &mut PodReadinessGate| { &mut m.conditionType },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodReadinessGate>(
            "PodReadinessGate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodReadinessGate {
    const NAME: &'static str = "PodReadinessGate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.conditionType = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.conditionType.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.conditionType.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodReadinessGate {
        PodReadinessGate::new()
    }

    fn clear(&mut self) {
        self.conditionType = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodReadinessGate {
        static instance: PodReadinessGate = PodReadinessGate {
            conditionType: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodReadinessGate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodReadinessGate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodReadinessGate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodReadinessGate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodResourceClaim)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodResourceClaim {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.PodResourceClaim.name)
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodResourceClaim.source)
    pub source: ::protobuf::MessageField<ClaimSource>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodResourceClaim.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodResourceClaim {
    fn default() -> &'a PodResourceClaim {
        <PodResourceClaim as ::protobuf::Message>::default_instance()
    }
}

impl PodResourceClaim {
    pub fn new() -> PodResourceClaim {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.ClaimSource source = 2;

    pub fn source(&self) -> &ClaimSource {
        self.source.as_ref().unwrap_or_else(|| <ClaimSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ClaimSource) {
        self.source = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ClaimSource {
        self.source.mut_or_insert_default()
    }

    // Take field
    pub fn take_source(&mut self) -> ClaimSource {
        self.source.take().unwrap_or_else(|| ClaimSource::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &PodResourceClaim| { &m.name },
            |m: &mut PodResourceClaim| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ClaimSource>(
            "source",
            |m: &PodResourceClaim| { &m.source },
            |m: &mut PodResourceClaim| { &mut m.source },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodResourceClaim>(
            "PodResourceClaim",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodResourceClaim {
    const NAME: &'static str = "PodResourceClaim";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.source)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.source.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodResourceClaim {
        PodResourceClaim::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.source.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodResourceClaim {
        static instance: PodResourceClaim = PodResourceClaim {
            name: ::std::option::Option::None,
            source: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodResourceClaim {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodResourceClaim").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodResourceClaim {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodResourceClaim {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodResourceClaimStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodResourceClaimStatus {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.PodResourceClaimStatus.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PodResourceClaimStatus.resourceClaimName)
    pub resourceClaimName: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodResourceClaimStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodResourceClaimStatus {
    fn default() -> &'a PodResourceClaimStatus {
        <PodResourceClaimStatus as ::protobuf::Message>::default_instance()
    }
}

impl PodResourceClaimStatus {
    pub fn new() -> PodResourceClaimStatus {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resourceClaimName = 2;

    pub fn resourceClaimName(&self) -> &str {
        match self.resourceClaimName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resourceClaimName(&mut self) {
        self.resourceClaimName = ::std::option::Option::None;
    }

    pub fn has_resourceClaimName(&self) -> bool {
        self.resourceClaimName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceClaimName(&mut self, v: ::std::string::String) {
        self.resourceClaimName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceClaimName(&mut self) -> &mut ::std::string::String {
        if self.resourceClaimName.is_none() {
            self.resourceClaimName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resourceClaimName.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceClaimName(&mut self) -> ::std::string::String {
        self.resourceClaimName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &PodResourceClaimStatus| { &m.name },
            |m: &mut PodResourceClaimStatus| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resourceClaimName",
            |m: &PodResourceClaimStatus| { &m.resourceClaimName },
            |m: &mut PodResourceClaimStatus| { &mut m.resourceClaimName },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodResourceClaimStatus>(
            "PodResourceClaimStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodResourceClaimStatus {
    const NAME: &'static str = "PodResourceClaimStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.resourceClaimName = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.resourceClaimName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.resourceClaimName.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodResourceClaimStatus {
        PodResourceClaimStatus::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.resourceClaimName = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodResourceClaimStatus {
        static instance: PodResourceClaimStatus = PodResourceClaimStatus {
            name: ::std::option::Option::None,
            resourceClaimName: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodResourceClaimStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodResourceClaimStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodResourceClaimStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodResourceClaimStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodSchedulingGate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodSchedulingGate {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.PodSchedulingGate.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodSchedulingGate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodSchedulingGate {
    fn default() -> &'a PodSchedulingGate {
        <PodSchedulingGate as ::protobuf::Message>::default_instance()
    }
}

impl PodSchedulingGate {
    pub fn new() -> PodSchedulingGate {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &PodSchedulingGate| { &m.name },
            |m: &mut PodSchedulingGate| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodSchedulingGate>(
            "PodSchedulingGate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodSchedulingGate {
    const NAME: &'static str = "PodSchedulingGate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodSchedulingGate {
        PodSchedulingGate::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodSchedulingGate {
        static instance: PodSchedulingGate = PodSchedulingGate {
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodSchedulingGate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodSchedulingGate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodSchedulingGate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodSchedulingGate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodSecurityContext)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodSecurityContext {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodSecurityContext.seLinuxOptions)
    pub seLinuxOptions: ::protobuf::MessageField<SELinuxOptions>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodSecurityContext.windowsOptions)
    pub windowsOptions: ::protobuf::MessageField<WindowsSecurityContextOptions>,
    // @@protoc_insertion_point(field:api.core.v1.PodSecurityContext.runAsUser)
    pub runAsUser: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.core.v1.PodSecurityContext.runAsGroup)
    pub runAsGroup: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.core.v1.PodSecurityContext.runAsNonRoot)
    pub runAsNonRoot: ::std::option::Option<bool>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodSecurityContext.supplementalGroups)
    pub supplementalGroups: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:api.core.v1.PodSecurityContext.fsGroup)
    pub fsGroup: ::std::option::Option<i64>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodSecurityContext.sysctls)
    pub sysctls: ::std::vec::Vec<Sysctl>,
    // @@protoc_insertion_point(field:api.core.v1.PodSecurityContext.fsGroupChangePolicy)
    pub fsGroupChangePolicy: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodSecurityContext.seccompProfile)
    pub seccompProfile: ::protobuf::MessageField<SeccompProfile>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodSecurityContext.appArmorProfile)
    pub appArmorProfile: ::protobuf::MessageField<AppArmorProfile>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodSecurityContext.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodSecurityContext {
    fn default() -> &'a PodSecurityContext {
        <PodSecurityContext as ::protobuf::Message>::default_instance()
    }
}

impl PodSecurityContext {
    pub fn new() -> PodSecurityContext {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.SELinuxOptions seLinuxOptions = 1;

    pub fn seLinuxOptions(&self) -> &SELinuxOptions {
        self.seLinuxOptions.as_ref().unwrap_or_else(|| <SELinuxOptions as ::protobuf::Message>::default_instance())
    }

    pub fn clear_seLinuxOptions(&mut self) {
        self.seLinuxOptions.clear();
    }

    pub fn has_seLinuxOptions(&self) -> bool {
        self.seLinuxOptions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seLinuxOptions(&mut self, v: SELinuxOptions) {
        self.seLinuxOptions = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seLinuxOptions(&mut self) -> &mut SELinuxOptions {
        self.seLinuxOptions.mut_or_insert_default()
    }

    // Take field
    pub fn take_seLinuxOptions(&mut self) -> SELinuxOptions {
        self.seLinuxOptions.take().unwrap_or_else(|| SELinuxOptions::new())
    }

    // optional .api.core.v1.WindowsSecurityContextOptions windowsOptions = 8;

    pub fn windowsOptions(&self) -> &WindowsSecurityContextOptions {
        self.windowsOptions.as_ref().unwrap_or_else(|| <WindowsSecurityContextOptions as ::protobuf::Message>::default_instance())
    }

    pub fn clear_windowsOptions(&mut self) {
        self.windowsOptions.clear();
    }

    pub fn has_windowsOptions(&self) -> bool {
        self.windowsOptions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_windowsOptions(&mut self, v: WindowsSecurityContextOptions) {
        self.windowsOptions = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_windowsOptions(&mut self) -> &mut WindowsSecurityContextOptions {
        self.windowsOptions.mut_or_insert_default()
    }

    // Take field
    pub fn take_windowsOptions(&mut self) -> WindowsSecurityContextOptions {
        self.windowsOptions.take().unwrap_or_else(|| WindowsSecurityContextOptions::new())
    }

    // optional int64 runAsUser = 2;

    pub fn runAsUser(&self) -> i64 {
        self.runAsUser.unwrap_or(0)
    }

    pub fn clear_runAsUser(&mut self) {
        self.runAsUser = ::std::option::Option::None;
    }

    pub fn has_runAsUser(&self) -> bool {
        self.runAsUser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runAsUser(&mut self, v: i64) {
        self.runAsUser = ::std::option::Option::Some(v);
    }

    // optional int64 runAsGroup = 6;

    pub fn runAsGroup(&self) -> i64 {
        self.runAsGroup.unwrap_or(0)
    }

    pub fn clear_runAsGroup(&mut self) {
        self.runAsGroup = ::std::option::Option::None;
    }

    pub fn has_runAsGroup(&self) -> bool {
        self.runAsGroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runAsGroup(&mut self, v: i64) {
        self.runAsGroup = ::std::option::Option::Some(v);
    }

    // optional bool runAsNonRoot = 3;

    pub fn runAsNonRoot(&self) -> bool {
        self.runAsNonRoot.unwrap_or(false)
    }

    pub fn clear_runAsNonRoot(&mut self) {
        self.runAsNonRoot = ::std::option::Option::None;
    }

    pub fn has_runAsNonRoot(&self) -> bool {
        self.runAsNonRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runAsNonRoot(&mut self, v: bool) {
        self.runAsNonRoot = ::std::option::Option::Some(v);
    }

    // repeated int64 supplementalGroups = 4;

    pub fn supplementalGroups(&self) -> &[i64] {
        &self.supplementalGroups
    }

    pub fn clear_supplementalGroups(&mut self) {
        self.supplementalGroups.clear();
    }

    // Param is passed by value, moved
    pub fn set_supplementalGroups(&mut self, v: ::std::vec::Vec<i64>) {
        self.supplementalGroups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supplementalGroups(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.supplementalGroups
    }

    // Take field
    pub fn take_supplementalGroups(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.supplementalGroups, ::std::vec::Vec::new())
    }

    // optional int64 fsGroup = 5;

    pub fn fsGroup(&self) -> i64 {
        self.fsGroup.unwrap_or(0)
    }

    pub fn clear_fsGroup(&mut self) {
        self.fsGroup = ::std::option::Option::None;
    }

    pub fn has_fsGroup(&self) -> bool {
        self.fsGroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsGroup(&mut self, v: i64) {
        self.fsGroup = ::std::option::Option::Some(v);
    }

    // repeated .api.core.v1.Sysctl sysctls = 7;

    pub fn sysctls(&self) -> &[Sysctl] {
        &self.sysctls
    }

    pub fn clear_sysctls(&mut self) {
        self.sysctls.clear();
    }

    // Param is passed by value, moved
    pub fn set_sysctls(&mut self, v: ::std::vec::Vec<Sysctl>) {
        self.sysctls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sysctls(&mut self) -> &mut ::std::vec::Vec<Sysctl> {
        &mut self.sysctls
    }

    // Take field
    pub fn take_sysctls(&mut self) -> ::std::vec::Vec<Sysctl> {
        ::std::mem::replace(&mut self.sysctls, ::std::vec::Vec::new())
    }

    // optional string fsGroupChangePolicy = 9;

    pub fn fsGroupChangePolicy(&self) -> &str {
        match self.fsGroupChangePolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fsGroupChangePolicy(&mut self) {
        self.fsGroupChangePolicy = ::std::option::Option::None;
    }

    pub fn has_fsGroupChangePolicy(&self) -> bool {
        self.fsGroupChangePolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsGroupChangePolicy(&mut self, v: ::std::string::String) {
        self.fsGroupChangePolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsGroupChangePolicy(&mut self) -> &mut ::std::string::String {
        if self.fsGroupChangePolicy.is_none() {
            self.fsGroupChangePolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fsGroupChangePolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsGroupChangePolicy(&mut self) -> ::std::string::String {
        self.fsGroupChangePolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.SeccompProfile seccompProfile = 10;

    pub fn seccompProfile(&self) -> &SeccompProfile {
        self.seccompProfile.as_ref().unwrap_or_else(|| <SeccompProfile as ::protobuf::Message>::default_instance())
    }

    pub fn clear_seccompProfile(&mut self) {
        self.seccompProfile.clear();
    }

    pub fn has_seccompProfile(&self) -> bool {
        self.seccompProfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seccompProfile(&mut self, v: SeccompProfile) {
        self.seccompProfile = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seccompProfile(&mut self) -> &mut SeccompProfile {
        self.seccompProfile.mut_or_insert_default()
    }

    // Take field
    pub fn take_seccompProfile(&mut self) -> SeccompProfile {
        self.seccompProfile.take().unwrap_or_else(|| SeccompProfile::new())
    }

    // optional .api.core.v1.AppArmorProfile appArmorProfile = 11;

    pub fn appArmorProfile(&self) -> &AppArmorProfile {
        self.appArmorProfile.as_ref().unwrap_or_else(|| <AppArmorProfile as ::protobuf::Message>::default_instance())
    }

    pub fn clear_appArmorProfile(&mut self) {
        self.appArmorProfile.clear();
    }

    pub fn has_appArmorProfile(&self) -> bool {
        self.appArmorProfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appArmorProfile(&mut self, v: AppArmorProfile) {
        self.appArmorProfile = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appArmorProfile(&mut self) -> &mut AppArmorProfile {
        self.appArmorProfile.mut_or_insert_default()
    }

    // Take field
    pub fn take_appArmorProfile(&mut self) -> AppArmorProfile {
        self.appArmorProfile.take().unwrap_or_else(|| AppArmorProfile::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SELinuxOptions>(
            "seLinuxOptions",
            |m: &PodSecurityContext| { &m.seLinuxOptions },
            |m: &mut PodSecurityContext| { &mut m.seLinuxOptions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WindowsSecurityContextOptions>(
            "windowsOptions",
            |m: &PodSecurityContext| { &m.windowsOptions },
            |m: &mut PodSecurityContext| { &mut m.windowsOptions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "runAsUser",
            |m: &PodSecurityContext| { &m.runAsUser },
            |m: &mut PodSecurityContext| { &mut m.runAsUser },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "runAsGroup",
            |m: &PodSecurityContext| { &m.runAsGroup },
            |m: &mut PodSecurityContext| { &mut m.runAsGroup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "runAsNonRoot",
            |m: &PodSecurityContext| { &m.runAsNonRoot },
            |m: &mut PodSecurityContext| { &mut m.runAsNonRoot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supplementalGroups",
            |m: &PodSecurityContext| { &m.supplementalGroups },
            |m: &mut PodSecurityContext| { &mut m.supplementalGroups },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsGroup",
            |m: &PodSecurityContext| { &m.fsGroup },
            |m: &mut PodSecurityContext| { &mut m.fsGroup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sysctls",
            |m: &PodSecurityContext| { &m.sysctls },
            |m: &mut PodSecurityContext| { &mut m.sysctls },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsGroupChangePolicy",
            |m: &PodSecurityContext| { &m.fsGroupChangePolicy },
            |m: &mut PodSecurityContext| { &mut m.fsGroupChangePolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SeccompProfile>(
            "seccompProfile",
            |m: &PodSecurityContext| { &m.seccompProfile },
            |m: &mut PodSecurityContext| { &mut m.seccompProfile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AppArmorProfile>(
            "appArmorProfile",
            |m: &PodSecurityContext| { &m.appArmorProfile },
            |m: &mut PodSecurityContext| { &mut m.appArmorProfile },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodSecurityContext>(
            "PodSecurityContext",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodSecurityContext {
    const NAME: &'static str = "PodSecurityContext";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.seLinuxOptions)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.windowsOptions)?;
                },
                16 => {
                    self.runAsUser = ::std::option::Option::Some(is.read_int64()?);
                },
                48 => {
                    self.runAsGroup = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.runAsNonRoot = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    is.read_repeated_packed_int64_into(&mut self.supplementalGroups)?;
                },
                32 => {
                    self.supplementalGroups.push(is.read_int64()?);
                },
                40 => {
                    self.fsGroup = ::std::option::Option::Some(is.read_int64()?);
                },
                58 => {
                    self.sysctls.push(is.read_message()?);
                },
                74 => {
                    self.fsGroupChangePolicy = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.seccompProfile)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.appArmorProfile)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.seLinuxOptions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.windowsOptions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.runAsUser {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.runAsGroup {
            my_size += ::protobuf::rt::int64_size(6, v);
        }
        if let Some(v) = self.runAsNonRoot {
            my_size += 1 + 1;
        }
        for value in &self.supplementalGroups {
            my_size += ::protobuf::rt::int64_size(4, *value);
        };
        if let Some(v) = self.fsGroup {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        for value in &self.sysctls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.fsGroupChangePolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.seccompProfile.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.appArmorProfile.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.seLinuxOptions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.windowsOptions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.runAsUser {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.runAsGroup {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.runAsNonRoot {
            os.write_bool(3, v)?;
        }
        for v in &self.supplementalGroups {
            os.write_int64(4, *v)?;
        };
        if let Some(v) = self.fsGroup {
            os.write_int64(5, v)?;
        }
        for v in &self.sysctls {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.fsGroupChangePolicy.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.seccompProfile.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.appArmorProfile.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodSecurityContext {
        PodSecurityContext::new()
    }

    fn clear(&mut self) {
        self.seLinuxOptions.clear();
        self.windowsOptions.clear();
        self.runAsUser = ::std::option::Option::None;
        self.runAsGroup = ::std::option::Option::None;
        self.runAsNonRoot = ::std::option::Option::None;
        self.supplementalGroups.clear();
        self.fsGroup = ::std::option::Option::None;
        self.sysctls.clear();
        self.fsGroupChangePolicy = ::std::option::Option::None;
        self.seccompProfile.clear();
        self.appArmorProfile.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodSecurityContext {
        static instance: PodSecurityContext = PodSecurityContext {
            seLinuxOptions: ::protobuf::MessageField::none(),
            windowsOptions: ::protobuf::MessageField::none(),
            runAsUser: ::std::option::Option::None,
            runAsGroup: ::std::option::Option::None,
            runAsNonRoot: ::std::option::Option::None,
            supplementalGroups: ::std::vec::Vec::new(),
            fsGroup: ::std::option::Option::None,
            sysctls: ::std::vec::Vec::new(),
            fsGroupChangePolicy: ::std::option::Option::None,
            seccompProfile: ::protobuf::MessageField::none(),
            appArmorProfile: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodSecurityContext {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodSecurityContext").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodSecurityContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodSecurityContext {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodSignature)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodSignature {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodSignature.podController)
    pub podController: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::OwnerReference>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodSignature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodSignature {
    fn default() -> &'a PodSignature {
        <PodSignature as ::protobuf::Message>::default_instance()
    }
}

impl PodSignature {
    pub fn new() -> PodSignature {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.OwnerReference podController = 1;

    pub fn podController(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::OwnerReference {
        self.podController.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::OwnerReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_podController(&mut self) {
        self.podController.clear();
    }

    pub fn has_podController(&self) -> bool {
        self.podController.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podController(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::OwnerReference) {
        self.podController = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podController(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::OwnerReference {
        self.podController.mut_or_insert_default()
    }

    // Take field
    pub fn take_podController(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::OwnerReference {
        self.podController.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::OwnerReference::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::OwnerReference>(
            "podController",
            |m: &PodSignature| { &m.podController },
            |m: &mut PodSignature| { &mut m.podController },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodSignature>(
            "PodSignature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodSignature {
    const NAME: &'static str = "PodSignature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.podController)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.podController.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.podController.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodSignature {
        PodSignature::new()
    }

    fn clear(&mut self) {
        self.podController.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodSignature {
        static instance: PodSignature = PodSignature {
            podController: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodSignature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodSignature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodSignature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodSpec {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.volumes)
    pub volumes: ::std::vec::Vec<Volume>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.initContainers)
    pub initContainers: ::std::vec::Vec<Container>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.containers)
    pub containers: ::std::vec::Vec<Container>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.ephemeralContainers)
    pub ephemeralContainers: ::std::vec::Vec<EphemeralContainer>,
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.restartPolicy)
    pub restartPolicy: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.terminationGracePeriodSeconds)
    pub terminationGracePeriodSeconds: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.activeDeadlineSeconds)
    pub activeDeadlineSeconds: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.dnsPolicy)
    pub dnsPolicy: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.nodeSelector)
    pub nodeSelector: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.serviceAccountName)
    pub serviceAccountName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.serviceAccount)
    pub serviceAccount: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.automountServiceAccountToken)
    pub automountServiceAccountToken: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.nodeName)
    pub nodeName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.hostNetwork)
    pub hostNetwork: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.hostPID)
    pub hostPID: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.hostIPC)
    pub hostIPC: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.shareProcessNamespace)
    pub shareProcessNamespace: ::std::option::Option<bool>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.securityContext)
    pub securityContext: ::protobuf::MessageField<PodSecurityContext>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.imagePullSecrets)
    pub imagePullSecrets: ::std::vec::Vec<LocalObjectReference>,
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.hostname)
    pub hostname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.subdomain)
    pub subdomain: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.affinity)
    pub affinity: ::protobuf::MessageField<Affinity>,
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.schedulerName)
    pub schedulerName: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.tolerations)
    pub tolerations: ::std::vec::Vec<Toleration>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.hostAliases)
    pub hostAliases: ::std::vec::Vec<HostAlias>,
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.priorityClassName)
    pub priorityClassName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.priority)
    pub priority: ::std::option::Option<i32>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.dnsConfig)
    pub dnsConfig: ::protobuf::MessageField<PodDNSConfig>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.readinessGates)
    pub readinessGates: ::std::vec::Vec<PodReadinessGate>,
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.runtimeClassName)
    pub runtimeClassName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.enableServiceLinks)
    pub enableServiceLinks: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.preemptionPolicy)
    pub preemptionPolicy: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.overhead)
    pub overhead: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.topologySpreadConstraints)
    pub topologySpreadConstraints: ::std::vec::Vec<TopologySpreadConstraint>,
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.setHostnameAsFQDN)
    pub setHostnameAsFQDN: ::std::option::Option<bool>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.os)
    pub os: ::protobuf::MessageField<PodOS>,
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.hostUsers)
    pub hostUsers: ::std::option::Option<bool>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.schedulingGates)
    pub schedulingGates: ::std::vec::Vec<PodSchedulingGate>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodSpec.resourceClaims)
    pub resourceClaims: ::std::vec::Vec<PodResourceClaim>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodSpec {
    fn default() -> &'a PodSpec {
        <PodSpec as ::protobuf::Message>::default_instance()
    }
}

impl PodSpec {
    pub fn new() -> PodSpec {
        ::std::default::Default::default()
    }

    // repeated .api.core.v1.Volume volumes = 1;

    pub fn volumes(&self) -> &[Volume] {
        &self.volumes
    }

    pub fn clear_volumes(&mut self) {
        self.volumes.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumes(&mut self, v: ::std::vec::Vec<Volume>) {
        self.volumes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumes(&mut self) -> &mut ::std::vec::Vec<Volume> {
        &mut self.volumes
    }

    // Take field
    pub fn take_volumes(&mut self) -> ::std::vec::Vec<Volume> {
        ::std::mem::replace(&mut self.volumes, ::std::vec::Vec::new())
    }

    // repeated .api.core.v1.Container initContainers = 20;

    pub fn initContainers(&self) -> &[Container] {
        &self.initContainers
    }

    pub fn clear_initContainers(&mut self) {
        self.initContainers.clear();
    }

    // Param is passed by value, moved
    pub fn set_initContainers(&mut self, v: ::std::vec::Vec<Container>) {
        self.initContainers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_initContainers(&mut self) -> &mut ::std::vec::Vec<Container> {
        &mut self.initContainers
    }

    // Take field
    pub fn take_initContainers(&mut self) -> ::std::vec::Vec<Container> {
        ::std::mem::replace(&mut self.initContainers, ::std::vec::Vec::new())
    }

    // repeated .api.core.v1.Container containers = 2;

    pub fn containers(&self) -> &[Container] {
        &self.containers
    }

    pub fn clear_containers(&mut self) {
        self.containers.clear();
    }

    // Param is passed by value, moved
    pub fn set_containers(&mut self, v: ::std::vec::Vec<Container>) {
        self.containers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_containers(&mut self) -> &mut ::std::vec::Vec<Container> {
        &mut self.containers
    }

    // Take field
    pub fn take_containers(&mut self) -> ::std::vec::Vec<Container> {
        ::std::mem::replace(&mut self.containers, ::std::vec::Vec::new())
    }

    // repeated .api.core.v1.EphemeralContainer ephemeralContainers = 34;

    pub fn ephemeralContainers(&self) -> &[EphemeralContainer] {
        &self.ephemeralContainers
    }

    pub fn clear_ephemeralContainers(&mut self) {
        self.ephemeralContainers.clear();
    }

    // Param is passed by value, moved
    pub fn set_ephemeralContainers(&mut self, v: ::std::vec::Vec<EphemeralContainer>) {
        self.ephemeralContainers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ephemeralContainers(&mut self) -> &mut ::std::vec::Vec<EphemeralContainer> {
        &mut self.ephemeralContainers
    }

    // Take field
    pub fn take_ephemeralContainers(&mut self) -> ::std::vec::Vec<EphemeralContainer> {
        ::std::mem::replace(&mut self.ephemeralContainers, ::std::vec::Vec::new())
    }

    // optional string restartPolicy = 3;

    pub fn restartPolicy(&self) -> &str {
        match self.restartPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_restartPolicy(&mut self) {
        self.restartPolicy = ::std::option::Option::None;
    }

    pub fn has_restartPolicy(&self) -> bool {
        self.restartPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_restartPolicy(&mut self, v: ::std::string::String) {
        self.restartPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_restartPolicy(&mut self) -> &mut ::std::string::String {
        if self.restartPolicy.is_none() {
            self.restartPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.restartPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_restartPolicy(&mut self) -> ::std::string::String {
        self.restartPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 terminationGracePeriodSeconds = 4;

    pub fn terminationGracePeriodSeconds(&self) -> i64 {
        self.terminationGracePeriodSeconds.unwrap_or(0)
    }

    pub fn clear_terminationGracePeriodSeconds(&mut self) {
        self.terminationGracePeriodSeconds = ::std::option::Option::None;
    }

    pub fn has_terminationGracePeriodSeconds(&self) -> bool {
        self.terminationGracePeriodSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_terminationGracePeriodSeconds(&mut self, v: i64) {
        self.terminationGracePeriodSeconds = ::std::option::Option::Some(v);
    }

    // optional int64 activeDeadlineSeconds = 5;

    pub fn activeDeadlineSeconds(&self) -> i64 {
        self.activeDeadlineSeconds.unwrap_or(0)
    }

    pub fn clear_activeDeadlineSeconds(&mut self) {
        self.activeDeadlineSeconds = ::std::option::Option::None;
    }

    pub fn has_activeDeadlineSeconds(&self) -> bool {
        self.activeDeadlineSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activeDeadlineSeconds(&mut self, v: i64) {
        self.activeDeadlineSeconds = ::std::option::Option::Some(v);
    }

    // optional string dnsPolicy = 6;

    pub fn dnsPolicy(&self) -> &str {
        match self.dnsPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_dnsPolicy(&mut self) {
        self.dnsPolicy = ::std::option::Option::None;
    }

    pub fn has_dnsPolicy(&self) -> bool {
        self.dnsPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dnsPolicy(&mut self, v: ::std::string::String) {
        self.dnsPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dnsPolicy(&mut self) -> &mut ::std::string::String {
        if self.dnsPolicy.is_none() {
            self.dnsPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.dnsPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_dnsPolicy(&mut self) -> ::std::string::String {
        self.dnsPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.core.v1.PodSpec.NodeSelectorEntry nodeSelector = 7;

    pub fn nodeSelector(&self) -> &::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &self.nodeSelector
    }

    pub fn clear_nodeSelector(&mut self) {
        self.nodeSelector.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodeSelector(&mut self, v: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
        self.nodeSelector = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodeSelector(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &mut self.nodeSelector
    }

    // Take field
    pub fn take_nodeSelector(&mut self) -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.nodeSelector, ::std::collections::BTreeMap::new())
    }

    // optional string serviceAccountName = 8;

    pub fn serviceAccountName(&self) -> &str {
        match self.serviceAccountName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_serviceAccountName(&mut self) {
        self.serviceAccountName = ::std::option::Option::None;
    }

    pub fn has_serviceAccountName(&self) -> bool {
        self.serviceAccountName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serviceAccountName(&mut self, v: ::std::string::String) {
        self.serviceAccountName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serviceAccountName(&mut self) -> &mut ::std::string::String {
        if self.serviceAccountName.is_none() {
            self.serviceAccountName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.serviceAccountName.as_mut().unwrap()
    }

    // Take field
    pub fn take_serviceAccountName(&mut self) -> ::std::string::String {
        self.serviceAccountName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string serviceAccount = 9;

    pub fn serviceAccount(&self) -> &str {
        match self.serviceAccount.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_serviceAccount(&mut self) {
        self.serviceAccount = ::std::option::Option::None;
    }

    pub fn has_serviceAccount(&self) -> bool {
        self.serviceAccount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serviceAccount(&mut self, v: ::std::string::String) {
        self.serviceAccount = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serviceAccount(&mut self) -> &mut ::std::string::String {
        if self.serviceAccount.is_none() {
            self.serviceAccount = ::std::option::Option::Some(::std::string::String::new());
        }
        self.serviceAccount.as_mut().unwrap()
    }

    // Take field
    pub fn take_serviceAccount(&mut self) -> ::std::string::String {
        self.serviceAccount.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool automountServiceAccountToken = 21;

    pub fn automountServiceAccountToken(&self) -> bool {
        self.automountServiceAccountToken.unwrap_or(false)
    }

    pub fn clear_automountServiceAccountToken(&mut self) {
        self.automountServiceAccountToken = ::std::option::Option::None;
    }

    pub fn has_automountServiceAccountToken(&self) -> bool {
        self.automountServiceAccountToken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_automountServiceAccountToken(&mut self, v: bool) {
        self.automountServiceAccountToken = ::std::option::Option::Some(v);
    }

    // optional string nodeName = 10;

    pub fn nodeName(&self) -> &str {
        match self.nodeName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nodeName(&mut self) {
        self.nodeName = ::std::option::Option::None;
    }

    pub fn has_nodeName(&self) -> bool {
        self.nodeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeName(&mut self, v: ::std::string::String) {
        self.nodeName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeName(&mut self) -> &mut ::std::string::String {
        if self.nodeName.is_none() {
            self.nodeName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.nodeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodeName(&mut self) -> ::std::string::String {
        self.nodeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool hostNetwork = 11;

    pub fn hostNetwork(&self) -> bool {
        self.hostNetwork.unwrap_or(false)
    }

    pub fn clear_hostNetwork(&mut self) {
        self.hostNetwork = ::std::option::Option::None;
    }

    pub fn has_hostNetwork(&self) -> bool {
        self.hostNetwork.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostNetwork(&mut self, v: bool) {
        self.hostNetwork = ::std::option::Option::Some(v);
    }

    // optional bool hostPID = 12;

    pub fn hostPID(&self) -> bool {
        self.hostPID.unwrap_or(false)
    }

    pub fn clear_hostPID(&mut self) {
        self.hostPID = ::std::option::Option::None;
    }

    pub fn has_hostPID(&self) -> bool {
        self.hostPID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostPID(&mut self, v: bool) {
        self.hostPID = ::std::option::Option::Some(v);
    }

    // optional bool hostIPC = 13;

    pub fn hostIPC(&self) -> bool {
        self.hostIPC.unwrap_or(false)
    }

    pub fn clear_hostIPC(&mut self) {
        self.hostIPC = ::std::option::Option::None;
    }

    pub fn has_hostIPC(&self) -> bool {
        self.hostIPC.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostIPC(&mut self, v: bool) {
        self.hostIPC = ::std::option::Option::Some(v);
    }

    // optional bool shareProcessNamespace = 27;

    pub fn shareProcessNamespace(&self) -> bool {
        self.shareProcessNamespace.unwrap_or(false)
    }

    pub fn clear_shareProcessNamespace(&mut self) {
        self.shareProcessNamespace = ::std::option::Option::None;
    }

    pub fn has_shareProcessNamespace(&self) -> bool {
        self.shareProcessNamespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shareProcessNamespace(&mut self, v: bool) {
        self.shareProcessNamespace = ::std::option::Option::Some(v);
    }

    // optional .api.core.v1.PodSecurityContext securityContext = 14;

    pub fn securityContext(&self) -> &PodSecurityContext {
        self.securityContext.as_ref().unwrap_or_else(|| <PodSecurityContext as ::protobuf::Message>::default_instance())
    }

    pub fn clear_securityContext(&mut self) {
        self.securityContext.clear();
    }

    pub fn has_securityContext(&self) -> bool {
        self.securityContext.is_some()
    }

    // Param is passed by value, moved
    pub fn set_securityContext(&mut self, v: PodSecurityContext) {
        self.securityContext = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_securityContext(&mut self) -> &mut PodSecurityContext {
        self.securityContext.mut_or_insert_default()
    }

    // Take field
    pub fn take_securityContext(&mut self) -> PodSecurityContext {
        self.securityContext.take().unwrap_or_else(|| PodSecurityContext::new())
    }

    // repeated .api.core.v1.LocalObjectReference imagePullSecrets = 15;

    pub fn imagePullSecrets(&self) -> &[LocalObjectReference] {
        &self.imagePullSecrets
    }

    pub fn clear_imagePullSecrets(&mut self) {
        self.imagePullSecrets.clear();
    }

    // Param is passed by value, moved
    pub fn set_imagePullSecrets(&mut self, v: ::std::vec::Vec<LocalObjectReference>) {
        self.imagePullSecrets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_imagePullSecrets(&mut self) -> &mut ::std::vec::Vec<LocalObjectReference> {
        &mut self.imagePullSecrets
    }

    // Take field
    pub fn take_imagePullSecrets(&mut self) -> ::std::vec::Vec<LocalObjectReference> {
        ::std::mem::replace(&mut self.imagePullSecrets, ::std::vec::Vec::new())
    }

    // optional string hostname = 16;

    pub fn hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hostname(&mut self) {
        self.hostname = ::std::option::Option::None;
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string subdomain = 17;

    pub fn subdomain(&self) -> &str {
        match self.subdomain.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_subdomain(&mut self) {
        self.subdomain = ::std::option::Option::None;
    }

    pub fn has_subdomain(&self) -> bool {
        self.subdomain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subdomain(&mut self, v: ::std::string::String) {
        self.subdomain = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subdomain(&mut self) -> &mut ::std::string::String {
        if self.subdomain.is_none() {
            self.subdomain = ::std::option::Option::Some(::std::string::String::new());
        }
        self.subdomain.as_mut().unwrap()
    }

    // Take field
    pub fn take_subdomain(&mut self) -> ::std::string::String {
        self.subdomain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.Affinity affinity = 18;

    pub fn affinity(&self) -> &Affinity {
        self.affinity.as_ref().unwrap_or_else(|| <Affinity as ::protobuf::Message>::default_instance())
    }

    pub fn clear_affinity(&mut self) {
        self.affinity.clear();
    }

    pub fn has_affinity(&self) -> bool {
        self.affinity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_affinity(&mut self, v: Affinity) {
        self.affinity = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_affinity(&mut self) -> &mut Affinity {
        self.affinity.mut_or_insert_default()
    }

    // Take field
    pub fn take_affinity(&mut self) -> Affinity {
        self.affinity.take().unwrap_or_else(|| Affinity::new())
    }

    // optional string schedulerName = 19;

    pub fn schedulerName(&self) -> &str {
        match self.schedulerName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_schedulerName(&mut self) {
        self.schedulerName = ::std::option::Option::None;
    }

    pub fn has_schedulerName(&self) -> bool {
        self.schedulerName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schedulerName(&mut self, v: ::std::string::String) {
        self.schedulerName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schedulerName(&mut self) -> &mut ::std::string::String {
        if self.schedulerName.is_none() {
            self.schedulerName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.schedulerName.as_mut().unwrap()
    }

    // Take field
    pub fn take_schedulerName(&mut self) -> ::std::string::String {
        self.schedulerName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.core.v1.Toleration tolerations = 22;

    pub fn tolerations(&self) -> &[Toleration] {
        &self.tolerations
    }

    pub fn clear_tolerations(&mut self) {
        self.tolerations.clear();
    }

    // Param is passed by value, moved
    pub fn set_tolerations(&mut self, v: ::std::vec::Vec<Toleration>) {
        self.tolerations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tolerations(&mut self) -> &mut ::std::vec::Vec<Toleration> {
        &mut self.tolerations
    }

    // Take field
    pub fn take_tolerations(&mut self) -> ::std::vec::Vec<Toleration> {
        ::std::mem::replace(&mut self.tolerations, ::std::vec::Vec::new())
    }

    // repeated .api.core.v1.HostAlias hostAliases = 23;

    pub fn hostAliases(&self) -> &[HostAlias] {
        &self.hostAliases
    }

    pub fn clear_hostAliases(&mut self) {
        self.hostAliases.clear();
    }

    // Param is passed by value, moved
    pub fn set_hostAliases(&mut self, v: ::std::vec::Vec<HostAlias>) {
        self.hostAliases = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hostAliases(&mut self) -> &mut ::std::vec::Vec<HostAlias> {
        &mut self.hostAliases
    }

    // Take field
    pub fn take_hostAliases(&mut self) -> ::std::vec::Vec<HostAlias> {
        ::std::mem::replace(&mut self.hostAliases, ::std::vec::Vec::new())
    }

    // optional string priorityClassName = 24;

    pub fn priorityClassName(&self) -> &str {
        match self.priorityClassName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_priorityClassName(&mut self) {
        self.priorityClassName = ::std::option::Option::None;
    }

    pub fn has_priorityClassName(&self) -> bool {
        self.priorityClassName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priorityClassName(&mut self, v: ::std::string::String) {
        self.priorityClassName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_priorityClassName(&mut self) -> &mut ::std::string::String {
        if self.priorityClassName.is_none() {
            self.priorityClassName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.priorityClassName.as_mut().unwrap()
    }

    // Take field
    pub fn take_priorityClassName(&mut self) -> ::std::string::String {
        self.priorityClassName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 priority = 25;

    pub fn priority(&self) -> i32 {
        self.priority.unwrap_or(0)
    }

    pub fn clear_priority(&mut self) {
        self.priority = ::std::option::Option::None;
    }

    pub fn has_priority(&self) -> bool {
        self.priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: i32) {
        self.priority = ::std::option::Option::Some(v);
    }

    // optional .api.core.v1.PodDNSConfig dnsConfig = 26;

    pub fn dnsConfig(&self) -> &PodDNSConfig {
        self.dnsConfig.as_ref().unwrap_or_else(|| <PodDNSConfig as ::protobuf::Message>::default_instance())
    }

    pub fn clear_dnsConfig(&mut self) {
        self.dnsConfig.clear();
    }

    pub fn has_dnsConfig(&self) -> bool {
        self.dnsConfig.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dnsConfig(&mut self, v: PodDNSConfig) {
        self.dnsConfig = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dnsConfig(&mut self) -> &mut PodDNSConfig {
        self.dnsConfig.mut_or_insert_default()
    }

    // Take field
    pub fn take_dnsConfig(&mut self) -> PodDNSConfig {
        self.dnsConfig.take().unwrap_or_else(|| PodDNSConfig::new())
    }

    // repeated .api.core.v1.PodReadinessGate readinessGates = 28;

    pub fn readinessGates(&self) -> &[PodReadinessGate] {
        &self.readinessGates
    }

    pub fn clear_readinessGates(&mut self) {
        self.readinessGates.clear();
    }

    // Param is passed by value, moved
    pub fn set_readinessGates(&mut self, v: ::std::vec::Vec<PodReadinessGate>) {
        self.readinessGates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_readinessGates(&mut self) -> &mut ::std::vec::Vec<PodReadinessGate> {
        &mut self.readinessGates
    }

    // Take field
    pub fn take_readinessGates(&mut self) -> ::std::vec::Vec<PodReadinessGate> {
        ::std::mem::replace(&mut self.readinessGates, ::std::vec::Vec::new())
    }

    // optional string runtimeClassName = 29;

    pub fn runtimeClassName(&self) -> &str {
        match self.runtimeClassName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_runtimeClassName(&mut self) {
        self.runtimeClassName = ::std::option::Option::None;
    }

    pub fn has_runtimeClassName(&self) -> bool {
        self.runtimeClassName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runtimeClassName(&mut self, v: ::std::string::String) {
        self.runtimeClassName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtimeClassName(&mut self) -> &mut ::std::string::String {
        if self.runtimeClassName.is_none() {
            self.runtimeClassName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.runtimeClassName.as_mut().unwrap()
    }

    // Take field
    pub fn take_runtimeClassName(&mut self) -> ::std::string::String {
        self.runtimeClassName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool enableServiceLinks = 30;

    pub fn enableServiceLinks(&self) -> bool {
        self.enableServiceLinks.unwrap_or(false)
    }

    pub fn clear_enableServiceLinks(&mut self) {
        self.enableServiceLinks = ::std::option::Option::None;
    }

    pub fn has_enableServiceLinks(&self) -> bool {
        self.enableServiceLinks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enableServiceLinks(&mut self, v: bool) {
        self.enableServiceLinks = ::std::option::Option::Some(v);
    }

    // optional string preemptionPolicy = 31;

    pub fn preemptionPolicy(&self) -> &str {
        match self.preemptionPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_preemptionPolicy(&mut self) {
        self.preemptionPolicy = ::std::option::Option::None;
    }

    pub fn has_preemptionPolicy(&self) -> bool {
        self.preemptionPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preemptionPolicy(&mut self, v: ::std::string::String) {
        self.preemptionPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preemptionPolicy(&mut self) -> &mut ::std::string::String {
        if self.preemptionPolicy.is_none() {
            self.preemptionPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.preemptionPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_preemptionPolicy(&mut self) -> ::std::string::String {
        self.preemptionPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.core.v1.PodSpec.OverheadEntry overhead = 32;

    pub fn overhead(&self) -> &::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &self.overhead
    }

    pub fn clear_overhead(&mut self) {
        self.overhead.clear();
    }

    // Param is passed by value, moved
    pub fn set_overhead(&mut self, v: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>) {
        self.overhead = v;
    }

    // Mutable pointer to the field.
    pub fn mut_overhead(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &mut self.overhead
    }

    // Take field
    pub fn take_overhead(&mut self) -> ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        ::std::mem::replace(&mut self.overhead, ::std::collections::BTreeMap::new())
    }

    // repeated .api.core.v1.TopologySpreadConstraint topologySpreadConstraints = 33;

    pub fn topologySpreadConstraints(&self) -> &[TopologySpreadConstraint] {
        &self.topologySpreadConstraints
    }

    pub fn clear_topologySpreadConstraints(&mut self) {
        self.topologySpreadConstraints.clear();
    }

    // Param is passed by value, moved
    pub fn set_topologySpreadConstraints(&mut self, v: ::std::vec::Vec<TopologySpreadConstraint>) {
        self.topologySpreadConstraints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_topologySpreadConstraints(&mut self) -> &mut ::std::vec::Vec<TopologySpreadConstraint> {
        &mut self.topologySpreadConstraints
    }

    // Take field
    pub fn take_topologySpreadConstraints(&mut self) -> ::std::vec::Vec<TopologySpreadConstraint> {
        ::std::mem::replace(&mut self.topologySpreadConstraints, ::std::vec::Vec::new())
    }

    // optional bool setHostnameAsFQDN = 35;

    pub fn setHostnameAsFQDN(&self) -> bool {
        self.setHostnameAsFQDN.unwrap_or(false)
    }

    pub fn clear_setHostnameAsFQDN(&mut self) {
        self.setHostnameAsFQDN = ::std::option::Option::None;
    }

    pub fn has_setHostnameAsFQDN(&self) -> bool {
        self.setHostnameAsFQDN.is_some()
    }

    // Param is passed by value, moved
    pub fn set_setHostnameAsFQDN(&mut self, v: bool) {
        self.setHostnameAsFQDN = ::std::option::Option::Some(v);
    }

    // optional .api.core.v1.PodOS os = 36;

    pub fn os(&self) -> &PodOS {
        self.os.as_ref().unwrap_or_else(|| <PodOS as ::protobuf::Message>::default_instance())
    }

    pub fn clear_os(&mut self) {
        self.os.clear();
    }

    pub fn has_os(&self) -> bool {
        self.os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os(&mut self, v: PodOS) {
        self.os = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os(&mut self) -> &mut PodOS {
        self.os.mut_or_insert_default()
    }

    // Take field
    pub fn take_os(&mut self) -> PodOS {
        self.os.take().unwrap_or_else(|| PodOS::new())
    }

    // optional bool hostUsers = 37;

    pub fn hostUsers(&self) -> bool {
        self.hostUsers.unwrap_or(false)
    }

    pub fn clear_hostUsers(&mut self) {
        self.hostUsers = ::std::option::Option::None;
    }

    pub fn has_hostUsers(&self) -> bool {
        self.hostUsers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostUsers(&mut self, v: bool) {
        self.hostUsers = ::std::option::Option::Some(v);
    }

    // repeated .api.core.v1.PodSchedulingGate schedulingGates = 38;

    pub fn schedulingGates(&self) -> &[PodSchedulingGate] {
        &self.schedulingGates
    }

    pub fn clear_schedulingGates(&mut self) {
        self.schedulingGates.clear();
    }

    // Param is passed by value, moved
    pub fn set_schedulingGates(&mut self, v: ::std::vec::Vec<PodSchedulingGate>) {
        self.schedulingGates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_schedulingGates(&mut self) -> &mut ::std::vec::Vec<PodSchedulingGate> {
        &mut self.schedulingGates
    }

    // Take field
    pub fn take_schedulingGates(&mut self) -> ::std::vec::Vec<PodSchedulingGate> {
        ::std::mem::replace(&mut self.schedulingGates, ::std::vec::Vec::new())
    }

    // repeated .api.core.v1.PodResourceClaim resourceClaims = 39;

    pub fn resourceClaims(&self) -> &[PodResourceClaim] {
        &self.resourceClaims
    }

    pub fn clear_resourceClaims(&mut self) {
        self.resourceClaims.clear();
    }

    // Param is passed by value, moved
    pub fn set_resourceClaims(&mut self, v: ::std::vec::Vec<PodResourceClaim>) {
        self.resourceClaims = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resourceClaims(&mut self) -> &mut ::std::vec::Vec<PodResourceClaim> {
        &mut self.resourceClaims
    }

    // Take field
    pub fn take_resourceClaims(&mut self) -> ::std::vec::Vec<PodResourceClaim> {
        ::std::mem::replace(&mut self.resourceClaims, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(39);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "volumes",
            |m: &PodSpec| { &m.volumes },
            |m: &mut PodSpec| { &mut m.volumes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "initContainers",
            |m: &PodSpec| { &m.initContainers },
            |m: &mut PodSpec| { &mut m.initContainers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "containers",
            |m: &PodSpec| { &m.containers },
            |m: &mut PodSpec| { &mut m.containers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ephemeralContainers",
            |m: &PodSpec| { &m.ephemeralContainers },
            |m: &mut PodSpec| { &mut m.ephemeralContainers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "restartPolicy",
            |m: &PodSpec| { &m.restartPolicy },
            |m: &mut PodSpec| { &mut m.restartPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "terminationGracePeriodSeconds",
            |m: &PodSpec| { &m.terminationGracePeriodSeconds },
            |m: &mut PodSpec| { &mut m.terminationGracePeriodSeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "activeDeadlineSeconds",
            |m: &PodSpec| { &m.activeDeadlineSeconds },
            |m: &mut PodSpec| { &mut m.activeDeadlineSeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dnsPolicy",
            |m: &PodSpec| { &m.dnsPolicy },
            |m: &mut PodSpec| { &mut m.dnsPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "nodeSelector",
            |m: &PodSpec| { &m.nodeSelector },
            |m: &mut PodSpec| { &mut m.nodeSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serviceAccountName",
            |m: &PodSpec| { &m.serviceAccountName },
            |m: &mut PodSpec| { &mut m.serviceAccountName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serviceAccount",
            |m: &PodSpec| { &m.serviceAccount },
            |m: &mut PodSpec| { &mut m.serviceAccount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "automountServiceAccountToken",
            |m: &PodSpec| { &m.automountServiceAccountToken },
            |m: &mut PodSpec| { &mut m.automountServiceAccountToken },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nodeName",
            |m: &PodSpec| { &m.nodeName },
            |m: &mut PodSpec| { &mut m.nodeName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hostNetwork",
            |m: &PodSpec| { &m.hostNetwork },
            |m: &mut PodSpec| { &mut m.hostNetwork },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hostPID",
            |m: &PodSpec| { &m.hostPID },
            |m: &mut PodSpec| { &mut m.hostPID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hostIPC",
            |m: &PodSpec| { &m.hostIPC },
            |m: &mut PodSpec| { &mut m.hostIPC },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shareProcessNamespace",
            |m: &PodSpec| { &m.shareProcessNamespace },
            |m: &mut PodSpec| { &mut m.shareProcessNamespace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PodSecurityContext>(
            "securityContext",
            |m: &PodSpec| { &m.securityContext },
            |m: &mut PodSpec| { &mut m.securityContext },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "imagePullSecrets",
            |m: &PodSpec| { &m.imagePullSecrets },
            |m: &mut PodSpec| { &mut m.imagePullSecrets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hostname",
            |m: &PodSpec| { &m.hostname },
            |m: &mut PodSpec| { &mut m.hostname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subdomain",
            |m: &PodSpec| { &m.subdomain },
            |m: &mut PodSpec| { &mut m.subdomain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Affinity>(
            "affinity",
            |m: &PodSpec| { &m.affinity },
            |m: &mut PodSpec| { &mut m.affinity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "schedulerName",
            |m: &PodSpec| { &m.schedulerName },
            |m: &mut PodSpec| { &mut m.schedulerName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tolerations",
            |m: &PodSpec| { &m.tolerations },
            |m: &mut PodSpec| { &mut m.tolerations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hostAliases",
            |m: &PodSpec| { &m.hostAliases },
            |m: &mut PodSpec| { &mut m.hostAliases },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "priorityClassName",
            |m: &PodSpec| { &m.priorityClassName },
            |m: &mut PodSpec| { &mut m.priorityClassName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "priority",
            |m: &PodSpec| { &m.priority },
            |m: &mut PodSpec| { &mut m.priority },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PodDNSConfig>(
            "dnsConfig",
            |m: &PodSpec| { &m.dnsConfig },
            |m: &mut PodSpec| { &mut m.dnsConfig },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "readinessGates",
            |m: &PodSpec| { &m.readinessGates },
            |m: &mut PodSpec| { &mut m.readinessGates },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "runtimeClassName",
            |m: &PodSpec| { &m.runtimeClassName },
            |m: &mut PodSpec| { &mut m.runtimeClassName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enableServiceLinks",
            |m: &PodSpec| { &m.enableServiceLinks },
            |m: &mut PodSpec| { &mut m.enableServiceLinks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "preemptionPolicy",
            |m: &PodSpec| { &m.preemptionPolicy },
            |m: &mut PodSpec| { &mut m.preemptionPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "overhead",
            |m: &PodSpec| { &m.overhead },
            |m: &mut PodSpec| { &mut m.overhead },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "topologySpreadConstraints",
            |m: &PodSpec| { &m.topologySpreadConstraints },
            |m: &mut PodSpec| { &mut m.topologySpreadConstraints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "setHostnameAsFQDN",
            |m: &PodSpec| { &m.setHostnameAsFQDN },
            |m: &mut PodSpec| { &mut m.setHostnameAsFQDN },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PodOS>(
            "os",
            |m: &PodSpec| { &m.os },
            |m: &mut PodSpec| { &mut m.os },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hostUsers",
            |m: &PodSpec| { &m.hostUsers },
            |m: &mut PodSpec| { &mut m.hostUsers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "schedulingGates",
            |m: &PodSpec| { &m.schedulingGates },
            |m: &mut PodSpec| { &mut m.schedulingGates },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resourceClaims",
            |m: &PodSpec| { &m.resourceClaims },
            |m: &mut PodSpec| { &mut m.resourceClaims },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodSpec>(
            "PodSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodSpec {
    const NAME: &'static str = "PodSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.volumes.push(is.read_message()?);
                },
                162 => {
                    self.initContainers.push(is.read_message()?);
                },
                18 => {
                    self.containers.push(is.read_message()?);
                },
                274 => {
                    self.ephemeralContainers.push(is.read_message()?);
                },
                26 => {
                    self.restartPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.terminationGracePeriodSeconds = ::std::option::Option::Some(is.read_int64()?);
                },
                40 => {
                    self.activeDeadlineSeconds = ::std::option::Option::Some(is.read_int64()?);
                },
                50 => {
                    self.dnsPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.nodeSelector.insert(key, value);
                },
                66 => {
                    self.serviceAccountName = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.serviceAccount = ::std::option::Option::Some(is.read_string()?);
                },
                168 => {
                    self.automountServiceAccountToken = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    self.nodeName = ::std::option::Option::Some(is.read_string()?);
                },
                88 => {
                    self.hostNetwork = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.hostPID = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.hostIPC = ::std::option::Option::Some(is.read_bool()?);
                },
                216 => {
                    self.shareProcessNamespace = ::std::option::Option::Some(is.read_bool()?);
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.securityContext)?;
                },
                122 => {
                    self.imagePullSecrets.push(is.read_message()?);
                },
                130 => {
                    self.hostname = ::std::option::Option::Some(is.read_string()?);
                },
                138 => {
                    self.subdomain = ::std::option::Option::Some(is.read_string()?);
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.affinity)?;
                },
                154 => {
                    self.schedulerName = ::std::option::Option::Some(is.read_string()?);
                },
                178 => {
                    self.tolerations.push(is.read_message()?);
                },
                186 => {
                    self.hostAliases.push(is.read_message()?);
                },
                194 => {
                    self.priorityClassName = ::std::option::Option::Some(is.read_string()?);
                },
                200 => {
                    self.priority = ::std::option::Option::Some(is.read_int32()?);
                },
                210 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dnsConfig)?;
                },
                226 => {
                    self.readinessGates.push(is.read_message()?);
                },
                234 => {
                    self.runtimeClassName = ::std::option::Option::Some(is.read_string()?);
                },
                240 => {
                    self.enableServiceLinks = ::std::option::Option::Some(is.read_bool()?);
                },
                250 => {
                    self.preemptionPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                258 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.overhead.insert(key, value);
                },
                266 => {
                    self.topologySpreadConstraints.push(is.read_message()?);
                },
                280 => {
                    self.setHostnameAsFQDN = ::std::option::Option::Some(is.read_bool()?);
                },
                290 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.os)?;
                },
                296 => {
                    self.hostUsers = ::std::option::Option::Some(is.read_bool()?);
                },
                306 => {
                    self.schedulingGates.push(is.read_message()?);
                },
                314 => {
                    self.resourceClaims.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.volumes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.initContainers {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.containers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.ephemeralContainers {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.restartPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.terminationGracePeriodSeconds {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.activeDeadlineSeconds {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.dnsPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for (k, v) in &self.nodeSelector {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.serviceAccountName.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.serviceAccount.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.automountServiceAccountToken {
            my_size += 2 + 1;
        }
        if let Some(v) = self.nodeName.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.hostNetwork {
            my_size += 1 + 1;
        }
        if let Some(v) = self.hostPID {
            my_size += 1 + 1;
        }
        if let Some(v) = self.hostIPC {
            my_size += 1 + 1;
        }
        if let Some(v) = self.shareProcessNamespace {
            my_size += 2 + 1;
        }
        if let Some(v) = self.securityContext.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.imagePullSecrets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.subdomain.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.affinity.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.schedulerName.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        for value in &self.tolerations {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.hostAliases {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.priorityClassName.as_ref() {
            my_size += ::protobuf::rt::string_size(24, &v);
        }
        if let Some(v) = self.priority {
            my_size += ::protobuf::rt::int32_size(25, v);
        }
        if let Some(v) = self.dnsConfig.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.readinessGates {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.runtimeClassName.as_ref() {
            my_size += ::protobuf::rt::string_size(29, &v);
        }
        if let Some(v) = self.enableServiceLinks {
            my_size += 2 + 1;
        }
        if let Some(v) = self.preemptionPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(31, &v);
        }
        for (k, v) in &self.overhead {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for value in &self.topologySpreadConstraints {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.setHostnameAsFQDN {
            my_size += 2 + 1;
        }
        if let Some(v) = self.os.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.hostUsers {
            my_size += 2 + 1;
        }
        for value in &self.schedulingGates {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.resourceClaims {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.volumes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.initContainers {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        };
        for v in &self.containers {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.ephemeralContainers {
            ::protobuf::rt::write_message_field_with_cached_size(34, v, os)?;
        };
        if let Some(v) = self.restartPolicy.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.terminationGracePeriodSeconds {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.activeDeadlineSeconds {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.dnsPolicy.as_ref() {
            os.write_string(6, v)?;
        }
        for (k, v) in &self.nodeSelector {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(58)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.serviceAccountName.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.serviceAccount.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.automountServiceAccountToken {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.nodeName.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.hostNetwork {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.hostPID {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.hostIPC {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.shareProcessNamespace {
            os.write_bool(27, v)?;
        }
        if let Some(v) = self.securityContext.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        for v in &self.imagePullSecrets {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        if let Some(v) = self.hostname.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.subdomain.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.affinity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.schedulerName.as_ref() {
            os.write_string(19, v)?;
        }
        for v in &self.tolerations {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        };
        for v in &self.hostAliases {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        };
        if let Some(v) = self.priorityClassName.as_ref() {
            os.write_string(24, v)?;
        }
        if let Some(v) = self.priority {
            os.write_int32(25, v)?;
        }
        if let Some(v) = self.dnsConfig.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        for v in &self.readinessGates {
            ::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
        };
        if let Some(v) = self.runtimeClassName.as_ref() {
            os.write_string(29, v)?;
        }
        if let Some(v) = self.enableServiceLinks {
            os.write_bool(30, v)?;
        }
        if let Some(v) = self.preemptionPolicy.as_ref() {
            os.write_string(31, v)?;
        }
        for (k, v) in &self.overhead {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(258)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.topologySpreadConstraints {
            ::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
        };
        if let Some(v) = self.setHostnameAsFQDN {
            os.write_bool(35, v)?;
        }
        if let Some(v) = self.os.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(36, v, os)?;
        }
        if let Some(v) = self.hostUsers {
            os.write_bool(37, v)?;
        }
        for v in &self.schedulingGates {
            ::protobuf::rt::write_message_field_with_cached_size(38, v, os)?;
        };
        for v in &self.resourceClaims {
            ::protobuf::rt::write_message_field_with_cached_size(39, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodSpec {
        PodSpec::new()
    }

    fn clear(&mut self) {
        self.volumes.clear();
        self.initContainers.clear();
        self.containers.clear();
        self.ephemeralContainers.clear();
        self.restartPolicy = ::std::option::Option::None;
        self.terminationGracePeriodSeconds = ::std::option::Option::None;
        self.activeDeadlineSeconds = ::std::option::Option::None;
        self.dnsPolicy = ::std::option::Option::None;
        self.nodeSelector.clear();
        self.serviceAccountName = ::std::option::Option::None;
        self.serviceAccount = ::std::option::Option::None;
        self.automountServiceAccountToken = ::std::option::Option::None;
        self.nodeName = ::std::option::Option::None;
        self.hostNetwork = ::std::option::Option::None;
        self.hostPID = ::std::option::Option::None;
        self.hostIPC = ::std::option::Option::None;
        self.shareProcessNamespace = ::std::option::Option::None;
        self.securityContext.clear();
        self.imagePullSecrets.clear();
        self.hostname = ::std::option::Option::None;
        self.subdomain = ::std::option::Option::None;
        self.affinity.clear();
        self.schedulerName = ::std::option::Option::None;
        self.tolerations.clear();
        self.hostAliases.clear();
        self.priorityClassName = ::std::option::Option::None;
        self.priority = ::std::option::Option::None;
        self.dnsConfig.clear();
        self.readinessGates.clear();
        self.runtimeClassName = ::std::option::Option::None;
        self.enableServiceLinks = ::std::option::Option::None;
        self.preemptionPolicy = ::std::option::Option::None;
        self.overhead.clear();
        self.topologySpreadConstraints.clear();
        self.setHostnameAsFQDN = ::std::option::Option::None;
        self.os.clear();
        self.hostUsers = ::std::option::Option::None;
        self.schedulingGates.clear();
        self.resourceClaims.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodSpec {
        static instance: ::protobuf::rt::Lazy<PodSpec> = ::protobuf::rt::Lazy::new();
        instance.get(PodSpec::new)
    }
}

impl ::protobuf::MessageFull for PodSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodStatus {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.PodStatus.phase)
    pub phase: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodStatus.conditions)
    pub conditions: ::std::vec::Vec<PodCondition>,
    // @@protoc_insertion_point(field:api.core.v1.PodStatus.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PodStatus.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PodStatus.nominatedNodeName)
    pub nominatedNodeName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PodStatus.hostIP)
    pub hostIP: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodStatus.hostIPs)
    pub hostIPs: ::std::vec::Vec<HostIP>,
    // @@protoc_insertion_point(field:api.core.v1.PodStatus.podIP)
    pub podIP: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodStatus.podIPs)
    pub podIPs: ::std::vec::Vec<PodIP>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodStatus.startTime)
    pub startTime: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodStatus.initContainerStatuses)
    pub initContainerStatuses: ::std::vec::Vec<ContainerStatus>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodStatus.containerStatuses)
    pub containerStatuses: ::std::vec::Vec<ContainerStatus>,
    // @@protoc_insertion_point(field:api.core.v1.PodStatus.qosClass)
    pub qosClass: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodStatus.ephemeralContainerStatuses)
    pub ephemeralContainerStatuses: ::std::vec::Vec<ContainerStatus>,
    // @@protoc_insertion_point(field:api.core.v1.PodStatus.resize)
    pub resize: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodStatus.resourceClaimStatuses)
    pub resourceClaimStatuses: ::std::vec::Vec<PodResourceClaimStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodStatus {
    fn default() -> &'a PodStatus {
        <PodStatus as ::protobuf::Message>::default_instance()
    }
}

impl PodStatus {
    pub fn new() -> PodStatus {
        ::std::default::Default::default()
    }

    // optional string phase = 1;

    pub fn phase(&self) -> &str {
        match self.phase.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_phase(&mut self) {
        self.phase = ::std::option::Option::None;
    }

    pub fn has_phase(&self) -> bool {
        self.phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase(&mut self, v: ::std::string::String) {
        self.phase = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phase(&mut self) -> &mut ::std::string::String {
        if self.phase.is_none() {
            self.phase = ::std::option::Option::Some(::std::string::String::new());
        }
        self.phase.as_mut().unwrap()
    }

    // Take field
    pub fn take_phase(&mut self) -> ::std::string::String {
        self.phase.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.core.v1.PodCondition conditions = 2;

    pub fn conditions(&self) -> &[PodCondition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<PodCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<PodCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<PodCondition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    // optional string message = 3;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reason = 4;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string nominatedNodeName = 11;

    pub fn nominatedNodeName(&self) -> &str {
        match self.nominatedNodeName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nominatedNodeName(&mut self) {
        self.nominatedNodeName = ::std::option::Option::None;
    }

    pub fn has_nominatedNodeName(&self) -> bool {
        self.nominatedNodeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nominatedNodeName(&mut self, v: ::std::string::String) {
        self.nominatedNodeName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nominatedNodeName(&mut self) -> &mut ::std::string::String {
        if self.nominatedNodeName.is_none() {
            self.nominatedNodeName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.nominatedNodeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_nominatedNodeName(&mut self) -> ::std::string::String {
        self.nominatedNodeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string hostIP = 5;

    pub fn hostIP(&self) -> &str {
        match self.hostIP.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hostIP(&mut self) {
        self.hostIP = ::std::option::Option::None;
    }

    pub fn has_hostIP(&self) -> bool {
        self.hostIP.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostIP(&mut self, v: ::std::string::String) {
        self.hostIP = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostIP(&mut self) -> &mut ::std::string::String {
        if self.hostIP.is_none() {
            self.hostIP = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hostIP.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostIP(&mut self) -> ::std::string::String {
        self.hostIP.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.core.v1.HostIP hostIPs = 16;

    pub fn hostIPs(&self) -> &[HostIP] {
        &self.hostIPs
    }

    pub fn clear_hostIPs(&mut self) {
        self.hostIPs.clear();
    }

    // Param is passed by value, moved
    pub fn set_hostIPs(&mut self, v: ::std::vec::Vec<HostIP>) {
        self.hostIPs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hostIPs(&mut self) -> &mut ::std::vec::Vec<HostIP> {
        &mut self.hostIPs
    }

    // Take field
    pub fn take_hostIPs(&mut self) -> ::std::vec::Vec<HostIP> {
        ::std::mem::replace(&mut self.hostIPs, ::std::vec::Vec::new())
    }

    // optional string podIP = 6;

    pub fn podIP(&self) -> &str {
        match self.podIP.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_podIP(&mut self) {
        self.podIP = ::std::option::Option::None;
    }

    pub fn has_podIP(&self) -> bool {
        self.podIP.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podIP(&mut self, v: ::std::string::String) {
        self.podIP = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podIP(&mut self) -> &mut ::std::string::String {
        if self.podIP.is_none() {
            self.podIP = ::std::option::Option::Some(::std::string::String::new());
        }
        self.podIP.as_mut().unwrap()
    }

    // Take field
    pub fn take_podIP(&mut self) -> ::std::string::String {
        self.podIP.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.core.v1.PodIP podIPs = 12;

    pub fn podIPs(&self) -> &[PodIP] {
        &self.podIPs
    }

    pub fn clear_podIPs(&mut self) {
        self.podIPs.clear();
    }

    // Param is passed by value, moved
    pub fn set_podIPs(&mut self, v: ::std::vec::Vec<PodIP>) {
        self.podIPs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_podIPs(&mut self) -> &mut ::std::vec::Vec<PodIP> {
        &mut self.podIPs
    }

    // Take field
    pub fn take_podIPs(&mut self) -> ::std::vec::Vec<PodIP> {
        ::std::mem::replace(&mut self.podIPs, ::std::vec::Vec::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time startTime = 7;

    pub fn startTime(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.startTime.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_startTime(&mut self) {
        self.startTime.clear();
    }

    pub fn has_startTime(&self) -> bool {
        self.startTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startTime(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::Time) {
        self.startTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startTime(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.startTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_startTime(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.startTime.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // repeated .api.core.v1.ContainerStatus initContainerStatuses = 10;

    pub fn initContainerStatuses(&self) -> &[ContainerStatus] {
        &self.initContainerStatuses
    }

    pub fn clear_initContainerStatuses(&mut self) {
        self.initContainerStatuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_initContainerStatuses(&mut self, v: ::std::vec::Vec<ContainerStatus>) {
        self.initContainerStatuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_initContainerStatuses(&mut self) -> &mut ::std::vec::Vec<ContainerStatus> {
        &mut self.initContainerStatuses
    }

    // Take field
    pub fn take_initContainerStatuses(&mut self) -> ::std::vec::Vec<ContainerStatus> {
        ::std::mem::replace(&mut self.initContainerStatuses, ::std::vec::Vec::new())
    }

    // repeated .api.core.v1.ContainerStatus containerStatuses = 8;

    pub fn containerStatuses(&self) -> &[ContainerStatus] {
        &self.containerStatuses
    }

    pub fn clear_containerStatuses(&mut self) {
        self.containerStatuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_containerStatuses(&mut self, v: ::std::vec::Vec<ContainerStatus>) {
        self.containerStatuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_containerStatuses(&mut self) -> &mut ::std::vec::Vec<ContainerStatus> {
        &mut self.containerStatuses
    }

    // Take field
    pub fn take_containerStatuses(&mut self) -> ::std::vec::Vec<ContainerStatus> {
        ::std::mem::replace(&mut self.containerStatuses, ::std::vec::Vec::new())
    }

    // optional string qosClass = 9;

    pub fn qosClass(&self) -> &str {
        match self.qosClass.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_qosClass(&mut self) {
        self.qosClass = ::std::option::Option::None;
    }

    pub fn has_qosClass(&self) -> bool {
        self.qosClass.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qosClass(&mut self, v: ::std::string::String) {
        self.qosClass = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_qosClass(&mut self) -> &mut ::std::string::String {
        if self.qosClass.is_none() {
            self.qosClass = ::std::option::Option::Some(::std::string::String::new());
        }
        self.qosClass.as_mut().unwrap()
    }

    // Take field
    pub fn take_qosClass(&mut self) -> ::std::string::String {
        self.qosClass.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.core.v1.ContainerStatus ephemeralContainerStatuses = 13;

    pub fn ephemeralContainerStatuses(&self) -> &[ContainerStatus] {
        &self.ephemeralContainerStatuses
    }

    pub fn clear_ephemeralContainerStatuses(&mut self) {
        self.ephemeralContainerStatuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_ephemeralContainerStatuses(&mut self, v: ::std::vec::Vec<ContainerStatus>) {
        self.ephemeralContainerStatuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ephemeralContainerStatuses(&mut self) -> &mut ::std::vec::Vec<ContainerStatus> {
        &mut self.ephemeralContainerStatuses
    }

    // Take field
    pub fn take_ephemeralContainerStatuses(&mut self) -> ::std::vec::Vec<ContainerStatus> {
        ::std::mem::replace(&mut self.ephemeralContainerStatuses, ::std::vec::Vec::new())
    }

    // optional string resize = 14;

    pub fn resize(&self) -> &str {
        match self.resize.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resize(&mut self) {
        self.resize = ::std::option::Option::None;
    }

    pub fn has_resize(&self) -> bool {
        self.resize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resize(&mut self, v: ::std::string::String) {
        self.resize = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resize(&mut self) -> &mut ::std::string::String {
        if self.resize.is_none() {
            self.resize = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resize.as_mut().unwrap()
    }

    // Take field
    pub fn take_resize(&mut self) -> ::std::string::String {
        self.resize.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.core.v1.PodResourceClaimStatus resourceClaimStatuses = 15;

    pub fn resourceClaimStatuses(&self) -> &[PodResourceClaimStatus] {
        &self.resourceClaimStatuses
    }

    pub fn clear_resourceClaimStatuses(&mut self) {
        self.resourceClaimStatuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_resourceClaimStatuses(&mut self, v: ::std::vec::Vec<PodResourceClaimStatus>) {
        self.resourceClaimStatuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resourceClaimStatuses(&mut self) -> &mut ::std::vec::Vec<PodResourceClaimStatus> {
        &mut self.resourceClaimStatuses
    }

    // Take field
    pub fn take_resourceClaimStatuses(&mut self) -> ::std::vec::Vec<PodResourceClaimStatus> {
        ::std::mem::replace(&mut self.resourceClaimStatuses, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "phase",
            |m: &PodStatus| { &m.phase },
            |m: &mut PodStatus| { &mut m.phase },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &PodStatus| { &m.conditions },
            |m: &mut PodStatus| { &mut m.conditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &PodStatus| { &m.message },
            |m: &mut PodStatus| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &PodStatus| { &m.reason },
            |m: &mut PodStatus| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nominatedNodeName",
            |m: &PodStatus| { &m.nominatedNodeName },
            |m: &mut PodStatus| { &mut m.nominatedNodeName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hostIP",
            |m: &PodStatus| { &m.hostIP },
            |m: &mut PodStatus| { &mut m.hostIP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hostIPs",
            |m: &PodStatus| { &m.hostIPs },
            |m: &mut PodStatus| { &mut m.hostIPs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "podIP",
            |m: &PodStatus| { &m.podIP },
            |m: &mut PodStatus| { &mut m.podIP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "podIPs",
            |m: &PodStatus| { &m.podIPs },
            |m: &mut PodStatus| { &mut m.podIPs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>(
            "startTime",
            |m: &PodStatus| { &m.startTime },
            |m: &mut PodStatus| { &mut m.startTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "initContainerStatuses",
            |m: &PodStatus| { &m.initContainerStatuses },
            |m: &mut PodStatus| { &mut m.initContainerStatuses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "containerStatuses",
            |m: &PodStatus| { &m.containerStatuses },
            |m: &mut PodStatus| { &mut m.containerStatuses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "qosClass",
            |m: &PodStatus| { &m.qosClass },
            |m: &mut PodStatus| { &mut m.qosClass },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ephemeralContainerStatuses",
            |m: &PodStatus| { &m.ephemeralContainerStatuses },
            |m: &mut PodStatus| { &mut m.ephemeralContainerStatuses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resize",
            |m: &PodStatus| { &m.resize },
            |m: &mut PodStatus| { &mut m.resize },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resourceClaimStatuses",
            |m: &PodStatus| { &m.resourceClaimStatuses },
            |m: &mut PodStatus| { &mut m.resourceClaimStatuses },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodStatus>(
            "PodStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodStatus {
    const NAME: &'static str = "PodStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.phase = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.conditions.push(is.read_message()?);
                },
                26 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.nominatedNodeName = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.hostIP = ::std::option::Option::Some(is.read_string()?);
                },
                130 => {
                    self.hostIPs.push(is.read_message()?);
                },
                50 => {
                    self.podIP = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.podIPs.push(is.read_message()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.startTime)?;
                },
                82 => {
                    self.initContainerStatuses.push(is.read_message()?);
                },
                66 => {
                    self.containerStatuses.push(is.read_message()?);
                },
                74 => {
                    self.qosClass = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.ephemeralContainerStatuses.push(is.read_message()?);
                },
                114 => {
                    self.resize = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    self.resourceClaimStatuses.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.phase.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.nominatedNodeName.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.hostIP.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.hostIPs {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.podIP.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.podIPs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.startTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.initContainerStatuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.containerStatuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.qosClass.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        for value in &self.ephemeralContainerStatuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.resize.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        for value in &self.resourceClaimStatuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.phase.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.message.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.nominatedNodeName.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.hostIP.as_ref() {
            os.write_string(5, v)?;
        }
        for v in &self.hostIPs {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        };
        if let Some(v) = self.podIP.as_ref() {
            os.write_string(6, v)?;
        }
        for v in &self.podIPs {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        if let Some(v) = self.startTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.initContainerStatuses {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.containerStatuses {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if let Some(v) = self.qosClass.as_ref() {
            os.write_string(9, v)?;
        }
        for v in &self.ephemeralContainerStatuses {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        if let Some(v) = self.resize.as_ref() {
            os.write_string(14, v)?;
        }
        for v in &self.resourceClaimStatuses {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodStatus {
        PodStatus::new()
    }

    fn clear(&mut self) {
        self.phase = ::std::option::Option::None;
        self.conditions.clear();
        self.message = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.nominatedNodeName = ::std::option::Option::None;
        self.hostIP = ::std::option::Option::None;
        self.hostIPs.clear();
        self.podIP = ::std::option::Option::None;
        self.podIPs.clear();
        self.startTime.clear();
        self.initContainerStatuses.clear();
        self.containerStatuses.clear();
        self.qosClass = ::std::option::Option::None;
        self.ephemeralContainerStatuses.clear();
        self.resize = ::std::option::Option::None;
        self.resourceClaimStatuses.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodStatus {
        static instance: PodStatus = PodStatus {
            phase: ::std::option::Option::None,
            conditions: ::std::vec::Vec::new(),
            message: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            nominatedNodeName: ::std::option::Option::None,
            hostIP: ::std::option::Option::None,
            hostIPs: ::std::vec::Vec::new(),
            podIP: ::std::option::Option::None,
            podIPs: ::std::vec::Vec::new(),
            startTime: ::protobuf::MessageField::none(),
            initContainerStatuses: ::std::vec::Vec::new(),
            containerStatuses: ::std::vec::Vec::new(),
            qosClass: ::std::option::Option::None,
            ephemeralContainerStatuses: ::std::vec::Vec::new(),
            resize: ::std::option::Option::None,
            resourceClaimStatuses: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodStatusResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodStatusResult {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodStatusResult.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodStatusResult.status)
    pub status: ::protobuf::MessageField<PodStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodStatusResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodStatusResult {
    fn default() -> &'a PodStatusResult {
        <PodStatusResult as ::protobuf::Message>::default_instance()
    }
}

impl PodStatusResult {
    pub fn new() -> PodStatusResult {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.core.v1.PodStatus status = 2;

    pub fn status(&self) -> &PodStatus {
        self.status.as_ref().unwrap_or_else(|| <PodStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: PodStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut PodStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> PodStatus {
        self.status.take().unwrap_or_else(|| PodStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &PodStatusResult| { &m.metadata },
            |m: &mut PodStatusResult| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PodStatus>(
            "status",
            |m: &PodStatusResult| { &m.status },
            |m: &mut PodStatusResult| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodStatusResult>(
            "PodStatusResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodStatusResult {
    const NAME: &'static str = "PodStatusResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodStatusResult {
        PodStatusResult::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodStatusResult {
        static instance: PodStatusResult = PodStatusResult {
            metadata: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodStatusResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodStatusResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodStatusResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodStatusResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodTemplate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodTemplate {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodTemplate.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodTemplate.template)
    pub template: ::protobuf::MessageField<PodTemplateSpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodTemplate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodTemplate {
    fn default() -> &'a PodTemplate {
        <PodTemplate as ::protobuf::Message>::default_instance()
    }
}

impl PodTemplate {
    pub fn new() -> PodTemplate {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.core.v1.PodTemplateSpec template = 2;

    pub fn template(&self) -> &PodTemplateSpec {
        self.template.as_ref().unwrap_or_else(|| <PodTemplateSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_template(&mut self) {
        self.template.clear();
    }

    pub fn has_template(&self) -> bool {
        self.template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template(&mut self, v: PodTemplateSpec) {
        self.template = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template(&mut self) -> &mut PodTemplateSpec {
        self.template.mut_or_insert_default()
    }

    // Take field
    pub fn take_template(&mut self) -> PodTemplateSpec {
        self.template.take().unwrap_or_else(|| PodTemplateSpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &PodTemplate| { &m.metadata },
            |m: &mut PodTemplate| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PodTemplateSpec>(
            "template",
            |m: &PodTemplate| { &m.template },
            |m: &mut PodTemplate| { &mut m.template },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodTemplate>(
            "PodTemplate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodTemplate {
    const NAME: &'static str = "PodTemplate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.template)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.template.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodTemplate {
        PodTemplate::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.template.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodTemplate {
        static instance: PodTemplate = PodTemplate {
            metadata: ::protobuf::MessageField::none(),
            template: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodTemplate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodTemplate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodTemplate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodTemplate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodTemplateList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodTemplateList {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodTemplateList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodTemplateList.items)
    pub items: ::std::vec::Vec<PodTemplate>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodTemplateList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodTemplateList {
    fn default() -> &'a PodTemplateList {
        <PodTemplateList as ::protobuf::Message>::default_instance()
    }
}

impl PodTemplateList {
    pub fn new() -> PodTemplateList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.core.v1.PodTemplate items = 2;

    pub fn items(&self) -> &[PodTemplate] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<PodTemplate>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<PodTemplate> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<PodTemplate> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &PodTemplateList| { &m.metadata },
            |m: &mut PodTemplateList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &PodTemplateList| { &m.items },
            |m: &mut PodTemplateList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodTemplateList>(
            "PodTemplateList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodTemplateList {
    const NAME: &'static str = "PodTemplateList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodTemplateList {
        PodTemplateList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodTemplateList {
        static instance: PodTemplateList = PodTemplateList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodTemplateList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodTemplateList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodTemplateList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodTemplateList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PodTemplateSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodTemplateSpec {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodTemplateSpec.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PodTemplateSpec.spec)
    pub spec: ::protobuf::MessageField<PodSpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PodTemplateSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodTemplateSpec {
    fn default() -> &'a PodTemplateSpec {
        <PodTemplateSpec as ::protobuf::Message>::default_instance()
    }
}

impl PodTemplateSpec {
    pub fn new() -> PodTemplateSpec {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.core.v1.PodSpec spec = 2;

    pub fn spec(&self) -> &PodSpec {
        self.spec.as_ref().unwrap_or_else(|| <PodSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: PodSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut PodSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> PodSpec {
        self.spec.take().unwrap_or_else(|| PodSpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &PodTemplateSpec| { &m.metadata },
            |m: &mut PodTemplateSpec| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PodSpec>(
            "spec",
            |m: &PodTemplateSpec| { &m.spec },
            |m: &mut PodTemplateSpec| { &mut m.spec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodTemplateSpec>(
            "PodTemplateSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodTemplateSpec {
    const NAME: &'static str = "PodTemplateSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodTemplateSpec {
        PodTemplateSpec::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodTemplateSpec {
        static instance: PodTemplateSpec = PodTemplateSpec {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodTemplateSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodTemplateSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodTemplateSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodTemplateSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PortStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PortStatus {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.PortStatus.port)
    pub port: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.PortStatus.protocol)
    pub protocol: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PortStatus.error)
    pub error: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PortStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PortStatus {
    fn default() -> &'a PortStatus {
        <PortStatus as ::protobuf::Message>::default_instance()
    }
}

impl PortStatus {
    pub fn new() -> PortStatus {
        ::std::default::Default::default()
    }

    // optional int32 port = 1;

    pub fn port(&self) -> i32 {
        self.port.unwrap_or(0)
    }

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Option::Some(v);
    }

    // optional string protocol = 2;

    pub fn protocol(&self) -> &str {
        match self.protocol.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_protocol(&mut self) {
        self.protocol = ::std::option::Option::None;
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol = ::std::option::Option::Some(::std::string::String::new());
        }
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string error = 3;

    pub fn error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "port",
            |m: &PortStatus| { &m.port },
            |m: &mut PortStatus| { &mut m.port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol",
            |m: &PortStatus| { &m.protocol },
            |m: &mut PortStatus| { &mut m.protocol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error",
            |m: &PortStatus| { &m.error },
            |m: &mut PortStatus| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PortStatus>(
            "PortStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PortStatus {
    const NAME: &'static str = "PortStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.port = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.protocol = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.error = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.protocol.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.port {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.protocol.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.error.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PortStatus {
        PortStatus::new()
    }

    fn clear(&mut self) {
        self.port = ::std::option::Option::None;
        self.protocol = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PortStatus {
        static instance: PortStatus = PortStatus {
            port: ::std::option::Option::None,
            protocol: ::std::option::Option::None,
            error: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PortStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PortStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PortStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PortStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PortworxVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PortworxVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.PortworxVolumeSource.volumeID)
    pub volumeID: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PortworxVolumeSource.fsType)
    pub fsType: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PortworxVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PortworxVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PortworxVolumeSource {
    fn default() -> &'a PortworxVolumeSource {
        <PortworxVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl PortworxVolumeSource {
    pub fn new() -> PortworxVolumeSource {
        ::std::default::Default::default()
    }

    // optional string volumeID = 1;

    pub fn volumeID(&self) -> &str {
        match self.volumeID.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_volumeID(&mut self) {
        self.volumeID = ::std::option::Option::None;
    }

    pub fn has_volumeID(&self) -> bool {
        self.volumeID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeID(&mut self, v: ::std::string::String) {
        self.volumeID = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeID(&mut self) -> &mut ::std::string::String {
        if self.volumeID.is_none() {
            self.volumeID = ::std::option::Option::Some(::std::string::String::new());
        }
        self.volumeID.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeID(&mut self) -> ::std::string::String {
        self.volumeID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 2;

    pub fn fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fsType(&mut self) {
        self.fsType = ::std::option::Option::None;
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 3;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volumeID",
            |m: &PortworxVolumeSource| { &m.volumeID },
            |m: &mut PortworxVolumeSource| { &mut m.volumeID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsType",
            |m: &PortworxVolumeSource| { &m.fsType },
            |m: &mut PortworxVolumeSource| { &mut m.fsType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &PortworxVolumeSource| { &m.readOnly },
            |m: &mut PortworxVolumeSource| { &mut m.readOnly },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PortworxVolumeSource>(
            "PortworxVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PortworxVolumeSource {
    const NAME: &'static str = "PortworxVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.volumeID = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.fsType = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.volumeID.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.volumeID.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.fsType.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PortworxVolumeSource {
        PortworxVolumeSource::new()
    }

    fn clear(&mut self) {
        self.volumeID = ::std::option::Option::None;
        self.fsType = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PortworxVolumeSource {
        static instance: PortworxVolumeSource = PortworxVolumeSource {
            volumeID: ::std::option::Option::None,
            fsType: ::std::option::Option::None,
            readOnly: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PortworxVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PortworxVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PortworxVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PortworxVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.Preconditions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Preconditions {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.Preconditions.uid)
    pub uid: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.Preconditions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Preconditions {
    fn default() -> &'a Preconditions {
        <Preconditions as ::protobuf::Message>::default_instance()
    }
}

impl Preconditions {
    pub fn new() -> Preconditions {
        ::std::default::Default::default()
    }

    // optional string uid = 1;

    pub fn uid(&self) -> &str {
        match self.uid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_uid(&mut self) {
        self.uid = ::std::option::Option::None;
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if self.uid.is_none() {
            self.uid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        self.uid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uid",
            |m: &Preconditions| { &m.uid },
            |m: &mut Preconditions| { &mut m.uid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Preconditions>(
            "Preconditions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Preconditions {
    const NAME: &'static str = "Preconditions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uid = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.uid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.uid.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Preconditions {
        Preconditions::new()
    }

    fn clear(&mut self) {
        self.uid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Preconditions {
        static instance: Preconditions = Preconditions {
            uid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Preconditions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Preconditions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Preconditions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Preconditions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PreferAvoidPodsEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PreferAvoidPodsEntry {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PreferAvoidPodsEntry.podSignature)
    pub podSignature: ::protobuf::MessageField<PodSignature>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PreferAvoidPodsEntry.evictionTime)
    pub evictionTime: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:api.core.v1.PreferAvoidPodsEntry.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.PreferAvoidPodsEntry.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PreferAvoidPodsEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PreferAvoidPodsEntry {
    fn default() -> &'a PreferAvoidPodsEntry {
        <PreferAvoidPodsEntry as ::protobuf::Message>::default_instance()
    }
}

impl PreferAvoidPodsEntry {
    pub fn new() -> PreferAvoidPodsEntry {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.PodSignature podSignature = 1;

    pub fn podSignature(&self) -> &PodSignature {
        self.podSignature.as_ref().unwrap_or_else(|| <PodSignature as ::protobuf::Message>::default_instance())
    }

    pub fn clear_podSignature(&mut self) {
        self.podSignature.clear();
    }

    pub fn has_podSignature(&self) -> bool {
        self.podSignature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podSignature(&mut self, v: PodSignature) {
        self.podSignature = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podSignature(&mut self) -> &mut PodSignature {
        self.podSignature.mut_or_insert_default()
    }

    // Take field
    pub fn take_podSignature(&mut self) -> PodSignature {
        self.podSignature.take().unwrap_or_else(|| PodSignature::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time evictionTime = 2;

    pub fn evictionTime(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.evictionTime.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_evictionTime(&mut self) {
        self.evictionTime.clear();
    }

    pub fn has_evictionTime(&self) -> bool {
        self.evictionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_evictionTime(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::Time) {
        self.evictionTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_evictionTime(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.evictionTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_evictionTime(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.evictionTime.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional string reason = 3;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 4;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PodSignature>(
            "podSignature",
            |m: &PreferAvoidPodsEntry| { &m.podSignature },
            |m: &mut PreferAvoidPodsEntry| { &mut m.podSignature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>(
            "evictionTime",
            |m: &PreferAvoidPodsEntry| { &m.evictionTime },
            |m: &mut PreferAvoidPodsEntry| { &mut m.evictionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &PreferAvoidPodsEntry| { &m.reason },
            |m: &mut PreferAvoidPodsEntry| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &PreferAvoidPodsEntry| { &m.message },
            |m: &mut PreferAvoidPodsEntry| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PreferAvoidPodsEntry>(
            "PreferAvoidPodsEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PreferAvoidPodsEntry {
    const NAME: &'static str = "PreferAvoidPodsEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.podSignature)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.evictionTime)?;
                },
                26 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.podSignature.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.evictionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.podSignature.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.evictionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PreferAvoidPodsEntry {
        PreferAvoidPodsEntry::new()
    }

    fn clear(&mut self) {
        self.podSignature.clear();
        self.evictionTime.clear();
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PreferAvoidPodsEntry {
        static instance: PreferAvoidPodsEntry = PreferAvoidPodsEntry {
            podSignature: ::protobuf::MessageField::none(),
            evictionTime: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PreferAvoidPodsEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PreferAvoidPodsEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PreferAvoidPodsEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreferAvoidPodsEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.PreferredSchedulingTerm)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PreferredSchedulingTerm {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.PreferredSchedulingTerm.weight)
    pub weight: ::std::option::Option<i32>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.PreferredSchedulingTerm.preference)
    pub preference: ::protobuf::MessageField<NodeSelectorTerm>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.PreferredSchedulingTerm.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PreferredSchedulingTerm {
    fn default() -> &'a PreferredSchedulingTerm {
        <PreferredSchedulingTerm as ::protobuf::Message>::default_instance()
    }
}

impl PreferredSchedulingTerm {
    pub fn new() -> PreferredSchedulingTerm {
        ::std::default::Default::default()
    }

    // optional int32 weight = 1;

    pub fn weight(&self) -> i32 {
        self.weight.unwrap_or(0)
    }

    pub fn clear_weight(&mut self) {
        self.weight = ::std::option::Option::None;
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: i32) {
        self.weight = ::std::option::Option::Some(v);
    }

    // optional .api.core.v1.NodeSelectorTerm preference = 2;

    pub fn preference(&self) -> &NodeSelectorTerm {
        self.preference.as_ref().unwrap_or_else(|| <NodeSelectorTerm as ::protobuf::Message>::default_instance())
    }

    pub fn clear_preference(&mut self) {
        self.preference.clear();
    }

    pub fn has_preference(&self) -> bool {
        self.preference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preference(&mut self, v: NodeSelectorTerm) {
        self.preference = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preference(&mut self) -> &mut NodeSelectorTerm {
        self.preference.mut_or_insert_default()
    }

    // Take field
    pub fn take_preference(&mut self) -> NodeSelectorTerm {
        self.preference.take().unwrap_or_else(|| NodeSelectorTerm::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "weight",
            |m: &PreferredSchedulingTerm| { &m.weight },
            |m: &mut PreferredSchedulingTerm| { &mut m.weight },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodeSelectorTerm>(
            "preference",
            |m: &PreferredSchedulingTerm| { &m.preference },
            |m: &mut PreferredSchedulingTerm| { &mut m.preference },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PreferredSchedulingTerm>(
            "PreferredSchedulingTerm",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PreferredSchedulingTerm {
    const NAME: &'static str = "PreferredSchedulingTerm";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.weight = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.preference)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.weight {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.preference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.weight {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.preference.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PreferredSchedulingTerm {
        PreferredSchedulingTerm::new()
    }

    fn clear(&mut self) {
        self.weight = ::std::option::Option::None;
        self.preference.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PreferredSchedulingTerm {
        static instance: PreferredSchedulingTerm = PreferredSchedulingTerm {
            weight: ::std::option::Option::None,
            preference: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PreferredSchedulingTerm {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PreferredSchedulingTerm").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PreferredSchedulingTerm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreferredSchedulingTerm {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.Probe)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Probe {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Probe.handler)
    pub handler: ::protobuf::MessageField<ProbeHandler>,
    // @@protoc_insertion_point(field:api.core.v1.Probe.initialDelaySeconds)
    pub initialDelaySeconds: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.Probe.timeoutSeconds)
    pub timeoutSeconds: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.Probe.periodSeconds)
    pub periodSeconds: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.Probe.successThreshold)
    pub successThreshold: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.Probe.failureThreshold)
    pub failureThreshold: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.Probe.terminationGracePeriodSeconds)
    pub terminationGracePeriodSeconds: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.Probe.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Probe {
    fn default() -> &'a Probe {
        <Probe as ::protobuf::Message>::default_instance()
    }
}

impl Probe {
    pub fn new() -> Probe {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.ProbeHandler handler = 1;

    pub fn handler(&self) -> &ProbeHandler {
        self.handler.as_ref().unwrap_or_else(|| <ProbeHandler as ::protobuf::Message>::default_instance())
    }

    pub fn clear_handler(&mut self) {
        self.handler.clear();
    }

    pub fn has_handler(&self) -> bool {
        self.handler.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handler(&mut self, v: ProbeHandler) {
        self.handler = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_handler(&mut self) -> &mut ProbeHandler {
        self.handler.mut_or_insert_default()
    }

    // Take field
    pub fn take_handler(&mut self) -> ProbeHandler {
        self.handler.take().unwrap_or_else(|| ProbeHandler::new())
    }

    // optional int32 initialDelaySeconds = 2;

    pub fn initialDelaySeconds(&self) -> i32 {
        self.initialDelaySeconds.unwrap_or(0)
    }

    pub fn clear_initialDelaySeconds(&mut self) {
        self.initialDelaySeconds = ::std::option::Option::None;
    }

    pub fn has_initialDelaySeconds(&self) -> bool {
        self.initialDelaySeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initialDelaySeconds(&mut self, v: i32) {
        self.initialDelaySeconds = ::std::option::Option::Some(v);
    }

    // optional int32 timeoutSeconds = 3;

    pub fn timeoutSeconds(&self) -> i32 {
        self.timeoutSeconds.unwrap_or(0)
    }

    pub fn clear_timeoutSeconds(&mut self) {
        self.timeoutSeconds = ::std::option::Option::None;
    }

    pub fn has_timeoutSeconds(&self) -> bool {
        self.timeoutSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeoutSeconds(&mut self, v: i32) {
        self.timeoutSeconds = ::std::option::Option::Some(v);
    }

    // optional int32 periodSeconds = 4;

    pub fn periodSeconds(&self) -> i32 {
        self.periodSeconds.unwrap_or(0)
    }

    pub fn clear_periodSeconds(&mut self) {
        self.periodSeconds = ::std::option::Option::None;
    }

    pub fn has_periodSeconds(&self) -> bool {
        self.periodSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_periodSeconds(&mut self, v: i32) {
        self.periodSeconds = ::std::option::Option::Some(v);
    }

    // optional int32 successThreshold = 5;

    pub fn successThreshold(&self) -> i32 {
        self.successThreshold.unwrap_or(0)
    }

    pub fn clear_successThreshold(&mut self) {
        self.successThreshold = ::std::option::Option::None;
    }

    pub fn has_successThreshold(&self) -> bool {
        self.successThreshold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_successThreshold(&mut self, v: i32) {
        self.successThreshold = ::std::option::Option::Some(v);
    }

    // optional int32 failureThreshold = 6;

    pub fn failureThreshold(&self) -> i32 {
        self.failureThreshold.unwrap_or(0)
    }

    pub fn clear_failureThreshold(&mut self) {
        self.failureThreshold = ::std::option::Option::None;
    }

    pub fn has_failureThreshold(&self) -> bool {
        self.failureThreshold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failureThreshold(&mut self, v: i32) {
        self.failureThreshold = ::std::option::Option::Some(v);
    }

    // optional int64 terminationGracePeriodSeconds = 7;

    pub fn terminationGracePeriodSeconds(&self) -> i64 {
        self.terminationGracePeriodSeconds.unwrap_or(0)
    }

    pub fn clear_terminationGracePeriodSeconds(&mut self) {
        self.terminationGracePeriodSeconds = ::std::option::Option::None;
    }

    pub fn has_terminationGracePeriodSeconds(&self) -> bool {
        self.terminationGracePeriodSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_terminationGracePeriodSeconds(&mut self, v: i64) {
        self.terminationGracePeriodSeconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProbeHandler>(
            "handler",
            |m: &Probe| { &m.handler },
            |m: &mut Probe| { &mut m.handler },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initialDelaySeconds",
            |m: &Probe| { &m.initialDelaySeconds },
            |m: &mut Probe| { &mut m.initialDelaySeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timeoutSeconds",
            |m: &Probe| { &m.timeoutSeconds },
            |m: &mut Probe| { &mut m.timeoutSeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "periodSeconds",
            |m: &Probe| { &m.periodSeconds },
            |m: &mut Probe| { &mut m.periodSeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "successThreshold",
            |m: &Probe| { &m.successThreshold },
            |m: &mut Probe| { &mut m.successThreshold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "failureThreshold",
            |m: &Probe| { &m.failureThreshold },
            |m: &mut Probe| { &mut m.failureThreshold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "terminationGracePeriodSeconds",
            |m: &Probe| { &m.terminationGracePeriodSeconds },
            |m: &mut Probe| { &mut m.terminationGracePeriodSeconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Probe>(
            "Probe",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Probe {
    const NAME: &'static str = "Probe";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.handler)?;
                },
                16 => {
                    self.initialDelaySeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.timeoutSeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.periodSeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.successThreshold = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.failureThreshold = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.terminationGracePeriodSeconds = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.handler.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.initialDelaySeconds {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.timeoutSeconds {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.periodSeconds {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.successThreshold {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.failureThreshold {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.terminationGracePeriodSeconds {
            my_size += ::protobuf::rt::int64_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.handler.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.initialDelaySeconds {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.timeoutSeconds {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.periodSeconds {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.successThreshold {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.failureThreshold {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.terminationGracePeriodSeconds {
            os.write_int64(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Probe {
        Probe::new()
    }

    fn clear(&mut self) {
        self.handler.clear();
        self.initialDelaySeconds = ::std::option::Option::None;
        self.timeoutSeconds = ::std::option::Option::None;
        self.periodSeconds = ::std::option::Option::None;
        self.successThreshold = ::std::option::Option::None;
        self.failureThreshold = ::std::option::Option::None;
        self.terminationGracePeriodSeconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Probe {
        static instance: Probe = Probe {
            handler: ::protobuf::MessageField::none(),
            initialDelaySeconds: ::std::option::Option::None,
            timeoutSeconds: ::std::option::Option::None,
            periodSeconds: ::std::option::Option::None,
            successThreshold: ::std::option::Option::None,
            failureThreshold: ::std::option::Option::None,
            terminationGracePeriodSeconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Probe {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Probe").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Probe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Probe {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ProbeHandler)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProbeHandler {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ProbeHandler.exec)
    pub exec: ::protobuf::MessageField<ExecAction>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ProbeHandler.httpGet)
    pub httpGet: ::protobuf::MessageField<HTTPGetAction>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ProbeHandler.tcpSocket)
    pub tcpSocket: ::protobuf::MessageField<TCPSocketAction>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ProbeHandler.grpc)
    pub grpc: ::protobuf::MessageField<GRPCAction>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ProbeHandler.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProbeHandler {
    fn default() -> &'a ProbeHandler {
        <ProbeHandler as ::protobuf::Message>::default_instance()
    }
}

impl ProbeHandler {
    pub fn new() -> ProbeHandler {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.ExecAction exec = 1;

    pub fn exec(&self) -> &ExecAction {
        self.exec.as_ref().unwrap_or_else(|| <ExecAction as ::protobuf::Message>::default_instance())
    }

    pub fn clear_exec(&mut self) {
        self.exec.clear();
    }

    pub fn has_exec(&self) -> bool {
        self.exec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exec(&mut self, v: ExecAction) {
        self.exec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec(&mut self) -> &mut ExecAction {
        self.exec.mut_or_insert_default()
    }

    // Take field
    pub fn take_exec(&mut self) -> ExecAction {
        self.exec.take().unwrap_or_else(|| ExecAction::new())
    }

    // optional .api.core.v1.HTTPGetAction httpGet = 2;

    pub fn httpGet(&self) -> &HTTPGetAction {
        self.httpGet.as_ref().unwrap_or_else(|| <HTTPGetAction as ::protobuf::Message>::default_instance())
    }

    pub fn clear_httpGet(&mut self) {
        self.httpGet.clear();
    }

    pub fn has_httpGet(&self) -> bool {
        self.httpGet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_httpGet(&mut self, v: HTTPGetAction) {
        self.httpGet = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_httpGet(&mut self) -> &mut HTTPGetAction {
        self.httpGet.mut_or_insert_default()
    }

    // Take field
    pub fn take_httpGet(&mut self) -> HTTPGetAction {
        self.httpGet.take().unwrap_or_else(|| HTTPGetAction::new())
    }

    // optional .api.core.v1.TCPSocketAction tcpSocket = 3;

    pub fn tcpSocket(&self) -> &TCPSocketAction {
        self.tcpSocket.as_ref().unwrap_or_else(|| <TCPSocketAction as ::protobuf::Message>::default_instance())
    }

    pub fn clear_tcpSocket(&mut self) {
        self.tcpSocket.clear();
    }

    pub fn has_tcpSocket(&self) -> bool {
        self.tcpSocket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcpSocket(&mut self, v: TCPSocketAction) {
        self.tcpSocket = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tcpSocket(&mut self) -> &mut TCPSocketAction {
        self.tcpSocket.mut_or_insert_default()
    }

    // Take field
    pub fn take_tcpSocket(&mut self) -> TCPSocketAction {
        self.tcpSocket.take().unwrap_or_else(|| TCPSocketAction::new())
    }

    // optional .api.core.v1.GRPCAction grpc = 4;

    pub fn grpc(&self) -> &GRPCAction {
        self.grpc.as_ref().unwrap_or_else(|| <GRPCAction as ::protobuf::Message>::default_instance())
    }

    pub fn clear_grpc(&mut self) {
        self.grpc.clear();
    }

    pub fn has_grpc(&self) -> bool {
        self.grpc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grpc(&mut self, v: GRPCAction) {
        self.grpc = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_grpc(&mut self) -> &mut GRPCAction {
        self.grpc.mut_or_insert_default()
    }

    // Take field
    pub fn take_grpc(&mut self) -> GRPCAction {
        self.grpc.take().unwrap_or_else(|| GRPCAction::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExecAction>(
            "exec",
            |m: &ProbeHandler| { &m.exec },
            |m: &mut ProbeHandler| { &mut m.exec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HTTPGetAction>(
            "httpGet",
            |m: &ProbeHandler| { &m.httpGet },
            |m: &mut ProbeHandler| { &mut m.httpGet },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TCPSocketAction>(
            "tcpSocket",
            |m: &ProbeHandler| { &m.tcpSocket },
            |m: &mut ProbeHandler| { &mut m.tcpSocket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GRPCAction>(
            "grpc",
            |m: &ProbeHandler| { &m.grpc },
            |m: &mut ProbeHandler| { &mut m.grpc },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProbeHandler>(
            "ProbeHandler",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProbeHandler {
    const NAME: &'static str = "ProbeHandler";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.exec)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.httpGet)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tcpSocket)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.grpc)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.exec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.httpGet.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tcpSocket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.grpc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.exec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.httpGet.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.tcpSocket.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.grpc.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProbeHandler {
        ProbeHandler::new()
    }

    fn clear(&mut self) {
        self.exec.clear();
        self.httpGet.clear();
        self.tcpSocket.clear();
        self.grpc.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProbeHandler {
        static instance: ProbeHandler = ProbeHandler {
            exec: ::protobuf::MessageField::none(),
            httpGet: ::protobuf::MessageField::none(),
            tcpSocket: ::protobuf::MessageField::none(),
            grpc: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProbeHandler {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProbeHandler").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProbeHandler {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProbeHandler {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ProjectedVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProjectedVolumeSource {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ProjectedVolumeSource.sources)
    pub sources: ::std::vec::Vec<VolumeProjection>,
    // @@protoc_insertion_point(field:api.core.v1.ProjectedVolumeSource.defaultMode)
    pub defaultMode: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ProjectedVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProjectedVolumeSource {
    fn default() -> &'a ProjectedVolumeSource {
        <ProjectedVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl ProjectedVolumeSource {
    pub fn new() -> ProjectedVolumeSource {
        ::std::default::Default::default()
    }

    // repeated .api.core.v1.VolumeProjection sources = 1;

    pub fn sources(&self) -> &[VolumeProjection] {
        &self.sources
    }

    pub fn clear_sources(&mut self) {
        self.sources.clear();
    }

    // Param is passed by value, moved
    pub fn set_sources(&mut self, v: ::std::vec::Vec<VolumeProjection>) {
        self.sources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sources(&mut self) -> &mut ::std::vec::Vec<VolumeProjection> {
        &mut self.sources
    }

    // Take field
    pub fn take_sources(&mut self) -> ::std::vec::Vec<VolumeProjection> {
        ::std::mem::replace(&mut self.sources, ::std::vec::Vec::new())
    }

    // optional int32 defaultMode = 2;

    pub fn defaultMode(&self) -> i32 {
        self.defaultMode.unwrap_or(0)
    }

    pub fn clear_defaultMode(&mut self) {
        self.defaultMode = ::std::option::Option::None;
    }

    pub fn has_defaultMode(&self) -> bool {
        self.defaultMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defaultMode(&mut self, v: i32) {
        self.defaultMode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sources",
            |m: &ProjectedVolumeSource| { &m.sources },
            |m: &mut ProjectedVolumeSource| { &mut m.sources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "defaultMode",
            |m: &ProjectedVolumeSource| { &m.defaultMode },
            |m: &mut ProjectedVolumeSource| { &mut m.defaultMode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProjectedVolumeSource>(
            "ProjectedVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProjectedVolumeSource {
    const NAME: &'static str = "ProjectedVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sources.push(is.read_message()?);
                },
                16 => {
                    self.defaultMode = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.sources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.defaultMode {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.sources {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.defaultMode {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProjectedVolumeSource {
        ProjectedVolumeSource::new()
    }

    fn clear(&mut self) {
        self.sources.clear();
        self.defaultMode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProjectedVolumeSource {
        static instance: ProjectedVolumeSource = ProjectedVolumeSource {
            sources: ::std::vec::Vec::new(),
            defaultMode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProjectedVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProjectedVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProjectedVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProjectedVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.QuobyteVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuobyteVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.QuobyteVolumeSource.registry)
    pub registry: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.QuobyteVolumeSource.volume)
    pub volume: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.QuobyteVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.QuobyteVolumeSource.user)
    pub user: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.QuobyteVolumeSource.group)
    pub group: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.QuobyteVolumeSource.tenant)
    pub tenant: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.QuobyteVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QuobyteVolumeSource {
    fn default() -> &'a QuobyteVolumeSource {
        <QuobyteVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl QuobyteVolumeSource {
    pub fn new() -> QuobyteVolumeSource {
        ::std::default::Default::default()
    }

    // optional string registry = 1;

    pub fn registry(&self) -> &str {
        match self.registry.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_registry(&mut self) {
        self.registry = ::std::option::Option::None;
    }

    pub fn has_registry(&self) -> bool {
        self.registry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registry(&mut self, v: ::std::string::String) {
        self.registry = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registry(&mut self) -> &mut ::std::string::String {
        if self.registry.is_none() {
            self.registry = ::std::option::Option::Some(::std::string::String::new());
        }
        self.registry.as_mut().unwrap()
    }

    // Take field
    pub fn take_registry(&mut self) -> ::std::string::String {
        self.registry.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string volume = 2;

    pub fn volume(&self) -> &str {
        match self.volume.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_volume(&mut self) {
        self.volume = ::std::option::Option::None;
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: ::std::string::String) {
        self.volume = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volume(&mut self) -> &mut ::std::string::String {
        if self.volume.is_none() {
            self.volume = ::std::option::Option::Some(::std::string::String::new());
        }
        self.volume.as_mut().unwrap()
    }

    // Take field
    pub fn take_volume(&mut self) -> ::std::string::String {
        self.volume.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 3;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // optional string user = 4;

    pub fn user(&self) -> &str {
        match self.user.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_user(&mut self) {
        self.user = ::std::option::Option::None;
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        if self.user.is_none() {
            self.user = ::std::option::Option::Some(::std::string::String::new());
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string group = 5;

    pub fn group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_group(&mut self) {
        self.group = ::std::option::Option::None;
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group = ::std::option::Option::Some(::std::string::String::new());
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string tenant = 6;

    pub fn tenant(&self) -> &str {
        match self.tenant.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tenant(&mut self) {
        self.tenant = ::std::option::Option::None;
    }

    pub fn has_tenant(&self) -> bool {
        self.tenant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tenant(&mut self, v: ::std::string::String) {
        self.tenant = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tenant(&mut self) -> &mut ::std::string::String {
        if self.tenant.is_none() {
            self.tenant = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tenant.as_mut().unwrap()
    }

    // Take field
    pub fn take_tenant(&mut self) -> ::std::string::String {
        self.tenant.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "registry",
            |m: &QuobyteVolumeSource| { &m.registry },
            |m: &mut QuobyteVolumeSource| { &mut m.registry },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volume",
            |m: &QuobyteVolumeSource| { &m.volume },
            |m: &mut QuobyteVolumeSource| { &mut m.volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &QuobyteVolumeSource| { &m.readOnly },
            |m: &mut QuobyteVolumeSource| { &mut m.readOnly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user",
            |m: &QuobyteVolumeSource| { &m.user },
            |m: &mut QuobyteVolumeSource| { &mut m.user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "group",
            |m: &QuobyteVolumeSource| { &m.group },
            |m: &mut QuobyteVolumeSource| { &mut m.group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tenant",
            |m: &QuobyteVolumeSource| { &m.tenant },
            |m: &mut QuobyteVolumeSource| { &mut m.tenant },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QuobyteVolumeSource>(
            "QuobyteVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QuobyteVolumeSource {
    const NAME: &'static str = "QuobyteVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.registry = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.volume = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.user = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.group = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.tenant = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.registry.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.volume.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        if let Some(v) = self.user.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.tenant.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.registry.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.volume.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.user.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.group.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.tenant.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QuobyteVolumeSource {
        QuobyteVolumeSource::new()
    }

    fn clear(&mut self) {
        self.registry = ::std::option::Option::None;
        self.volume = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.user = ::std::option::Option::None;
        self.group = ::std::option::Option::None;
        self.tenant = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QuobyteVolumeSource {
        static instance: QuobyteVolumeSource = QuobyteVolumeSource {
            registry: ::std::option::Option::None,
            volume: ::std::option::Option::None,
            readOnly: ::std::option::Option::None,
            user: ::std::option::Option::None,
            group: ::std::option::Option::None,
            tenant: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QuobyteVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QuobyteVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QuobyteVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuobyteVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.RBDPersistentVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RBDPersistentVolumeSource {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.RBDPersistentVolumeSource.monitors)
    pub monitors: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.RBDPersistentVolumeSource.image)
    pub image: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.RBDPersistentVolumeSource.fsType)
    pub fsType: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.RBDPersistentVolumeSource.pool)
    pub pool: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.RBDPersistentVolumeSource.user)
    pub user: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.RBDPersistentVolumeSource.keyring)
    pub keyring: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.RBDPersistentVolumeSource.secretRef)
    pub secretRef: ::protobuf::MessageField<SecretReference>,
    // @@protoc_insertion_point(field:api.core.v1.RBDPersistentVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.RBDPersistentVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RBDPersistentVolumeSource {
    fn default() -> &'a RBDPersistentVolumeSource {
        <RBDPersistentVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl RBDPersistentVolumeSource {
    pub fn new() -> RBDPersistentVolumeSource {
        ::std::default::Default::default()
    }

    // repeated string monitors = 1;

    pub fn monitors(&self) -> &[::std::string::String] {
        &self.monitors
    }

    pub fn clear_monitors(&mut self) {
        self.monitors.clear();
    }

    // Param is passed by value, moved
    pub fn set_monitors(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.monitors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_monitors(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.monitors
    }

    // Take field
    pub fn take_monitors(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.monitors, ::std::vec::Vec::new())
    }

    // optional string image = 2;

    pub fn image(&self) -> &str {
        match self.image.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_image(&mut self) {
        self.image = ::std::option::Option::None;
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        if self.image.is_none() {
            self.image = ::std::option::Option::Some(::std::string::String::new());
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        self.image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 3;

    pub fn fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fsType(&mut self) {
        self.fsType = ::std::option::Option::None;
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pool = 4;

    pub fn pool(&self) -> &str {
        match self.pool.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pool(&mut self) {
        self.pool = ::std::option::Option::None;
    }

    pub fn has_pool(&self) -> bool {
        self.pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pool(&mut self, v: ::std::string::String) {
        self.pool = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pool(&mut self) -> &mut ::std::string::String {
        if self.pool.is_none() {
            self.pool = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pool.as_mut().unwrap()
    }

    // Take field
    pub fn take_pool(&mut self) -> ::std::string::String {
        self.pool.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string user = 5;

    pub fn user(&self) -> &str {
        match self.user.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_user(&mut self) {
        self.user = ::std::option::Option::None;
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        if self.user.is_none() {
            self.user = ::std::option::Option::Some(::std::string::String::new());
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string keyring = 6;

    pub fn keyring(&self) -> &str {
        match self.keyring.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_keyring(&mut self) {
        self.keyring = ::std::option::Option::None;
    }

    pub fn has_keyring(&self) -> bool {
        self.keyring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyring(&mut self, v: ::std::string::String) {
        self.keyring = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyring(&mut self) -> &mut ::std::string::String {
        if self.keyring.is_none() {
            self.keyring = ::std::option::Option::Some(::std::string::String::new());
        }
        self.keyring.as_mut().unwrap()
    }

    // Take field
    pub fn take_keyring(&mut self) -> ::std::string::String {
        self.keyring.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.SecretReference secretRef = 7;

    pub fn secretRef(&self) -> &SecretReference {
        self.secretRef.as_ref().unwrap_or_else(|| <SecretReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: SecretReference) {
        self.secretRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut SecretReference {
        self.secretRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> SecretReference {
        self.secretRef.take().unwrap_or_else(|| SecretReference::new())
    }

    // optional bool readOnly = 8;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "monitors",
            |m: &RBDPersistentVolumeSource| { &m.monitors },
            |m: &mut RBDPersistentVolumeSource| { &mut m.monitors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "image",
            |m: &RBDPersistentVolumeSource| { &m.image },
            |m: &mut RBDPersistentVolumeSource| { &mut m.image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsType",
            |m: &RBDPersistentVolumeSource| { &m.fsType },
            |m: &mut RBDPersistentVolumeSource| { &mut m.fsType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pool",
            |m: &RBDPersistentVolumeSource| { &m.pool },
            |m: &mut RBDPersistentVolumeSource| { &mut m.pool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user",
            |m: &RBDPersistentVolumeSource| { &m.user },
            |m: &mut RBDPersistentVolumeSource| { &mut m.user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "keyring",
            |m: &RBDPersistentVolumeSource| { &m.keyring },
            |m: &mut RBDPersistentVolumeSource| { &mut m.keyring },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SecretReference>(
            "secretRef",
            |m: &RBDPersistentVolumeSource| { &m.secretRef },
            |m: &mut RBDPersistentVolumeSource| { &mut m.secretRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &RBDPersistentVolumeSource| { &m.readOnly },
            |m: &mut RBDPersistentVolumeSource| { &mut m.readOnly },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RBDPersistentVolumeSource>(
            "RBDPersistentVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RBDPersistentVolumeSource {
    const NAME: &'static str = "RBDPersistentVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.monitors.push(is.read_string()?);
                },
                18 => {
                    self.image = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.fsType = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.pool = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.user = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.keyring = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.secretRef)?;
                },
                64 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.monitors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.image.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.pool.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.user.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.keyring.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.monitors {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.image.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.fsType.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.pool.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.user.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.keyring.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.secretRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RBDPersistentVolumeSource {
        RBDPersistentVolumeSource::new()
    }

    fn clear(&mut self) {
        self.monitors.clear();
        self.image = ::std::option::Option::None;
        self.fsType = ::std::option::Option::None;
        self.pool = ::std::option::Option::None;
        self.user = ::std::option::Option::None;
        self.keyring = ::std::option::Option::None;
        self.secretRef.clear();
        self.readOnly = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RBDPersistentVolumeSource {
        static instance: RBDPersistentVolumeSource = RBDPersistentVolumeSource {
            monitors: ::std::vec::Vec::new(),
            image: ::std::option::Option::None,
            fsType: ::std::option::Option::None,
            pool: ::std::option::Option::None,
            user: ::std::option::Option::None,
            keyring: ::std::option::Option::None,
            secretRef: ::protobuf::MessageField::none(),
            readOnly: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RBDPersistentVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RBDPersistentVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RBDPersistentVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RBDPersistentVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.RBDVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RBDVolumeSource {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.RBDVolumeSource.monitors)
    pub monitors: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.RBDVolumeSource.image)
    pub image: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.RBDVolumeSource.fsType)
    pub fsType: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.RBDVolumeSource.pool)
    pub pool: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.RBDVolumeSource.user)
    pub user: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.RBDVolumeSource.keyring)
    pub keyring: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.RBDVolumeSource.secretRef)
    pub secretRef: ::protobuf::MessageField<LocalObjectReference>,
    // @@protoc_insertion_point(field:api.core.v1.RBDVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.RBDVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RBDVolumeSource {
    fn default() -> &'a RBDVolumeSource {
        <RBDVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl RBDVolumeSource {
    pub fn new() -> RBDVolumeSource {
        ::std::default::Default::default()
    }

    // repeated string monitors = 1;

    pub fn monitors(&self) -> &[::std::string::String] {
        &self.monitors
    }

    pub fn clear_monitors(&mut self) {
        self.monitors.clear();
    }

    // Param is passed by value, moved
    pub fn set_monitors(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.monitors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_monitors(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.monitors
    }

    // Take field
    pub fn take_monitors(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.monitors, ::std::vec::Vec::new())
    }

    // optional string image = 2;

    pub fn image(&self) -> &str {
        match self.image.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_image(&mut self) {
        self.image = ::std::option::Option::None;
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        if self.image.is_none() {
            self.image = ::std::option::Option::Some(::std::string::String::new());
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        self.image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 3;

    pub fn fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fsType(&mut self) {
        self.fsType = ::std::option::Option::None;
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pool = 4;

    pub fn pool(&self) -> &str {
        match self.pool.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pool(&mut self) {
        self.pool = ::std::option::Option::None;
    }

    pub fn has_pool(&self) -> bool {
        self.pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pool(&mut self, v: ::std::string::String) {
        self.pool = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pool(&mut self) -> &mut ::std::string::String {
        if self.pool.is_none() {
            self.pool = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pool.as_mut().unwrap()
    }

    // Take field
    pub fn take_pool(&mut self) -> ::std::string::String {
        self.pool.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string user = 5;

    pub fn user(&self) -> &str {
        match self.user.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_user(&mut self) {
        self.user = ::std::option::Option::None;
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        if self.user.is_none() {
            self.user = ::std::option::Option::Some(::std::string::String::new());
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string keyring = 6;

    pub fn keyring(&self) -> &str {
        match self.keyring.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_keyring(&mut self) {
        self.keyring = ::std::option::Option::None;
    }

    pub fn has_keyring(&self) -> bool {
        self.keyring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyring(&mut self, v: ::std::string::String) {
        self.keyring = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyring(&mut self) -> &mut ::std::string::String {
        if self.keyring.is_none() {
            self.keyring = ::std::option::Option::Some(::std::string::String::new());
        }
        self.keyring.as_mut().unwrap()
    }

    // Take field
    pub fn take_keyring(&mut self) -> ::std::string::String {
        self.keyring.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.LocalObjectReference secretRef = 7;

    pub fn secretRef(&self) -> &LocalObjectReference {
        self.secretRef.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: LocalObjectReference) {
        self.secretRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut LocalObjectReference {
        self.secretRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> LocalObjectReference {
        self.secretRef.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    // optional bool readOnly = 8;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "monitors",
            |m: &RBDVolumeSource| { &m.monitors },
            |m: &mut RBDVolumeSource| { &mut m.monitors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "image",
            |m: &RBDVolumeSource| { &m.image },
            |m: &mut RBDVolumeSource| { &mut m.image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsType",
            |m: &RBDVolumeSource| { &m.fsType },
            |m: &mut RBDVolumeSource| { &mut m.fsType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pool",
            |m: &RBDVolumeSource| { &m.pool },
            |m: &mut RBDVolumeSource| { &mut m.pool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user",
            |m: &RBDVolumeSource| { &m.user },
            |m: &mut RBDVolumeSource| { &mut m.user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "keyring",
            |m: &RBDVolumeSource| { &m.keyring },
            |m: &mut RBDVolumeSource| { &mut m.keyring },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LocalObjectReference>(
            "secretRef",
            |m: &RBDVolumeSource| { &m.secretRef },
            |m: &mut RBDVolumeSource| { &mut m.secretRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &RBDVolumeSource| { &m.readOnly },
            |m: &mut RBDVolumeSource| { &mut m.readOnly },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RBDVolumeSource>(
            "RBDVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RBDVolumeSource {
    const NAME: &'static str = "RBDVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.monitors.push(is.read_string()?);
                },
                18 => {
                    self.image = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.fsType = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.pool = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.user = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.keyring = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.secretRef)?;
                },
                64 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.monitors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.image.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.pool.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.user.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.keyring.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.monitors {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.image.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.fsType.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.pool.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.user.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.keyring.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.secretRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RBDVolumeSource {
        RBDVolumeSource::new()
    }

    fn clear(&mut self) {
        self.monitors.clear();
        self.image = ::std::option::Option::None;
        self.fsType = ::std::option::Option::None;
        self.pool = ::std::option::Option::None;
        self.user = ::std::option::Option::None;
        self.keyring = ::std::option::Option::None;
        self.secretRef.clear();
        self.readOnly = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RBDVolumeSource {
        static instance: RBDVolumeSource = RBDVolumeSource {
            monitors: ::std::vec::Vec::new(),
            image: ::std::option::Option::None,
            fsType: ::std::option::Option::None,
            pool: ::std::option::Option::None,
            user: ::std::option::Option::None,
            keyring: ::std::option::Option::None,
            secretRef: ::protobuf::MessageField::none(),
            readOnly: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RBDVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RBDVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RBDVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RBDVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.RangeAllocation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RangeAllocation {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.RangeAllocation.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    // @@protoc_insertion_point(field:api.core.v1.RangeAllocation.range)
    pub range: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.RangeAllocation.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.RangeAllocation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RangeAllocation {
    fn default() -> &'a RangeAllocation {
        <RangeAllocation as ::protobuf::Message>::default_instance()
    }
}

impl RangeAllocation {
    pub fn new() -> RangeAllocation {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional string range = 2;

    pub fn range(&self) -> &str {
        match self.range.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_range(&mut self) {
        self.range = ::std::option::Option::None;
    }

    pub fn has_range(&self) -> bool {
        self.range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: ::std::string::String) {
        self.range = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range(&mut self) -> &mut ::std::string::String {
        if self.range.is_none() {
            self.range = ::std::option::Option::Some(::std::string::String::new());
        }
        self.range.as_mut().unwrap()
    }

    // Take field
    pub fn take_range(&mut self) -> ::std::string::String {
        self.range.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes data = 3;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &RangeAllocation| { &m.metadata },
            |m: &mut RangeAllocation| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "range",
            |m: &RangeAllocation| { &m.range },
            |m: &mut RangeAllocation| { &mut m.range },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &RangeAllocation| { &m.data },
            |m: &mut RangeAllocation| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RangeAllocation>(
            "RangeAllocation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RangeAllocation {
    const NAME: &'static str = "RangeAllocation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.range = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.range.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.range.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RangeAllocation {
        RangeAllocation::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.range = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RangeAllocation {
        static instance: RangeAllocation = RangeAllocation {
            metadata: ::protobuf::MessageField::none(),
            range: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RangeAllocation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RangeAllocation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RangeAllocation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RangeAllocation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ReplicationController)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReplicationController {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ReplicationController.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ReplicationController.spec)
    pub spec: ::protobuf::MessageField<ReplicationControllerSpec>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ReplicationController.status)
    pub status: ::protobuf::MessageField<ReplicationControllerStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ReplicationController.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReplicationController {
    fn default() -> &'a ReplicationController {
        <ReplicationController as ::protobuf::Message>::default_instance()
    }
}

impl ReplicationController {
    pub fn new() -> ReplicationController {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.core.v1.ReplicationControllerSpec spec = 2;

    pub fn spec(&self) -> &ReplicationControllerSpec {
        self.spec.as_ref().unwrap_or_else(|| <ReplicationControllerSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ReplicationControllerSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ReplicationControllerSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ReplicationControllerSpec {
        self.spec.take().unwrap_or_else(|| ReplicationControllerSpec::new())
    }

    // optional .api.core.v1.ReplicationControllerStatus status = 3;

    pub fn status(&self) -> &ReplicationControllerStatus {
        self.status.as_ref().unwrap_or_else(|| <ReplicationControllerStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ReplicationControllerStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ReplicationControllerStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> ReplicationControllerStatus {
        self.status.take().unwrap_or_else(|| ReplicationControllerStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ReplicationController| { &m.metadata },
            |m: &mut ReplicationController| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ReplicationControllerSpec>(
            "spec",
            |m: &ReplicationController| { &m.spec },
            |m: &mut ReplicationController| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ReplicationControllerStatus>(
            "status",
            |m: &ReplicationController| { &m.status },
            |m: &mut ReplicationController| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplicationController>(
            "ReplicationController",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReplicationController {
    const NAME: &'static str = "ReplicationController";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReplicationController {
        ReplicationController::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReplicationController {
        static instance: ReplicationController = ReplicationController {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReplicationController {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReplicationController").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReplicationController {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicationController {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ReplicationControllerCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReplicationControllerCondition {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ReplicationControllerCondition.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ReplicationControllerCondition.status)
    pub status: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ReplicationControllerCondition.lastTransitionTime)
    pub lastTransitionTime: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:api.core.v1.ReplicationControllerCondition.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ReplicationControllerCondition.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ReplicationControllerCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReplicationControllerCondition {
    fn default() -> &'a ReplicationControllerCondition {
        <ReplicationControllerCondition as ::protobuf::Message>::default_instance()
    }
}

impl ReplicationControllerCondition {
    pub fn new() -> ReplicationControllerCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

    pub fn lastTransitionTime(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastTransitionTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional string reason = 4;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 5;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &ReplicationControllerCondition| { &m.type_ },
            |m: &mut ReplicationControllerCondition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &ReplicationControllerCondition| { &m.status },
            |m: &mut ReplicationControllerCondition| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>(
            "lastTransitionTime",
            |m: &ReplicationControllerCondition| { &m.lastTransitionTime },
            |m: &mut ReplicationControllerCondition| { &mut m.lastTransitionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &ReplicationControllerCondition| { &m.reason },
            |m: &mut ReplicationControllerCondition| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &ReplicationControllerCondition| { &m.message },
            |m: &mut ReplicationControllerCondition| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplicationControllerCondition>(
            "ReplicationControllerCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReplicationControllerCondition {
    const NAME: &'static str = "ReplicationControllerCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTransitionTime)?;
                },
                34 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReplicationControllerCondition {
        ReplicationControllerCondition::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.lastTransitionTime.clear();
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReplicationControllerCondition {
        static instance: ReplicationControllerCondition = ReplicationControllerCondition {
            type_: ::std::option::Option::None,
            status: ::std::option::Option::None,
            lastTransitionTime: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReplicationControllerCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReplicationControllerCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReplicationControllerCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicationControllerCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ReplicationControllerList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReplicationControllerList {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ReplicationControllerList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ReplicationControllerList.items)
    pub items: ::std::vec::Vec<ReplicationController>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ReplicationControllerList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReplicationControllerList {
    fn default() -> &'a ReplicationControllerList {
        <ReplicationControllerList as ::protobuf::Message>::default_instance()
    }
}

impl ReplicationControllerList {
    pub fn new() -> ReplicationControllerList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.core.v1.ReplicationController items = 2;

    pub fn items(&self) -> &[ReplicationController] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ReplicationController>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ReplicationController> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ReplicationController> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ReplicationControllerList| { &m.metadata },
            |m: &mut ReplicationControllerList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ReplicationControllerList| { &m.items },
            |m: &mut ReplicationControllerList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplicationControllerList>(
            "ReplicationControllerList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReplicationControllerList {
    const NAME: &'static str = "ReplicationControllerList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReplicationControllerList {
        ReplicationControllerList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReplicationControllerList {
        static instance: ReplicationControllerList = ReplicationControllerList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReplicationControllerList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReplicationControllerList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReplicationControllerList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicationControllerList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ReplicationControllerSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReplicationControllerSpec {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ReplicationControllerSpec.replicas)
    pub replicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.ReplicationControllerSpec.minReadySeconds)
    pub minReadySeconds: ::std::option::Option<i32>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ReplicationControllerSpec.selector)
    pub selector: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ReplicationControllerSpec.template)
    pub template: ::protobuf::MessageField<PodTemplateSpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ReplicationControllerSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReplicationControllerSpec {
    fn default() -> &'a ReplicationControllerSpec {
        <ReplicationControllerSpec as ::protobuf::Message>::default_instance()
    }
}

impl ReplicationControllerSpec {
    pub fn new() -> ReplicationControllerSpec {
        ::std::default::Default::default()
    }

    // optional int32 replicas = 1;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // optional int32 minReadySeconds = 4;

    pub fn minReadySeconds(&self) -> i32 {
        self.minReadySeconds.unwrap_or(0)
    }

    pub fn clear_minReadySeconds(&mut self) {
        self.minReadySeconds = ::std::option::Option::None;
    }

    pub fn has_minReadySeconds(&self) -> bool {
        self.minReadySeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minReadySeconds(&mut self, v: i32) {
        self.minReadySeconds = ::std::option::Option::Some(v);
    }

    // repeated .api.core.v1.ReplicationControllerSpec.SelectorEntry selector = 2;

    pub fn selector(&self) -> &::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &self.selector
    }

    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
        self.selector = v;
    }

    // Mutable pointer to the field.
    pub fn mut_selector(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &mut self.selector
    }

    // Take field
    pub fn take_selector(&mut self) -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.selector, ::std::collections::BTreeMap::new())
    }

    // optional .api.core.v1.PodTemplateSpec template = 3;

    pub fn template(&self) -> &PodTemplateSpec {
        self.template.as_ref().unwrap_or_else(|| <PodTemplateSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_template(&mut self) {
        self.template.clear();
    }

    pub fn has_template(&self) -> bool {
        self.template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template(&mut self, v: PodTemplateSpec) {
        self.template = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template(&mut self) -> &mut PodTemplateSpec {
        self.template.mut_or_insert_default()
    }

    // Take field
    pub fn take_template(&mut self) -> PodTemplateSpec {
        self.template.take().unwrap_or_else(|| PodTemplateSpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &ReplicationControllerSpec| { &m.replicas },
            |m: &mut ReplicationControllerSpec| { &mut m.replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minReadySeconds",
            |m: &ReplicationControllerSpec| { &m.minReadySeconds },
            |m: &mut ReplicationControllerSpec| { &mut m.minReadySeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "selector",
            |m: &ReplicationControllerSpec| { &m.selector },
            |m: &mut ReplicationControllerSpec| { &mut m.selector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PodTemplateSpec>(
            "template",
            |m: &ReplicationControllerSpec| { &m.template },
            |m: &mut ReplicationControllerSpec| { &mut m.template },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplicationControllerSpec>(
            "ReplicationControllerSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReplicationControllerSpec {
    const NAME: &'static str = "ReplicationControllerSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.minReadySeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.selector.insert(key, value);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.template)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.minReadySeconds {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        for (k, v) in &self.selector {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.replicas {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.minReadySeconds {
            os.write_int32(4, v)?;
        }
        for (k, v) in &self.selector {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.template.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReplicationControllerSpec {
        ReplicationControllerSpec::new()
    }

    fn clear(&mut self) {
        self.replicas = ::std::option::Option::None;
        self.minReadySeconds = ::std::option::Option::None;
        self.selector.clear();
        self.template.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReplicationControllerSpec {
        static instance: ::protobuf::rt::Lazy<ReplicationControllerSpec> = ::protobuf::rt::Lazy::new();
        instance.get(ReplicationControllerSpec::new)
    }
}

impl ::protobuf::MessageFull for ReplicationControllerSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReplicationControllerSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReplicationControllerSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicationControllerSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ReplicationControllerStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReplicationControllerStatus {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ReplicationControllerStatus.replicas)
    pub replicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.ReplicationControllerStatus.fullyLabeledReplicas)
    pub fullyLabeledReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.ReplicationControllerStatus.readyReplicas)
    pub readyReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.ReplicationControllerStatus.availableReplicas)
    pub availableReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.ReplicationControllerStatus.observedGeneration)
    pub observedGeneration: ::std::option::Option<i64>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ReplicationControllerStatus.conditions)
    pub conditions: ::std::vec::Vec<ReplicationControllerCondition>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ReplicationControllerStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReplicationControllerStatus {
    fn default() -> &'a ReplicationControllerStatus {
        <ReplicationControllerStatus as ::protobuf::Message>::default_instance()
    }
}

impl ReplicationControllerStatus {
    pub fn new() -> ReplicationControllerStatus {
        ::std::default::Default::default()
    }

    // optional int32 replicas = 1;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // optional int32 fullyLabeledReplicas = 2;

    pub fn fullyLabeledReplicas(&self) -> i32 {
        self.fullyLabeledReplicas.unwrap_or(0)
    }

    pub fn clear_fullyLabeledReplicas(&mut self) {
        self.fullyLabeledReplicas = ::std::option::Option::None;
    }

    pub fn has_fullyLabeledReplicas(&self) -> bool {
        self.fullyLabeledReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fullyLabeledReplicas(&mut self, v: i32) {
        self.fullyLabeledReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 readyReplicas = 4;

    pub fn readyReplicas(&self) -> i32 {
        self.readyReplicas.unwrap_or(0)
    }

    pub fn clear_readyReplicas(&mut self) {
        self.readyReplicas = ::std::option::Option::None;
    }

    pub fn has_readyReplicas(&self) -> bool {
        self.readyReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readyReplicas(&mut self, v: i32) {
        self.readyReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 availableReplicas = 5;

    pub fn availableReplicas(&self) -> i32 {
        self.availableReplicas.unwrap_or(0)
    }

    pub fn clear_availableReplicas(&mut self) {
        self.availableReplicas = ::std::option::Option::None;
    }

    pub fn has_availableReplicas(&self) -> bool {
        self.availableReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_availableReplicas(&mut self, v: i32) {
        self.availableReplicas = ::std::option::Option::Some(v);
    }

    // optional int64 observedGeneration = 3;

    pub fn observedGeneration(&self) -> i64 {
        self.observedGeneration.unwrap_or(0)
    }

    pub fn clear_observedGeneration(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
    }

    pub fn has_observedGeneration(&self) -> bool {
        self.observedGeneration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observedGeneration(&mut self, v: i64) {
        self.observedGeneration = ::std::option::Option::Some(v);
    }

    // repeated .api.core.v1.ReplicationControllerCondition conditions = 6;

    pub fn conditions(&self) -> &[ReplicationControllerCondition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<ReplicationControllerCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<ReplicationControllerCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<ReplicationControllerCondition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &ReplicationControllerStatus| { &m.replicas },
            |m: &mut ReplicationControllerStatus| { &mut m.replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fullyLabeledReplicas",
            |m: &ReplicationControllerStatus| { &m.fullyLabeledReplicas },
            |m: &mut ReplicationControllerStatus| { &mut m.fullyLabeledReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readyReplicas",
            |m: &ReplicationControllerStatus| { &m.readyReplicas },
            |m: &mut ReplicationControllerStatus| { &mut m.readyReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "availableReplicas",
            |m: &ReplicationControllerStatus| { &m.availableReplicas },
            |m: &mut ReplicationControllerStatus| { &mut m.availableReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "observedGeneration",
            |m: &ReplicationControllerStatus| { &m.observedGeneration },
            |m: &mut ReplicationControllerStatus| { &mut m.observedGeneration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &ReplicationControllerStatus| { &m.conditions },
            |m: &mut ReplicationControllerStatus| { &mut m.conditions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplicationControllerStatus>(
            "ReplicationControllerStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReplicationControllerStatus {
    const NAME: &'static str = "ReplicationControllerStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.fullyLabeledReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.readyReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.availableReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.observedGeneration = ::std::option::Option::Some(is.read_int64()?);
                },
                50 => {
                    self.conditions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.fullyLabeledReplicas {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.readyReplicas {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.availableReplicas {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.observedGeneration {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.replicas {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.fullyLabeledReplicas {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.readyReplicas {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.availableReplicas {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.observedGeneration {
            os.write_int64(3, v)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReplicationControllerStatus {
        ReplicationControllerStatus::new()
    }

    fn clear(&mut self) {
        self.replicas = ::std::option::Option::None;
        self.fullyLabeledReplicas = ::std::option::Option::None;
        self.readyReplicas = ::std::option::Option::None;
        self.availableReplicas = ::std::option::Option::None;
        self.observedGeneration = ::std::option::Option::None;
        self.conditions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReplicationControllerStatus {
        static instance: ReplicationControllerStatus = ReplicationControllerStatus {
            replicas: ::std::option::Option::None,
            fullyLabeledReplicas: ::std::option::Option::None,
            readyReplicas: ::std::option::Option::None,
            availableReplicas: ::std::option::Option::None,
            observedGeneration: ::std::option::Option::None,
            conditions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReplicationControllerStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReplicationControllerStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReplicationControllerStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicationControllerStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ResourceClaim)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaim {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ResourceClaim.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ResourceClaim.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaim {
    fn default() -> &'a ResourceClaim {
        <ResourceClaim as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaim {
    pub fn new() -> ResourceClaim {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ResourceClaim| { &m.name },
            |m: &mut ResourceClaim| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaim>(
            "ResourceClaim",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaim {
    const NAME: &'static str = "ResourceClaim";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaim {
        ResourceClaim::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaim {
        static instance: ResourceClaim = ResourceClaim {
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaim {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaim").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaim {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaim {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ResourceFieldSelector)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceFieldSelector {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ResourceFieldSelector.containerName)
    pub containerName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ResourceFieldSelector.resource)
    pub resource: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ResourceFieldSelector.divisor)
    pub divisor: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::api::resource::Quantity>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ResourceFieldSelector.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceFieldSelector {
    fn default() -> &'a ResourceFieldSelector {
        <ResourceFieldSelector as ::protobuf::Message>::default_instance()
    }
}

impl ResourceFieldSelector {
    pub fn new() -> ResourceFieldSelector {
        ::std::default::Default::default()
    }

    // optional string containerName = 1;

    pub fn containerName(&self) -> &str {
        match self.containerName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_containerName(&mut self) {
        self.containerName = ::std::option::Option::None;
    }

    pub fn has_containerName(&self) -> bool {
        self.containerName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_containerName(&mut self, v: ::std::string::String) {
        self.containerName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_containerName(&mut self) -> &mut ::std::string::String {
        if self.containerName.is_none() {
            self.containerName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.containerName.as_mut().unwrap()
    }

    // Take field
    pub fn take_containerName(&mut self) -> ::std::string::String {
        self.containerName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resource = 2;

    pub fn resource(&self) -> &str {
        match self.resource.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resource(&mut self) {
        self.resource = ::std::option::Option::None;
    }

    pub fn has_resource(&self) -> bool {
        self.resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: ::std::string::String) {
        self.resource = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut ::std::string::String {
        if self.resource.is_none() {
            self.resource = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resource.as_mut().unwrap()
    }

    // Take field
    pub fn take_resource(&mut self) -> ::std::string::String {
        self.resource.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.api.resource.Quantity divisor = 3;

    pub fn divisor(&self) -> &crate::v1_30::apimachinery::pkg::api::resource::Quantity {
        self.divisor.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::api::resource::Quantity as ::protobuf::Message>::default_instance())
    }

    pub fn clear_divisor(&mut self) {
        self.divisor.clear();
    }

    pub fn has_divisor(&self) -> bool {
        self.divisor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_divisor(&mut self, v: crate::v1_30::apimachinery::pkg::api::resource::Quantity) {
        self.divisor = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_divisor(&mut self) -> &mut crate::v1_30::apimachinery::pkg::api::resource::Quantity {
        self.divisor.mut_or_insert_default()
    }

    // Take field
    pub fn take_divisor(&mut self) -> crate::v1_30::apimachinery::pkg::api::resource::Quantity {
        self.divisor.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::api::resource::Quantity::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "containerName",
            |m: &ResourceFieldSelector| { &m.containerName },
            |m: &mut ResourceFieldSelector| { &mut m.containerName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resource",
            |m: &ResourceFieldSelector| { &m.resource },
            |m: &mut ResourceFieldSelector| { &mut m.resource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::api::resource::Quantity>(
            "divisor",
            |m: &ResourceFieldSelector| { &m.divisor },
            |m: &mut ResourceFieldSelector| { &mut m.divisor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceFieldSelector>(
            "ResourceFieldSelector",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceFieldSelector {
    const NAME: &'static str = "ResourceFieldSelector";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.containerName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.resource = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.divisor)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.containerName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.resource.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.divisor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.containerName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.resource.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.divisor.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceFieldSelector {
        ResourceFieldSelector::new()
    }

    fn clear(&mut self) {
        self.containerName = ::std::option::Option::None;
        self.resource = ::std::option::Option::None;
        self.divisor.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceFieldSelector {
        static instance: ResourceFieldSelector = ResourceFieldSelector {
            containerName: ::std::option::Option::None,
            resource: ::std::option::Option::None,
            divisor: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceFieldSelector {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceFieldSelector").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceFieldSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceFieldSelector {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ResourceQuota)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceQuota {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ResourceQuota.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ResourceQuota.spec)
    pub spec: ::protobuf::MessageField<ResourceQuotaSpec>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ResourceQuota.status)
    pub status: ::protobuf::MessageField<ResourceQuotaStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ResourceQuota.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceQuota {
    fn default() -> &'a ResourceQuota {
        <ResourceQuota as ::protobuf::Message>::default_instance()
    }
}

impl ResourceQuota {
    pub fn new() -> ResourceQuota {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.core.v1.ResourceQuotaSpec spec = 2;

    pub fn spec(&self) -> &ResourceQuotaSpec {
        self.spec.as_ref().unwrap_or_else(|| <ResourceQuotaSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ResourceQuotaSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ResourceQuotaSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ResourceQuotaSpec {
        self.spec.take().unwrap_or_else(|| ResourceQuotaSpec::new())
    }

    // optional .api.core.v1.ResourceQuotaStatus status = 3;

    pub fn status(&self) -> &ResourceQuotaStatus {
        self.status.as_ref().unwrap_or_else(|| <ResourceQuotaStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ResourceQuotaStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ResourceQuotaStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> ResourceQuotaStatus {
        self.status.take().unwrap_or_else(|| ResourceQuotaStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ResourceQuota| { &m.metadata },
            |m: &mut ResourceQuota| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceQuotaSpec>(
            "spec",
            |m: &ResourceQuota| { &m.spec },
            |m: &mut ResourceQuota| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceQuotaStatus>(
            "status",
            |m: &ResourceQuota| { &m.status },
            |m: &mut ResourceQuota| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceQuota>(
            "ResourceQuota",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceQuota {
    const NAME: &'static str = "ResourceQuota";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceQuota {
        ResourceQuota::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceQuota {
        static instance: ResourceQuota = ResourceQuota {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceQuota {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceQuota").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceQuota {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceQuota {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ResourceQuotaList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceQuotaList {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ResourceQuotaList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ResourceQuotaList.items)
    pub items: ::std::vec::Vec<ResourceQuota>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ResourceQuotaList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceQuotaList {
    fn default() -> &'a ResourceQuotaList {
        <ResourceQuotaList as ::protobuf::Message>::default_instance()
    }
}

impl ResourceQuotaList {
    pub fn new() -> ResourceQuotaList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.core.v1.ResourceQuota items = 2;

    pub fn items(&self) -> &[ResourceQuota] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ResourceQuota>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ResourceQuota> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ResourceQuota> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ResourceQuotaList| { &m.metadata },
            |m: &mut ResourceQuotaList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ResourceQuotaList| { &m.items },
            |m: &mut ResourceQuotaList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceQuotaList>(
            "ResourceQuotaList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceQuotaList {
    const NAME: &'static str = "ResourceQuotaList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceQuotaList {
        ResourceQuotaList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceQuotaList {
        static instance: ResourceQuotaList = ResourceQuotaList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceQuotaList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceQuotaList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceQuotaList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceQuotaList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ResourceQuotaSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceQuotaSpec {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ResourceQuotaSpec.hard)
    pub hard: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ResourceQuotaSpec.scopes)
    pub scopes: ::std::vec::Vec<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ResourceQuotaSpec.scopeSelector)
    pub scopeSelector: ::protobuf::MessageField<ScopeSelector>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ResourceQuotaSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceQuotaSpec {
    fn default() -> &'a ResourceQuotaSpec {
        <ResourceQuotaSpec as ::protobuf::Message>::default_instance()
    }
}

impl ResourceQuotaSpec {
    pub fn new() -> ResourceQuotaSpec {
        ::std::default::Default::default()
    }

    // repeated .api.core.v1.ResourceQuotaSpec.HardEntry hard = 1;

    pub fn hard(&self) -> &::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &self.hard
    }

    pub fn clear_hard(&mut self) {
        self.hard.clear();
    }

    // Param is passed by value, moved
    pub fn set_hard(&mut self, v: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>) {
        self.hard = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hard(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &mut self.hard
    }

    // Take field
    pub fn take_hard(&mut self) -> ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        ::std::mem::replace(&mut self.hard, ::std::collections::BTreeMap::new())
    }

    // repeated string scopes = 2;

    pub fn scopes(&self) -> &[::std::string::String] {
        &self.scopes
    }

    pub fn clear_scopes(&mut self) {
        self.scopes.clear();
    }

    // Param is passed by value, moved
    pub fn set_scopes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.scopes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scopes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.scopes
    }

    // Take field
    pub fn take_scopes(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.scopes, ::std::vec::Vec::new())
    }

    // optional .api.core.v1.ScopeSelector scopeSelector = 3;

    pub fn scopeSelector(&self) -> &ScopeSelector {
        self.scopeSelector.as_ref().unwrap_or_else(|| <ScopeSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_scopeSelector(&mut self) {
        self.scopeSelector.clear();
    }

    pub fn has_scopeSelector(&self) -> bool {
        self.scopeSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scopeSelector(&mut self, v: ScopeSelector) {
        self.scopeSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scopeSelector(&mut self) -> &mut ScopeSelector {
        self.scopeSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_scopeSelector(&mut self) -> ScopeSelector {
        self.scopeSelector.take().unwrap_or_else(|| ScopeSelector::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "hard",
            |m: &ResourceQuotaSpec| { &m.hard },
            |m: &mut ResourceQuotaSpec| { &mut m.hard },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scopes",
            |m: &ResourceQuotaSpec| { &m.scopes },
            |m: &mut ResourceQuotaSpec| { &mut m.scopes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ScopeSelector>(
            "scopeSelector",
            |m: &ResourceQuotaSpec| { &m.scopeSelector },
            |m: &mut ResourceQuotaSpec| { &mut m.scopeSelector },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceQuotaSpec>(
            "ResourceQuotaSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceQuotaSpec {
    const NAME: &'static str = "ResourceQuotaSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.hard.insert(key, value);
                },
                18 => {
                    self.scopes.push(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scopeSelector)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.hard {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for value in &self.scopes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(v) = self.scopeSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.hard {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.scopes {
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.scopeSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceQuotaSpec {
        ResourceQuotaSpec::new()
    }

    fn clear(&mut self) {
        self.hard.clear();
        self.scopes.clear();
        self.scopeSelector.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceQuotaSpec {
        static instance: ::protobuf::rt::Lazy<ResourceQuotaSpec> = ::protobuf::rt::Lazy::new();
        instance.get(ResourceQuotaSpec::new)
    }
}

impl ::protobuf::MessageFull for ResourceQuotaSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceQuotaSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceQuotaSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceQuotaSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ResourceQuotaStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceQuotaStatus {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ResourceQuotaStatus.hard)
    pub hard: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ResourceQuotaStatus.used)
    pub used: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ResourceQuotaStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceQuotaStatus {
    fn default() -> &'a ResourceQuotaStatus {
        <ResourceQuotaStatus as ::protobuf::Message>::default_instance()
    }
}

impl ResourceQuotaStatus {
    pub fn new() -> ResourceQuotaStatus {
        ::std::default::Default::default()
    }

    // repeated .api.core.v1.ResourceQuotaStatus.HardEntry hard = 1;

    pub fn hard(&self) -> &::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &self.hard
    }

    pub fn clear_hard(&mut self) {
        self.hard.clear();
    }

    // Param is passed by value, moved
    pub fn set_hard(&mut self, v: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>) {
        self.hard = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hard(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &mut self.hard
    }

    // Take field
    pub fn take_hard(&mut self) -> ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        ::std::mem::replace(&mut self.hard, ::std::collections::BTreeMap::new())
    }

    // repeated .api.core.v1.ResourceQuotaStatus.UsedEntry used = 2;

    pub fn used(&self) -> &::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &self.used
    }

    pub fn clear_used(&mut self) {
        self.used.clear();
    }

    // Param is passed by value, moved
    pub fn set_used(&mut self, v: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>) {
        self.used = v;
    }

    // Mutable pointer to the field.
    pub fn mut_used(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &mut self.used
    }

    // Take field
    pub fn take_used(&mut self) -> ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        ::std::mem::replace(&mut self.used, ::std::collections::BTreeMap::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "hard",
            |m: &ResourceQuotaStatus| { &m.hard },
            |m: &mut ResourceQuotaStatus| { &mut m.hard },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "used",
            |m: &ResourceQuotaStatus| { &m.used },
            |m: &mut ResourceQuotaStatus| { &mut m.used },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceQuotaStatus>(
            "ResourceQuotaStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceQuotaStatus {
    const NAME: &'static str = "ResourceQuotaStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.hard.insert(key, value);
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.used.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.hard {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.used {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.hard {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.used {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceQuotaStatus {
        ResourceQuotaStatus::new()
    }

    fn clear(&mut self) {
        self.hard.clear();
        self.used.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceQuotaStatus {
        static instance: ::protobuf::rt::Lazy<ResourceQuotaStatus> = ::protobuf::rt::Lazy::new();
        instance.get(ResourceQuotaStatus::new)
    }
}

impl ::protobuf::MessageFull for ResourceQuotaStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceQuotaStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceQuotaStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceQuotaStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ResourceRequirements)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceRequirements {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ResourceRequirements.limits)
    pub limits: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ResourceRequirements.requests)
    pub requests: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ResourceRequirements.claims)
    pub claims: ::std::vec::Vec<ResourceClaim>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ResourceRequirements.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceRequirements {
    fn default() -> &'a ResourceRequirements {
        <ResourceRequirements as ::protobuf::Message>::default_instance()
    }
}

impl ResourceRequirements {
    pub fn new() -> ResourceRequirements {
        ::std::default::Default::default()
    }

    // repeated .api.core.v1.ResourceRequirements.LimitsEntry limits = 1;

    pub fn limits(&self) -> &::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &self.limits
    }

    pub fn clear_limits(&mut self) {
        self.limits.clear();
    }

    // Param is passed by value, moved
    pub fn set_limits(&mut self, v: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>) {
        self.limits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_limits(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &mut self.limits
    }

    // Take field
    pub fn take_limits(&mut self) -> ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        ::std::mem::replace(&mut self.limits, ::std::collections::BTreeMap::new())
    }

    // repeated .api.core.v1.ResourceRequirements.RequestsEntry requests = 2;

    pub fn requests(&self) -> &::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &self.requests
    }

    pub fn clear_requests(&mut self) {
        self.requests.clear();
    }

    // Param is passed by value, moved
    pub fn set_requests(&mut self, v: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>) {
        self.requests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requests(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &mut self.requests
    }

    // Take field
    pub fn take_requests(&mut self) -> ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        ::std::mem::replace(&mut self.requests, ::std::collections::BTreeMap::new())
    }

    // repeated .api.core.v1.ResourceClaim claims = 3;

    pub fn claims(&self) -> &[ResourceClaim] {
        &self.claims
    }

    pub fn clear_claims(&mut self) {
        self.claims.clear();
    }

    // Param is passed by value, moved
    pub fn set_claims(&mut self, v: ::std::vec::Vec<ResourceClaim>) {
        self.claims = v;
    }

    // Mutable pointer to the field.
    pub fn mut_claims(&mut self) -> &mut ::std::vec::Vec<ResourceClaim> {
        &mut self.claims
    }

    // Take field
    pub fn take_claims(&mut self) -> ::std::vec::Vec<ResourceClaim> {
        ::std::mem::replace(&mut self.claims, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "limits",
            |m: &ResourceRequirements| { &m.limits },
            |m: &mut ResourceRequirements| { &mut m.limits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "requests",
            |m: &ResourceRequirements| { &m.requests },
            |m: &mut ResourceRequirements| { &mut m.requests },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "claims",
            |m: &ResourceRequirements| { &m.claims },
            |m: &mut ResourceRequirements| { &mut m.claims },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceRequirements>(
            "ResourceRequirements",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceRequirements {
    const NAME: &'static str = "ResourceRequirements";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.limits.insert(key, value);
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.requests.insert(key, value);
                },
                26 => {
                    self.claims.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.limits {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.requests {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for value in &self.claims {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.limits {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.requests {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.claims {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceRequirements {
        ResourceRequirements::new()
    }

    fn clear(&mut self) {
        self.limits.clear();
        self.requests.clear();
        self.claims.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceRequirements {
        static instance: ::protobuf::rt::Lazy<ResourceRequirements> = ::protobuf::rt::Lazy::new();
        instance.get(ResourceRequirements::new)
    }
}

impl ::protobuf::MessageFull for ResourceRequirements {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceRequirements").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceRequirements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceRequirements {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.SELinuxOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SELinuxOptions {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.SELinuxOptions.user)
    pub user: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.SELinuxOptions.role)
    pub role: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.SELinuxOptions.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.SELinuxOptions.level)
    pub level: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.SELinuxOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SELinuxOptions {
    fn default() -> &'a SELinuxOptions {
        <SELinuxOptions as ::protobuf::Message>::default_instance()
    }
}

impl SELinuxOptions {
    pub fn new() -> SELinuxOptions {
        ::std::default::Default::default()
    }

    // optional string user = 1;

    pub fn user(&self) -> &str {
        match self.user.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_user(&mut self) {
        self.user = ::std::option::Option::None;
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        if self.user.is_none() {
            self.user = ::std::option::Option::Some(::std::string::String::new());
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string role = 2;

    pub fn role(&self) -> &str {
        match self.role.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_role(&mut self) {
        self.role = ::std::option::Option::None;
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role(&mut self) -> &mut ::std::string::String {
        if self.role.is_none() {
            self.role = ::std::option::Option::Some(::std::string::String::new());
        }
        self.role.as_mut().unwrap()
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        self.role.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string type = 3;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string level = 4;

    pub fn level(&self) -> &str {
        match self.level.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: ::std::string::String) {
        self.level = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_level(&mut self) -> &mut ::std::string::String {
        if self.level.is_none() {
            self.level = ::std::option::Option::Some(::std::string::String::new());
        }
        self.level.as_mut().unwrap()
    }

    // Take field
    pub fn take_level(&mut self) -> ::std::string::String {
        self.level.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user",
            |m: &SELinuxOptions| { &m.user },
            |m: &mut SELinuxOptions| { &mut m.user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role",
            |m: &SELinuxOptions| { &m.role },
            |m: &mut SELinuxOptions| { &mut m.role },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &SELinuxOptions| { &m.type_ },
            |m: &mut SELinuxOptions| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "level",
            |m: &SELinuxOptions| { &m.level },
            |m: &mut SELinuxOptions| { &mut m.level },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SELinuxOptions>(
            "SELinuxOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SELinuxOptions {
    const NAME: &'static str = "SELinuxOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.user = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.role = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.level = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.role.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.level.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.role.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.type_.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.level.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SELinuxOptions {
        SELinuxOptions::new()
    }

    fn clear(&mut self) {
        self.user = ::std::option::Option::None;
        self.role = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SELinuxOptions {
        static instance: SELinuxOptions = SELinuxOptions {
            user: ::std::option::Option::None,
            role: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            level: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SELinuxOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SELinuxOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SELinuxOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SELinuxOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ScaleIOPersistentVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ScaleIOPersistentVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ScaleIOPersistentVolumeSource.gateway)
    pub gateway: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ScaleIOPersistentVolumeSource.system)
    pub system: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ScaleIOPersistentVolumeSource.secretRef)
    pub secretRef: ::protobuf::MessageField<SecretReference>,
    // @@protoc_insertion_point(field:api.core.v1.ScaleIOPersistentVolumeSource.sslEnabled)
    pub sslEnabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.ScaleIOPersistentVolumeSource.protectionDomain)
    pub protectionDomain: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ScaleIOPersistentVolumeSource.storagePool)
    pub storagePool: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ScaleIOPersistentVolumeSource.storageMode)
    pub storageMode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ScaleIOPersistentVolumeSource.volumeName)
    pub volumeName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ScaleIOPersistentVolumeSource.fsType)
    pub fsType: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ScaleIOPersistentVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ScaleIOPersistentVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScaleIOPersistentVolumeSource {
    fn default() -> &'a ScaleIOPersistentVolumeSource {
        <ScaleIOPersistentVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl ScaleIOPersistentVolumeSource {
    pub fn new() -> ScaleIOPersistentVolumeSource {
        ::std::default::Default::default()
    }

    // optional string gateway = 1;

    pub fn gateway(&self) -> &str {
        match self.gateway.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gateway(&mut self) {
        self.gateway = ::std::option::Option::None;
    }

    pub fn has_gateway(&self) -> bool {
        self.gateway.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gateway(&mut self, v: ::std::string::String) {
        self.gateway = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gateway(&mut self) -> &mut ::std::string::String {
        if self.gateway.is_none() {
            self.gateway = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gateway.as_mut().unwrap()
    }

    // Take field
    pub fn take_gateway(&mut self) -> ::std::string::String {
        self.gateway.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string system = 2;

    pub fn system(&self) -> &str {
        match self.system.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_system(&mut self) {
        self.system = ::std::option::Option::None;
    }

    pub fn has_system(&self) -> bool {
        self.system.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system(&mut self, v: ::std::string::String) {
        self.system = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system(&mut self) -> &mut ::std::string::String {
        if self.system.is_none() {
            self.system = ::std::option::Option::Some(::std::string::String::new());
        }
        self.system.as_mut().unwrap()
    }

    // Take field
    pub fn take_system(&mut self) -> ::std::string::String {
        self.system.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.SecretReference secretRef = 3;

    pub fn secretRef(&self) -> &SecretReference {
        self.secretRef.as_ref().unwrap_or_else(|| <SecretReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: SecretReference) {
        self.secretRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut SecretReference {
        self.secretRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> SecretReference {
        self.secretRef.take().unwrap_or_else(|| SecretReference::new())
    }

    // optional bool sslEnabled = 4;

    pub fn sslEnabled(&self) -> bool {
        self.sslEnabled.unwrap_or(false)
    }

    pub fn clear_sslEnabled(&mut self) {
        self.sslEnabled = ::std::option::Option::None;
    }

    pub fn has_sslEnabled(&self) -> bool {
        self.sslEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sslEnabled(&mut self, v: bool) {
        self.sslEnabled = ::std::option::Option::Some(v);
    }

    // optional string protectionDomain = 5;

    pub fn protectionDomain(&self) -> &str {
        match self.protectionDomain.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_protectionDomain(&mut self) {
        self.protectionDomain = ::std::option::Option::None;
    }

    pub fn has_protectionDomain(&self) -> bool {
        self.protectionDomain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protectionDomain(&mut self, v: ::std::string::String) {
        self.protectionDomain = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protectionDomain(&mut self) -> &mut ::std::string::String {
        if self.protectionDomain.is_none() {
            self.protectionDomain = ::std::option::Option::Some(::std::string::String::new());
        }
        self.protectionDomain.as_mut().unwrap()
    }

    // Take field
    pub fn take_protectionDomain(&mut self) -> ::std::string::String {
        self.protectionDomain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string storagePool = 6;

    pub fn storagePool(&self) -> &str {
        match self.storagePool.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_storagePool(&mut self) {
        self.storagePool = ::std::option::Option::None;
    }

    pub fn has_storagePool(&self) -> bool {
        self.storagePool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storagePool(&mut self, v: ::std::string::String) {
        self.storagePool = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storagePool(&mut self) -> &mut ::std::string::String {
        if self.storagePool.is_none() {
            self.storagePool = ::std::option::Option::Some(::std::string::String::new());
        }
        self.storagePool.as_mut().unwrap()
    }

    // Take field
    pub fn take_storagePool(&mut self) -> ::std::string::String {
        self.storagePool.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string storageMode = 7;

    pub fn storageMode(&self) -> &str {
        match self.storageMode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_storageMode(&mut self) {
        self.storageMode = ::std::option::Option::None;
    }

    pub fn has_storageMode(&self) -> bool {
        self.storageMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageMode(&mut self, v: ::std::string::String) {
        self.storageMode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageMode(&mut self) -> &mut ::std::string::String {
        if self.storageMode.is_none() {
            self.storageMode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.storageMode.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageMode(&mut self) -> ::std::string::String {
        self.storageMode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string volumeName = 8;

    pub fn volumeName(&self) -> &str {
        match self.volumeName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_volumeName(&mut self) {
        self.volumeName = ::std::option::Option::None;
    }

    pub fn has_volumeName(&self) -> bool {
        self.volumeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeName(&mut self, v: ::std::string::String) {
        self.volumeName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeName(&mut self) -> &mut ::std::string::String {
        if self.volumeName.is_none() {
            self.volumeName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.volumeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeName(&mut self) -> ::std::string::String {
        self.volumeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 9;

    pub fn fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fsType(&mut self) {
        self.fsType = ::std::option::Option::None;
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 10;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gateway",
            |m: &ScaleIOPersistentVolumeSource| { &m.gateway },
            |m: &mut ScaleIOPersistentVolumeSource| { &mut m.gateway },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "system",
            |m: &ScaleIOPersistentVolumeSource| { &m.system },
            |m: &mut ScaleIOPersistentVolumeSource| { &mut m.system },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SecretReference>(
            "secretRef",
            |m: &ScaleIOPersistentVolumeSource| { &m.secretRef },
            |m: &mut ScaleIOPersistentVolumeSource| { &mut m.secretRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sslEnabled",
            |m: &ScaleIOPersistentVolumeSource| { &m.sslEnabled },
            |m: &mut ScaleIOPersistentVolumeSource| { &mut m.sslEnabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protectionDomain",
            |m: &ScaleIOPersistentVolumeSource| { &m.protectionDomain },
            |m: &mut ScaleIOPersistentVolumeSource| { &mut m.protectionDomain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "storagePool",
            |m: &ScaleIOPersistentVolumeSource| { &m.storagePool },
            |m: &mut ScaleIOPersistentVolumeSource| { &mut m.storagePool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "storageMode",
            |m: &ScaleIOPersistentVolumeSource| { &m.storageMode },
            |m: &mut ScaleIOPersistentVolumeSource| { &mut m.storageMode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volumeName",
            |m: &ScaleIOPersistentVolumeSource| { &m.volumeName },
            |m: &mut ScaleIOPersistentVolumeSource| { &mut m.volumeName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsType",
            |m: &ScaleIOPersistentVolumeSource| { &m.fsType },
            |m: &mut ScaleIOPersistentVolumeSource| { &mut m.fsType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &ScaleIOPersistentVolumeSource| { &m.readOnly },
            |m: &mut ScaleIOPersistentVolumeSource| { &mut m.readOnly },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScaleIOPersistentVolumeSource>(
            "ScaleIOPersistentVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScaleIOPersistentVolumeSource {
    const NAME: &'static str = "ScaleIOPersistentVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.gateway = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.system = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.secretRef)?;
                },
                32 => {
                    self.sslEnabled = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.protectionDomain = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.storagePool = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.storageMode = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.volumeName = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.fsType = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gateway.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.system.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sslEnabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.protectionDomain.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.storagePool.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.storageMode.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.volumeName.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gateway.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.system.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.secretRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.sslEnabled {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.protectionDomain.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.storagePool.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.storageMode.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.volumeName.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.fsType.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScaleIOPersistentVolumeSource {
        ScaleIOPersistentVolumeSource::new()
    }

    fn clear(&mut self) {
        self.gateway = ::std::option::Option::None;
        self.system = ::std::option::Option::None;
        self.secretRef.clear();
        self.sslEnabled = ::std::option::Option::None;
        self.protectionDomain = ::std::option::Option::None;
        self.storagePool = ::std::option::Option::None;
        self.storageMode = ::std::option::Option::None;
        self.volumeName = ::std::option::Option::None;
        self.fsType = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScaleIOPersistentVolumeSource {
        static instance: ScaleIOPersistentVolumeSource = ScaleIOPersistentVolumeSource {
            gateway: ::std::option::Option::None,
            system: ::std::option::Option::None,
            secretRef: ::protobuf::MessageField::none(),
            sslEnabled: ::std::option::Option::None,
            protectionDomain: ::std::option::Option::None,
            storagePool: ::std::option::Option::None,
            storageMode: ::std::option::Option::None,
            volumeName: ::std::option::Option::None,
            fsType: ::std::option::Option::None,
            readOnly: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScaleIOPersistentVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScaleIOPersistentVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScaleIOPersistentVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScaleIOPersistentVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ScaleIOVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ScaleIOVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ScaleIOVolumeSource.gateway)
    pub gateway: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ScaleIOVolumeSource.system)
    pub system: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ScaleIOVolumeSource.secretRef)
    pub secretRef: ::protobuf::MessageField<LocalObjectReference>,
    // @@protoc_insertion_point(field:api.core.v1.ScaleIOVolumeSource.sslEnabled)
    pub sslEnabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.ScaleIOVolumeSource.protectionDomain)
    pub protectionDomain: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ScaleIOVolumeSource.storagePool)
    pub storagePool: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ScaleIOVolumeSource.storageMode)
    pub storageMode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ScaleIOVolumeSource.volumeName)
    pub volumeName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ScaleIOVolumeSource.fsType)
    pub fsType: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ScaleIOVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ScaleIOVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScaleIOVolumeSource {
    fn default() -> &'a ScaleIOVolumeSource {
        <ScaleIOVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl ScaleIOVolumeSource {
    pub fn new() -> ScaleIOVolumeSource {
        ::std::default::Default::default()
    }

    // optional string gateway = 1;

    pub fn gateway(&self) -> &str {
        match self.gateway.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gateway(&mut self) {
        self.gateway = ::std::option::Option::None;
    }

    pub fn has_gateway(&self) -> bool {
        self.gateway.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gateway(&mut self, v: ::std::string::String) {
        self.gateway = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gateway(&mut self) -> &mut ::std::string::String {
        if self.gateway.is_none() {
            self.gateway = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gateway.as_mut().unwrap()
    }

    // Take field
    pub fn take_gateway(&mut self) -> ::std::string::String {
        self.gateway.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string system = 2;

    pub fn system(&self) -> &str {
        match self.system.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_system(&mut self) {
        self.system = ::std::option::Option::None;
    }

    pub fn has_system(&self) -> bool {
        self.system.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system(&mut self, v: ::std::string::String) {
        self.system = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system(&mut self) -> &mut ::std::string::String {
        if self.system.is_none() {
            self.system = ::std::option::Option::Some(::std::string::String::new());
        }
        self.system.as_mut().unwrap()
    }

    // Take field
    pub fn take_system(&mut self) -> ::std::string::String {
        self.system.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.LocalObjectReference secretRef = 3;

    pub fn secretRef(&self) -> &LocalObjectReference {
        self.secretRef.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: LocalObjectReference) {
        self.secretRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut LocalObjectReference {
        self.secretRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> LocalObjectReference {
        self.secretRef.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    // optional bool sslEnabled = 4;

    pub fn sslEnabled(&self) -> bool {
        self.sslEnabled.unwrap_or(false)
    }

    pub fn clear_sslEnabled(&mut self) {
        self.sslEnabled = ::std::option::Option::None;
    }

    pub fn has_sslEnabled(&self) -> bool {
        self.sslEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sslEnabled(&mut self, v: bool) {
        self.sslEnabled = ::std::option::Option::Some(v);
    }

    // optional string protectionDomain = 5;

    pub fn protectionDomain(&self) -> &str {
        match self.protectionDomain.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_protectionDomain(&mut self) {
        self.protectionDomain = ::std::option::Option::None;
    }

    pub fn has_protectionDomain(&self) -> bool {
        self.protectionDomain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protectionDomain(&mut self, v: ::std::string::String) {
        self.protectionDomain = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protectionDomain(&mut self) -> &mut ::std::string::String {
        if self.protectionDomain.is_none() {
            self.protectionDomain = ::std::option::Option::Some(::std::string::String::new());
        }
        self.protectionDomain.as_mut().unwrap()
    }

    // Take field
    pub fn take_protectionDomain(&mut self) -> ::std::string::String {
        self.protectionDomain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string storagePool = 6;

    pub fn storagePool(&self) -> &str {
        match self.storagePool.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_storagePool(&mut self) {
        self.storagePool = ::std::option::Option::None;
    }

    pub fn has_storagePool(&self) -> bool {
        self.storagePool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storagePool(&mut self, v: ::std::string::String) {
        self.storagePool = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storagePool(&mut self) -> &mut ::std::string::String {
        if self.storagePool.is_none() {
            self.storagePool = ::std::option::Option::Some(::std::string::String::new());
        }
        self.storagePool.as_mut().unwrap()
    }

    // Take field
    pub fn take_storagePool(&mut self) -> ::std::string::String {
        self.storagePool.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string storageMode = 7;

    pub fn storageMode(&self) -> &str {
        match self.storageMode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_storageMode(&mut self) {
        self.storageMode = ::std::option::Option::None;
    }

    pub fn has_storageMode(&self) -> bool {
        self.storageMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageMode(&mut self, v: ::std::string::String) {
        self.storageMode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageMode(&mut self) -> &mut ::std::string::String {
        if self.storageMode.is_none() {
            self.storageMode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.storageMode.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageMode(&mut self) -> ::std::string::String {
        self.storageMode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string volumeName = 8;

    pub fn volumeName(&self) -> &str {
        match self.volumeName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_volumeName(&mut self) {
        self.volumeName = ::std::option::Option::None;
    }

    pub fn has_volumeName(&self) -> bool {
        self.volumeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeName(&mut self, v: ::std::string::String) {
        self.volumeName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeName(&mut self) -> &mut ::std::string::String {
        if self.volumeName.is_none() {
            self.volumeName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.volumeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeName(&mut self) -> ::std::string::String {
        self.volumeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 9;

    pub fn fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fsType(&mut self) {
        self.fsType = ::std::option::Option::None;
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 10;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gateway",
            |m: &ScaleIOVolumeSource| { &m.gateway },
            |m: &mut ScaleIOVolumeSource| { &mut m.gateway },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "system",
            |m: &ScaleIOVolumeSource| { &m.system },
            |m: &mut ScaleIOVolumeSource| { &mut m.system },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LocalObjectReference>(
            "secretRef",
            |m: &ScaleIOVolumeSource| { &m.secretRef },
            |m: &mut ScaleIOVolumeSource| { &mut m.secretRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sslEnabled",
            |m: &ScaleIOVolumeSource| { &m.sslEnabled },
            |m: &mut ScaleIOVolumeSource| { &mut m.sslEnabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protectionDomain",
            |m: &ScaleIOVolumeSource| { &m.protectionDomain },
            |m: &mut ScaleIOVolumeSource| { &mut m.protectionDomain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "storagePool",
            |m: &ScaleIOVolumeSource| { &m.storagePool },
            |m: &mut ScaleIOVolumeSource| { &mut m.storagePool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "storageMode",
            |m: &ScaleIOVolumeSource| { &m.storageMode },
            |m: &mut ScaleIOVolumeSource| { &mut m.storageMode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volumeName",
            |m: &ScaleIOVolumeSource| { &m.volumeName },
            |m: &mut ScaleIOVolumeSource| { &mut m.volumeName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsType",
            |m: &ScaleIOVolumeSource| { &m.fsType },
            |m: &mut ScaleIOVolumeSource| { &mut m.fsType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &ScaleIOVolumeSource| { &m.readOnly },
            |m: &mut ScaleIOVolumeSource| { &mut m.readOnly },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScaleIOVolumeSource>(
            "ScaleIOVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScaleIOVolumeSource {
    const NAME: &'static str = "ScaleIOVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.gateway = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.system = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.secretRef)?;
                },
                32 => {
                    self.sslEnabled = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.protectionDomain = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.storagePool = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.storageMode = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.volumeName = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.fsType = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gateway.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.system.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sslEnabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.protectionDomain.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.storagePool.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.storageMode.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.volumeName.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gateway.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.system.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.secretRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.sslEnabled {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.protectionDomain.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.storagePool.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.storageMode.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.volumeName.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.fsType.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScaleIOVolumeSource {
        ScaleIOVolumeSource::new()
    }

    fn clear(&mut self) {
        self.gateway = ::std::option::Option::None;
        self.system = ::std::option::Option::None;
        self.secretRef.clear();
        self.sslEnabled = ::std::option::Option::None;
        self.protectionDomain = ::std::option::Option::None;
        self.storagePool = ::std::option::Option::None;
        self.storageMode = ::std::option::Option::None;
        self.volumeName = ::std::option::Option::None;
        self.fsType = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScaleIOVolumeSource {
        static instance: ScaleIOVolumeSource = ScaleIOVolumeSource {
            gateway: ::std::option::Option::None,
            system: ::std::option::Option::None,
            secretRef: ::protobuf::MessageField::none(),
            sslEnabled: ::std::option::Option::None,
            protectionDomain: ::std::option::Option::None,
            storagePool: ::std::option::Option::None,
            storageMode: ::std::option::Option::None,
            volumeName: ::std::option::Option::None,
            fsType: ::std::option::Option::None,
            readOnly: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScaleIOVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScaleIOVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScaleIOVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScaleIOVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ScopeSelector)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ScopeSelector {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ScopeSelector.matchExpressions)
    pub matchExpressions: ::std::vec::Vec<ScopedResourceSelectorRequirement>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ScopeSelector.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScopeSelector {
    fn default() -> &'a ScopeSelector {
        <ScopeSelector as ::protobuf::Message>::default_instance()
    }
}

impl ScopeSelector {
    pub fn new() -> ScopeSelector {
        ::std::default::Default::default()
    }

    // repeated .api.core.v1.ScopedResourceSelectorRequirement matchExpressions = 1;

    pub fn matchExpressions(&self) -> &[ScopedResourceSelectorRequirement] {
        &self.matchExpressions
    }

    pub fn clear_matchExpressions(&mut self) {
        self.matchExpressions.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchExpressions(&mut self, v: ::std::vec::Vec<ScopedResourceSelectorRequirement>) {
        self.matchExpressions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchExpressions(&mut self) -> &mut ::std::vec::Vec<ScopedResourceSelectorRequirement> {
        &mut self.matchExpressions
    }

    // Take field
    pub fn take_matchExpressions(&mut self) -> ::std::vec::Vec<ScopedResourceSelectorRequirement> {
        ::std::mem::replace(&mut self.matchExpressions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matchExpressions",
            |m: &ScopeSelector| { &m.matchExpressions },
            |m: &mut ScopeSelector| { &mut m.matchExpressions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScopeSelector>(
            "ScopeSelector",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScopeSelector {
    const NAME: &'static str = "ScopeSelector";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.matchExpressions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.matchExpressions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.matchExpressions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScopeSelector {
        ScopeSelector::new()
    }

    fn clear(&mut self) {
        self.matchExpressions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScopeSelector {
        static instance: ScopeSelector = ScopeSelector {
            matchExpressions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScopeSelector {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScopeSelector").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScopeSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScopeSelector {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ScopedResourceSelectorRequirement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ScopedResourceSelectorRequirement {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ScopedResourceSelectorRequirement.scopeName)
    pub scopeName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ScopedResourceSelectorRequirement.operator)
    pub operator: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ScopedResourceSelectorRequirement.values)
    pub values: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ScopedResourceSelectorRequirement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScopedResourceSelectorRequirement {
    fn default() -> &'a ScopedResourceSelectorRequirement {
        <ScopedResourceSelectorRequirement as ::protobuf::Message>::default_instance()
    }
}

impl ScopedResourceSelectorRequirement {
    pub fn new() -> ScopedResourceSelectorRequirement {
        ::std::default::Default::default()
    }

    // optional string scopeName = 1;

    pub fn scopeName(&self) -> &str {
        match self.scopeName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_scopeName(&mut self) {
        self.scopeName = ::std::option::Option::None;
    }

    pub fn has_scopeName(&self) -> bool {
        self.scopeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scopeName(&mut self, v: ::std::string::String) {
        self.scopeName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scopeName(&mut self) -> &mut ::std::string::String {
        if self.scopeName.is_none() {
            self.scopeName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.scopeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_scopeName(&mut self) -> ::std::string::String {
        self.scopeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string operator = 2;

    pub fn operator(&self) -> &str {
        match self.operator.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_operator(&mut self) {
        self.operator = ::std::option::Option::None;
    }

    pub fn has_operator(&self) -> bool {
        self.operator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operator(&mut self, v: ::std::string::String) {
        self.operator = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operator(&mut self) -> &mut ::std::string::String {
        if self.operator.is_none() {
            self.operator = ::std::option::Option::Some(::std::string::String::new());
        }
        self.operator.as_mut().unwrap()
    }

    // Take field
    pub fn take_operator(&mut self) -> ::std::string::String {
        self.operator.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string values = 3;

    pub fn values(&self) -> &[::std::string::String] {
        &self.values
    }

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scopeName",
            |m: &ScopedResourceSelectorRequirement| { &m.scopeName },
            |m: &mut ScopedResourceSelectorRequirement| { &mut m.scopeName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "operator",
            |m: &ScopedResourceSelectorRequirement| { &m.operator },
            |m: &mut ScopedResourceSelectorRequirement| { &mut m.operator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &ScopedResourceSelectorRequirement| { &m.values },
            |m: &mut ScopedResourceSelectorRequirement| { &mut m.values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScopedResourceSelectorRequirement>(
            "ScopedResourceSelectorRequirement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScopedResourceSelectorRequirement {
    const NAME: &'static str = "ScopedResourceSelectorRequirement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.scopeName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.operator = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.values.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.scopeName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.operator.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.values {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.scopeName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.operator.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.values {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScopedResourceSelectorRequirement {
        ScopedResourceSelectorRequirement::new()
    }

    fn clear(&mut self) {
        self.scopeName = ::std::option::Option::None;
        self.operator = ::std::option::Option::None;
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScopedResourceSelectorRequirement {
        static instance: ScopedResourceSelectorRequirement = ScopedResourceSelectorRequirement {
            scopeName: ::std::option::Option::None,
            operator: ::std::option::Option::None,
            values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScopedResourceSelectorRequirement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScopedResourceSelectorRequirement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScopedResourceSelectorRequirement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScopedResourceSelectorRequirement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.SeccompProfile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SeccompProfile {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.SeccompProfile.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.SeccompProfile.localhostProfile)
    pub localhostProfile: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.SeccompProfile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SeccompProfile {
    fn default() -> &'a SeccompProfile {
        <SeccompProfile as ::protobuf::Message>::default_instance()
    }
}

impl SeccompProfile {
    pub fn new() -> SeccompProfile {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string localhostProfile = 2;

    pub fn localhostProfile(&self) -> &str {
        match self.localhostProfile.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_localhostProfile(&mut self) {
        self.localhostProfile = ::std::option::Option::None;
    }

    pub fn has_localhostProfile(&self) -> bool {
        self.localhostProfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localhostProfile(&mut self, v: ::std::string::String) {
        self.localhostProfile = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localhostProfile(&mut self) -> &mut ::std::string::String {
        if self.localhostProfile.is_none() {
            self.localhostProfile = ::std::option::Option::Some(::std::string::String::new());
        }
        self.localhostProfile.as_mut().unwrap()
    }

    // Take field
    pub fn take_localhostProfile(&mut self) -> ::std::string::String {
        self.localhostProfile.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &SeccompProfile| { &m.type_ },
            |m: &mut SeccompProfile| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "localhostProfile",
            |m: &SeccompProfile| { &m.localhostProfile },
            |m: &mut SeccompProfile| { &mut m.localhostProfile },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SeccompProfile>(
            "SeccompProfile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SeccompProfile {
    const NAME: &'static str = "SeccompProfile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.localhostProfile = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.localhostProfile.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.localhostProfile.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SeccompProfile {
        SeccompProfile::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.localhostProfile = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SeccompProfile {
        static instance: SeccompProfile = SeccompProfile {
            type_: ::std::option::Option::None,
            localhostProfile: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SeccompProfile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SeccompProfile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SeccompProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SeccompProfile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.Secret)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Secret {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Secret.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    // @@protoc_insertion_point(field:api.core.v1.Secret.immutable)
    pub immutable: ::std::option::Option<bool>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Secret.data)
    pub data: ::std::collections::BTreeMap<::std::string::String, ::std::vec::Vec<u8>>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Secret.stringData)
    pub stringData: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.Secret.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.Secret.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Secret {
    fn default() -> &'a Secret {
        <Secret as ::protobuf::Message>::default_instance()
    }
}

impl Secret {
    pub fn new() -> Secret {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional bool immutable = 5;

    pub fn immutable(&self) -> bool {
        self.immutable.unwrap_or(false)
    }

    pub fn clear_immutable(&mut self) {
        self.immutable = ::std::option::Option::None;
    }

    pub fn has_immutable(&self) -> bool {
        self.immutable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_immutable(&mut self, v: bool) {
        self.immutable = ::std::option::Option::Some(v);
    }

    // repeated .api.core.v1.Secret.DataEntry data = 2;

    pub fn data(&self) -> &::std::collections::BTreeMap<::std::string::String, ::std::vec::Vec<u8>> {
        &self.data
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::collections::BTreeMap<::std::string::String, ::std::vec::Vec<u8>>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, ::std::vec::Vec<u8>> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::collections::BTreeMap<::std::string::String, ::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.data, ::std::collections::BTreeMap::new())
    }

    // repeated .api.core.v1.Secret.StringDataEntry stringData = 4;

    pub fn stringData(&self) -> &::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &self.stringData
    }

    pub fn clear_stringData(&mut self) {
        self.stringData.clear();
    }

    // Param is passed by value, moved
    pub fn set_stringData(&mut self, v: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
        self.stringData = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stringData(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &mut self.stringData
    }

    // Take field
    pub fn take_stringData(&mut self) -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.stringData, ::std::collections::BTreeMap::new())
    }

    // optional string type = 3;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &Secret| { &m.metadata },
            |m: &mut Secret| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "immutable",
            |m: &Secret| { &m.immutable },
            |m: &mut Secret| { &mut m.immutable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "data",
            |m: &Secret| { &m.data },
            |m: &mut Secret| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "stringData",
            |m: &Secret| { &m.stringData },
            |m: &mut Secret| { &mut m.stringData },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &Secret| { &m.type_ },
            |m: &mut Secret| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Secret>(
            "Secret",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Secret {
    const NAME: &'static str = "Secret";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                40 => {
                    self.immutable = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_bytes()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.data.insert(key, value);
                },
                34 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.stringData.insert(key, value);
                },
                26 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.immutable {
            my_size += 1 + 1;
        }
        for (k, v) in &self.data {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.stringData {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.immutable {
            os.write_bool(5, v)?;
        }
        for (k, v) in &self.data {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_bytes(2, &v)?;
        };
        for (k, v) in &self.stringData {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(34)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.type_.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Secret {
        Secret::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.immutable = ::std::option::Option::None;
        self.data.clear();
        self.stringData.clear();
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Secret {
        static instance: ::protobuf::rt::Lazy<Secret> = ::protobuf::rt::Lazy::new();
        instance.get(Secret::new)
    }
}

impl ::protobuf::MessageFull for Secret {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Secret").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Secret {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Secret {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.SecretEnvSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SecretEnvSource {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.SecretEnvSource.localObjectReference)
    pub localObjectReference: ::protobuf::MessageField<LocalObjectReference>,
    // @@protoc_insertion_point(field:api.core.v1.SecretEnvSource.optional)
    pub optional: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.SecretEnvSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SecretEnvSource {
    fn default() -> &'a SecretEnvSource {
        <SecretEnvSource as ::protobuf::Message>::default_instance()
    }
}

impl SecretEnvSource {
    pub fn new() -> SecretEnvSource {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.LocalObjectReference localObjectReference = 1;

    pub fn localObjectReference(&self) -> &LocalObjectReference {
        self.localObjectReference.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_localObjectReference(&mut self) {
        self.localObjectReference.clear();
    }

    pub fn has_localObjectReference(&self) -> bool {
        self.localObjectReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localObjectReference(&mut self, v: LocalObjectReference) {
        self.localObjectReference = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localObjectReference(&mut self) -> &mut LocalObjectReference {
        self.localObjectReference.mut_or_insert_default()
    }

    // Take field
    pub fn take_localObjectReference(&mut self) -> LocalObjectReference {
        self.localObjectReference.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    // optional bool optional = 2;

    pub fn optional(&self) -> bool {
        self.optional.unwrap_or(false)
    }

    pub fn clear_optional(&mut self) {
        self.optional = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        self.optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LocalObjectReference>(
            "localObjectReference",
            |m: &SecretEnvSource| { &m.localObjectReference },
            |m: &mut SecretEnvSource| { &mut m.localObjectReference },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "optional",
            |m: &SecretEnvSource| { &m.optional },
            |m: &mut SecretEnvSource| { &mut m.optional },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SecretEnvSource>(
            "SecretEnvSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SecretEnvSource {
    const NAME: &'static str = "SecretEnvSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.localObjectReference)?;
                },
                16 => {
                    self.optional = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.localObjectReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.optional {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.localObjectReference.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.optional {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SecretEnvSource {
        SecretEnvSource::new()
    }

    fn clear(&mut self) {
        self.localObjectReference.clear();
        self.optional = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SecretEnvSource {
        static instance: SecretEnvSource = SecretEnvSource {
            localObjectReference: ::protobuf::MessageField::none(),
            optional: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SecretEnvSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SecretEnvSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SecretEnvSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretEnvSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.SecretKeySelector)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SecretKeySelector {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.SecretKeySelector.localObjectReference)
    pub localObjectReference: ::protobuf::MessageField<LocalObjectReference>,
    // @@protoc_insertion_point(field:api.core.v1.SecretKeySelector.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.SecretKeySelector.optional)
    pub optional: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.SecretKeySelector.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SecretKeySelector {
    fn default() -> &'a SecretKeySelector {
        <SecretKeySelector as ::protobuf::Message>::default_instance()
    }
}

impl SecretKeySelector {
    pub fn new() -> SecretKeySelector {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.LocalObjectReference localObjectReference = 1;

    pub fn localObjectReference(&self) -> &LocalObjectReference {
        self.localObjectReference.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_localObjectReference(&mut self) {
        self.localObjectReference.clear();
    }

    pub fn has_localObjectReference(&self) -> bool {
        self.localObjectReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localObjectReference(&mut self, v: LocalObjectReference) {
        self.localObjectReference = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localObjectReference(&mut self) -> &mut LocalObjectReference {
        self.localObjectReference.mut_or_insert_default()
    }

    // Take field
    pub fn take_localObjectReference(&mut self) -> LocalObjectReference {
        self.localObjectReference.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    // optional string key = 2;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool optional = 3;

    pub fn optional(&self) -> bool {
        self.optional.unwrap_or(false)
    }

    pub fn clear_optional(&mut self) {
        self.optional = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        self.optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LocalObjectReference>(
            "localObjectReference",
            |m: &SecretKeySelector| { &m.localObjectReference },
            |m: &mut SecretKeySelector| { &mut m.localObjectReference },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &SecretKeySelector| { &m.key },
            |m: &mut SecretKeySelector| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "optional",
            |m: &SecretKeySelector| { &m.optional },
            |m: &mut SecretKeySelector| { &mut m.optional },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SecretKeySelector>(
            "SecretKeySelector",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SecretKeySelector {
    const NAME: &'static str = "SecretKeySelector";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.localObjectReference)?;
                },
                18 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.optional = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.localObjectReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.optional {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.localObjectReference.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.key.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.optional {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SecretKeySelector {
        SecretKeySelector::new()
    }

    fn clear(&mut self) {
        self.localObjectReference.clear();
        self.key = ::std::option::Option::None;
        self.optional = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SecretKeySelector {
        static instance: SecretKeySelector = SecretKeySelector {
            localObjectReference: ::protobuf::MessageField::none(),
            key: ::std::option::Option::None,
            optional: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SecretKeySelector {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SecretKeySelector").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SecretKeySelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretKeySelector {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.SecretList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SecretList {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.SecretList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.SecretList.items)
    pub items: ::std::vec::Vec<Secret>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.SecretList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SecretList {
    fn default() -> &'a SecretList {
        <SecretList as ::protobuf::Message>::default_instance()
    }
}

impl SecretList {
    pub fn new() -> SecretList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.core.v1.Secret items = 2;

    pub fn items(&self) -> &[Secret] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<Secret>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<Secret> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<Secret> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &SecretList| { &m.metadata },
            |m: &mut SecretList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &SecretList| { &m.items },
            |m: &mut SecretList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SecretList>(
            "SecretList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SecretList {
    const NAME: &'static str = "SecretList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SecretList {
        SecretList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SecretList {
        static instance: SecretList = SecretList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SecretList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SecretList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SecretList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.SecretProjection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SecretProjection {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.SecretProjection.localObjectReference)
    pub localObjectReference: ::protobuf::MessageField<LocalObjectReference>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.SecretProjection.items)
    pub items: ::std::vec::Vec<KeyToPath>,
    // @@protoc_insertion_point(field:api.core.v1.SecretProjection.optional)
    pub optional: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.SecretProjection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SecretProjection {
    fn default() -> &'a SecretProjection {
        <SecretProjection as ::protobuf::Message>::default_instance()
    }
}

impl SecretProjection {
    pub fn new() -> SecretProjection {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.LocalObjectReference localObjectReference = 1;

    pub fn localObjectReference(&self) -> &LocalObjectReference {
        self.localObjectReference.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_localObjectReference(&mut self) {
        self.localObjectReference.clear();
    }

    pub fn has_localObjectReference(&self) -> bool {
        self.localObjectReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localObjectReference(&mut self, v: LocalObjectReference) {
        self.localObjectReference = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localObjectReference(&mut self) -> &mut LocalObjectReference {
        self.localObjectReference.mut_or_insert_default()
    }

    // Take field
    pub fn take_localObjectReference(&mut self) -> LocalObjectReference {
        self.localObjectReference.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    // repeated .api.core.v1.KeyToPath items = 2;

    pub fn items(&self) -> &[KeyToPath] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<KeyToPath>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<KeyToPath> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<KeyToPath> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    // optional bool optional = 4;

    pub fn optional(&self) -> bool {
        self.optional.unwrap_or(false)
    }

    pub fn clear_optional(&mut self) {
        self.optional = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        self.optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LocalObjectReference>(
            "localObjectReference",
            |m: &SecretProjection| { &m.localObjectReference },
            |m: &mut SecretProjection| { &mut m.localObjectReference },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &SecretProjection| { &m.items },
            |m: &mut SecretProjection| { &mut m.items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "optional",
            |m: &SecretProjection| { &m.optional },
            |m: &mut SecretProjection| { &mut m.optional },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SecretProjection>(
            "SecretProjection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SecretProjection {
    const NAME: &'static str = "SecretProjection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.localObjectReference)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                32 => {
                    self.optional = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.localObjectReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.optional {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.localObjectReference.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.optional {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SecretProjection {
        SecretProjection::new()
    }

    fn clear(&mut self) {
        self.localObjectReference.clear();
        self.items.clear();
        self.optional = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SecretProjection {
        static instance: SecretProjection = SecretProjection {
            localObjectReference: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            optional: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SecretProjection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SecretProjection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SecretProjection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretProjection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.SecretReference)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SecretReference {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.SecretReference.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.SecretReference.namespace)
    pub namespace: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.SecretReference.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SecretReference {
    fn default() -> &'a SecretReference {
        <SecretReference as ::protobuf::Message>::default_instance()
    }
}

impl SecretReference {
    pub fn new() -> SecretReference {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string namespace = 2;

    pub fn namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_namespace(&mut self) {
        self.namespace = ::std::option::Option::None;
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &SecretReference| { &m.name },
            |m: &mut SecretReference| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "namespace",
            |m: &SecretReference| { &m.namespace },
            |m: &mut SecretReference| { &mut m.namespace },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SecretReference>(
            "SecretReference",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SecretReference {
    const NAME: &'static str = "SecretReference";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.namespace = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.namespace.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SecretReference {
        SecretReference::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.namespace = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SecretReference {
        static instance: SecretReference = SecretReference {
            name: ::std::option::Option::None,
            namespace: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SecretReference {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SecretReference").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SecretReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretReference {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.SecretVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SecretVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.SecretVolumeSource.secretName)
    pub secretName: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.SecretVolumeSource.items)
    pub items: ::std::vec::Vec<KeyToPath>,
    // @@protoc_insertion_point(field:api.core.v1.SecretVolumeSource.defaultMode)
    pub defaultMode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.SecretVolumeSource.optional)
    pub optional: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.SecretVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SecretVolumeSource {
    fn default() -> &'a SecretVolumeSource {
        <SecretVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl SecretVolumeSource {
    pub fn new() -> SecretVolumeSource {
        ::std::default::Default::default()
    }

    // optional string secretName = 1;

    pub fn secretName(&self) -> &str {
        match self.secretName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_secretName(&mut self) {
        self.secretName = ::std::option::Option::None;
    }

    pub fn has_secretName(&self) -> bool {
        self.secretName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretName(&mut self, v: ::std::string::String) {
        self.secretName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretName(&mut self) -> &mut ::std::string::String {
        if self.secretName.is_none() {
            self.secretName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.secretName.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretName(&mut self) -> ::std::string::String {
        self.secretName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.core.v1.KeyToPath items = 2;

    pub fn items(&self) -> &[KeyToPath] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<KeyToPath>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<KeyToPath> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<KeyToPath> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    // optional int32 defaultMode = 3;

    pub fn defaultMode(&self) -> i32 {
        self.defaultMode.unwrap_or(0)
    }

    pub fn clear_defaultMode(&mut self) {
        self.defaultMode = ::std::option::Option::None;
    }

    pub fn has_defaultMode(&self) -> bool {
        self.defaultMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defaultMode(&mut self, v: i32) {
        self.defaultMode = ::std::option::Option::Some(v);
    }

    // optional bool optional = 4;

    pub fn optional(&self) -> bool {
        self.optional.unwrap_or(false)
    }

    pub fn clear_optional(&mut self) {
        self.optional = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        self.optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "secretName",
            |m: &SecretVolumeSource| { &m.secretName },
            |m: &mut SecretVolumeSource| { &mut m.secretName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &SecretVolumeSource| { &m.items },
            |m: &mut SecretVolumeSource| { &mut m.items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "defaultMode",
            |m: &SecretVolumeSource| { &m.defaultMode },
            |m: &mut SecretVolumeSource| { &mut m.defaultMode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "optional",
            |m: &SecretVolumeSource| { &m.optional },
            |m: &mut SecretVolumeSource| { &mut m.optional },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SecretVolumeSource>(
            "SecretVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SecretVolumeSource {
    const NAME: &'static str = "SecretVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.secretName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                24 => {
                    self.defaultMode = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.optional = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.secretName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.defaultMode {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.optional {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.secretName.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.defaultMode {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.optional {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SecretVolumeSource {
        SecretVolumeSource::new()
    }

    fn clear(&mut self) {
        self.secretName = ::std::option::Option::None;
        self.items.clear();
        self.defaultMode = ::std::option::Option::None;
        self.optional = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SecretVolumeSource {
        static instance: SecretVolumeSource = SecretVolumeSource {
            secretName: ::std::option::Option::None,
            items: ::std::vec::Vec::new(),
            defaultMode: ::std::option::Option::None,
            optional: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SecretVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SecretVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SecretVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.SecurityContext)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SecurityContext {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.SecurityContext.capabilities)
    pub capabilities: ::protobuf::MessageField<Capabilities>,
    // @@protoc_insertion_point(field:api.core.v1.SecurityContext.privileged)
    pub privileged: ::std::option::Option<bool>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.SecurityContext.seLinuxOptions)
    pub seLinuxOptions: ::protobuf::MessageField<SELinuxOptions>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.SecurityContext.windowsOptions)
    pub windowsOptions: ::protobuf::MessageField<WindowsSecurityContextOptions>,
    // @@protoc_insertion_point(field:api.core.v1.SecurityContext.runAsUser)
    pub runAsUser: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.core.v1.SecurityContext.runAsGroup)
    pub runAsGroup: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.core.v1.SecurityContext.runAsNonRoot)
    pub runAsNonRoot: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.SecurityContext.readOnlyRootFilesystem)
    pub readOnlyRootFilesystem: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.SecurityContext.allowPrivilegeEscalation)
    pub allowPrivilegeEscalation: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.SecurityContext.procMount)
    pub procMount: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.SecurityContext.seccompProfile)
    pub seccompProfile: ::protobuf::MessageField<SeccompProfile>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.SecurityContext.appArmorProfile)
    pub appArmorProfile: ::protobuf::MessageField<AppArmorProfile>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.SecurityContext.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SecurityContext {
    fn default() -> &'a SecurityContext {
        <SecurityContext as ::protobuf::Message>::default_instance()
    }
}

impl SecurityContext {
    pub fn new() -> SecurityContext {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.Capabilities capabilities = 1;

    pub fn capabilities(&self) -> &Capabilities {
        self.capabilities.as_ref().unwrap_or_else(|| <Capabilities as ::protobuf::Message>::default_instance())
    }

    pub fn clear_capabilities(&mut self) {
        self.capabilities.clear();
    }

    pub fn has_capabilities(&self) -> bool {
        self.capabilities.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capabilities(&mut self, v: Capabilities) {
        self.capabilities = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_capabilities(&mut self) -> &mut Capabilities {
        self.capabilities.mut_or_insert_default()
    }

    // Take field
    pub fn take_capabilities(&mut self) -> Capabilities {
        self.capabilities.take().unwrap_or_else(|| Capabilities::new())
    }

    // optional bool privileged = 2;

    pub fn privileged(&self) -> bool {
        self.privileged.unwrap_or(false)
    }

    pub fn clear_privileged(&mut self) {
        self.privileged = ::std::option::Option::None;
    }

    pub fn has_privileged(&self) -> bool {
        self.privileged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privileged(&mut self, v: bool) {
        self.privileged = ::std::option::Option::Some(v);
    }

    // optional .api.core.v1.SELinuxOptions seLinuxOptions = 3;

    pub fn seLinuxOptions(&self) -> &SELinuxOptions {
        self.seLinuxOptions.as_ref().unwrap_or_else(|| <SELinuxOptions as ::protobuf::Message>::default_instance())
    }

    pub fn clear_seLinuxOptions(&mut self) {
        self.seLinuxOptions.clear();
    }

    pub fn has_seLinuxOptions(&self) -> bool {
        self.seLinuxOptions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seLinuxOptions(&mut self, v: SELinuxOptions) {
        self.seLinuxOptions = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seLinuxOptions(&mut self) -> &mut SELinuxOptions {
        self.seLinuxOptions.mut_or_insert_default()
    }

    // Take field
    pub fn take_seLinuxOptions(&mut self) -> SELinuxOptions {
        self.seLinuxOptions.take().unwrap_or_else(|| SELinuxOptions::new())
    }

    // optional .api.core.v1.WindowsSecurityContextOptions windowsOptions = 10;

    pub fn windowsOptions(&self) -> &WindowsSecurityContextOptions {
        self.windowsOptions.as_ref().unwrap_or_else(|| <WindowsSecurityContextOptions as ::protobuf::Message>::default_instance())
    }

    pub fn clear_windowsOptions(&mut self) {
        self.windowsOptions.clear();
    }

    pub fn has_windowsOptions(&self) -> bool {
        self.windowsOptions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_windowsOptions(&mut self, v: WindowsSecurityContextOptions) {
        self.windowsOptions = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_windowsOptions(&mut self) -> &mut WindowsSecurityContextOptions {
        self.windowsOptions.mut_or_insert_default()
    }

    // Take field
    pub fn take_windowsOptions(&mut self) -> WindowsSecurityContextOptions {
        self.windowsOptions.take().unwrap_or_else(|| WindowsSecurityContextOptions::new())
    }

    // optional int64 runAsUser = 4;

    pub fn runAsUser(&self) -> i64 {
        self.runAsUser.unwrap_or(0)
    }

    pub fn clear_runAsUser(&mut self) {
        self.runAsUser = ::std::option::Option::None;
    }

    pub fn has_runAsUser(&self) -> bool {
        self.runAsUser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runAsUser(&mut self, v: i64) {
        self.runAsUser = ::std::option::Option::Some(v);
    }

    // optional int64 runAsGroup = 8;

    pub fn runAsGroup(&self) -> i64 {
        self.runAsGroup.unwrap_or(0)
    }

    pub fn clear_runAsGroup(&mut self) {
        self.runAsGroup = ::std::option::Option::None;
    }

    pub fn has_runAsGroup(&self) -> bool {
        self.runAsGroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runAsGroup(&mut self, v: i64) {
        self.runAsGroup = ::std::option::Option::Some(v);
    }

    // optional bool runAsNonRoot = 5;

    pub fn runAsNonRoot(&self) -> bool {
        self.runAsNonRoot.unwrap_or(false)
    }

    pub fn clear_runAsNonRoot(&mut self) {
        self.runAsNonRoot = ::std::option::Option::None;
    }

    pub fn has_runAsNonRoot(&self) -> bool {
        self.runAsNonRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runAsNonRoot(&mut self, v: bool) {
        self.runAsNonRoot = ::std::option::Option::Some(v);
    }

    // optional bool readOnlyRootFilesystem = 6;

    pub fn readOnlyRootFilesystem(&self) -> bool {
        self.readOnlyRootFilesystem.unwrap_or(false)
    }

    pub fn clear_readOnlyRootFilesystem(&mut self) {
        self.readOnlyRootFilesystem = ::std::option::Option::None;
    }

    pub fn has_readOnlyRootFilesystem(&self) -> bool {
        self.readOnlyRootFilesystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnlyRootFilesystem(&mut self, v: bool) {
        self.readOnlyRootFilesystem = ::std::option::Option::Some(v);
    }

    // optional bool allowPrivilegeEscalation = 7;

    pub fn allowPrivilegeEscalation(&self) -> bool {
        self.allowPrivilegeEscalation.unwrap_or(false)
    }

    pub fn clear_allowPrivilegeEscalation(&mut self) {
        self.allowPrivilegeEscalation = ::std::option::Option::None;
    }

    pub fn has_allowPrivilegeEscalation(&self) -> bool {
        self.allowPrivilegeEscalation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allowPrivilegeEscalation(&mut self, v: bool) {
        self.allowPrivilegeEscalation = ::std::option::Option::Some(v);
    }

    // optional string procMount = 9;

    pub fn procMount(&self) -> &str {
        match self.procMount.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_procMount(&mut self) {
        self.procMount = ::std::option::Option::None;
    }

    pub fn has_procMount(&self) -> bool {
        self.procMount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_procMount(&mut self, v: ::std::string::String) {
        self.procMount = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_procMount(&mut self) -> &mut ::std::string::String {
        if self.procMount.is_none() {
            self.procMount = ::std::option::Option::Some(::std::string::String::new());
        }
        self.procMount.as_mut().unwrap()
    }

    // Take field
    pub fn take_procMount(&mut self) -> ::std::string::String {
        self.procMount.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.SeccompProfile seccompProfile = 11;

    pub fn seccompProfile(&self) -> &SeccompProfile {
        self.seccompProfile.as_ref().unwrap_or_else(|| <SeccompProfile as ::protobuf::Message>::default_instance())
    }

    pub fn clear_seccompProfile(&mut self) {
        self.seccompProfile.clear();
    }

    pub fn has_seccompProfile(&self) -> bool {
        self.seccompProfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seccompProfile(&mut self, v: SeccompProfile) {
        self.seccompProfile = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seccompProfile(&mut self) -> &mut SeccompProfile {
        self.seccompProfile.mut_or_insert_default()
    }

    // Take field
    pub fn take_seccompProfile(&mut self) -> SeccompProfile {
        self.seccompProfile.take().unwrap_or_else(|| SeccompProfile::new())
    }

    // optional .api.core.v1.AppArmorProfile appArmorProfile = 12;

    pub fn appArmorProfile(&self) -> &AppArmorProfile {
        self.appArmorProfile.as_ref().unwrap_or_else(|| <AppArmorProfile as ::protobuf::Message>::default_instance())
    }

    pub fn clear_appArmorProfile(&mut self) {
        self.appArmorProfile.clear();
    }

    pub fn has_appArmorProfile(&self) -> bool {
        self.appArmorProfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appArmorProfile(&mut self, v: AppArmorProfile) {
        self.appArmorProfile = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appArmorProfile(&mut self) -> &mut AppArmorProfile {
        self.appArmorProfile.mut_or_insert_default()
    }

    // Take field
    pub fn take_appArmorProfile(&mut self) -> AppArmorProfile {
        self.appArmorProfile.take().unwrap_or_else(|| AppArmorProfile::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Capabilities>(
            "capabilities",
            |m: &SecurityContext| { &m.capabilities },
            |m: &mut SecurityContext| { &mut m.capabilities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "privileged",
            |m: &SecurityContext| { &m.privileged },
            |m: &mut SecurityContext| { &mut m.privileged },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SELinuxOptions>(
            "seLinuxOptions",
            |m: &SecurityContext| { &m.seLinuxOptions },
            |m: &mut SecurityContext| { &mut m.seLinuxOptions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WindowsSecurityContextOptions>(
            "windowsOptions",
            |m: &SecurityContext| { &m.windowsOptions },
            |m: &mut SecurityContext| { &mut m.windowsOptions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "runAsUser",
            |m: &SecurityContext| { &m.runAsUser },
            |m: &mut SecurityContext| { &mut m.runAsUser },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "runAsGroup",
            |m: &SecurityContext| { &m.runAsGroup },
            |m: &mut SecurityContext| { &mut m.runAsGroup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "runAsNonRoot",
            |m: &SecurityContext| { &m.runAsNonRoot },
            |m: &mut SecurityContext| { &mut m.runAsNonRoot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnlyRootFilesystem",
            |m: &SecurityContext| { &m.readOnlyRootFilesystem },
            |m: &mut SecurityContext| { &mut m.readOnlyRootFilesystem },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allowPrivilegeEscalation",
            |m: &SecurityContext| { &m.allowPrivilegeEscalation },
            |m: &mut SecurityContext| { &mut m.allowPrivilegeEscalation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "procMount",
            |m: &SecurityContext| { &m.procMount },
            |m: &mut SecurityContext| { &mut m.procMount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SeccompProfile>(
            "seccompProfile",
            |m: &SecurityContext| { &m.seccompProfile },
            |m: &mut SecurityContext| { &mut m.seccompProfile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AppArmorProfile>(
            "appArmorProfile",
            |m: &SecurityContext| { &m.appArmorProfile },
            |m: &mut SecurityContext| { &mut m.appArmorProfile },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SecurityContext>(
            "SecurityContext",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SecurityContext {
    const NAME: &'static str = "SecurityContext";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.capabilities)?;
                },
                16 => {
                    self.privileged = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.seLinuxOptions)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.windowsOptions)?;
                },
                32 => {
                    self.runAsUser = ::std::option::Option::Some(is.read_int64()?);
                },
                64 => {
                    self.runAsGroup = ::std::option::Option::Some(is.read_int64()?);
                },
                40 => {
                    self.runAsNonRoot = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.readOnlyRootFilesystem = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.allowPrivilegeEscalation = ::std::option::Option::Some(is.read_bool()?);
                },
                74 => {
                    self.procMount = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.seccompProfile)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.appArmorProfile)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.capabilities.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.privileged {
            my_size += 1 + 1;
        }
        if let Some(v) = self.seLinuxOptions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.windowsOptions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.runAsUser {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.runAsGroup {
            my_size += ::protobuf::rt::int64_size(8, v);
        }
        if let Some(v) = self.runAsNonRoot {
            my_size += 1 + 1;
        }
        if let Some(v) = self.readOnlyRootFilesystem {
            my_size += 1 + 1;
        }
        if let Some(v) = self.allowPrivilegeEscalation {
            my_size += 1 + 1;
        }
        if let Some(v) = self.procMount.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.seccompProfile.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.appArmorProfile.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.capabilities.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.privileged {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.seLinuxOptions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.windowsOptions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.runAsUser {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.runAsGroup {
            os.write_int64(8, v)?;
        }
        if let Some(v) = self.runAsNonRoot {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.readOnlyRootFilesystem {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.allowPrivilegeEscalation {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.procMount.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.seccompProfile.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.appArmorProfile.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SecurityContext {
        SecurityContext::new()
    }

    fn clear(&mut self) {
        self.capabilities.clear();
        self.privileged = ::std::option::Option::None;
        self.seLinuxOptions.clear();
        self.windowsOptions.clear();
        self.runAsUser = ::std::option::Option::None;
        self.runAsGroup = ::std::option::Option::None;
        self.runAsNonRoot = ::std::option::Option::None;
        self.readOnlyRootFilesystem = ::std::option::Option::None;
        self.allowPrivilegeEscalation = ::std::option::Option::None;
        self.procMount = ::std::option::Option::None;
        self.seccompProfile.clear();
        self.appArmorProfile.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SecurityContext {
        static instance: SecurityContext = SecurityContext {
            capabilities: ::protobuf::MessageField::none(),
            privileged: ::std::option::Option::None,
            seLinuxOptions: ::protobuf::MessageField::none(),
            windowsOptions: ::protobuf::MessageField::none(),
            runAsUser: ::std::option::Option::None,
            runAsGroup: ::std::option::Option::None,
            runAsNonRoot: ::std::option::Option::None,
            readOnlyRootFilesystem: ::std::option::Option::None,
            allowPrivilegeEscalation: ::std::option::Option::None,
            procMount: ::std::option::Option::None,
            seccompProfile: ::protobuf::MessageField::none(),
            appArmorProfile: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SecurityContext {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SecurityContext").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SecurityContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecurityContext {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.SerializedReference)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SerializedReference {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.SerializedReference.reference)
    pub reference: ::protobuf::MessageField<ObjectReference>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.SerializedReference.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SerializedReference {
    fn default() -> &'a SerializedReference {
        <SerializedReference as ::protobuf::Message>::default_instance()
    }
}

impl SerializedReference {
    pub fn new() -> SerializedReference {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.ObjectReference reference = 1;

    pub fn reference(&self) -> &ObjectReference {
        self.reference.as_ref().unwrap_or_else(|| <ObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_reference(&mut self) {
        self.reference.clear();
    }

    pub fn has_reference(&self) -> bool {
        self.reference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reference(&mut self, v: ObjectReference) {
        self.reference = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reference(&mut self) -> &mut ObjectReference {
        self.reference.mut_or_insert_default()
    }

    // Take field
    pub fn take_reference(&mut self) -> ObjectReference {
        self.reference.take().unwrap_or_else(|| ObjectReference::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ObjectReference>(
            "reference",
            |m: &SerializedReference| { &m.reference },
            |m: &mut SerializedReference| { &mut m.reference },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SerializedReference>(
            "SerializedReference",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SerializedReference {
    const NAME: &'static str = "SerializedReference";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.reference)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reference.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SerializedReference {
        SerializedReference::new()
    }

    fn clear(&mut self) {
        self.reference.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SerializedReference {
        static instance: SerializedReference = SerializedReference {
            reference: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SerializedReference {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SerializedReference").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SerializedReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SerializedReference {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.Service)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Service {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Service.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Service.spec)
    pub spec: ::protobuf::MessageField<ServiceSpec>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Service.status)
    pub status: ::protobuf::MessageField<ServiceStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.Service.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Service {
    fn default() -> &'a Service {
        <Service as ::protobuf::Message>::default_instance()
    }
}

impl Service {
    pub fn new() -> Service {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.core.v1.ServiceSpec spec = 2;

    pub fn spec(&self) -> &ServiceSpec {
        self.spec.as_ref().unwrap_or_else(|| <ServiceSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ServiceSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ServiceSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ServiceSpec {
        self.spec.take().unwrap_or_else(|| ServiceSpec::new())
    }

    // optional .api.core.v1.ServiceStatus status = 3;

    pub fn status(&self) -> &ServiceStatus {
        self.status.as_ref().unwrap_or_else(|| <ServiceStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ServiceStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ServiceStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> ServiceStatus {
        self.status.take().unwrap_or_else(|| ServiceStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &Service| { &m.metadata },
            |m: &mut Service| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ServiceSpec>(
            "spec",
            |m: &Service| { &m.spec },
            |m: &mut Service| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ServiceStatus>(
            "status",
            |m: &Service| { &m.status },
            |m: &mut Service| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Service>(
            "Service",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Service {
    const NAME: &'static str = "Service";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Service {
        Service::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Service {
        static instance: Service = Service {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Service {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Service").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Service {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Service {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ServiceAccount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServiceAccount {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ServiceAccount.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ServiceAccount.secrets)
    pub secrets: ::std::vec::Vec<ObjectReference>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ServiceAccount.imagePullSecrets)
    pub imagePullSecrets: ::std::vec::Vec<LocalObjectReference>,
    // @@protoc_insertion_point(field:api.core.v1.ServiceAccount.automountServiceAccountToken)
    pub automountServiceAccountToken: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ServiceAccount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceAccount {
    fn default() -> &'a ServiceAccount {
        <ServiceAccount as ::protobuf::Message>::default_instance()
    }
}

impl ServiceAccount {
    pub fn new() -> ServiceAccount {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // repeated .api.core.v1.ObjectReference secrets = 2;

    pub fn secrets(&self) -> &[ObjectReference] {
        &self.secrets
    }

    pub fn clear_secrets(&mut self) {
        self.secrets.clear();
    }

    // Param is passed by value, moved
    pub fn set_secrets(&mut self, v: ::std::vec::Vec<ObjectReference>) {
        self.secrets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_secrets(&mut self) -> &mut ::std::vec::Vec<ObjectReference> {
        &mut self.secrets
    }

    // Take field
    pub fn take_secrets(&mut self) -> ::std::vec::Vec<ObjectReference> {
        ::std::mem::replace(&mut self.secrets, ::std::vec::Vec::new())
    }

    // repeated .api.core.v1.LocalObjectReference imagePullSecrets = 3;

    pub fn imagePullSecrets(&self) -> &[LocalObjectReference] {
        &self.imagePullSecrets
    }

    pub fn clear_imagePullSecrets(&mut self) {
        self.imagePullSecrets.clear();
    }

    // Param is passed by value, moved
    pub fn set_imagePullSecrets(&mut self, v: ::std::vec::Vec<LocalObjectReference>) {
        self.imagePullSecrets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_imagePullSecrets(&mut self) -> &mut ::std::vec::Vec<LocalObjectReference> {
        &mut self.imagePullSecrets
    }

    // Take field
    pub fn take_imagePullSecrets(&mut self) -> ::std::vec::Vec<LocalObjectReference> {
        ::std::mem::replace(&mut self.imagePullSecrets, ::std::vec::Vec::new())
    }

    // optional bool automountServiceAccountToken = 4;

    pub fn automountServiceAccountToken(&self) -> bool {
        self.automountServiceAccountToken.unwrap_or(false)
    }

    pub fn clear_automountServiceAccountToken(&mut self) {
        self.automountServiceAccountToken = ::std::option::Option::None;
    }

    pub fn has_automountServiceAccountToken(&self) -> bool {
        self.automountServiceAccountToken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_automountServiceAccountToken(&mut self, v: bool) {
        self.automountServiceAccountToken = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ServiceAccount| { &m.metadata },
            |m: &mut ServiceAccount| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "secrets",
            |m: &ServiceAccount| { &m.secrets },
            |m: &mut ServiceAccount| { &mut m.secrets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "imagePullSecrets",
            |m: &ServiceAccount| { &m.imagePullSecrets },
            |m: &mut ServiceAccount| { &mut m.imagePullSecrets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "automountServiceAccountToken",
            |m: &ServiceAccount| { &m.automountServiceAccountToken },
            |m: &mut ServiceAccount| { &mut m.automountServiceAccountToken },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServiceAccount>(
            "ServiceAccount",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServiceAccount {
    const NAME: &'static str = "ServiceAccount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.secrets.push(is.read_message()?);
                },
                26 => {
                    self.imagePullSecrets.push(is.read_message()?);
                },
                32 => {
                    self.automountServiceAccountToken = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.secrets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.imagePullSecrets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.automountServiceAccountToken {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.secrets {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.imagePullSecrets {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.automountServiceAccountToken {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceAccount {
        ServiceAccount::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.secrets.clear();
        self.imagePullSecrets.clear();
        self.automountServiceAccountToken = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceAccount {
        static instance: ServiceAccount = ServiceAccount {
            metadata: ::protobuf::MessageField::none(),
            secrets: ::std::vec::Vec::new(),
            imagePullSecrets: ::std::vec::Vec::new(),
            automountServiceAccountToken: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServiceAccount {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceAccount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceAccount {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ServiceAccountList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServiceAccountList {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ServiceAccountList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ServiceAccountList.items)
    pub items: ::std::vec::Vec<ServiceAccount>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ServiceAccountList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceAccountList {
    fn default() -> &'a ServiceAccountList {
        <ServiceAccountList as ::protobuf::Message>::default_instance()
    }
}

impl ServiceAccountList {
    pub fn new() -> ServiceAccountList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.core.v1.ServiceAccount items = 2;

    pub fn items(&self) -> &[ServiceAccount] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ServiceAccount>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ServiceAccount> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ServiceAccount> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ServiceAccountList| { &m.metadata },
            |m: &mut ServiceAccountList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ServiceAccountList| { &m.items },
            |m: &mut ServiceAccountList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServiceAccountList>(
            "ServiceAccountList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServiceAccountList {
    const NAME: &'static str = "ServiceAccountList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceAccountList {
        ServiceAccountList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceAccountList {
        static instance: ServiceAccountList = ServiceAccountList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServiceAccountList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceAccountList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceAccountList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceAccountList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ServiceAccountTokenProjection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServiceAccountTokenProjection {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ServiceAccountTokenProjection.audience)
    pub audience: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ServiceAccountTokenProjection.expirationSeconds)
    pub expirationSeconds: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.core.v1.ServiceAccountTokenProjection.path)
    pub path: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ServiceAccountTokenProjection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceAccountTokenProjection {
    fn default() -> &'a ServiceAccountTokenProjection {
        <ServiceAccountTokenProjection as ::protobuf::Message>::default_instance()
    }
}

impl ServiceAccountTokenProjection {
    pub fn new() -> ServiceAccountTokenProjection {
        ::std::default::Default::default()
    }

    // optional string audience = 1;

    pub fn audience(&self) -> &str {
        match self.audience.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_audience(&mut self) {
        self.audience = ::std::option::Option::None;
    }

    pub fn has_audience(&self) -> bool {
        self.audience.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audience(&mut self, v: ::std::string::String) {
        self.audience = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_audience(&mut self) -> &mut ::std::string::String {
        if self.audience.is_none() {
            self.audience = ::std::option::Option::Some(::std::string::String::new());
        }
        self.audience.as_mut().unwrap()
    }

    // Take field
    pub fn take_audience(&mut self) -> ::std::string::String {
        self.audience.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 expirationSeconds = 2;

    pub fn expirationSeconds(&self) -> i64 {
        self.expirationSeconds.unwrap_or(0)
    }

    pub fn clear_expirationSeconds(&mut self) {
        self.expirationSeconds = ::std::option::Option::None;
    }

    pub fn has_expirationSeconds(&self) -> bool {
        self.expirationSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expirationSeconds(&mut self, v: i64) {
        self.expirationSeconds = ::std::option::Option::Some(v);
    }

    // optional string path = 3;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "audience",
            |m: &ServiceAccountTokenProjection| { &m.audience },
            |m: &mut ServiceAccountTokenProjection| { &mut m.audience },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expirationSeconds",
            |m: &ServiceAccountTokenProjection| { &m.expirationSeconds },
            |m: &mut ServiceAccountTokenProjection| { &mut m.expirationSeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &ServiceAccountTokenProjection| { &m.path },
            |m: &mut ServiceAccountTokenProjection| { &mut m.path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServiceAccountTokenProjection>(
            "ServiceAccountTokenProjection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServiceAccountTokenProjection {
    const NAME: &'static str = "ServiceAccountTokenProjection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.audience = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.expirationSeconds = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.audience.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.expirationSeconds {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.audience.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.expirationSeconds {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceAccountTokenProjection {
        ServiceAccountTokenProjection::new()
    }

    fn clear(&mut self) {
        self.audience = ::std::option::Option::None;
        self.expirationSeconds = ::std::option::Option::None;
        self.path = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceAccountTokenProjection {
        static instance: ServiceAccountTokenProjection = ServiceAccountTokenProjection {
            audience: ::std::option::Option::None,
            expirationSeconds: ::std::option::Option::None,
            path: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServiceAccountTokenProjection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceAccountTokenProjection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceAccountTokenProjection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceAccountTokenProjection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ServiceList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServiceList {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ServiceList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ServiceList.items)
    pub items: ::std::vec::Vec<Service>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ServiceList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceList {
    fn default() -> &'a ServiceList {
        <ServiceList as ::protobuf::Message>::default_instance()
    }
}

impl ServiceList {
    pub fn new() -> ServiceList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.core.v1.Service items = 2;

    pub fn items(&self) -> &[Service] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<Service>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<Service> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<Service> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ServiceList| { &m.metadata },
            |m: &mut ServiceList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ServiceList| { &m.items },
            |m: &mut ServiceList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServiceList>(
            "ServiceList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServiceList {
    const NAME: &'static str = "ServiceList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceList {
        ServiceList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceList {
        static instance: ServiceList = ServiceList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServiceList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ServicePort)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServicePort {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ServicePort.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ServicePort.protocol)
    pub protocol: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ServicePort.appProtocol)
    pub appProtocol: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ServicePort.port)
    pub port: ::std::option::Option<i32>,
    #[serde(with = "crate::v1_30::intorstr")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ServicePort.targetPort)
    pub targetPort: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::util::intstr::IntOrString>,
    // @@protoc_insertion_point(field:api.core.v1.ServicePort.nodePort)
    pub nodePort: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ServicePort.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServicePort {
    fn default() -> &'a ServicePort {
        <ServicePort as ::protobuf::Message>::default_instance()
    }
}

impl ServicePort {
    pub fn new() -> ServicePort {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string protocol = 2;

    pub fn protocol(&self) -> &str {
        match self.protocol.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_protocol(&mut self) {
        self.protocol = ::std::option::Option::None;
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol = ::std::option::Option::Some(::std::string::String::new());
        }
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string appProtocol = 6;

    pub fn appProtocol(&self) -> &str {
        match self.appProtocol.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_appProtocol(&mut self) {
        self.appProtocol = ::std::option::Option::None;
    }

    pub fn has_appProtocol(&self) -> bool {
        self.appProtocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appProtocol(&mut self, v: ::std::string::String) {
        self.appProtocol = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appProtocol(&mut self) -> &mut ::std::string::String {
        if self.appProtocol.is_none() {
            self.appProtocol = ::std::option::Option::Some(::std::string::String::new());
        }
        self.appProtocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_appProtocol(&mut self) -> ::std::string::String {
        self.appProtocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 port = 3;

    pub fn port(&self) -> i32 {
        self.port.unwrap_or(0)
    }

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Option::Some(v);
    }

    // optional .apimachinery.pkg.util.intstr.IntOrString targetPort = 4;

    pub fn targetPort(&self) -> &crate::v1_30::apimachinery::pkg::util::intstr::IntOrString {
        self.targetPort.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::util::intstr::IntOrString as ::protobuf::Message>::default_instance())
    }

    pub fn clear_targetPort(&mut self) {
        self.targetPort.clear();
    }

    pub fn has_targetPort(&self) -> bool {
        self.targetPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetPort(&mut self, v: crate::v1_30::apimachinery::pkg::util::intstr::IntOrString) {
        self.targetPort = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetPort(&mut self) -> &mut crate::v1_30::apimachinery::pkg::util::intstr::IntOrString {
        self.targetPort.mut_or_insert_default()
    }

    // Take field
    pub fn take_targetPort(&mut self) -> crate::v1_30::apimachinery::pkg::util::intstr::IntOrString {
        self.targetPort.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::util::intstr::IntOrString::new())
    }

    // optional int32 nodePort = 5;

    pub fn nodePort(&self) -> i32 {
        self.nodePort.unwrap_or(0)
    }

    pub fn clear_nodePort(&mut self) {
        self.nodePort = ::std::option::Option::None;
    }

    pub fn has_nodePort(&self) -> bool {
        self.nodePort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodePort(&mut self, v: i32) {
        self.nodePort = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ServicePort| { &m.name },
            |m: &mut ServicePort| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol",
            |m: &ServicePort| { &m.protocol },
            |m: &mut ServicePort| { &mut m.protocol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appProtocol",
            |m: &ServicePort| { &m.appProtocol },
            |m: &mut ServicePort| { &mut m.appProtocol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "port",
            |m: &ServicePort| { &m.port },
            |m: &mut ServicePort| { &mut m.port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::util::intstr::IntOrString>(
            "targetPort",
            |m: &ServicePort| { &m.targetPort },
            |m: &mut ServicePort| { &mut m.targetPort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nodePort",
            |m: &ServicePort| { &m.nodePort },
            |m: &mut ServicePort| { &mut m.nodePort },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServicePort>(
            "ServicePort",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServicePort {
    const NAME: &'static str = "ServicePort";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.protocol = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.appProtocol = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.port = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.targetPort)?;
                },
                40 => {
                    self.nodePort = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.protocol.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.appProtocol.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.targetPort.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.nodePort {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.protocol.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.appProtocol.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.port {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.targetPort.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.nodePort {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServicePort {
        ServicePort::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.protocol = ::std::option::Option::None;
        self.appProtocol = ::std::option::Option::None;
        self.port = ::std::option::Option::None;
        self.targetPort.clear();
        self.nodePort = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServicePort {
        static instance: ServicePort = ServicePort {
            name: ::std::option::Option::None,
            protocol: ::std::option::Option::None,
            appProtocol: ::std::option::Option::None,
            port: ::std::option::Option::None,
            targetPort: ::protobuf::MessageField::none(),
            nodePort: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServicePort {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServicePort").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServicePort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServicePort {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ServiceProxyOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServiceProxyOptions {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.ServiceProxyOptions.path)
    pub path: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ServiceProxyOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceProxyOptions {
    fn default() -> &'a ServiceProxyOptions {
        <ServiceProxyOptions as ::protobuf::Message>::default_instance()
    }
}

impl ServiceProxyOptions {
    pub fn new() -> ServiceProxyOptions {
        ::std::default::Default::default()
    }

    // optional string path = 1;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &ServiceProxyOptions| { &m.path },
            |m: &mut ServiceProxyOptions| { &mut m.path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServiceProxyOptions>(
            "ServiceProxyOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServiceProxyOptions {
    const NAME: &'static str = "ServiceProxyOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.path.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceProxyOptions {
        ServiceProxyOptions::new()
    }

    fn clear(&mut self) {
        self.path = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceProxyOptions {
        static instance: ServiceProxyOptions = ServiceProxyOptions {
            path: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServiceProxyOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceProxyOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceProxyOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceProxyOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ServiceSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServiceSpec {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ServiceSpec.ports)
    pub ports: ::std::vec::Vec<ServicePort>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ServiceSpec.selector)
    pub selector: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ServiceSpec.clusterIP)
    pub clusterIP: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ServiceSpec.clusterIPs)
    pub clusterIPs: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ServiceSpec.type)
    pub type_: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ServiceSpec.externalIPs)
    pub externalIPs: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ServiceSpec.sessionAffinity)
    pub sessionAffinity: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ServiceSpec.loadBalancerIP)
    pub loadBalancerIP: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ServiceSpec.loadBalancerSourceRanges)
    pub loadBalancerSourceRanges: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ServiceSpec.externalName)
    pub externalName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ServiceSpec.externalTrafficPolicy)
    pub externalTrafficPolicy: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ServiceSpec.healthCheckNodePort)
    pub healthCheckNodePort: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.ServiceSpec.publishNotReadyAddresses)
    pub publishNotReadyAddresses: ::std::option::Option<bool>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ServiceSpec.sessionAffinityConfig)
    pub sessionAffinityConfig: ::protobuf::MessageField<SessionAffinityConfig>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ServiceSpec.ipFamilies)
    pub ipFamilies: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ServiceSpec.ipFamilyPolicy)
    pub ipFamilyPolicy: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ServiceSpec.allocateLoadBalancerNodePorts)
    pub allocateLoadBalancerNodePorts: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.ServiceSpec.loadBalancerClass)
    pub loadBalancerClass: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ServiceSpec.internalTrafficPolicy)
    pub internalTrafficPolicy: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.ServiceSpec.trafficDistribution)
    pub trafficDistribution: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ServiceSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceSpec {
    fn default() -> &'a ServiceSpec {
        <ServiceSpec as ::protobuf::Message>::default_instance()
    }
}

impl ServiceSpec {
    pub fn new() -> ServiceSpec {
        ::std::default::Default::default()
    }

    // repeated .api.core.v1.ServicePort ports = 1;

    pub fn ports(&self) -> &[ServicePort] {
        &self.ports
    }

    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::std::vec::Vec<ServicePort>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::std::vec::Vec<ServicePort> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::std::vec::Vec<ServicePort> {
        ::std::mem::replace(&mut self.ports, ::std::vec::Vec::new())
    }

    // repeated .api.core.v1.ServiceSpec.SelectorEntry selector = 2;

    pub fn selector(&self) -> &::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &self.selector
    }

    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
        self.selector = v;
    }

    // Mutable pointer to the field.
    pub fn mut_selector(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &mut self.selector
    }

    // Take field
    pub fn take_selector(&mut self) -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.selector, ::std::collections::BTreeMap::new())
    }

    // optional string clusterIP = 3;

    pub fn clusterIP(&self) -> &str {
        match self.clusterIP.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_clusterIP(&mut self) {
        self.clusterIP = ::std::option::Option::None;
    }

    pub fn has_clusterIP(&self) -> bool {
        self.clusterIP.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clusterIP(&mut self, v: ::std::string::String) {
        self.clusterIP = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clusterIP(&mut self) -> &mut ::std::string::String {
        if self.clusterIP.is_none() {
            self.clusterIP = ::std::option::Option::Some(::std::string::String::new());
        }
        self.clusterIP.as_mut().unwrap()
    }

    // Take field
    pub fn take_clusterIP(&mut self) -> ::std::string::String {
        self.clusterIP.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string clusterIPs = 18;

    pub fn clusterIPs(&self) -> &[::std::string::String] {
        &self.clusterIPs
    }

    pub fn clear_clusterIPs(&mut self) {
        self.clusterIPs.clear();
    }

    // Param is passed by value, moved
    pub fn set_clusterIPs(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.clusterIPs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_clusterIPs(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.clusterIPs
    }

    // Take field
    pub fn take_clusterIPs(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.clusterIPs, ::std::vec::Vec::new())
    }

    // optional string type = 4;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string externalIPs = 5;

    pub fn externalIPs(&self) -> &[::std::string::String] {
        &self.externalIPs
    }

    pub fn clear_externalIPs(&mut self) {
        self.externalIPs.clear();
    }

    // Param is passed by value, moved
    pub fn set_externalIPs(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.externalIPs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_externalIPs(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.externalIPs
    }

    // Take field
    pub fn take_externalIPs(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.externalIPs, ::std::vec::Vec::new())
    }

    // optional string sessionAffinity = 7;

    pub fn sessionAffinity(&self) -> &str {
        match self.sessionAffinity.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sessionAffinity(&mut self) {
        self.sessionAffinity = ::std::option::Option::None;
    }

    pub fn has_sessionAffinity(&self) -> bool {
        self.sessionAffinity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sessionAffinity(&mut self, v: ::std::string::String) {
        self.sessionAffinity = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sessionAffinity(&mut self) -> &mut ::std::string::String {
        if self.sessionAffinity.is_none() {
            self.sessionAffinity = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sessionAffinity.as_mut().unwrap()
    }

    // Take field
    pub fn take_sessionAffinity(&mut self) -> ::std::string::String {
        self.sessionAffinity.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string loadBalancerIP = 8;

    pub fn loadBalancerIP(&self) -> &str {
        match self.loadBalancerIP.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_loadBalancerIP(&mut self) {
        self.loadBalancerIP = ::std::option::Option::None;
    }

    pub fn has_loadBalancerIP(&self) -> bool {
        self.loadBalancerIP.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loadBalancerIP(&mut self, v: ::std::string::String) {
        self.loadBalancerIP = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loadBalancerIP(&mut self) -> &mut ::std::string::String {
        if self.loadBalancerIP.is_none() {
            self.loadBalancerIP = ::std::option::Option::Some(::std::string::String::new());
        }
        self.loadBalancerIP.as_mut().unwrap()
    }

    // Take field
    pub fn take_loadBalancerIP(&mut self) -> ::std::string::String {
        self.loadBalancerIP.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string loadBalancerSourceRanges = 9;

    pub fn loadBalancerSourceRanges(&self) -> &[::std::string::String] {
        &self.loadBalancerSourceRanges
    }

    pub fn clear_loadBalancerSourceRanges(&mut self) {
        self.loadBalancerSourceRanges.clear();
    }

    // Param is passed by value, moved
    pub fn set_loadBalancerSourceRanges(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.loadBalancerSourceRanges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_loadBalancerSourceRanges(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.loadBalancerSourceRanges
    }

    // Take field
    pub fn take_loadBalancerSourceRanges(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.loadBalancerSourceRanges, ::std::vec::Vec::new())
    }

    // optional string externalName = 10;

    pub fn externalName(&self) -> &str {
        match self.externalName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_externalName(&mut self) {
        self.externalName = ::std::option::Option::None;
    }

    pub fn has_externalName(&self) -> bool {
        self.externalName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_externalName(&mut self, v: ::std::string::String) {
        self.externalName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_externalName(&mut self) -> &mut ::std::string::String {
        if self.externalName.is_none() {
            self.externalName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.externalName.as_mut().unwrap()
    }

    // Take field
    pub fn take_externalName(&mut self) -> ::std::string::String {
        self.externalName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string externalTrafficPolicy = 11;

    pub fn externalTrafficPolicy(&self) -> &str {
        match self.externalTrafficPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_externalTrafficPolicy(&mut self) {
        self.externalTrafficPolicy = ::std::option::Option::None;
    }

    pub fn has_externalTrafficPolicy(&self) -> bool {
        self.externalTrafficPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_externalTrafficPolicy(&mut self, v: ::std::string::String) {
        self.externalTrafficPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_externalTrafficPolicy(&mut self) -> &mut ::std::string::String {
        if self.externalTrafficPolicy.is_none() {
            self.externalTrafficPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.externalTrafficPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_externalTrafficPolicy(&mut self) -> ::std::string::String {
        self.externalTrafficPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 healthCheckNodePort = 12;

    pub fn healthCheckNodePort(&self) -> i32 {
        self.healthCheckNodePort.unwrap_or(0)
    }

    pub fn clear_healthCheckNodePort(&mut self) {
        self.healthCheckNodePort = ::std::option::Option::None;
    }

    pub fn has_healthCheckNodePort(&self) -> bool {
        self.healthCheckNodePort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healthCheckNodePort(&mut self, v: i32) {
        self.healthCheckNodePort = ::std::option::Option::Some(v);
    }

    // optional bool publishNotReadyAddresses = 13;

    pub fn publishNotReadyAddresses(&self) -> bool {
        self.publishNotReadyAddresses.unwrap_or(false)
    }

    pub fn clear_publishNotReadyAddresses(&mut self) {
        self.publishNotReadyAddresses = ::std::option::Option::None;
    }

    pub fn has_publishNotReadyAddresses(&self) -> bool {
        self.publishNotReadyAddresses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishNotReadyAddresses(&mut self, v: bool) {
        self.publishNotReadyAddresses = ::std::option::Option::Some(v);
    }

    // optional .api.core.v1.SessionAffinityConfig sessionAffinityConfig = 14;

    pub fn sessionAffinityConfig(&self) -> &SessionAffinityConfig {
        self.sessionAffinityConfig.as_ref().unwrap_or_else(|| <SessionAffinityConfig as ::protobuf::Message>::default_instance())
    }

    pub fn clear_sessionAffinityConfig(&mut self) {
        self.sessionAffinityConfig.clear();
    }

    pub fn has_sessionAffinityConfig(&self) -> bool {
        self.sessionAffinityConfig.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sessionAffinityConfig(&mut self, v: SessionAffinityConfig) {
        self.sessionAffinityConfig = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sessionAffinityConfig(&mut self) -> &mut SessionAffinityConfig {
        self.sessionAffinityConfig.mut_or_insert_default()
    }

    // Take field
    pub fn take_sessionAffinityConfig(&mut self) -> SessionAffinityConfig {
        self.sessionAffinityConfig.take().unwrap_or_else(|| SessionAffinityConfig::new())
    }

    // repeated string ipFamilies = 19;

    pub fn ipFamilies(&self) -> &[::std::string::String] {
        &self.ipFamilies
    }

    pub fn clear_ipFamilies(&mut self) {
        self.ipFamilies.clear();
    }

    // Param is passed by value, moved
    pub fn set_ipFamilies(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.ipFamilies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ipFamilies(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.ipFamilies
    }

    // Take field
    pub fn take_ipFamilies(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.ipFamilies, ::std::vec::Vec::new())
    }

    // optional string ipFamilyPolicy = 17;

    pub fn ipFamilyPolicy(&self) -> &str {
        match self.ipFamilyPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ipFamilyPolicy(&mut self) {
        self.ipFamilyPolicy = ::std::option::Option::None;
    }

    pub fn has_ipFamilyPolicy(&self) -> bool {
        self.ipFamilyPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipFamilyPolicy(&mut self, v: ::std::string::String) {
        self.ipFamilyPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipFamilyPolicy(&mut self) -> &mut ::std::string::String {
        if self.ipFamilyPolicy.is_none() {
            self.ipFamilyPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ipFamilyPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_ipFamilyPolicy(&mut self) -> ::std::string::String {
        self.ipFamilyPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool allocateLoadBalancerNodePorts = 20;

    pub fn allocateLoadBalancerNodePorts(&self) -> bool {
        self.allocateLoadBalancerNodePorts.unwrap_or(false)
    }

    pub fn clear_allocateLoadBalancerNodePorts(&mut self) {
        self.allocateLoadBalancerNodePorts = ::std::option::Option::None;
    }

    pub fn has_allocateLoadBalancerNodePorts(&self) -> bool {
        self.allocateLoadBalancerNodePorts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allocateLoadBalancerNodePorts(&mut self, v: bool) {
        self.allocateLoadBalancerNodePorts = ::std::option::Option::Some(v);
    }

    // optional string loadBalancerClass = 21;

    pub fn loadBalancerClass(&self) -> &str {
        match self.loadBalancerClass.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_loadBalancerClass(&mut self) {
        self.loadBalancerClass = ::std::option::Option::None;
    }

    pub fn has_loadBalancerClass(&self) -> bool {
        self.loadBalancerClass.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loadBalancerClass(&mut self, v: ::std::string::String) {
        self.loadBalancerClass = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loadBalancerClass(&mut self) -> &mut ::std::string::String {
        if self.loadBalancerClass.is_none() {
            self.loadBalancerClass = ::std::option::Option::Some(::std::string::String::new());
        }
        self.loadBalancerClass.as_mut().unwrap()
    }

    // Take field
    pub fn take_loadBalancerClass(&mut self) -> ::std::string::String {
        self.loadBalancerClass.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string internalTrafficPolicy = 22;

    pub fn internalTrafficPolicy(&self) -> &str {
        match self.internalTrafficPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_internalTrafficPolicy(&mut self) {
        self.internalTrafficPolicy = ::std::option::Option::None;
    }

    pub fn has_internalTrafficPolicy(&self) -> bool {
        self.internalTrafficPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_internalTrafficPolicy(&mut self, v: ::std::string::String) {
        self.internalTrafficPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_internalTrafficPolicy(&mut self) -> &mut ::std::string::String {
        if self.internalTrafficPolicy.is_none() {
            self.internalTrafficPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.internalTrafficPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_internalTrafficPolicy(&mut self) -> ::std::string::String {
        self.internalTrafficPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string trafficDistribution = 23;

    pub fn trafficDistribution(&self) -> &str {
        match self.trafficDistribution.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_trafficDistribution(&mut self) {
        self.trafficDistribution = ::std::option::Option::None;
    }

    pub fn has_trafficDistribution(&self) -> bool {
        self.trafficDistribution.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trafficDistribution(&mut self, v: ::std::string::String) {
        self.trafficDistribution = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trafficDistribution(&mut self) -> &mut ::std::string::String {
        if self.trafficDistribution.is_none() {
            self.trafficDistribution = ::std::option::Option::Some(::std::string::String::new());
        }
        self.trafficDistribution.as_mut().unwrap()
    }

    // Take field
    pub fn take_trafficDistribution(&mut self) -> ::std::string::String {
        self.trafficDistribution.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(20);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ports",
            |m: &ServiceSpec| { &m.ports },
            |m: &mut ServiceSpec| { &mut m.ports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "selector",
            |m: &ServiceSpec| { &m.selector },
            |m: &mut ServiceSpec| { &mut m.selector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clusterIP",
            |m: &ServiceSpec| { &m.clusterIP },
            |m: &mut ServiceSpec| { &mut m.clusterIP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "clusterIPs",
            |m: &ServiceSpec| { &m.clusterIPs },
            |m: &mut ServiceSpec| { &mut m.clusterIPs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &ServiceSpec| { &m.type_ },
            |m: &mut ServiceSpec| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "externalIPs",
            |m: &ServiceSpec| { &m.externalIPs },
            |m: &mut ServiceSpec| { &mut m.externalIPs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sessionAffinity",
            |m: &ServiceSpec| { &m.sessionAffinity },
            |m: &mut ServiceSpec| { &mut m.sessionAffinity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "loadBalancerIP",
            |m: &ServiceSpec| { &m.loadBalancerIP },
            |m: &mut ServiceSpec| { &mut m.loadBalancerIP },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "loadBalancerSourceRanges",
            |m: &ServiceSpec| { &m.loadBalancerSourceRanges },
            |m: &mut ServiceSpec| { &mut m.loadBalancerSourceRanges },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "externalName",
            |m: &ServiceSpec| { &m.externalName },
            |m: &mut ServiceSpec| { &mut m.externalName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "externalTrafficPolicy",
            |m: &ServiceSpec| { &m.externalTrafficPolicy },
            |m: &mut ServiceSpec| { &mut m.externalTrafficPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "healthCheckNodePort",
            |m: &ServiceSpec| { &m.healthCheckNodePort },
            |m: &mut ServiceSpec| { &mut m.healthCheckNodePort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "publishNotReadyAddresses",
            |m: &ServiceSpec| { &m.publishNotReadyAddresses },
            |m: &mut ServiceSpec| { &mut m.publishNotReadyAddresses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SessionAffinityConfig>(
            "sessionAffinityConfig",
            |m: &ServiceSpec| { &m.sessionAffinityConfig },
            |m: &mut ServiceSpec| { &mut m.sessionAffinityConfig },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ipFamilies",
            |m: &ServiceSpec| { &m.ipFamilies },
            |m: &mut ServiceSpec| { &mut m.ipFamilies },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ipFamilyPolicy",
            |m: &ServiceSpec| { &m.ipFamilyPolicy },
            |m: &mut ServiceSpec| { &mut m.ipFamilyPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allocateLoadBalancerNodePorts",
            |m: &ServiceSpec| { &m.allocateLoadBalancerNodePorts },
            |m: &mut ServiceSpec| { &mut m.allocateLoadBalancerNodePorts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "loadBalancerClass",
            |m: &ServiceSpec| { &m.loadBalancerClass },
            |m: &mut ServiceSpec| { &mut m.loadBalancerClass },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "internalTrafficPolicy",
            |m: &ServiceSpec| { &m.internalTrafficPolicy },
            |m: &mut ServiceSpec| { &mut m.internalTrafficPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trafficDistribution",
            |m: &ServiceSpec| { &m.trafficDistribution },
            |m: &mut ServiceSpec| { &mut m.trafficDistribution },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServiceSpec>(
            "ServiceSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServiceSpec {
    const NAME: &'static str = "ServiceSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ports.push(is.read_message()?);
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.selector.insert(key, value);
                },
                26 => {
                    self.clusterIP = ::std::option::Option::Some(is.read_string()?);
                },
                146 => {
                    self.clusterIPs.push(is.read_string()?);
                },
                34 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.externalIPs.push(is.read_string()?);
                },
                58 => {
                    self.sessionAffinity = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.loadBalancerIP = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.loadBalancerSourceRanges.push(is.read_string()?);
                },
                82 => {
                    self.externalName = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.externalTrafficPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                96 => {
                    self.healthCheckNodePort = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.publishNotReadyAddresses = ::std::option::Option::Some(is.read_bool()?);
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sessionAffinityConfig)?;
                },
                154 => {
                    self.ipFamilies.push(is.read_string()?);
                },
                138 => {
                    self.ipFamilyPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                160 => {
                    self.allocateLoadBalancerNodePorts = ::std::option::Option::Some(is.read_bool()?);
                },
                170 => {
                    self.loadBalancerClass = ::std::option::Option::Some(is.read_string()?);
                },
                178 => {
                    self.internalTrafficPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                186 => {
                    self.trafficDistribution = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for (k, v) in &self.selector {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.clusterIP.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.clusterIPs {
            my_size += ::protobuf::rt::string_size(18, &value);
        };
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.externalIPs {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(v) = self.sessionAffinity.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.loadBalancerIP.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        for value in &self.loadBalancerSourceRanges {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        if let Some(v) = self.externalName.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.externalTrafficPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.healthCheckNodePort {
            my_size += ::protobuf::rt::int32_size(12, v);
        }
        if let Some(v) = self.publishNotReadyAddresses {
            my_size += 1 + 1;
        }
        if let Some(v) = self.sessionAffinityConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ipFamilies {
            my_size += ::protobuf::rt::string_size(19, &value);
        };
        if let Some(v) = self.ipFamilyPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.allocateLoadBalancerNodePorts {
            my_size += 2 + 1;
        }
        if let Some(v) = self.loadBalancerClass.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(v) = self.internalTrafficPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(22, &v);
        }
        if let Some(v) = self.trafficDistribution.as_ref() {
            my_size += ::protobuf::rt::string_size(23, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ports {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for (k, v) in &self.selector {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.clusterIP.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.clusterIPs {
            os.write_string(18, &v)?;
        };
        if let Some(v) = self.type_.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.externalIPs {
            os.write_string(5, &v)?;
        };
        if let Some(v) = self.sessionAffinity.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.loadBalancerIP.as_ref() {
            os.write_string(8, v)?;
        }
        for v in &self.loadBalancerSourceRanges {
            os.write_string(9, &v)?;
        };
        if let Some(v) = self.externalName.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.externalTrafficPolicy.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.healthCheckNodePort {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.publishNotReadyAddresses {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.sessionAffinityConfig.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        for v in &self.ipFamilies {
            os.write_string(19, &v)?;
        };
        if let Some(v) = self.ipFamilyPolicy.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.allocateLoadBalancerNodePorts {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.loadBalancerClass.as_ref() {
            os.write_string(21, v)?;
        }
        if let Some(v) = self.internalTrafficPolicy.as_ref() {
            os.write_string(22, v)?;
        }
        if let Some(v) = self.trafficDistribution.as_ref() {
            os.write_string(23, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceSpec {
        ServiceSpec::new()
    }

    fn clear(&mut self) {
        self.ports.clear();
        self.selector.clear();
        self.clusterIP = ::std::option::Option::None;
        self.clusterIPs.clear();
        self.type_ = ::std::option::Option::None;
        self.externalIPs.clear();
        self.sessionAffinity = ::std::option::Option::None;
        self.loadBalancerIP = ::std::option::Option::None;
        self.loadBalancerSourceRanges.clear();
        self.externalName = ::std::option::Option::None;
        self.externalTrafficPolicy = ::std::option::Option::None;
        self.healthCheckNodePort = ::std::option::Option::None;
        self.publishNotReadyAddresses = ::std::option::Option::None;
        self.sessionAffinityConfig.clear();
        self.ipFamilies.clear();
        self.ipFamilyPolicy = ::std::option::Option::None;
        self.allocateLoadBalancerNodePorts = ::std::option::Option::None;
        self.loadBalancerClass = ::std::option::Option::None;
        self.internalTrafficPolicy = ::std::option::Option::None;
        self.trafficDistribution = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceSpec {
        static instance: ::protobuf::rt::Lazy<ServiceSpec> = ::protobuf::rt::Lazy::new();
        instance.get(ServiceSpec::new)
    }
}

impl ::protobuf::MessageFull for ServiceSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.ServiceStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServiceStatus {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ServiceStatus.loadBalancer)
    pub loadBalancer: ::protobuf::MessageField<LoadBalancerStatus>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.ServiceStatus.conditions)
    pub conditions: ::std::vec::Vec<crate::v1_30::apimachinery::pkg::apis::meta::v1::Condition>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.ServiceStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceStatus {
    fn default() -> &'a ServiceStatus {
        <ServiceStatus as ::protobuf::Message>::default_instance()
    }
}

impl ServiceStatus {
    pub fn new() -> ServiceStatus {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.LoadBalancerStatus loadBalancer = 1;

    pub fn loadBalancer(&self) -> &LoadBalancerStatus {
        self.loadBalancer.as_ref().unwrap_or_else(|| <LoadBalancerStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_loadBalancer(&mut self) {
        self.loadBalancer.clear();
    }

    pub fn has_loadBalancer(&self) -> bool {
        self.loadBalancer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loadBalancer(&mut self, v: LoadBalancerStatus) {
        self.loadBalancer = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loadBalancer(&mut self) -> &mut LoadBalancerStatus {
        self.loadBalancer.mut_or_insert_default()
    }

    // Take field
    pub fn take_loadBalancer(&mut self) -> LoadBalancerStatus {
        self.loadBalancer.take().unwrap_or_else(|| LoadBalancerStatus::new())
    }

    // repeated .apimachinery.pkg.apis.meta.v1.Condition conditions = 2;

    pub fn conditions(&self) -> &[crate::v1_30::apimachinery::pkg::apis::meta::v1::Condition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<crate::v1_30::apimachinery::pkg::apis::meta::v1::Condition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<crate::v1_30::apimachinery::pkg::apis::meta::v1::Condition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<crate::v1_30::apimachinery::pkg::apis::meta::v1::Condition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LoadBalancerStatus>(
            "loadBalancer",
            |m: &ServiceStatus| { &m.loadBalancer },
            |m: &mut ServiceStatus| { &mut m.loadBalancer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &ServiceStatus| { &m.conditions },
            |m: &mut ServiceStatus| { &mut m.conditions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServiceStatus>(
            "ServiceStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServiceStatus {
    const NAME: &'static str = "ServiceStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.loadBalancer)?;
                },
                18 => {
                    self.conditions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.loadBalancer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.loadBalancer.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceStatus {
        ServiceStatus::new()
    }

    fn clear(&mut self) {
        self.loadBalancer.clear();
        self.conditions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceStatus {
        static instance: ServiceStatus = ServiceStatus {
            loadBalancer: ::protobuf::MessageField::none(),
            conditions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServiceStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.SessionAffinityConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SessionAffinityConfig {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.SessionAffinityConfig.clientIP)
    pub clientIP: ::protobuf::MessageField<ClientIPConfig>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.SessionAffinityConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SessionAffinityConfig {
    fn default() -> &'a SessionAffinityConfig {
        <SessionAffinityConfig as ::protobuf::Message>::default_instance()
    }
}

impl SessionAffinityConfig {
    pub fn new() -> SessionAffinityConfig {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.ClientIPConfig clientIP = 1;

    pub fn clientIP(&self) -> &ClientIPConfig {
        self.clientIP.as_ref().unwrap_or_else(|| <ClientIPConfig as ::protobuf::Message>::default_instance())
    }

    pub fn clear_clientIP(&mut self) {
        self.clientIP.clear();
    }

    pub fn has_clientIP(&self) -> bool {
        self.clientIP.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientIP(&mut self, v: ClientIPConfig) {
        self.clientIP = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientIP(&mut self) -> &mut ClientIPConfig {
        self.clientIP.mut_or_insert_default()
    }

    // Take field
    pub fn take_clientIP(&mut self) -> ClientIPConfig {
        self.clientIP.take().unwrap_or_else(|| ClientIPConfig::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ClientIPConfig>(
            "clientIP",
            |m: &SessionAffinityConfig| { &m.clientIP },
            |m: &mut SessionAffinityConfig| { &mut m.clientIP },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SessionAffinityConfig>(
            "SessionAffinityConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SessionAffinityConfig {
    const NAME: &'static str = "SessionAffinityConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.clientIP)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.clientIP.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.clientIP.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SessionAffinityConfig {
        SessionAffinityConfig::new()
    }

    fn clear(&mut self) {
        self.clientIP.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SessionAffinityConfig {
        static instance: SessionAffinityConfig = SessionAffinityConfig {
            clientIP: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SessionAffinityConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SessionAffinityConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SessionAffinityConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SessionAffinityConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.SleepAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SleepAction {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.SleepAction.seconds)
    pub seconds: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.SleepAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SleepAction {
    fn default() -> &'a SleepAction {
        <SleepAction as ::protobuf::Message>::default_instance()
    }
}

impl SleepAction {
    pub fn new() -> SleepAction {
        ::std::default::Default::default()
    }

    // optional int64 seconds = 1;

    pub fn seconds(&self) -> i64 {
        self.seconds.unwrap_or(0)
    }

    pub fn clear_seconds(&mut self) {
        self.seconds = ::std::option::Option::None;
    }

    pub fn has_seconds(&self) -> bool {
        self.seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds(&mut self, v: i64) {
        self.seconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds",
            |m: &SleepAction| { &m.seconds },
            |m: &mut SleepAction| { &mut m.seconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SleepAction>(
            "SleepAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SleepAction {
    const NAME: &'static str = "SleepAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.seconds = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.seconds {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.seconds {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SleepAction {
        SleepAction::new()
    }

    fn clear(&mut self) {
        self.seconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SleepAction {
        static instance: SleepAction = SleepAction {
            seconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SleepAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SleepAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SleepAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SleepAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.StorageOSPersistentVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StorageOSPersistentVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.StorageOSPersistentVolumeSource.volumeName)
    pub volumeName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.StorageOSPersistentVolumeSource.volumeNamespace)
    pub volumeNamespace: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.StorageOSPersistentVolumeSource.fsType)
    pub fsType: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.StorageOSPersistentVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.StorageOSPersistentVolumeSource.secretRef)
    pub secretRef: ::protobuf::MessageField<ObjectReference>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.StorageOSPersistentVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StorageOSPersistentVolumeSource {
    fn default() -> &'a StorageOSPersistentVolumeSource {
        <StorageOSPersistentVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl StorageOSPersistentVolumeSource {
    pub fn new() -> StorageOSPersistentVolumeSource {
        ::std::default::Default::default()
    }

    // optional string volumeName = 1;

    pub fn volumeName(&self) -> &str {
        match self.volumeName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_volumeName(&mut self) {
        self.volumeName = ::std::option::Option::None;
    }

    pub fn has_volumeName(&self) -> bool {
        self.volumeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeName(&mut self, v: ::std::string::String) {
        self.volumeName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeName(&mut self) -> &mut ::std::string::String {
        if self.volumeName.is_none() {
            self.volumeName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.volumeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeName(&mut self) -> ::std::string::String {
        self.volumeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string volumeNamespace = 2;

    pub fn volumeNamespace(&self) -> &str {
        match self.volumeNamespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_volumeNamespace(&mut self) {
        self.volumeNamespace = ::std::option::Option::None;
    }

    pub fn has_volumeNamespace(&self) -> bool {
        self.volumeNamespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeNamespace(&mut self, v: ::std::string::String) {
        self.volumeNamespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeNamespace(&mut self) -> &mut ::std::string::String {
        if self.volumeNamespace.is_none() {
            self.volumeNamespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.volumeNamespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeNamespace(&mut self) -> ::std::string::String {
        self.volumeNamespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 3;

    pub fn fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fsType(&mut self) {
        self.fsType = ::std::option::Option::None;
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 4;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // optional .api.core.v1.ObjectReference secretRef = 5;

    pub fn secretRef(&self) -> &ObjectReference {
        self.secretRef.as_ref().unwrap_or_else(|| <ObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: ObjectReference) {
        self.secretRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut ObjectReference {
        self.secretRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> ObjectReference {
        self.secretRef.take().unwrap_or_else(|| ObjectReference::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volumeName",
            |m: &StorageOSPersistentVolumeSource| { &m.volumeName },
            |m: &mut StorageOSPersistentVolumeSource| { &mut m.volumeName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volumeNamespace",
            |m: &StorageOSPersistentVolumeSource| { &m.volumeNamespace },
            |m: &mut StorageOSPersistentVolumeSource| { &mut m.volumeNamespace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsType",
            |m: &StorageOSPersistentVolumeSource| { &m.fsType },
            |m: &mut StorageOSPersistentVolumeSource| { &mut m.fsType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &StorageOSPersistentVolumeSource| { &m.readOnly },
            |m: &mut StorageOSPersistentVolumeSource| { &mut m.readOnly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ObjectReference>(
            "secretRef",
            |m: &StorageOSPersistentVolumeSource| { &m.secretRef },
            |m: &mut StorageOSPersistentVolumeSource| { &mut m.secretRef },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StorageOSPersistentVolumeSource>(
            "StorageOSPersistentVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StorageOSPersistentVolumeSource {
    const NAME: &'static str = "StorageOSPersistentVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.volumeName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.volumeNamespace = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.fsType = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.secretRef)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.volumeName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.volumeNamespace.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        if let Some(v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.volumeName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.volumeNamespace.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.fsType.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.secretRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StorageOSPersistentVolumeSource {
        StorageOSPersistentVolumeSource::new()
    }

    fn clear(&mut self) {
        self.volumeName = ::std::option::Option::None;
        self.volumeNamespace = ::std::option::Option::None;
        self.fsType = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.secretRef.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StorageOSPersistentVolumeSource {
        static instance: StorageOSPersistentVolumeSource = StorageOSPersistentVolumeSource {
            volumeName: ::std::option::Option::None,
            volumeNamespace: ::std::option::Option::None,
            fsType: ::std::option::Option::None,
            readOnly: ::std::option::Option::None,
            secretRef: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StorageOSPersistentVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StorageOSPersistentVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StorageOSPersistentVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageOSPersistentVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.StorageOSVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StorageOSVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.StorageOSVolumeSource.volumeName)
    pub volumeName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.StorageOSVolumeSource.volumeNamespace)
    pub volumeNamespace: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.StorageOSVolumeSource.fsType)
    pub fsType: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.StorageOSVolumeSource.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.StorageOSVolumeSource.secretRef)
    pub secretRef: ::protobuf::MessageField<LocalObjectReference>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.StorageOSVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StorageOSVolumeSource {
    fn default() -> &'a StorageOSVolumeSource {
        <StorageOSVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl StorageOSVolumeSource {
    pub fn new() -> StorageOSVolumeSource {
        ::std::default::Default::default()
    }

    // optional string volumeName = 1;

    pub fn volumeName(&self) -> &str {
        match self.volumeName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_volumeName(&mut self) {
        self.volumeName = ::std::option::Option::None;
    }

    pub fn has_volumeName(&self) -> bool {
        self.volumeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeName(&mut self, v: ::std::string::String) {
        self.volumeName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeName(&mut self) -> &mut ::std::string::String {
        if self.volumeName.is_none() {
            self.volumeName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.volumeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeName(&mut self) -> ::std::string::String {
        self.volumeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string volumeNamespace = 2;

    pub fn volumeNamespace(&self) -> &str {
        match self.volumeNamespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_volumeNamespace(&mut self) {
        self.volumeNamespace = ::std::option::Option::None;
    }

    pub fn has_volumeNamespace(&self) -> bool {
        self.volumeNamespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeNamespace(&mut self, v: ::std::string::String) {
        self.volumeNamespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeNamespace(&mut self) -> &mut ::std::string::String {
        if self.volumeNamespace.is_none() {
            self.volumeNamespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.volumeNamespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeNamespace(&mut self) -> ::std::string::String {
        self.volumeNamespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 3;

    pub fn fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fsType(&mut self) {
        self.fsType = ::std::option::Option::None;
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 4;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // optional .api.core.v1.LocalObjectReference secretRef = 5;

    pub fn secretRef(&self) -> &LocalObjectReference {
        self.secretRef.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: LocalObjectReference) {
        self.secretRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut LocalObjectReference {
        self.secretRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> LocalObjectReference {
        self.secretRef.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volumeName",
            |m: &StorageOSVolumeSource| { &m.volumeName },
            |m: &mut StorageOSVolumeSource| { &mut m.volumeName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volumeNamespace",
            |m: &StorageOSVolumeSource| { &m.volumeNamespace },
            |m: &mut StorageOSVolumeSource| { &mut m.volumeNamespace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsType",
            |m: &StorageOSVolumeSource| { &m.fsType },
            |m: &mut StorageOSVolumeSource| { &mut m.fsType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &StorageOSVolumeSource| { &m.readOnly },
            |m: &mut StorageOSVolumeSource| { &mut m.readOnly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LocalObjectReference>(
            "secretRef",
            |m: &StorageOSVolumeSource| { &m.secretRef },
            |m: &mut StorageOSVolumeSource| { &mut m.secretRef },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StorageOSVolumeSource>(
            "StorageOSVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StorageOSVolumeSource {
    const NAME: &'static str = "StorageOSVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.volumeName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.volumeNamespace = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.fsType = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.secretRef)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.volumeName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.volumeNamespace.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        if let Some(v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.volumeName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.volumeNamespace.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.fsType.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.secretRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StorageOSVolumeSource {
        StorageOSVolumeSource::new()
    }

    fn clear(&mut self) {
        self.volumeName = ::std::option::Option::None;
        self.volumeNamespace = ::std::option::Option::None;
        self.fsType = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.secretRef.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StorageOSVolumeSource {
        static instance: StorageOSVolumeSource = StorageOSVolumeSource {
            volumeName: ::std::option::Option::None,
            volumeNamespace: ::std::option::Option::None,
            fsType: ::std::option::Option::None,
            readOnly: ::std::option::Option::None,
            secretRef: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StorageOSVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StorageOSVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StorageOSVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageOSVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.Sysctl)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Sysctl {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.Sysctl.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.Sysctl.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.Sysctl.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Sysctl {
    fn default() -> &'a Sysctl {
        <Sysctl as ::protobuf::Message>::default_instance()
    }
}

impl Sysctl {
    pub fn new() -> Sysctl {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Sysctl| { &m.name },
            |m: &mut Sysctl| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &Sysctl| { &m.value },
            |m: &mut Sysctl| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Sysctl>(
            "Sysctl",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Sysctl {
    const NAME: &'static str = "Sysctl";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Sysctl {
        Sysctl::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Sysctl {
        static instance: Sysctl = Sysctl {
            name: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Sysctl {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Sysctl").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Sysctl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Sysctl {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.TCPSocketAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TCPSocketAction {
    // message fields
    #[serde(with = "crate::v1_30::intorstr")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.TCPSocketAction.port)
    pub port: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::util::intstr::IntOrString>,
    // @@protoc_insertion_point(field:api.core.v1.TCPSocketAction.host)
    pub host: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.TCPSocketAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TCPSocketAction {
    fn default() -> &'a TCPSocketAction {
        <TCPSocketAction as ::protobuf::Message>::default_instance()
    }
}

impl TCPSocketAction {
    pub fn new() -> TCPSocketAction {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.util.intstr.IntOrString port = 1;

    pub fn port(&self) -> &crate::v1_30::apimachinery::pkg::util::intstr::IntOrString {
        self.port.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::util::intstr::IntOrString as ::protobuf::Message>::default_instance())
    }

    pub fn clear_port(&mut self) {
        self.port.clear();
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: crate::v1_30::apimachinery::pkg::util::intstr::IntOrString) {
        self.port = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_port(&mut self) -> &mut crate::v1_30::apimachinery::pkg::util::intstr::IntOrString {
        self.port.mut_or_insert_default()
    }

    // Take field
    pub fn take_port(&mut self) -> crate::v1_30::apimachinery::pkg::util::intstr::IntOrString {
        self.port.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::util::intstr::IntOrString::new())
    }

    // optional string host = 2;

    pub fn host(&self) -> &str {
        match self.host.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_host(&mut self) {
        self.host = ::std::option::Option::None;
    }

    pub fn has_host(&self) -> bool {
        self.host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        if self.host.is_none() {
            self.host = ::std::option::Option::Some(::std::string::String::new());
        }
        self.host.as_mut().unwrap()
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        self.host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::util::intstr::IntOrString>(
            "port",
            |m: &TCPSocketAction| { &m.port },
            |m: &mut TCPSocketAction| { &mut m.port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "host",
            |m: &TCPSocketAction| { &m.host },
            |m: &mut TCPSocketAction| { &mut m.host },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TCPSocketAction>(
            "TCPSocketAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TCPSocketAction {
    const NAME: &'static str = "TCPSocketAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.port)?;
                },
                18 => {
                    self.host = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.port.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.host.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.port.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.host.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TCPSocketAction {
        TCPSocketAction::new()
    }

    fn clear(&mut self) {
        self.port.clear();
        self.host = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TCPSocketAction {
        static instance: TCPSocketAction = TCPSocketAction {
            port: ::protobuf::MessageField::none(),
            host: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TCPSocketAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TCPSocketAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TCPSocketAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TCPSocketAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.Taint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Taint {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.Taint.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.Taint.value)
    pub value: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.Taint.effect)
    pub effect: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Taint.timeAdded)
    pub timeAdded: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.Taint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Taint {
    fn default() -> &'a Taint {
        <Taint as ::protobuf::Message>::default_instance()
    }
}

impl Taint {
    pub fn new() -> Taint {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string effect = 3;

    pub fn effect(&self) -> &str {
        match self.effect.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_effect(&mut self) {
        self.effect = ::std::option::Option::None;
    }

    pub fn has_effect(&self) -> bool {
        self.effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: ::std::string::String) {
        self.effect = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_effect(&mut self) -> &mut ::std::string::String {
        if self.effect.is_none() {
            self.effect = ::std::option::Option::Some(::std::string::String::new());
        }
        self.effect.as_mut().unwrap()
    }

    // Take field
    pub fn take_effect(&mut self) -> ::std::string::String {
        self.effect.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time timeAdded = 4;

    pub fn timeAdded(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.timeAdded.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_timeAdded(&mut self) {
        self.timeAdded.clear();
    }

    pub fn has_timeAdded(&self) -> bool {
        self.timeAdded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeAdded(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::Time) {
        self.timeAdded = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timeAdded(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.timeAdded.mut_or_insert_default()
    }

    // Take field
    pub fn take_timeAdded(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::Time {
        self.timeAdded.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &Taint| { &m.key },
            |m: &mut Taint| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &Taint| { &m.value },
            |m: &mut Taint| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "effect",
            |m: &Taint| { &m.effect },
            |m: &mut Taint| { &mut m.effect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::Time>(
            "timeAdded",
            |m: &Taint| { &m.timeAdded },
            |m: &mut Taint| { &mut m.timeAdded },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Taint>(
            "Taint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Taint {
    const NAME: &'static str = "Taint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.effect = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timeAdded)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.effect.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.timeAdded.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.effect.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.timeAdded.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Taint {
        Taint::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.effect = ::std::option::Option::None;
        self.timeAdded.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Taint {
        static instance: Taint = Taint {
            key: ::std::option::Option::None,
            value: ::std::option::Option::None,
            effect: ::std::option::Option::None,
            timeAdded: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Taint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Taint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Taint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Taint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.Toleration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Toleration {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.Toleration.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.Toleration.operator)
    pub operator: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.Toleration.value)
    pub value: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.Toleration.effect)
    pub effect: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.Toleration.tolerationSeconds)
    pub tolerationSeconds: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.Toleration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Toleration {
    fn default() -> &'a Toleration {
        <Toleration as ::protobuf::Message>::default_instance()
    }
}

impl Toleration {
    pub fn new() -> Toleration {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string operator = 2;

    pub fn operator(&self) -> &str {
        match self.operator.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_operator(&mut self) {
        self.operator = ::std::option::Option::None;
    }

    pub fn has_operator(&self) -> bool {
        self.operator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operator(&mut self, v: ::std::string::String) {
        self.operator = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operator(&mut self) -> &mut ::std::string::String {
        if self.operator.is_none() {
            self.operator = ::std::option::Option::Some(::std::string::String::new());
        }
        self.operator.as_mut().unwrap()
    }

    // Take field
    pub fn take_operator(&mut self) -> ::std::string::String {
        self.operator.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 3;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string effect = 4;

    pub fn effect(&self) -> &str {
        match self.effect.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_effect(&mut self) {
        self.effect = ::std::option::Option::None;
    }

    pub fn has_effect(&self) -> bool {
        self.effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: ::std::string::String) {
        self.effect = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_effect(&mut self) -> &mut ::std::string::String {
        if self.effect.is_none() {
            self.effect = ::std::option::Option::Some(::std::string::String::new());
        }
        self.effect.as_mut().unwrap()
    }

    // Take field
    pub fn take_effect(&mut self) -> ::std::string::String {
        self.effect.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 tolerationSeconds = 5;

    pub fn tolerationSeconds(&self) -> i64 {
        self.tolerationSeconds.unwrap_or(0)
    }

    pub fn clear_tolerationSeconds(&mut self) {
        self.tolerationSeconds = ::std::option::Option::None;
    }

    pub fn has_tolerationSeconds(&self) -> bool {
        self.tolerationSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tolerationSeconds(&mut self, v: i64) {
        self.tolerationSeconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &Toleration| { &m.key },
            |m: &mut Toleration| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "operator",
            |m: &Toleration| { &m.operator },
            |m: &mut Toleration| { &mut m.operator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &Toleration| { &m.value },
            |m: &mut Toleration| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "effect",
            |m: &Toleration| { &m.effect },
            |m: &mut Toleration| { &mut m.effect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tolerationSeconds",
            |m: &Toleration| { &m.tolerationSeconds },
            |m: &mut Toleration| { &mut m.tolerationSeconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Toleration>(
            "Toleration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Toleration {
    const NAME: &'static str = "Toleration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.operator = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.effect = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.tolerationSeconds = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.operator.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.effect.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.tolerationSeconds {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.operator.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.effect.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.tolerationSeconds {
            os.write_int64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Toleration {
        Toleration::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.operator = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.effect = ::std::option::Option::None;
        self.tolerationSeconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Toleration {
        static instance: Toleration = Toleration {
            key: ::std::option::Option::None,
            operator: ::std::option::Option::None,
            value: ::std::option::Option::None,
            effect: ::std::option::Option::None,
            tolerationSeconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Toleration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Toleration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Toleration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Toleration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.TopologySelectorLabelRequirement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TopologySelectorLabelRequirement {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.TopologySelectorLabelRequirement.key)
    pub key: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.TopologySelectorLabelRequirement.values)
    pub values: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.TopologySelectorLabelRequirement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TopologySelectorLabelRequirement {
    fn default() -> &'a TopologySelectorLabelRequirement {
        <TopologySelectorLabelRequirement as ::protobuf::Message>::default_instance()
    }
}

impl TopologySelectorLabelRequirement {
    pub fn new() -> TopologySelectorLabelRequirement {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string values = 2;

    pub fn values(&self) -> &[::std::string::String] {
        &self.values
    }

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &TopologySelectorLabelRequirement| { &m.key },
            |m: &mut TopologySelectorLabelRequirement| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &TopologySelectorLabelRequirement| { &m.values },
            |m: &mut TopologySelectorLabelRequirement| { &mut m.values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TopologySelectorLabelRequirement>(
            "TopologySelectorLabelRequirement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TopologySelectorLabelRequirement {
    const NAME: &'static str = "TopologySelectorLabelRequirement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.values.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.values {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.values {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TopologySelectorLabelRequirement {
        TopologySelectorLabelRequirement::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TopologySelectorLabelRequirement {
        static instance: TopologySelectorLabelRequirement = TopologySelectorLabelRequirement {
            key: ::std::option::Option::None,
            values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TopologySelectorLabelRequirement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TopologySelectorLabelRequirement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TopologySelectorLabelRequirement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TopologySelectorLabelRequirement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.TopologySelectorTerm)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TopologySelectorTerm {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.TopologySelectorTerm.matchLabelExpressions)
    pub matchLabelExpressions: ::std::vec::Vec<TopologySelectorLabelRequirement>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.TopologySelectorTerm.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TopologySelectorTerm {
    fn default() -> &'a TopologySelectorTerm {
        <TopologySelectorTerm as ::protobuf::Message>::default_instance()
    }
}

impl TopologySelectorTerm {
    pub fn new() -> TopologySelectorTerm {
        ::std::default::Default::default()
    }

    // repeated .api.core.v1.TopologySelectorLabelRequirement matchLabelExpressions = 1;

    pub fn matchLabelExpressions(&self) -> &[TopologySelectorLabelRequirement] {
        &self.matchLabelExpressions
    }

    pub fn clear_matchLabelExpressions(&mut self) {
        self.matchLabelExpressions.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchLabelExpressions(&mut self, v: ::std::vec::Vec<TopologySelectorLabelRequirement>) {
        self.matchLabelExpressions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchLabelExpressions(&mut self) -> &mut ::std::vec::Vec<TopologySelectorLabelRequirement> {
        &mut self.matchLabelExpressions
    }

    // Take field
    pub fn take_matchLabelExpressions(&mut self) -> ::std::vec::Vec<TopologySelectorLabelRequirement> {
        ::std::mem::replace(&mut self.matchLabelExpressions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matchLabelExpressions",
            |m: &TopologySelectorTerm| { &m.matchLabelExpressions },
            |m: &mut TopologySelectorTerm| { &mut m.matchLabelExpressions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TopologySelectorTerm>(
            "TopologySelectorTerm",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TopologySelectorTerm {
    const NAME: &'static str = "TopologySelectorTerm";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.matchLabelExpressions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.matchLabelExpressions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.matchLabelExpressions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TopologySelectorTerm {
        TopologySelectorTerm::new()
    }

    fn clear(&mut self) {
        self.matchLabelExpressions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TopologySelectorTerm {
        static instance: TopologySelectorTerm = TopologySelectorTerm {
            matchLabelExpressions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TopologySelectorTerm {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TopologySelectorTerm").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TopologySelectorTerm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TopologySelectorTerm {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.TopologySpreadConstraint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TopologySpreadConstraint {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.TopologySpreadConstraint.maxSkew)
    pub maxSkew: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.TopologySpreadConstraint.topologyKey)
    pub topologyKey: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.TopologySpreadConstraint.whenUnsatisfiable)
    pub whenUnsatisfiable: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.TopologySpreadConstraint.labelSelector)
    pub labelSelector: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    // @@protoc_insertion_point(field:api.core.v1.TopologySpreadConstraint.minDomains)
    pub minDomains: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.core.v1.TopologySpreadConstraint.nodeAffinityPolicy)
    pub nodeAffinityPolicy: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.TopologySpreadConstraint.nodeTaintsPolicy)
    pub nodeTaintsPolicy: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.TopologySpreadConstraint.matchLabelKeys)
    pub matchLabelKeys: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.TopologySpreadConstraint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TopologySpreadConstraint {
    fn default() -> &'a TopologySpreadConstraint {
        <TopologySpreadConstraint as ::protobuf::Message>::default_instance()
    }
}

impl TopologySpreadConstraint {
    pub fn new() -> TopologySpreadConstraint {
        ::std::default::Default::default()
    }

    // optional int32 maxSkew = 1;

    pub fn maxSkew(&self) -> i32 {
        self.maxSkew.unwrap_or(0)
    }

    pub fn clear_maxSkew(&mut self) {
        self.maxSkew = ::std::option::Option::None;
    }

    pub fn has_maxSkew(&self) -> bool {
        self.maxSkew.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxSkew(&mut self, v: i32) {
        self.maxSkew = ::std::option::Option::Some(v);
    }

    // optional string topologyKey = 2;

    pub fn topologyKey(&self) -> &str {
        match self.topologyKey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_topologyKey(&mut self) {
        self.topologyKey = ::std::option::Option::None;
    }

    pub fn has_topologyKey(&self) -> bool {
        self.topologyKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topologyKey(&mut self, v: ::std::string::String) {
        self.topologyKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topologyKey(&mut self) -> &mut ::std::string::String {
        if self.topologyKey.is_none() {
            self.topologyKey = ::std::option::Option::Some(::std::string::String::new());
        }
        self.topologyKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_topologyKey(&mut self) -> ::std::string::String {
        self.topologyKey.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string whenUnsatisfiable = 3;

    pub fn whenUnsatisfiable(&self) -> &str {
        match self.whenUnsatisfiable.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_whenUnsatisfiable(&mut self) {
        self.whenUnsatisfiable = ::std::option::Option::None;
    }

    pub fn has_whenUnsatisfiable(&self) -> bool {
        self.whenUnsatisfiable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_whenUnsatisfiable(&mut self, v: ::std::string::String) {
        self.whenUnsatisfiable = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_whenUnsatisfiable(&mut self) -> &mut ::std::string::String {
        if self.whenUnsatisfiable.is_none() {
            self.whenUnsatisfiable = ::std::option::Option::Some(::std::string::String::new());
        }
        self.whenUnsatisfiable.as_mut().unwrap()
    }

    // Take field
    pub fn take_whenUnsatisfiable(&mut self) -> ::std::string::String {
        self.whenUnsatisfiable.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 4;

    pub fn labelSelector(&self) -> &crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.labelSelector.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_labelSelector(&mut self) {
        self.labelSelector.clear();
    }

    pub fn has_labelSelector(&self) -> bool {
        self.labelSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labelSelector(&mut self, v: crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.labelSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labelSelector(&mut self) -> &mut crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.labelSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_labelSelector(&mut self) -> crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.labelSelector.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional int32 minDomains = 5;

    pub fn minDomains(&self) -> i32 {
        self.minDomains.unwrap_or(0)
    }

    pub fn clear_minDomains(&mut self) {
        self.minDomains = ::std::option::Option::None;
    }

    pub fn has_minDomains(&self) -> bool {
        self.minDomains.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minDomains(&mut self, v: i32) {
        self.minDomains = ::std::option::Option::Some(v);
    }

    // optional string nodeAffinityPolicy = 6;

    pub fn nodeAffinityPolicy(&self) -> &str {
        match self.nodeAffinityPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nodeAffinityPolicy(&mut self) {
        self.nodeAffinityPolicy = ::std::option::Option::None;
    }

    pub fn has_nodeAffinityPolicy(&self) -> bool {
        self.nodeAffinityPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeAffinityPolicy(&mut self, v: ::std::string::String) {
        self.nodeAffinityPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeAffinityPolicy(&mut self) -> &mut ::std::string::String {
        if self.nodeAffinityPolicy.is_none() {
            self.nodeAffinityPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.nodeAffinityPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodeAffinityPolicy(&mut self) -> ::std::string::String {
        self.nodeAffinityPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string nodeTaintsPolicy = 7;

    pub fn nodeTaintsPolicy(&self) -> &str {
        match self.nodeTaintsPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nodeTaintsPolicy(&mut self) {
        self.nodeTaintsPolicy = ::std::option::Option::None;
    }

    pub fn has_nodeTaintsPolicy(&self) -> bool {
        self.nodeTaintsPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeTaintsPolicy(&mut self, v: ::std::string::String) {
        self.nodeTaintsPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeTaintsPolicy(&mut self) -> &mut ::std::string::String {
        if self.nodeTaintsPolicy.is_none() {
            self.nodeTaintsPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.nodeTaintsPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodeTaintsPolicy(&mut self) -> ::std::string::String {
        self.nodeTaintsPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string matchLabelKeys = 8;

    pub fn matchLabelKeys(&self) -> &[::std::string::String] {
        &self.matchLabelKeys
    }

    pub fn clear_matchLabelKeys(&mut self) {
        self.matchLabelKeys.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchLabelKeys(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.matchLabelKeys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchLabelKeys(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.matchLabelKeys
    }

    // Take field
    pub fn take_matchLabelKeys(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.matchLabelKeys, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maxSkew",
            |m: &TopologySpreadConstraint| { &m.maxSkew },
            |m: &mut TopologySpreadConstraint| { &mut m.maxSkew },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "topologyKey",
            |m: &TopologySpreadConstraint| { &m.topologyKey },
            |m: &mut TopologySpreadConstraint| { &mut m.topologyKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "whenUnsatisfiable",
            |m: &TopologySpreadConstraint| { &m.whenUnsatisfiable },
            |m: &mut TopologySpreadConstraint| { &mut m.whenUnsatisfiable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "labelSelector",
            |m: &TopologySpreadConstraint| { &m.labelSelector },
            |m: &mut TopologySpreadConstraint| { &mut m.labelSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minDomains",
            |m: &TopologySpreadConstraint| { &m.minDomains },
            |m: &mut TopologySpreadConstraint| { &mut m.minDomains },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nodeAffinityPolicy",
            |m: &TopologySpreadConstraint| { &m.nodeAffinityPolicy },
            |m: &mut TopologySpreadConstraint| { &mut m.nodeAffinityPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nodeTaintsPolicy",
            |m: &TopologySpreadConstraint| { &m.nodeTaintsPolicy },
            |m: &mut TopologySpreadConstraint| { &mut m.nodeTaintsPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matchLabelKeys",
            |m: &TopologySpreadConstraint| { &m.matchLabelKeys },
            |m: &mut TopologySpreadConstraint| { &mut m.matchLabelKeys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TopologySpreadConstraint>(
            "TopologySpreadConstraint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TopologySpreadConstraint {
    const NAME: &'static str = "TopologySpreadConstraint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.maxSkew = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.topologyKey = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.whenUnsatisfiable = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.labelSelector)?;
                },
                40 => {
                    self.minDomains = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    self.nodeAffinityPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.nodeTaintsPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.matchLabelKeys.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.maxSkew {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.topologyKey.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.whenUnsatisfiable.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.labelSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.minDomains {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.nodeAffinityPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.nodeTaintsPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        for value in &self.matchLabelKeys {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.maxSkew {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.topologyKey.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.whenUnsatisfiable.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.labelSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.minDomains {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.nodeAffinityPolicy.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.nodeTaintsPolicy.as_ref() {
            os.write_string(7, v)?;
        }
        for v in &self.matchLabelKeys {
            os.write_string(8, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TopologySpreadConstraint {
        TopologySpreadConstraint::new()
    }

    fn clear(&mut self) {
        self.maxSkew = ::std::option::Option::None;
        self.topologyKey = ::std::option::Option::None;
        self.whenUnsatisfiable = ::std::option::Option::None;
        self.labelSelector.clear();
        self.minDomains = ::std::option::Option::None;
        self.nodeAffinityPolicy = ::std::option::Option::None;
        self.nodeTaintsPolicy = ::std::option::Option::None;
        self.matchLabelKeys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TopologySpreadConstraint {
        static instance: TopologySpreadConstraint = TopologySpreadConstraint {
            maxSkew: ::std::option::Option::None,
            topologyKey: ::std::option::Option::None,
            whenUnsatisfiable: ::std::option::Option::None,
            labelSelector: ::protobuf::MessageField::none(),
            minDomains: ::std::option::Option::None,
            nodeAffinityPolicy: ::std::option::Option::None,
            nodeTaintsPolicy: ::std::option::Option::None,
            matchLabelKeys: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TopologySpreadConstraint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TopologySpreadConstraint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TopologySpreadConstraint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TopologySpreadConstraint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.TypedLocalObjectReference)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TypedLocalObjectReference {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.TypedLocalObjectReference.apiGroup)
    pub apiGroup: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.TypedLocalObjectReference.kind)
    pub kind: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.TypedLocalObjectReference.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.TypedLocalObjectReference.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TypedLocalObjectReference {
    fn default() -> &'a TypedLocalObjectReference {
        <TypedLocalObjectReference as ::protobuf::Message>::default_instance()
    }
}

impl TypedLocalObjectReference {
    pub fn new() -> TypedLocalObjectReference {
        ::std::default::Default::default()
    }

    // optional string apiGroup = 1;

    pub fn apiGroup(&self) -> &str {
        match self.apiGroup.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_apiGroup(&mut self) {
        self.apiGroup = ::std::option::Option::None;
    }

    pub fn has_apiGroup(&self) -> bool {
        self.apiGroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiGroup(&mut self, v: ::std::string::String) {
        self.apiGroup = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiGroup(&mut self) -> &mut ::std::string::String {
        if self.apiGroup.is_none() {
            self.apiGroup = ::std::option::Option::Some(::std::string::String::new());
        }
        self.apiGroup.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiGroup(&mut self) -> ::std::string::String {
        self.apiGroup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kind = 2;

    pub fn kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "apiGroup",
            |m: &TypedLocalObjectReference| { &m.apiGroup },
            |m: &mut TypedLocalObjectReference| { &mut m.apiGroup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &TypedLocalObjectReference| { &m.kind },
            |m: &mut TypedLocalObjectReference| { &mut m.kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &TypedLocalObjectReference| { &m.name },
            |m: &mut TypedLocalObjectReference| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TypedLocalObjectReference>(
            "TypedLocalObjectReference",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TypedLocalObjectReference {
    const NAME: &'static str = "TypedLocalObjectReference";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.apiGroup = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.kind = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.apiGroup.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.apiGroup.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.kind.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TypedLocalObjectReference {
        TypedLocalObjectReference::new()
    }

    fn clear(&mut self) {
        self.apiGroup = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TypedLocalObjectReference {
        static instance: TypedLocalObjectReference = TypedLocalObjectReference {
            apiGroup: ::std::option::Option::None,
            kind: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TypedLocalObjectReference {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TypedLocalObjectReference").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TypedLocalObjectReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypedLocalObjectReference {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.TypedObjectReference)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TypedObjectReference {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.TypedObjectReference.apiGroup)
    pub apiGroup: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.TypedObjectReference.kind)
    pub kind: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.TypedObjectReference.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.TypedObjectReference.namespace)
    pub namespace: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.TypedObjectReference.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TypedObjectReference {
    fn default() -> &'a TypedObjectReference {
        <TypedObjectReference as ::protobuf::Message>::default_instance()
    }
}

impl TypedObjectReference {
    pub fn new() -> TypedObjectReference {
        ::std::default::Default::default()
    }

    // optional string apiGroup = 1;

    pub fn apiGroup(&self) -> &str {
        match self.apiGroup.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_apiGroup(&mut self) {
        self.apiGroup = ::std::option::Option::None;
    }

    pub fn has_apiGroup(&self) -> bool {
        self.apiGroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiGroup(&mut self, v: ::std::string::String) {
        self.apiGroup = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiGroup(&mut self) -> &mut ::std::string::String {
        if self.apiGroup.is_none() {
            self.apiGroup = ::std::option::Option::Some(::std::string::String::new());
        }
        self.apiGroup.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiGroup(&mut self) -> ::std::string::String {
        self.apiGroup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kind = 2;

    pub fn kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string namespace = 4;

    pub fn namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_namespace(&mut self) {
        self.namespace = ::std::option::Option::None;
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "apiGroup",
            |m: &TypedObjectReference| { &m.apiGroup },
            |m: &mut TypedObjectReference| { &mut m.apiGroup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &TypedObjectReference| { &m.kind },
            |m: &mut TypedObjectReference| { &mut m.kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &TypedObjectReference| { &m.name },
            |m: &mut TypedObjectReference| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "namespace",
            |m: &TypedObjectReference| { &m.namespace },
            |m: &mut TypedObjectReference| { &mut m.namespace },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TypedObjectReference>(
            "TypedObjectReference",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TypedObjectReference {
    const NAME: &'static str = "TypedObjectReference";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.apiGroup = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.kind = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.namespace = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.apiGroup.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.apiGroup.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.kind.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.namespace.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TypedObjectReference {
        TypedObjectReference::new()
    }

    fn clear(&mut self) {
        self.apiGroup = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.namespace = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TypedObjectReference {
        static instance: TypedObjectReference = TypedObjectReference {
            apiGroup: ::std::option::Option::None,
            kind: ::std::option::Option::None,
            name: ::std::option::Option::None,
            namespace: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TypedObjectReference {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TypedObjectReference").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TypedObjectReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypedObjectReference {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.Volume)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Volume {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.Volume.name)
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.Volume.volumeSource)
    pub volumeSource: ::protobuf::MessageField<VolumeSource>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.Volume.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Volume {
    fn default() -> &'a Volume {
        <Volume as ::protobuf::Message>::default_instance()
    }
}

impl Volume {
    pub fn new() -> Volume {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.VolumeSource volumeSource = 2;

    pub fn volumeSource(&self) -> &VolumeSource {
        self.volumeSource.as_ref().unwrap_or_else(|| <VolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_volumeSource(&mut self) {
        self.volumeSource.clear();
    }

    pub fn has_volumeSource(&self) -> bool {
        self.volumeSource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeSource(&mut self, v: VolumeSource) {
        self.volumeSource = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeSource(&mut self) -> &mut VolumeSource {
        self.volumeSource.mut_or_insert_default()
    }

    // Take field
    pub fn take_volumeSource(&mut self) -> VolumeSource {
        self.volumeSource.take().unwrap_or_else(|| VolumeSource::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Volume| { &m.name },
            |m: &mut Volume| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VolumeSource>(
            "volumeSource",
            |m: &Volume| { &m.volumeSource },
            |m: &mut Volume| { &mut m.volumeSource },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Volume>(
            "Volume",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Volume {
    const NAME: &'static str = "Volume";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.volumeSource)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.volumeSource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.volumeSource.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Volume {
        Volume::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.volumeSource.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Volume {
        static instance: Volume = Volume {
            name: ::std::option::Option::None,
            volumeSource: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Volume {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Volume").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Volume {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Volume {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.VolumeDevice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VolumeDevice {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.VolumeDevice.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.VolumeDevice.devicePath)
    pub devicePath: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.VolumeDevice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VolumeDevice {
    fn default() -> &'a VolumeDevice {
        <VolumeDevice as ::protobuf::Message>::default_instance()
    }
}

impl VolumeDevice {
    pub fn new() -> VolumeDevice {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string devicePath = 2;

    pub fn devicePath(&self) -> &str {
        match self.devicePath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_devicePath(&mut self) {
        self.devicePath = ::std::option::Option::None;
    }

    pub fn has_devicePath(&self) -> bool {
        self.devicePath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_devicePath(&mut self, v: ::std::string::String) {
        self.devicePath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_devicePath(&mut self) -> &mut ::std::string::String {
        if self.devicePath.is_none() {
            self.devicePath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.devicePath.as_mut().unwrap()
    }

    // Take field
    pub fn take_devicePath(&mut self) -> ::std::string::String {
        self.devicePath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &VolumeDevice| { &m.name },
            |m: &mut VolumeDevice| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "devicePath",
            |m: &VolumeDevice| { &m.devicePath },
            |m: &mut VolumeDevice| { &mut m.devicePath },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VolumeDevice>(
            "VolumeDevice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VolumeDevice {
    const NAME: &'static str = "VolumeDevice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.devicePath = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.devicePath.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.devicePath.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VolumeDevice {
        VolumeDevice::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.devicePath = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VolumeDevice {
        static instance: VolumeDevice = VolumeDevice {
            name: ::std::option::Option::None,
            devicePath: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VolumeDevice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VolumeDevice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VolumeDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VolumeDevice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.VolumeMount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VolumeMount {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.VolumeMount.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.VolumeMount.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.VolumeMount.recursiveReadOnly)
    pub recursiveReadOnly: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.VolumeMount.mountPath)
    pub mountPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.VolumeMount.subPath)
    pub subPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.VolumeMount.mountPropagation)
    pub mountPropagation: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.VolumeMount.subPathExpr)
    pub subPathExpr: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.VolumeMount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VolumeMount {
    fn default() -> &'a VolumeMount {
        <VolumeMount as ::protobuf::Message>::default_instance()
    }
}

impl VolumeMount {
    pub fn new() -> VolumeMount {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 2;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // optional string recursiveReadOnly = 7;

    pub fn recursiveReadOnly(&self) -> &str {
        match self.recursiveReadOnly.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_recursiveReadOnly(&mut self) {
        self.recursiveReadOnly = ::std::option::Option::None;
    }

    pub fn has_recursiveReadOnly(&self) -> bool {
        self.recursiveReadOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recursiveReadOnly(&mut self, v: ::std::string::String) {
        self.recursiveReadOnly = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recursiveReadOnly(&mut self) -> &mut ::std::string::String {
        if self.recursiveReadOnly.is_none() {
            self.recursiveReadOnly = ::std::option::Option::Some(::std::string::String::new());
        }
        self.recursiveReadOnly.as_mut().unwrap()
    }

    // Take field
    pub fn take_recursiveReadOnly(&mut self) -> ::std::string::String {
        self.recursiveReadOnly.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mountPath = 3;

    pub fn mountPath(&self) -> &str {
        match self.mountPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mountPath(&mut self) {
        self.mountPath = ::std::option::Option::None;
    }

    pub fn has_mountPath(&self) -> bool {
        self.mountPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mountPath(&mut self, v: ::std::string::String) {
        self.mountPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mountPath(&mut self) -> &mut ::std::string::String {
        if self.mountPath.is_none() {
            self.mountPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mountPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_mountPath(&mut self) -> ::std::string::String {
        self.mountPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string subPath = 4;

    pub fn subPath(&self) -> &str {
        match self.subPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_subPath(&mut self) {
        self.subPath = ::std::option::Option::None;
    }

    pub fn has_subPath(&self) -> bool {
        self.subPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subPath(&mut self, v: ::std::string::String) {
        self.subPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subPath(&mut self) -> &mut ::std::string::String {
        if self.subPath.is_none() {
            self.subPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.subPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_subPath(&mut self) -> ::std::string::String {
        self.subPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mountPropagation = 5;

    pub fn mountPropagation(&self) -> &str {
        match self.mountPropagation.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mountPropagation(&mut self) {
        self.mountPropagation = ::std::option::Option::None;
    }

    pub fn has_mountPropagation(&self) -> bool {
        self.mountPropagation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mountPropagation(&mut self, v: ::std::string::String) {
        self.mountPropagation = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mountPropagation(&mut self) -> &mut ::std::string::String {
        if self.mountPropagation.is_none() {
            self.mountPropagation = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mountPropagation.as_mut().unwrap()
    }

    // Take field
    pub fn take_mountPropagation(&mut self) -> ::std::string::String {
        self.mountPropagation.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string subPathExpr = 6;

    pub fn subPathExpr(&self) -> &str {
        match self.subPathExpr.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_subPathExpr(&mut self) {
        self.subPathExpr = ::std::option::Option::None;
    }

    pub fn has_subPathExpr(&self) -> bool {
        self.subPathExpr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subPathExpr(&mut self, v: ::std::string::String) {
        self.subPathExpr = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subPathExpr(&mut self) -> &mut ::std::string::String {
        if self.subPathExpr.is_none() {
            self.subPathExpr = ::std::option::Option::Some(::std::string::String::new());
        }
        self.subPathExpr.as_mut().unwrap()
    }

    // Take field
    pub fn take_subPathExpr(&mut self) -> ::std::string::String {
        self.subPathExpr.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &VolumeMount| { &m.name },
            |m: &mut VolumeMount| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &VolumeMount| { &m.readOnly },
            |m: &mut VolumeMount| { &mut m.readOnly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recursiveReadOnly",
            |m: &VolumeMount| { &m.recursiveReadOnly },
            |m: &mut VolumeMount| { &mut m.recursiveReadOnly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mountPath",
            |m: &VolumeMount| { &m.mountPath },
            |m: &mut VolumeMount| { &mut m.mountPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subPath",
            |m: &VolumeMount| { &m.subPath },
            |m: &mut VolumeMount| { &mut m.subPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mountPropagation",
            |m: &VolumeMount| { &m.mountPropagation },
            |m: &mut VolumeMount| { &mut m.mountPropagation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subPathExpr",
            |m: &VolumeMount| { &m.subPathExpr },
            |m: &mut VolumeMount| { &mut m.subPathExpr },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VolumeMount>(
            "VolumeMount",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VolumeMount {
    const NAME: &'static str = "VolumeMount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    self.recursiveReadOnly = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.mountPath = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.subPath = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.mountPropagation = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.subPathExpr = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        if let Some(v) = self.recursiveReadOnly.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.mountPath.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.subPath.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.mountPropagation.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.subPathExpr.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.recursiveReadOnly.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.mountPath.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.subPath.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.mountPropagation.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.subPathExpr.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VolumeMount {
        VolumeMount::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.recursiveReadOnly = ::std::option::Option::None;
        self.mountPath = ::std::option::Option::None;
        self.subPath = ::std::option::Option::None;
        self.mountPropagation = ::std::option::Option::None;
        self.subPathExpr = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VolumeMount {
        static instance: VolumeMount = VolumeMount {
            name: ::std::option::Option::None,
            readOnly: ::std::option::Option::None,
            recursiveReadOnly: ::std::option::Option::None,
            mountPath: ::std::option::Option::None,
            subPath: ::std::option::Option::None,
            mountPropagation: ::std::option::Option::None,
            subPathExpr: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VolumeMount {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VolumeMount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VolumeMount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VolumeMount {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.VolumeMountStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VolumeMountStatus {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.VolumeMountStatus.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.VolumeMountStatus.mountPath)
    pub mountPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.VolumeMountStatus.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.core.v1.VolumeMountStatus.recursiveReadOnly)
    pub recursiveReadOnly: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.VolumeMountStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VolumeMountStatus {
    fn default() -> &'a VolumeMountStatus {
        <VolumeMountStatus as ::protobuf::Message>::default_instance()
    }
}

impl VolumeMountStatus {
    pub fn new() -> VolumeMountStatus {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mountPath = 2;

    pub fn mountPath(&self) -> &str {
        match self.mountPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mountPath(&mut self) {
        self.mountPath = ::std::option::Option::None;
    }

    pub fn has_mountPath(&self) -> bool {
        self.mountPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mountPath(&mut self, v: ::std::string::String) {
        self.mountPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mountPath(&mut self) -> &mut ::std::string::String {
        if self.mountPath.is_none() {
            self.mountPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mountPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_mountPath(&mut self) -> ::std::string::String {
        self.mountPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 3;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // optional string recursiveReadOnly = 4;

    pub fn recursiveReadOnly(&self) -> &str {
        match self.recursiveReadOnly.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_recursiveReadOnly(&mut self) {
        self.recursiveReadOnly = ::std::option::Option::None;
    }

    pub fn has_recursiveReadOnly(&self) -> bool {
        self.recursiveReadOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recursiveReadOnly(&mut self, v: ::std::string::String) {
        self.recursiveReadOnly = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recursiveReadOnly(&mut self) -> &mut ::std::string::String {
        if self.recursiveReadOnly.is_none() {
            self.recursiveReadOnly = ::std::option::Option::Some(::std::string::String::new());
        }
        self.recursiveReadOnly.as_mut().unwrap()
    }

    // Take field
    pub fn take_recursiveReadOnly(&mut self) -> ::std::string::String {
        self.recursiveReadOnly.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &VolumeMountStatus| { &m.name },
            |m: &mut VolumeMountStatus| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mountPath",
            |m: &VolumeMountStatus| { &m.mountPath },
            |m: &mut VolumeMountStatus| { &mut m.mountPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &VolumeMountStatus| { &m.readOnly },
            |m: &mut VolumeMountStatus| { &mut m.readOnly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recursiveReadOnly",
            |m: &VolumeMountStatus| { &m.recursiveReadOnly },
            |m: &mut VolumeMountStatus| { &mut m.recursiveReadOnly },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VolumeMountStatus>(
            "VolumeMountStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VolumeMountStatus {
    const NAME: &'static str = "VolumeMountStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.mountPath = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.recursiveReadOnly = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.mountPath.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        if let Some(v) = self.recursiveReadOnly.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.mountPath.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.recursiveReadOnly.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VolumeMountStatus {
        VolumeMountStatus::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.mountPath = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.recursiveReadOnly = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VolumeMountStatus {
        static instance: VolumeMountStatus = VolumeMountStatus {
            name: ::std::option::Option::None,
            mountPath: ::std::option::Option::None,
            readOnly: ::std::option::Option::None,
            recursiveReadOnly: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VolumeMountStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VolumeMountStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VolumeMountStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VolumeMountStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.VolumeNodeAffinity)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VolumeNodeAffinity {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeNodeAffinity.required)
    pub required: ::protobuf::MessageField<NodeSelector>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.VolumeNodeAffinity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VolumeNodeAffinity {
    fn default() -> &'a VolumeNodeAffinity {
        <VolumeNodeAffinity as ::protobuf::Message>::default_instance()
    }
}

impl VolumeNodeAffinity {
    pub fn new() -> VolumeNodeAffinity {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.NodeSelector required = 1;

    pub fn required(&self) -> &NodeSelector {
        self.required.as_ref().unwrap_or_else(|| <NodeSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_required(&mut self) {
        self.required.clear();
    }

    pub fn has_required(&self) -> bool {
        self.required.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required(&mut self, v: NodeSelector) {
        self.required = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_required(&mut self) -> &mut NodeSelector {
        self.required.mut_or_insert_default()
    }

    // Take field
    pub fn take_required(&mut self) -> NodeSelector {
        self.required.take().unwrap_or_else(|| NodeSelector::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodeSelector>(
            "required",
            |m: &VolumeNodeAffinity| { &m.required },
            |m: &mut VolumeNodeAffinity| { &mut m.required },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VolumeNodeAffinity>(
            "VolumeNodeAffinity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VolumeNodeAffinity {
    const NAME: &'static str = "VolumeNodeAffinity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.required)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.required.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.required.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VolumeNodeAffinity {
        VolumeNodeAffinity::new()
    }

    fn clear(&mut self) {
        self.required.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VolumeNodeAffinity {
        static instance: VolumeNodeAffinity = VolumeNodeAffinity {
            required: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VolumeNodeAffinity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VolumeNodeAffinity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VolumeNodeAffinity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VolumeNodeAffinity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.VolumeProjection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VolumeProjection {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeProjection.secret)
    pub secret: ::protobuf::MessageField<SecretProjection>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeProjection.downwardAPI)
    pub downwardAPI: ::protobuf::MessageField<DownwardAPIProjection>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeProjection.configMap)
    pub configMap: ::protobuf::MessageField<ConfigMapProjection>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeProjection.serviceAccountToken)
    pub serviceAccountToken: ::protobuf::MessageField<ServiceAccountTokenProjection>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeProjection.clusterTrustBundle)
    pub clusterTrustBundle: ::protobuf::MessageField<ClusterTrustBundleProjection>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.VolumeProjection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VolumeProjection {
    fn default() -> &'a VolumeProjection {
        <VolumeProjection as ::protobuf::Message>::default_instance()
    }
}

impl VolumeProjection {
    pub fn new() -> VolumeProjection {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.SecretProjection secret = 1;

    pub fn secret(&self) -> &SecretProjection {
        self.secret.as_ref().unwrap_or_else(|| <SecretProjection as ::protobuf::Message>::default_instance())
    }

    pub fn clear_secret(&mut self) {
        self.secret.clear();
    }

    pub fn has_secret(&self) -> bool {
        self.secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secret(&mut self, v: SecretProjection) {
        self.secret = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret(&mut self) -> &mut SecretProjection {
        self.secret.mut_or_insert_default()
    }

    // Take field
    pub fn take_secret(&mut self) -> SecretProjection {
        self.secret.take().unwrap_or_else(|| SecretProjection::new())
    }

    // optional .api.core.v1.DownwardAPIProjection downwardAPI = 2;

    pub fn downwardAPI(&self) -> &DownwardAPIProjection {
        self.downwardAPI.as_ref().unwrap_or_else(|| <DownwardAPIProjection as ::protobuf::Message>::default_instance())
    }

    pub fn clear_downwardAPI(&mut self) {
        self.downwardAPI.clear();
    }

    pub fn has_downwardAPI(&self) -> bool {
        self.downwardAPI.is_some()
    }

    // Param is passed by value, moved
    pub fn set_downwardAPI(&mut self, v: DownwardAPIProjection) {
        self.downwardAPI = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_downwardAPI(&mut self) -> &mut DownwardAPIProjection {
        self.downwardAPI.mut_or_insert_default()
    }

    // Take field
    pub fn take_downwardAPI(&mut self) -> DownwardAPIProjection {
        self.downwardAPI.take().unwrap_or_else(|| DownwardAPIProjection::new())
    }

    // optional .api.core.v1.ConfigMapProjection configMap = 3;

    pub fn configMap(&self) -> &ConfigMapProjection {
        self.configMap.as_ref().unwrap_or_else(|| <ConfigMapProjection as ::protobuf::Message>::default_instance())
    }

    pub fn clear_configMap(&mut self) {
        self.configMap.clear();
    }

    pub fn has_configMap(&self) -> bool {
        self.configMap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configMap(&mut self, v: ConfigMapProjection) {
        self.configMap = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configMap(&mut self) -> &mut ConfigMapProjection {
        self.configMap.mut_or_insert_default()
    }

    // Take field
    pub fn take_configMap(&mut self) -> ConfigMapProjection {
        self.configMap.take().unwrap_or_else(|| ConfigMapProjection::new())
    }

    // optional .api.core.v1.ServiceAccountTokenProjection serviceAccountToken = 4;

    pub fn serviceAccountToken(&self) -> &ServiceAccountTokenProjection {
        self.serviceAccountToken.as_ref().unwrap_or_else(|| <ServiceAccountTokenProjection as ::protobuf::Message>::default_instance())
    }

    pub fn clear_serviceAccountToken(&mut self) {
        self.serviceAccountToken.clear();
    }

    pub fn has_serviceAccountToken(&self) -> bool {
        self.serviceAccountToken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serviceAccountToken(&mut self, v: ServiceAccountTokenProjection) {
        self.serviceAccountToken = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serviceAccountToken(&mut self) -> &mut ServiceAccountTokenProjection {
        self.serviceAccountToken.mut_or_insert_default()
    }

    // Take field
    pub fn take_serviceAccountToken(&mut self) -> ServiceAccountTokenProjection {
        self.serviceAccountToken.take().unwrap_or_else(|| ServiceAccountTokenProjection::new())
    }

    // optional .api.core.v1.ClusterTrustBundleProjection clusterTrustBundle = 5;

    pub fn clusterTrustBundle(&self) -> &ClusterTrustBundleProjection {
        self.clusterTrustBundle.as_ref().unwrap_or_else(|| <ClusterTrustBundleProjection as ::protobuf::Message>::default_instance())
    }

    pub fn clear_clusterTrustBundle(&mut self) {
        self.clusterTrustBundle.clear();
    }

    pub fn has_clusterTrustBundle(&self) -> bool {
        self.clusterTrustBundle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clusterTrustBundle(&mut self, v: ClusterTrustBundleProjection) {
        self.clusterTrustBundle = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clusterTrustBundle(&mut self) -> &mut ClusterTrustBundleProjection {
        self.clusterTrustBundle.mut_or_insert_default()
    }

    // Take field
    pub fn take_clusterTrustBundle(&mut self) -> ClusterTrustBundleProjection {
        self.clusterTrustBundle.take().unwrap_or_else(|| ClusterTrustBundleProjection::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SecretProjection>(
            "secret",
            |m: &VolumeProjection| { &m.secret },
            |m: &mut VolumeProjection| { &mut m.secret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DownwardAPIProjection>(
            "downwardAPI",
            |m: &VolumeProjection| { &m.downwardAPI },
            |m: &mut VolumeProjection| { &mut m.downwardAPI },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConfigMapProjection>(
            "configMap",
            |m: &VolumeProjection| { &m.configMap },
            |m: &mut VolumeProjection| { &mut m.configMap },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ServiceAccountTokenProjection>(
            "serviceAccountToken",
            |m: &VolumeProjection| { &m.serviceAccountToken },
            |m: &mut VolumeProjection| { &mut m.serviceAccountToken },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ClusterTrustBundleProjection>(
            "clusterTrustBundle",
            |m: &VolumeProjection| { &m.clusterTrustBundle },
            |m: &mut VolumeProjection| { &mut m.clusterTrustBundle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VolumeProjection>(
            "VolumeProjection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VolumeProjection {
    const NAME: &'static str = "VolumeProjection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.secret)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.downwardAPI)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.configMap)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.serviceAccountToken)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.clusterTrustBundle)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.secret.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.downwardAPI.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.configMap.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.serviceAccountToken.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.clusterTrustBundle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.secret.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.downwardAPI.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.configMap.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.serviceAccountToken.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.clusterTrustBundle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VolumeProjection {
        VolumeProjection::new()
    }

    fn clear(&mut self) {
        self.secret.clear();
        self.downwardAPI.clear();
        self.configMap.clear();
        self.serviceAccountToken.clear();
        self.clusterTrustBundle.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VolumeProjection {
        static instance: VolumeProjection = VolumeProjection {
            secret: ::protobuf::MessageField::none(),
            downwardAPI: ::protobuf::MessageField::none(),
            configMap: ::protobuf::MessageField::none(),
            serviceAccountToken: ::protobuf::MessageField::none(),
            clusterTrustBundle: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VolumeProjection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VolumeProjection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VolumeProjection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VolumeProjection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.VolumeResourceRequirements)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VolumeResourceRequirements {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeResourceRequirements.limits)
    pub limits: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeResourceRequirements.requests)
    pub requests: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.VolumeResourceRequirements.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VolumeResourceRequirements {
    fn default() -> &'a VolumeResourceRequirements {
        <VolumeResourceRequirements as ::protobuf::Message>::default_instance()
    }
}

impl VolumeResourceRequirements {
    pub fn new() -> VolumeResourceRequirements {
        ::std::default::Default::default()
    }

    // repeated .api.core.v1.VolumeResourceRequirements.LimitsEntry limits = 1;

    pub fn limits(&self) -> &::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &self.limits
    }

    pub fn clear_limits(&mut self) {
        self.limits.clear();
    }

    // Param is passed by value, moved
    pub fn set_limits(&mut self, v: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>) {
        self.limits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_limits(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &mut self.limits
    }

    // Take field
    pub fn take_limits(&mut self) -> ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        ::std::mem::replace(&mut self.limits, ::std::collections::BTreeMap::new())
    }

    // repeated .api.core.v1.VolumeResourceRequirements.RequestsEntry requests = 2;

    pub fn requests(&self) -> &::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &self.requests
    }

    pub fn clear_requests(&mut self) {
        self.requests.clear();
    }

    // Param is passed by value, moved
    pub fn set_requests(&mut self, v: ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity>) {
        self.requests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requests(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        &mut self.requests
    }

    // Take field
    pub fn take_requests(&mut self) -> ::std::collections::BTreeMap<::std::string::String, crate::v1_30::apimachinery::pkg::api::resource::Quantity> {
        ::std::mem::replace(&mut self.requests, ::std::collections::BTreeMap::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "limits",
            |m: &VolumeResourceRequirements| { &m.limits },
            |m: &mut VolumeResourceRequirements| { &mut m.limits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "requests",
            |m: &VolumeResourceRequirements| { &m.requests },
            |m: &mut VolumeResourceRequirements| { &mut m.requests },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VolumeResourceRequirements>(
            "VolumeResourceRequirements",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VolumeResourceRequirements {
    const NAME: &'static str = "VolumeResourceRequirements";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.limits.insert(key, value);
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.requests.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.limits {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.requests {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.limits {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.requests {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VolumeResourceRequirements {
        VolumeResourceRequirements::new()
    }

    fn clear(&mut self) {
        self.limits.clear();
        self.requests.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VolumeResourceRequirements {
        static instance: ::protobuf::rt::Lazy<VolumeResourceRequirements> = ::protobuf::rt::Lazy::new();
        instance.get(VolumeResourceRequirements::new)
    }
}

impl ::protobuf::MessageFull for VolumeResourceRequirements {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VolumeResourceRequirements").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VolumeResourceRequirements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VolumeResourceRequirements {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.VolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VolumeSource {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.hostPath)
    pub hostPath: ::protobuf::MessageField<HostPathVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.emptyDir)
    pub emptyDir: ::protobuf::MessageField<EmptyDirVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.gcePersistentDisk)
    pub gcePersistentDisk: ::protobuf::MessageField<GCEPersistentDiskVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.awsElasticBlockStore)
    pub awsElasticBlockStore: ::protobuf::MessageField<AWSElasticBlockStoreVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.gitRepo)
    pub gitRepo: ::protobuf::MessageField<GitRepoVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.secret)
    pub secret: ::protobuf::MessageField<SecretVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.nfs)
    pub nfs: ::protobuf::MessageField<NFSVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.iscsi)
    pub iscsi: ::protobuf::MessageField<ISCSIVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.glusterfs)
    pub glusterfs: ::protobuf::MessageField<GlusterfsVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.persistentVolumeClaim)
    pub persistentVolumeClaim: ::protobuf::MessageField<PersistentVolumeClaimVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.rbd)
    pub rbd: ::protobuf::MessageField<RBDVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.flexVolume)
    pub flexVolume: ::protobuf::MessageField<FlexVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.cinder)
    pub cinder: ::protobuf::MessageField<CinderVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.cephfs)
    pub cephfs: ::protobuf::MessageField<CephFSVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.flocker)
    pub flocker: ::protobuf::MessageField<FlockerVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.downwardAPI)
    pub downwardAPI: ::protobuf::MessageField<DownwardAPIVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.fc)
    pub fc: ::protobuf::MessageField<FCVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.azureFile)
    pub azureFile: ::protobuf::MessageField<AzureFileVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.configMap)
    pub configMap: ::protobuf::MessageField<ConfigMapVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.vsphereVolume)
    pub vsphereVolume: ::protobuf::MessageField<VsphereVirtualDiskVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.quobyte)
    pub quobyte: ::protobuf::MessageField<QuobyteVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.azureDisk)
    pub azureDisk: ::protobuf::MessageField<AzureDiskVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.photonPersistentDisk)
    pub photonPersistentDisk: ::protobuf::MessageField<PhotonPersistentDiskVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.projected)
    pub projected: ::protobuf::MessageField<ProjectedVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.portworxVolume)
    pub portworxVolume: ::protobuf::MessageField<PortworxVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.scaleIO)
    pub scaleIO: ::protobuf::MessageField<ScaleIOVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.storageos)
    pub storageos: ::protobuf::MessageField<StorageOSVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.csi)
    pub csi: ::protobuf::MessageField<CSIVolumeSource>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.VolumeSource.ephemeral)
    pub ephemeral: ::protobuf::MessageField<EphemeralVolumeSource>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.VolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VolumeSource {
    fn default() -> &'a VolumeSource {
        <VolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl VolumeSource {
    pub fn new() -> VolumeSource {
        ::std::default::Default::default()
    }

    // optional .api.core.v1.HostPathVolumeSource hostPath = 1;

    pub fn hostPath(&self) -> &HostPathVolumeSource {
        self.hostPath.as_ref().unwrap_or_else(|| <HostPathVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_hostPath(&mut self) {
        self.hostPath.clear();
    }

    pub fn has_hostPath(&self) -> bool {
        self.hostPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostPath(&mut self, v: HostPathVolumeSource) {
        self.hostPath = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostPath(&mut self) -> &mut HostPathVolumeSource {
        self.hostPath.mut_or_insert_default()
    }

    // Take field
    pub fn take_hostPath(&mut self) -> HostPathVolumeSource {
        self.hostPath.take().unwrap_or_else(|| HostPathVolumeSource::new())
    }

    // optional .api.core.v1.EmptyDirVolumeSource emptyDir = 2;

    pub fn emptyDir(&self) -> &EmptyDirVolumeSource {
        self.emptyDir.as_ref().unwrap_or_else(|| <EmptyDirVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_emptyDir(&mut self) {
        self.emptyDir.clear();
    }

    pub fn has_emptyDir(&self) -> bool {
        self.emptyDir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_emptyDir(&mut self, v: EmptyDirVolumeSource) {
        self.emptyDir = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_emptyDir(&mut self) -> &mut EmptyDirVolumeSource {
        self.emptyDir.mut_or_insert_default()
    }

    // Take field
    pub fn take_emptyDir(&mut self) -> EmptyDirVolumeSource {
        self.emptyDir.take().unwrap_or_else(|| EmptyDirVolumeSource::new())
    }

    // optional .api.core.v1.GCEPersistentDiskVolumeSource gcePersistentDisk = 3;

    pub fn gcePersistentDisk(&self) -> &GCEPersistentDiskVolumeSource {
        self.gcePersistentDisk.as_ref().unwrap_or_else(|| <GCEPersistentDiskVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_gcePersistentDisk(&mut self) {
        self.gcePersistentDisk.clear();
    }

    pub fn has_gcePersistentDisk(&self) -> bool {
        self.gcePersistentDisk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gcePersistentDisk(&mut self, v: GCEPersistentDiskVolumeSource) {
        self.gcePersistentDisk = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gcePersistentDisk(&mut self) -> &mut GCEPersistentDiskVolumeSource {
        self.gcePersistentDisk.mut_or_insert_default()
    }

    // Take field
    pub fn take_gcePersistentDisk(&mut self) -> GCEPersistentDiskVolumeSource {
        self.gcePersistentDisk.take().unwrap_or_else(|| GCEPersistentDiskVolumeSource::new())
    }

    // optional .api.core.v1.AWSElasticBlockStoreVolumeSource awsElasticBlockStore = 4;

    pub fn awsElasticBlockStore(&self) -> &AWSElasticBlockStoreVolumeSource {
        self.awsElasticBlockStore.as_ref().unwrap_or_else(|| <AWSElasticBlockStoreVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_awsElasticBlockStore(&mut self) {
        self.awsElasticBlockStore.clear();
    }

    pub fn has_awsElasticBlockStore(&self) -> bool {
        self.awsElasticBlockStore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_awsElasticBlockStore(&mut self, v: AWSElasticBlockStoreVolumeSource) {
        self.awsElasticBlockStore = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_awsElasticBlockStore(&mut self) -> &mut AWSElasticBlockStoreVolumeSource {
        self.awsElasticBlockStore.mut_or_insert_default()
    }

    // Take field
    pub fn take_awsElasticBlockStore(&mut self) -> AWSElasticBlockStoreVolumeSource {
        self.awsElasticBlockStore.take().unwrap_or_else(|| AWSElasticBlockStoreVolumeSource::new())
    }

    // optional .api.core.v1.GitRepoVolumeSource gitRepo = 5;

    pub fn gitRepo(&self) -> &GitRepoVolumeSource {
        self.gitRepo.as_ref().unwrap_or_else(|| <GitRepoVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_gitRepo(&mut self) {
        self.gitRepo.clear();
    }

    pub fn has_gitRepo(&self) -> bool {
        self.gitRepo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gitRepo(&mut self, v: GitRepoVolumeSource) {
        self.gitRepo = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gitRepo(&mut self) -> &mut GitRepoVolumeSource {
        self.gitRepo.mut_or_insert_default()
    }

    // Take field
    pub fn take_gitRepo(&mut self) -> GitRepoVolumeSource {
        self.gitRepo.take().unwrap_or_else(|| GitRepoVolumeSource::new())
    }

    // optional .api.core.v1.SecretVolumeSource secret = 6;

    pub fn secret(&self) -> &SecretVolumeSource {
        self.secret.as_ref().unwrap_or_else(|| <SecretVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_secret(&mut self) {
        self.secret.clear();
    }

    pub fn has_secret(&self) -> bool {
        self.secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secret(&mut self, v: SecretVolumeSource) {
        self.secret = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret(&mut self) -> &mut SecretVolumeSource {
        self.secret.mut_or_insert_default()
    }

    // Take field
    pub fn take_secret(&mut self) -> SecretVolumeSource {
        self.secret.take().unwrap_or_else(|| SecretVolumeSource::new())
    }

    // optional .api.core.v1.NFSVolumeSource nfs = 7;

    pub fn nfs(&self) -> &NFSVolumeSource {
        self.nfs.as_ref().unwrap_or_else(|| <NFSVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_nfs(&mut self) {
        self.nfs.clear();
    }

    pub fn has_nfs(&self) -> bool {
        self.nfs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nfs(&mut self, v: NFSVolumeSource) {
        self.nfs = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nfs(&mut self) -> &mut NFSVolumeSource {
        self.nfs.mut_or_insert_default()
    }

    // Take field
    pub fn take_nfs(&mut self) -> NFSVolumeSource {
        self.nfs.take().unwrap_or_else(|| NFSVolumeSource::new())
    }

    // optional .api.core.v1.ISCSIVolumeSource iscsi = 8;

    pub fn iscsi(&self) -> &ISCSIVolumeSource {
        self.iscsi.as_ref().unwrap_or_else(|| <ISCSIVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_iscsi(&mut self) {
        self.iscsi.clear();
    }

    pub fn has_iscsi(&self) -> bool {
        self.iscsi.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iscsi(&mut self, v: ISCSIVolumeSource) {
        self.iscsi = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iscsi(&mut self) -> &mut ISCSIVolumeSource {
        self.iscsi.mut_or_insert_default()
    }

    // Take field
    pub fn take_iscsi(&mut self) -> ISCSIVolumeSource {
        self.iscsi.take().unwrap_or_else(|| ISCSIVolumeSource::new())
    }

    // optional .api.core.v1.GlusterfsVolumeSource glusterfs = 9;

    pub fn glusterfs(&self) -> &GlusterfsVolumeSource {
        self.glusterfs.as_ref().unwrap_or_else(|| <GlusterfsVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_glusterfs(&mut self) {
        self.glusterfs.clear();
    }

    pub fn has_glusterfs(&self) -> bool {
        self.glusterfs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_glusterfs(&mut self, v: GlusterfsVolumeSource) {
        self.glusterfs = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_glusterfs(&mut self) -> &mut GlusterfsVolumeSource {
        self.glusterfs.mut_or_insert_default()
    }

    // Take field
    pub fn take_glusterfs(&mut self) -> GlusterfsVolumeSource {
        self.glusterfs.take().unwrap_or_else(|| GlusterfsVolumeSource::new())
    }

    // optional .api.core.v1.PersistentVolumeClaimVolumeSource persistentVolumeClaim = 10;

    pub fn persistentVolumeClaim(&self) -> &PersistentVolumeClaimVolumeSource {
        self.persistentVolumeClaim.as_ref().unwrap_or_else(|| <PersistentVolumeClaimVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_persistentVolumeClaim(&mut self) {
        self.persistentVolumeClaim.clear();
    }

    pub fn has_persistentVolumeClaim(&self) -> bool {
        self.persistentVolumeClaim.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persistentVolumeClaim(&mut self, v: PersistentVolumeClaimVolumeSource) {
        self.persistentVolumeClaim = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persistentVolumeClaim(&mut self) -> &mut PersistentVolumeClaimVolumeSource {
        self.persistentVolumeClaim.mut_or_insert_default()
    }

    // Take field
    pub fn take_persistentVolumeClaim(&mut self) -> PersistentVolumeClaimVolumeSource {
        self.persistentVolumeClaim.take().unwrap_or_else(|| PersistentVolumeClaimVolumeSource::new())
    }

    // optional .api.core.v1.RBDVolumeSource rbd = 11;

    pub fn rbd(&self) -> &RBDVolumeSource {
        self.rbd.as_ref().unwrap_or_else(|| <RBDVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_rbd(&mut self) {
        self.rbd.clear();
    }

    pub fn has_rbd(&self) -> bool {
        self.rbd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rbd(&mut self, v: RBDVolumeSource) {
        self.rbd = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rbd(&mut self) -> &mut RBDVolumeSource {
        self.rbd.mut_or_insert_default()
    }

    // Take field
    pub fn take_rbd(&mut self) -> RBDVolumeSource {
        self.rbd.take().unwrap_or_else(|| RBDVolumeSource::new())
    }

    // optional .api.core.v1.FlexVolumeSource flexVolume = 12;

    pub fn flexVolume(&self) -> &FlexVolumeSource {
        self.flexVolume.as_ref().unwrap_or_else(|| <FlexVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_flexVolume(&mut self) {
        self.flexVolume.clear();
    }

    pub fn has_flexVolume(&self) -> bool {
        self.flexVolume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flexVolume(&mut self, v: FlexVolumeSource) {
        self.flexVolume = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flexVolume(&mut self) -> &mut FlexVolumeSource {
        self.flexVolume.mut_or_insert_default()
    }

    // Take field
    pub fn take_flexVolume(&mut self) -> FlexVolumeSource {
        self.flexVolume.take().unwrap_or_else(|| FlexVolumeSource::new())
    }

    // optional .api.core.v1.CinderVolumeSource cinder = 13;

    pub fn cinder(&self) -> &CinderVolumeSource {
        self.cinder.as_ref().unwrap_or_else(|| <CinderVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_cinder(&mut self) {
        self.cinder.clear();
    }

    pub fn has_cinder(&self) -> bool {
        self.cinder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cinder(&mut self, v: CinderVolumeSource) {
        self.cinder = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cinder(&mut self) -> &mut CinderVolumeSource {
        self.cinder.mut_or_insert_default()
    }

    // Take field
    pub fn take_cinder(&mut self) -> CinderVolumeSource {
        self.cinder.take().unwrap_or_else(|| CinderVolumeSource::new())
    }

    // optional .api.core.v1.CephFSVolumeSource cephfs = 14;

    pub fn cephfs(&self) -> &CephFSVolumeSource {
        self.cephfs.as_ref().unwrap_or_else(|| <CephFSVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_cephfs(&mut self) {
        self.cephfs.clear();
    }

    pub fn has_cephfs(&self) -> bool {
        self.cephfs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cephfs(&mut self, v: CephFSVolumeSource) {
        self.cephfs = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cephfs(&mut self) -> &mut CephFSVolumeSource {
        self.cephfs.mut_or_insert_default()
    }

    // Take field
    pub fn take_cephfs(&mut self) -> CephFSVolumeSource {
        self.cephfs.take().unwrap_or_else(|| CephFSVolumeSource::new())
    }

    // optional .api.core.v1.FlockerVolumeSource flocker = 15;

    pub fn flocker(&self) -> &FlockerVolumeSource {
        self.flocker.as_ref().unwrap_or_else(|| <FlockerVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_flocker(&mut self) {
        self.flocker.clear();
    }

    pub fn has_flocker(&self) -> bool {
        self.flocker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flocker(&mut self, v: FlockerVolumeSource) {
        self.flocker = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flocker(&mut self) -> &mut FlockerVolumeSource {
        self.flocker.mut_or_insert_default()
    }

    // Take field
    pub fn take_flocker(&mut self) -> FlockerVolumeSource {
        self.flocker.take().unwrap_or_else(|| FlockerVolumeSource::new())
    }

    // optional .api.core.v1.DownwardAPIVolumeSource downwardAPI = 16;

    pub fn downwardAPI(&self) -> &DownwardAPIVolumeSource {
        self.downwardAPI.as_ref().unwrap_or_else(|| <DownwardAPIVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_downwardAPI(&mut self) {
        self.downwardAPI.clear();
    }

    pub fn has_downwardAPI(&self) -> bool {
        self.downwardAPI.is_some()
    }

    // Param is passed by value, moved
    pub fn set_downwardAPI(&mut self, v: DownwardAPIVolumeSource) {
        self.downwardAPI = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_downwardAPI(&mut self) -> &mut DownwardAPIVolumeSource {
        self.downwardAPI.mut_or_insert_default()
    }

    // Take field
    pub fn take_downwardAPI(&mut self) -> DownwardAPIVolumeSource {
        self.downwardAPI.take().unwrap_or_else(|| DownwardAPIVolumeSource::new())
    }

    // optional .api.core.v1.FCVolumeSource fc = 17;

    pub fn fc(&self) -> &FCVolumeSource {
        self.fc.as_ref().unwrap_or_else(|| <FCVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_fc(&mut self) {
        self.fc.clear();
    }

    pub fn has_fc(&self) -> bool {
        self.fc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fc(&mut self, v: FCVolumeSource) {
        self.fc = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fc(&mut self) -> &mut FCVolumeSource {
        self.fc.mut_or_insert_default()
    }

    // Take field
    pub fn take_fc(&mut self) -> FCVolumeSource {
        self.fc.take().unwrap_or_else(|| FCVolumeSource::new())
    }

    // optional .api.core.v1.AzureFileVolumeSource azureFile = 18;

    pub fn azureFile(&self) -> &AzureFileVolumeSource {
        self.azureFile.as_ref().unwrap_or_else(|| <AzureFileVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_azureFile(&mut self) {
        self.azureFile.clear();
    }

    pub fn has_azureFile(&self) -> bool {
        self.azureFile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_azureFile(&mut self, v: AzureFileVolumeSource) {
        self.azureFile = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_azureFile(&mut self) -> &mut AzureFileVolumeSource {
        self.azureFile.mut_or_insert_default()
    }

    // Take field
    pub fn take_azureFile(&mut self) -> AzureFileVolumeSource {
        self.azureFile.take().unwrap_or_else(|| AzureFileVolumeSource::new())
    }

    // optional .api.core.v1.ConfigMapVolumeSource configMap = 19;

    pub fn configMap(&self) -> &ConfigMapVolumeSource {
        self.configMap.as_ref().unwrap_or_else(|| <ConfigMapVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_configMap(&mut self) {
        self.configMap.clear();
    }

    pub fn has_configMap(&self) -> bool {
        self.configMap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configMap(&mut self, v: ConfigMapVolumeSource) {
        self.configMap = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configMap(&mut self) -> &mut ConfigMapVolumeSource {
        self.configMap.mut_or_insert_default()
    }

    // Take field
    pub fn take_configMap(&mut self) -> ConfigMapVolumeSource {
        self.configMap.take().unwrap_or_else(|| ConfigMapVolumeSource::new())
    }

    // optional .api.core.v1.VsphereVirtualDiskVolumeSource vsphereVolume = 20;

    pub fn vsphereVolume(&self) -> &VsphereVirtualDiskVolumeSource {
        self.vsphereVolume.as_ref().unwrap_or_else(|| <VsphereVirtualDiskVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_vsphereVolume(&mut self) {
        self.vsphereVolume.clear();
    }

    pub fn has_vsphereVolume(&self) -> bool {
        self.vsphereVolume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vsphereVolume(&mut self, v: VsphereVirtualDiskVolumeSource) {
        self.vsphereVolume = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vsphereVolume(&mut self) -> &mut VsphereVirtualDiskVolumeSource {
        self.vsphereVolume.mut_or_insert_default()
    }

    // Take field
    pub fn take_vsphereVolume(&mut self) -> VsphereVirtualDiskVolumeSource {
        self.vsphereVolume.take().unwrap_or_else(|| VsphereVirtualDiskVolumeSource::new())
    }

    // optional .api.core.v1.QuobyteVolumeSource quobyte = 21;

    pub fn quobyte(&self) -> &QuobyteVolumeSource {
        self.quobyte.as_ref().unwrap_or_else(|| <QuobyteVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_quobyte(&mut self) {
        self.quobyte.clear();
    }

    pub fn has_quobyte(&self) -> bool {
        self.quobyte.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quobyte(&mut self, v: QuobyteVolumeSource) {
        self.quobyte = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quobyte(&mut self) -> &mut QuobyteVolumeSource {
        self.quobyte.mut_or_insert_default()
    }

    // Take field
    pub fn take_quobyte(&mut self) -> QuobyteVolumeSource {
        self.quobyte.take().unwrap_or_else(|| QuobyteVolumeSource::new())
    }

    // optional .api.core.v1.AzureDiskVolumeSource azureDisk = 22;

    pub fn azureDisk(&self) -> &AzureDiskVolumeSource {
        self.azureDisk.as_ref().unwrap_or_else(|| <AzureDiskVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_azureDisk(&mut self) {
        self.azureDisk.clear();
    }

    pub fn has_azureDisk(&self) -> bool {
        self.azureDisk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_azureDisk(&mut self, v: AzureDiskVolumeSource) {
        self.azureDisk = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_azureDisk(&mut self) -> &mut AzureDiskVolumeSource {
        self.azureDisk.mut_or_insert_default()
    }

    // Take field
    pub fn take_azureDisk(&mut self) -> AzureDiskVolumeSource {
        self.azureDisk.take().unwrap_or_else(|| AzureDiskVolumeSource::new())
    }

    // optional .api.core.v1.PhotonPersistentDiskVolumeSource photonPersistentDisk = 23;

    pub fn photonPersistentDisk(&self) -> &PhotonPersistentDiskVolumeSource {
        self.photonPersistentDisk.as_ref().unwrap_or_else(|| <PhotonPersistentDiskVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_photonPersistentDisk(&mut self) {
        self.photonPersistentDisk.clear();
    }

    pub fn has_photonPersistentDisk(&self) -> bool {
        self.photonPersistentDisk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_photonPersistentDisk(&mut self, v: PhotonPersistentDiskVolumeSource) {
        self.photonPersistentDisk = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_photonPersistentDisk(&mut self) -> &mut PhotonPersistentDiskVolumeSource {
        self.photonPersistentDisk.mut_or_insert_default()
    }

    // Take field
    pub fn take_photonPersistentDisk(&mut self) -> PhotonPersistentDiskVolumeSource {
        self.photonPersistentDisk.take().unwrap_or_else(|| PhotonPersistentDiskVolumeSource::new())
    }

    // optional .api.core.v1.ProjectedVolumeSource projected = 26;

    pub fn projected(&self) -> &ProjectedVolumeSource {
        self.projected.as_ref().unwrap_or_else(|| <ProjectedVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_projected(&mut self) {
        self.projected.clear();
    }

    pub fn has_projected(&self) -> bool {
        self.projected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_projected(&mut self, v: ProjectedVolumeSource) {
        self.projected = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_projected(&mut self) -> &mut ProjectedVolumeSource {
        self.projected.mut_or_insert_default()
    }

    // Take field
    pub fn take_projected(&mut self) -> ProjectedVolumeSource {
        self.projected.take().unwrap_or_else(|| ProjectedVolumeSource::new())
    }

    // optional .api.core.v1.PortworxVolumeSource portworxVolume = 24;

    pub fn portworxVolume(&self) -> &PortworxVolumeSource {
        self.portworxVolume.as_ref().unwrap_or_else(|| <PortworxVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_portworxVolume(&mut self) {
        self.portworxVolume.clear();
    }

    pub fn has_portworxVolume(&self) -> bool {
        self.portworxVolume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_portworxVolume(&mut self, v: PortworxVolumeSource) {
        self.portworxVolume = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_portworxVolume(&mut self) -> &mut PortworxVolumeSource {
        self.portworxVolume.mut_or_insert_default()
    }

    // Take field
    pub fn take_portworxVolume(&mut self) -> PortworxVolumeSource {
        self.portworxVolume.take().unwrap_or_else(|| PortworxVolumeSource::new())
    }

    // optional .api.core.v1.ScaleIOVolumeSource scaleIO = 25;

    pub fn scaleIO(&self) -> &ScaleIOVolumeSource {
        self.scaleIO.as_ref().unwrap_or_else(|| <ScaleIOVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_scaleIO(&mut self) {
        self.scaleIO.clear();
    }

    pub fn has_scaleIO(&self) -> bool {
        self.scaleIO.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scaleIO(&mut self, v: ScaleIOVolumeSource) {
        self.scaleIO = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scaleIO(&mut self) -> &mut ScaleIOVolumeSource {
        self.scaleIO.mut_or_insert_default()
    }

    // Take field
    pub fn take_scaleIO(&mut self) -> ScaleIOVolumeSource {
        self.scaleIO.take().unwrap_or_else(|| ScaleIOVolumeSource::new())
    }

    // optional .api.core.v1.StorageOSVolumeSource storageos = 27;

    pub fn storageos(&self) -> &StorageOSVolumeSource {
        self.storageos.as_ref().unwrap_or_else(|| <StorageOSVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_storageos(&mut self) {
        self.storageos.clear();
    }

    pub fn has_storageos(&self) -> bool {
        self.storageos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageos(&mut self, v: StorageOSVolumeSource) {
        self.storageos = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageos(&mut self) -> &mut StorageOSVolumeSource {
        self.storageos.mut_or_insert_default()
    }

    // Take field
    pub fn take_storageos(&mut self) -> StorageOSVolumeSource {
        self.storageos.take().unwrap_or_else(|| StorageOSVolumeSource::new())
    }

    // optional .api.core.v1.CSIVolumeSource csi = 28;

    pub fn csi(&self) -> &CSIVolumeSource {
        self.csi.as_ref().unwrap_or_else(|| <CSIVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_csi(&mut self) {
        self.csi.clear();
    }

    pub fn has_csi(&self) -> bool {
        self.csi.is_some()
    }

    // Param is passed by value, moved
    pub fn set_csi(&mut self, v: CSIVolumeSource) {
        self.csi = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_csi(&mut self) -> &mut CSIVolumeSource {
        self.csi.mut_or_insert_default()
    }

    // Take field
    pub fn take_csi(&mut self) -> CSIVolumeSource {
        self.csi.take().unwrap_or_else(|| CSIVolumeSource::new())
    }

    // optional .api.core.v1.EphemeralVolumeSource ephemeral = 29;

    pub fn ephemeral(&self) -> &EphemeralVolumeSource {
        self.ephemeral.as_ref().unwrap_or_else(|| <EphemeralVolumeSource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_ephemeral(&mut self) {
        self.ephemeral.clear();
    }

    pub fn has_ephemeral(&self) -> bool {
        self.ephemeral.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeral(&mut self, v: EphemeralVolumeSource) {
        self.ephemeral = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ephemeral(&mut self) -> &mut EphemeralVolumeSource {
        self.ephemeral.mut_or_insert_default()
    }

    // Take field
    pub fn take_ephemeral(&mut self) -> EphemeralVolumeSource {
        self.ephemeral.take().unwrap_or_else(|| EphemeralVolumeSource::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(29);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HostPathVolumeSource>(
            "hostPath",
            |m: &VolumeSource| { &m.hostPath },
            |m: &mut VolumeSource| { &mut m.hostPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EmptyDirVolumeSource>(
            "emptyDir",
            |m: &VolumeSource| { &m.emptyDir },
            |m: &mut VolumeSource| { &mut m.emptyDir },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GCEPersistentDiskVolumeSource>(
            "gcePersistentDisk",
            |m: &VolumeSource| { &m.gcePersistentDisk },
            |m: &mut VolumeSource| { &mut m.gcePersistentDisk },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AWSElasticBlockStoreVolumeSource>(
            "awsElasticBlockStore",
            |m: &VolumeSource| { &m.awsElasticBlockStore },
            |m: &mut VolumeSource| { &mut m.awsElasticBlockStore },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GitRepoVolumeSource>(
            "gitRepo",
            |m: &VolumeSource| { &m.gitRepo },
            |m: &mut VolumeSource| { &mut m.gitRepo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SecretVolumeSource>(
            "secret",
            |m: &VolumeSource| { &m.secret },
            |m: &mut VolumeSource| { &mut m.secret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NFSVolumeSource>(
            "nfs",
            |m: &VolumeSource| { &m.nfs },
            |m: &mut VolumeSource| { &mut m.nfs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ISCSIVolumeSource>(
            "iscsi",
            |m: &VolumeSource| { &m.iscsi },
            |m: &mut VolumeSource| { &mut m.iscsi },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GlusterfsVolumeSource>(
            "glusterfs",
            |m: &VolumeSource| { &m.glusterfs },
            |m: &mut VolumeSource| { &mut m.glusterfs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PersistentVolumeClaimVolumeSource>(
            "persistentVolumeClaim",
            |m: &VolumeSource| { &m.persistentVolumeClaim },
            |m: &mut VolumeSource| { &mut m.persistentVolumeClaim },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RBDVolumeSource>(
            "rbd",
            |m: &VolumeSource| { &m.rbd },
            |m: &mut VolumeSource| { &mut m.rbd },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FlexVolumeSource>(
            "flexVolume",
            |m: &VolumeSource| { &m.flexVolume },
            |m: &mut VolumeSource| { &mut m.flexVolume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CinderVolumeSource>(
            "cinder",
            |m: &VolumeSource| { &m.cinder },
            |m: &mut VolumeSource| { &mut m.cinder },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CephFSVolumeSource>(
            "cephfs",
            |m: &VolumeSource| { &m.cephfs },
            |m: &mut VolumeSource| { &mut m.cephfs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FlockerVolumeSource>(
            "flocker",
            |m: &VolumeSource| { &m.flocker },
            |m: &mut VolumeSource| { &mut m.flocker },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DownwardAPIVolumeSource>(
            "downwardAPI",
            |m: &VolumeSource| { &m.downwardAPI },
            |m: &mut VolumeSource| { &mut m.downwardAPI },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FCVolumeSource>(
            "fc",
            |m: &VolumeSource| { &m.fc },
            |m: &mut VolumeSource| { &mut m.fc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AzureFileVolumeSource>(
            "azureFile",
            |m: &VolumeSource| { &m.azureFile },
            |m: &mut VolumeSource| { &mut m.azureFile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConfigMapVolumeSource>(
            "configMap",
            |m: &VolumeSource| { &m.configMap },
            |m: &mut VolumeSource| { &mut m.configMap },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VsphereVirtualDiskVolumeSource>(
            "vsphereVolume",
            |m: &VolumeSource| { &m.vsphereVolume },
            |m: &mut VolumeSource| { &mut m.vsphereVolume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, QuobyteVolumeSource>(
            "quobyte",
            |m: &VolumeSource| { &m.quobyte },
            |m: &mut VolumeSource| { &mut m.quobyte },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AzureDiskVolumeSource>(
            "azureDisk",
            |m: &VolumeSource| { &m.azureDisk },
            |m: &mut VolumeSource| { &mut m.azureDisk },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PhotonPersistentDiskVolumeSource>(
            "photonPersistentDisk",
            |m: &VolumeSource| { &m.photonPersistentDisk },
            |m: &mut VolumeSource| { &mut m.photonPersistentDisk },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProjectedVolumeSource>(
            "projected",
            |m: &VolumeSource| { &m.projected },
            |m: &mut VolumeSource| { &mut m.projected },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PortworxVolumeSource>(
            "portworxVolume",
            |m: &VolumeSource| { &m.portworxVolume },
            |m: &mut VolumeSource| { &mut m.portworxVolume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ScaleIOVolumeSource>(
            "scaleIO",
            |m: &VolumeSource| { &m.scaleIO },
            |m: &mut VolumeSource| { &mut m.scaleIO },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StorageOSVolumeSource>(
            "storageos",
            |m: &VolumeSource| { &m.storageos },
            |m: &mut VolumeSource| { &mut m.storageos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CSIVolumeSource>(
            "csi",
            |m: &VolumeSource| { &m.csi },
            |m: &mut VolumeSource| { &mut m.csi },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EphemeralVolumeSource>(
            "ephemeral",
            |m: &VolumeSource| { &m.ephemeral },
            |m: &mut VolumeSource| { &mut m.ephemeral },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VolumeSource>(
            "VolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VolumeSource {
    const NAME: &'static str = "VolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hostPath)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.emptyDir)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.gcePersistentDisk)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.awsElasticBlockStore)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.gitRepo)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.secret)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.nfs)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.iscsi)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.glusterfs)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.persistentVolumeClaim)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rbd)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.flexVolume)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cinder)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cephfs)?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.flocker)?;
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.downwardAPI)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fc)?;
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.azureFile)?;
                },
                154 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.configMap)?;
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vsphereVolume)?;
                },
                170 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quobyte)?;
                },
                178 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.azureDisk)?;
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.photonPersistentDisk)?;
                },
                210 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.projected)?;
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.portworxVolume)?;
                },
                202 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scaleIO)?;
                },
                218 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.storageos)?;
                },
                226 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.csi)?;
                },
                234 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ephemeral)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hostPath.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.emptyDir.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.gcePersistentDisk.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.awsElasticBlockStore.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.gitRepo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.secret.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.nfs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.iscsi.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.glusterfs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.persistentVolumeClaim.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rbd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.flexVolume.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cinder.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cephfs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.flocker.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.downwardAPI.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fc.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.azureFile.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.configMap.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.vsphereVolume.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quobyte.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.azureDisk.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.photonPersistentDisk.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.projected.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.portworxVolume.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scaleIO.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.storageos.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.csi.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ephemeral.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hostPath.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.emptyDir.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.gcePersistentDisk.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.awsElasticBlockStore.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.gitRepo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.secret.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.nfs.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.iscsi.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.glusterfs.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.persistentVolumeClaim.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.rbd.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.flexVolume.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.cinder.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.cephfs.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.flocker.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.downwardAPI.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.fc.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.azureFile.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.configMap.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.vsphereVolume.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.quobyte.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if let Some(v) = self.azureDisk.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.photonPersistentDisk.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.projected.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        if let Some(v) = self.portworxVolume.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.scaleIO.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        if let Some(v) = self.storageos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
        }
        if let Some(v) = self.csi.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
        }
        if let Some(v) = self.ephemeral.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(29, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VolumeSource {
        VolumeSource::new()
    }

    fn clear(&mut self) {
        self.hostPath.clear();
        self.emptyDir.clear();
        self.gcePersistentDisk.clear();
        self.awsElasticBlockStore.clear();
        self.gitRepo.clear();
        self.secret.clear();
        self.nfs.clear();
        self.iscsi.clear();
        self.glusterfs.clear();
        self.persistentVolumeClaim.clear();
        self.rbd.clear();
        self.flexVolume.clear();
        self.cinder.clear();
        self.cephfs.clear();
        self.flocker.clear();
        self.downwardAPI.clear();
        self.fc.clear();
        self.azureFile.clear();
        self.configMap.clear();
        self.vsphereVolume.clear();
        self.quobyte.clear();
        self.azureDisk.clear();
        self.photonPersistentDisk.clear();
        self.projected.clear();
        self.portworxVolume.clear();
        self.scaleIO.clear();
        self.storageos.clear();
        self.csi.clear();
        self.ephemeral.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VolumeSource {
        static instance: VolumeSource = VolumeSource {
            hostPath: ::protobuf::MessageField::none(),
            emptyDir: ::protobuf::MessageField::none(),
            gcePersistentDisk: ::protobuf::MessageField::none(),
            awsElasticBlockStore: ::protobuf::MessageField::none(),
            gitRepo: ::protobuf::MessageField::none(),
            secret: ::protobuf::MessageField::none(),
            nfs: ::protobuf::MessageField::none(),
            iscsi: ::protobuf::MessageField::none(),
            glusterfs: ::protobuf::MessageField::none(),
            persistentVolumeClaim: ::protobuf::MessageField::none(),
            rbd: ::protobuf::MessageField::none(),
            flexVolume: ::protobuf::MessageField::none(),
            cinder: ::protobuf::MessageField::none(),
            cephfs: ::protobuf::MessageField::none(),
            flocker: ::protobuf::MessageField::none(),
            downwardAPI: ::protobuf::MessageField::none(),
            fc: ::protobuf::MessageField::none(),
            azureFile: ::protobuf::MessageField::none(),
            configMap: ::protobuf::MessageField::none(),
            vsphereVolume: ::protobuf::MessageField::none(),
            quobyte: ::protobuf::MessageField::none(),
            azureDisk: ::protobuf::MessageField::none(),
            photonPersistentDisk: ::protobuf::MessageField::none(),
            projected: ::protobuf::MessageField::none(),
            portworxVolume: ::protobuf::MessageField::none(),
            scaleIO: ::protobuf::MessageField::none(),
            storageos: ::protobuf::MessageField::none(),
            csi: ::protobuf::MessageField::none(),
            ephemeral: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.VsphereVirtualDiskVolumeSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VsphereVirtualDiskVolumeSource {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.VsphereVirtualDiskVolumeSource.volumePath)
    pub volumePath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.VsphereVirtualDiskVolumeSource.fsType)
    pub fsType: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.VsphereVirtualDiskVolumeSource.storagePolicyName)
    pub storagePolicyName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.VsphereVirtualDiskVolumeSource.storagePolicyID)
    pub storagePolicyID: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.VsphereVirtualDiskVolumeSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VsphereVirtualDiskVolumeSource {
    fn default() -> &'a VsphereVirtualDiskVolumeSource {
        <VsphereVirtualDiskVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl VsphereVirtualDiskVolumeSource {
    pub fn new() -> VsphereVirtualDiskVolumeSource {
        ::std::default::Default::default()
    }

    // optional string volumePath = 1;

    pub fn volumePath(&self) -> &str {
        match self.volumePath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_volumePath(&mut self) {
        self.volumePath = ::std::option::Option::None;
    }

    pub fn has_volumePath(&self) -> bool {
        self.volumePath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumePath(&mut self, v: ::std::string::String) {
        self.volumePath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumePath(&mut self) -> &mut ::std::string::String {
        if self.volumePath.is_none() {
            self.volumePath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.volumePath.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumePath(&mut self) -> ::std::string::String {
        self.volumePath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 2;

    pub fn fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fsType(&mut self) {
        self.fsType = ::std::option::Option::None;
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string storagePolicyName = 3;

    pub fn storagePolicyName(&self) -> &str {
        match self.storagePolicyName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_storagePolicyName(&mut self) {
        self.storagePolicyName = ::std::option::Option::None;
    }

    pub fn has_storagePolicyName(&self) -> bool {
        self.storagePolicyName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storagePolicyName(&mut self, v: ::std::string::String) {
        self.storagePolicyName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storagePolicyName(&mut self) -> &mut ::std::string::String {
        if self.storagePolicyName.is_none() {
            self.storagePolicyName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.storagePolicyName.as_mut().unwrap()
    }

    // Take field
    pub fn take_storagePolicyName(&mut self) -> ::std::string::String {
        self.storagePolicyName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string storagePolicyID = 4;

    pub fn storagePolicyID(&self) -> &str {
        match self.storagePolicyID.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_storagePolicyID(&mut self) {
        self.storagePolicyID = ::std::option::Option::None;
    }

    pub fn has_storagePolicyID(&self) -> bool {
        self.storagePolicyID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storagePolicyID(&mut self, v: ::std::string::String) {
        self.storagePolicyID = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storagePolicyID(&mut self) -> &mut ::std::string::String {
        if self.storagePolicyID.is_none() {
            self.storagePolicyID = ::std::option::Option::Some(::std::string::String::new());
        }
        self.storagePolicyID.as_mut().unwrap()
    }

    // Take field
    pub fn take_storagePolicyID(&mut self) -> ::std::string::String {
        self.storagePolicyID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volumePath",
            |m: &VsphereVirtualDiskVolumeSource| { &m.volumePath },
            |m: &mut VsphereVirtualDiskVolumeSource| { &mut m.volumePath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fsType",
            |m: &VsphereVirtualDiskVolumeSource| { &m.fsType },
            |m: &mut VsphereVirtualDiskVolumeSource| { &mut m.fsType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "storagePolicyName",
            |m: &VsphereVirtualDiskVolumeSource| { &m.storagePolicyName },
            |m: &mut VsphereVirtualDiskVolumeSource| { &mut m.storagePolicyName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "storagePolicyID",
            |m: &VsphereVirtualDiskVolumeSource| { &m.storagePolicyID },
            |m: &mut VsphereVirtualDiskVolumeSource| { &mut m.storagePolicyID },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VsphereVirtualDiskVolumeSource>(
            "VsphereVirtualDiskVolumeSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VsphereVirtualDiskVolumeSource {
    const NAME: &'static str = "VsphereVirtualDiskVolumeSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.volumePath = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.fsType = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.storagePolicyName = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.storagePolicyID = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.volumePath.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.storagePolicyName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.storagePolicyID.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.volumePath.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.fsType.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.storagePolicyName.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.storagePolicyID.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VsphereVirtualDiskVolumeSource {
        VsphereVirtualDiskVolumeSource::new()
    }

    fn clear(&mut self) {
        self.volumePath = ::std::option::Option::None;
        self.fsType = ::std::option::Option::None;
        self.storagePolicyName = ::std::option::Option::None;
        self.storagePolicyID = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VsphereVirtualDiskVolumeSource {
        static instance: VsphereVirtualDiskVolumeSource = VsphereVirtualDiskVolumeSource {
            volumePath: ::std::option::Option::None,
            fsType: ::std::option::Option::None,
            storagePolicyName: ::std::option::Option::None,
            storagePolicyID: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VsphereVirtualDiskVolumeSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VsphereVirtualDiskVolumeSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VsphereVirtualDiskVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VsphereVirtualDiskVolumeSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.WeightedPodAffinityTerm)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WeightedPodAffinityTerm {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.WeightedPodAffinityTerm.weight)
    pub weight: ::std::option::Option<i32>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.core.v1.WeightedPodAffinityTerm.podAffinityTerm)
    pub podAffinityTerm: ::protobuf::MessageField<PodAffinityTerm>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.WeightedPodAffinityTerm.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WeightedPodAffinityTerm {
    fn default() -> &'a WeightedPodAffinityTerm {
        <WeightedPodAffinityTerm as ::protobuf::Message>::default_instance()
    }
}

impl WeightedPodAffinityTerm {
    pub fn new() -> WeightedPodAffinityTerm {
        ::std::default::Default::default()
    }

    // optional int32 weight = 1;

    pub fn weight(&self) -> i32 {
        self.weight.unwrap_or(0)
    }

    pub fn clear_weight(&mut self) {
        self.weight = ::std::option::Option::None;
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: i32) {
        self.weight = ::std::option::Option::Some(v);
    }

    // optional .api.core.v1.PodAffinityTerm podAffinityTerm = 2;

    pub fn podAffinityTerm(&self) -> &PodAffinityTerm {
        self.podAffinityTerm.as_ref().unwrap_or_else(|| <PodAffinityTerm as ::protobuf::Message>::default_instance())
    }

    pub fn clear_podAffinityTerm(&mut self) {
        self.podAffinityTerm.clear();
    }

    pub fn has_podAffinityTerm(&self) -> bool {
        self.podAffinityTerm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podAffinityTerm(&mut self, v: PodAffinityTerm) {
        self.podAffinityTerm = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podAffinityTerm(&mut self) -> &mut PodAffinityTerm {
        self.podAffinityTerm.mut_or_insert_default()
    }

    // Take field
    pub fn take_podAffinityTerm(&mut self) -> PodAffinityTerm {
        self.podAffinityTerm.take().unwrap_or_else(|| PodAffinityTerm::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "weight",
            |m: &WeightedPodAffinityTerm| { &m.weight },
            |m: &mut WeightedPodAffinityTerm| { &mut m.weight },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PodAffinityTerm>(
            "podAffinityTerm",
            |m: &WeightedPodAffinityTerm| { &m.podAffinityTerm },
            |m: &mut WeightedPodAffinityTerm| { &mut m.podAffinityTerm },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WeightedPodAffinityTerm>(
            "WeightedPodAffinityTerm",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WeightedPodAffinityTerm {
    const NAME: &'static str = "WeightedPodAffinityTerm";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.weight = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.podAffinityTerm)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.weight {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.podAffinityTerm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.weight {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.podAffinityTerm.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WeightedPodAffinityTerm {
        WeightedPodAffinityTerm::new()
    }

    fn clear(&mut self) {
        self.weight = ::std::option::Option::None;
        self.podAffinityTerm.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WeightedPodAffinityTerm {
        static instance: WeightedPodAffinityTerm = WeightedPodAffinityTerm {
            weight: ::std::option::Option::None,
            podAffinityTerm: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WeightedPodAffinityTerm {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WeightedPodAffinityTerm").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WeightedPodAffinityTerm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WeightedPodAffinityTerm {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.core.v1.WindowsSecurityContextOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WindowsSecurityContextOptions {
    // message fields
    // @@protoc_insertion_point(field:api.core.v1.WindowsSecurityContextOptions.gmsaCredentialSpecName)
    pub gmsaCredentialSpecName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.WindowsSecurityContextOptions.gmsaCredentialSpec)
    pub gmsaCredentialSpec: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.WindowsSecurityContextOptions.runAsUserName)
    pub runAsUserName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.core.v1.WindowsSecurityContextOptions.hostProcess)
    pub hostProcess: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.core.v1.WindowsSecurityContextOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WindowsSecurityContextOptions {
    fn default() -> &'a WindowsSecurityContextOptions {
        <WindowsSecurityContextOptions as ::protobuf::Message>::default_instance()
    }
}

impl WindowsSecurityContextOptions {
    pub fn new() -> WindowsSecurityContextOptions {
        ::std::default::Default::default()
    }

    // optional string gmsaCredentialSpecName = 1;

    pub fn gmsaCredentialSpecName(&self) -> &str {
        match self.gmsaCredentialSpecName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gmsaCredentialSpecName(&mut self) {
        self.gmsaCredentialSpecName = ::std::option::Option::None;
    }

    pub fn has_gmsaCredentialSpecName(&self) -> bool {
        self.gmsaCredentialSpecName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gmsaCredentialSpecName(&mut self, v: ::std::string::String) {
        self.gmsaCredentialSpecName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gmsaCredentialSpecName(&mut self) -> &mut ::std::string::String {
        if self.gmsaCredentialSpecName.is_none() {
            self.gmsaCredentialSpecName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gmsaCredentialSpecName.as_mut().unwrap()
    }

    // Take field
    pub fn take_gmsaCredentialSpecName(&mut self) -> ::std::string::String {
        self.gmsaCredentialSpecName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string gmsaCredentialSpec = 2;

    pub fn gmsaCredentialSpec(&self) -> &str {
        match self.gmsaCredentialSpec.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gmsaCredentialSpec(&mut self) {
        self.gmsaCredentialSpec = ::std::option::Option::None;
    }

    pub fn has_gmsaCredentialSpec(&self) -> bool {
        self.gmsaCredentialSpec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gmsaCredentialSpec(&mut self, v: ::std::string::String) {
        self.gmsaCredentialSpec = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gmsaCredentialSpec(&mut self) -> &mut ::std::string::String {
        if self.gmsaCredentialSpec.is_none() {
            self.gmsaCredentialSpec = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gmsaCredentialSpec.as_mut().unwrap()
    }

    // Take field
    pub fn take_gmsaCredentialSpec(&mut self) -> ::std::string::String {
        self.gmsaCredentialSpec.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string runAsUserName = 3;

    pub fn runAsUserName(&self) -> &str {
        match self.runAsUserName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_runAsUserName(&mut self) {
        self.runAsUserName = ::std::option::Option::None;
    }

    pub fn has_runAsUserName(&self) -> bool {
        self.runAsUserName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runAsUserName(&mut self, v: ::std::string::String) {
        self.runAsUserName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runAsUserName(&mut self) -> &mut ::std::string::String {
        if self.runAsUserName.is_none() {
            self.runAsUserName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.runAsUserName.as_mut().unwrap()
    }

    // Take field
    pub fn take_runAsUserName(&mut self) -> ::std::string::String {
        self.runAsUserName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool hostProcess = 4;

    pub fn hostProcess(&self) -> bool {
        self.hostProcess.unwrap_or(false)
    }

    pub fn clear_hostProcess(&mut self) {
        self.hostProcess = ::std::option::Option::None;
    }

    pub fn has_hostProcess(&self) -> bool {
        self.hostProcess.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostProcess(&mut self, v: bool) {
        self.hostProcess = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gmsaCredentialSpecName",
            |m: &WindowsSecurityContextOptions| { &m.gmsaCredentialSpecName },
            |m: &mut WindowsSecurityContextOptions| { &mut m.gmsaCredentialSpecName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gmsaCredentialSpec",
            |m: &WindowsSecurityContextOptions| { &m.gmsaCredentialSpec },
            |m: &mut WindowsSecurityContextOptions| { &mut m.gmsaCredentialSpec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "runAsUserName",
            |m: &WindowsSecurityContextOptions| { &m.runAsUserName },
            |m: &mut WindowsSecurityContextOptions| { &mut m.runAsUserName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hostProcess",
            |m: &WindowsSecurityContextOptions| { &m.hostProcess },
            |m: &mut WindowsSecurityContextOptions| { &mut m.hostProcess },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WindowsSecurityContextOptions>(
            "WindowsSecurityContextOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WindowsSecurityContextOptions {
    const NAME: &'static str = "WindowsSecurityContextOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.gmsaCredentialSpecName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.gmsaCredentialSpec = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.runAsUserName = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.hostProcess = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gmsaCredentialSpecName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.gmsaCredentialSpec.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.runAsUserName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.hostProcess {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gmsaCredentialSpecName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.gmsaCredentialSpec.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.runAsUserName.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.hostProcess {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WindowsSecurityContextOptions {
        WindowsSecurityContextOptions::new()
    }

    fn clear(&mut self) {
        self.gmsaCredentialSpecName = ::std::option::Option::None;
        self.gmsaCredentialSpec = ::std::option::Option::None;
        self.runAsUserName = ::std::option::Option::None;
        self.hostProcess = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WindowsSecurityContextOptions {
        static instance: WindowsSecurityContextOptions = WindowsSecurityContextOptions {
            gmsaCredentialSpecName: ::std::option::Option::None,
            gmsaCredentialSpec: ::std::option::Option::None,
            runAsUserName: ::std::option::Option::None,
            hostProcess: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WindowsSecurityContextOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WindowsSecurityContextOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WindowsSecurityContextOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WindowsSecurityContextOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1bapi/core/v1/generated.proto\x12\x0bapi.core.v1\x1a-apimachinery/pk\
    g/api/resource/generated.proto\x1a-apimachinery/pkg/apis/meta/v1/generat\
    ed.proto\x1a(apimachinery/pkg/runtime/generated.proto\x1a/apimachinery/p\
    kg/runtime/schema/generated.proto\x1a,apimachinery/pkg/util/intstr/gener\
    ated.proto\"\x90\x01\n\x20AWSElasticBlockStoreVolumeSource\x12\x1a\n\x08\
    volumeID\x18\x01\x20\x01(\tR\x08volumeID\x12\x16\n\x06fsType\x18\x02\x20\
    \x01(\tR\x06fsType\x12\x1c\n\tpartition\x18\x03\x20\x01(\x05R\tpartition\
    \x12\x1a\n\x08readOnly\x18\x04\x20\x01(\x08R\x08readOnly\"\xcd\x01\n\x08\
    Affinity\x12=\n\x0cnodeAffinity\x18\x01\x20\x01(\x0b2\x19.api.core.v1.No\
    deAffinityR\x0cnodeAffinity\x12:\n\x0bpodAffinity\x18\x02\x20\x01(\x0b2\
    \x18.api.core.v1.PodAffinityR\x0bpodAffinity\x12F\n\x0fpodAntiAffinity\
    \x18\x03\x20\x01(\x0b2\x1c.api.core.v1.PodAntiAffinityR\x0fpodAntiAffini\
    ty\"Q\n\x0fAppArmorProfile\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\
    \x12*\n\x10localhostProfile\x18\x02\x20\x01(\tR\x10localhostProfile\"D\n\
    \x0eAttachedVolume\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1e\
    \n\ndevicePath\x18\x02\x20\x01(\tR\ndevicePath\"X\n\tAvoidPods\x12K\n\
    \x0fpreferAvoidPods\x18\x01\x20\x03(\x0b2!.api.core.v1.PreferAvoidPodsEn\
    tryR\x0fpreferAvoidPods\"\xb7\x01\n\x15AzureDiskVolumeSource\x12\x1a\n\
    \x08diskName\x18\x01\x20\x01(\tR\x08diskName\x12\x18\n\x07diskURI\x18\
    \x02\x20\x01(\tR\x07diskURI\x12\x20\n\x0bcachingMode\x18\x03\x20\x01(\tR\
    \x0bcachingMode\x12\x16\n\x06fsType\x18\x04\x20\x01(\tR\x06fsType\x12\
    \x1a\n\x08readOnly\x18\x05\x20\x01(\x08R\x08readOnly\x12\x12\n\x04kind\
    \x18\x06\x20\x01(\tR\x04kind\"\xa5\x01\n\x1fAzureFilePersistentVolumeSou\
    rce\x12\x1e\n\nsecretName\x18\x01\x20\x01(\tR\nsecretName\x12\x1c\n\tsha\
    reName\x18\x02\x20\x01(\tR\tshareName\x12\x1a\n\x08readOnly\x18\x03\x20\
    \x01(\x08R\x08readOnly\x12(\n\x0fsecretNamespace\x18\x04\x20\x01(\tR\x0f\
    secretNamespace\"q\n\x15AzureFileVolumeSource\x12\x1e\n\nsecretName\x18\
    \x01\x20\x01(\tR\nsecretName\x12\x1c\n\tshareName\x18\x02\x20\x01(\tR\ts\
    hareName\x12\x1a\n\x08readOnly\x18\x03\x20\x01(\x08R\x08readOnly\"\x86\
    \x01\n\x07Binding\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachinery\
    .pkg.apis.meta.v1.ObjectMetaR\x08metadata\x124\n\x06target\x18\x02\x20\
    \x01(\x0b2\x1c.api.core.v1.ObjectReferenceR\x06target\"\xe4\x05\n\x19CSI\
    PersistentVolumeSource\x12\x16\n\x06driver\x18\x01\x20\x01(\tR\x06driver\
    \x12\"\n\x0cvolumeHandle\x18\x02\x20\x01(\tR\x0cvolumeHandle\x12\x1a\n\
    \x08readOnly\x18\x03\x20\x01(\x08R\x08readOnly\x12\x16\n\x06fsType\x18\
    \x04\x20\x01(\tR\x06fsType\x12h\n\x10volumeAttributes\x18\x05\x20\x03(\
    \x0b2<.api.core.v1.CSIPersistentVolumeSource.VolumeAttributesEntryR\x10v\
    olumeAttributes\x12\\\n\x1acontrollerPublishSecretRef\x18\x06\x20\x01(\
    \x0b2\x1c.api.core.v1.SecretReferenceR\x1acontrollerPublishSecretRef\x12\
    L\n\x12nodeStageSecretRef\x18\x07\x20\x01(\x0b2\x1c.api.core.v1.SecretRe\
    ferenceR\x12nodeStageSecretRef\x12P\n\x14nodePublishSecretRef\x18\x08\
    \x20\x01(\x0b2\x1c.api.core.v1.SecretReferenceR\x14nodePublishSecretRef\
    \x12Z\n\x19controllerExpandSecretRef\x18\t\x20\x01(\x0b2\x1c.api.core.v1\
    .SecretReferenceR\x19controllerExpandSecretRef\x12N\n\x13nodeExpandSecre\
    tRef\x18\n\x20\x01(\x0b2\x1c.api.core.v1.SecretReferenceR\x13nodeExpandS\
    ecretRef\x1aC\n\x15VolumeAttributesEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\
    \x01\"\xd9\x02\n\x0fCSIVolumeSource\x12\x16\n\x06driver\x18\x01\x20\x01(\
    \tR\x06driver\x12\x1a\n\x08readOnly\x18\x02\x20\x01(\x08R\x08readOnly\
    \x12\x16\n\x06fsType\x18\x03\x20\x01(\tR\x06fsType\x12^\n\x10volumeAttri\
    butes\x18\x04\x20\x03(\x0b22.api.core.v1.CSIVolumeSource.VolumeAttribute\
    sEntryR\x10volumeAttributes\x12U\n\x14nodePublishSecretRef\x18\x05\x20\
    \x01(\x0b2!.api.core.v1.LocalObjectReferenceR\x14nodePublishSecretRef\
    \x1aC\n\x15VolumeAttributesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"4\n\
    \x0cCapabilities\x12\x10\n\x03add\x18\x01\x20\x03(\tR\x03add\x12\x12\n\
    \x04drop\x18\x02\x20\x03(\tR\x04drop\"\xda\x01\n\x1cCephFSPersistentVolu\
    meSource\x12\x1a\n\x08monitors\x18\x01\x20\x03(\tR\x08monitors\x12\x12\n\
    \x04path\x18\x02\x20\x01(\tR\x04path\x12\x12\n\x04user\x18\x03\x20\x01(\
    \tR\x04user\x12\x1e\n\nsecretFile\x18\x04\x20\x01(\tR\nsecretFile\x12:\n\
    \tsecretRef\x18\x05\x20\x01(\x0b2\x1c.api.core.v1.SecretReferenceR\tsecr\
    etRef\x12\x1a\n\x08readOnly\x18\x06\x20\x01(\x08R\x08readOnly\"\xd5\x01\
    \n\x12CephFSVolumeSource\x12\x1a\n\x08monitors\x18\x01\x20\x03(\tR\x08mo\
    nitors\x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04path\x12\x12\n\x04user\
    \x18\x03\x20\x01(\tR\x04user\x12\x1e\n\nsecretFile\x18\x04\x20\x01(\tR\n\
    secretFile\x12?\n\tsecretRef\x18\x05\x20\x01(\x0b2!.api.core.v1.LocalObj\
    ectReferenceR\tsecretRef\x12\x1a\n\x08readOnly\x18\x06\x20\x01(\x08R\x08\
    readOnly\"\xaa\x01\n\x1cCinderPersistentVolumeSource\x12\x1a\n\x08volume\
    ID\x18\x01\x20\x01(\tR\x08volumeID\x12\x16\n\x06fsType\x18\x02\x20\x01(\
    \tR\x06fsType\x12\x1a\n\x08readOnly\x18\x03\x20\x01(\x08R\x08readOnly\
    \x12:\n\tsecretRef\x18\x04\x20\x01(\x0b2\x1c.api.core.v1.SecretReference\
    R\tsecretRef\"\xa5\x01\n\x12CinderVolumeSource\x12\x1a\n\x08volumeID\x18\
    \x01\x20\x01(\tR\x08volumeID\x12\x16\n\x06fsType\x18\x02\x20\x01(\tR\x06\
    fsType\x12\x1a\n\x08readOnly\x18\x03\x20\x01(\x08R\x08readOnly\x12?\n\ts\
    ecretRef\x18\x04\x20\x01(\x0b2!.api.core.v1.LocalObjectReferenceR\tsecre\
    tRef\"y\n\x0bClaimSource\x12,\n\x11resourceClaimName\x18\x01\x20\x01(\tR\
    \x11resourceClaimName\x12<\n\x19resourceClaimTemplateName\x18\x02\x20\
    \x01(\tR\x19resourceClaimTemplateName\"8\n\x0eClientIPConfig\x12&\n\x0et\
    imeoutSeconds\x18\x01\x20\x01(\x05R\x0etimeoutSeconds\"\xd6\x01\n\x1cClu\
    sterTrustBundleProjection\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12\x1e\n\nsignerName\x18\x02\x20\x01(\tR\nsignerName\x12R\n\rlabelSele\
    ctor\x18\x03\x20\x01(\x0b2,.apimachinery.pkg.apis.meta.v1.LabelSelectorR\
    \rlabelSelector\x12\x1a\n\x08optional\x18\x05\x20\x01(\x08R\x08optional\
    \x12\x12\n\x04path\x18\x04\x20\x01(\tR\x04path\"p\n\x12ComponentConditio\
    n\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12\x16\n\x06status\x18\
    \x02\x20\x01(\tR\x06status\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07m\
    essage\x12\x14\n\x05error\x18\x04\x20\x01(\tR\x05error\"\x99\x01\n\x0fCo\
    mponentStatus\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachinery.pkg\
    .apis.meta.v1.ObjectMetaR\x08metadata\x12?\n\nconditions\x18\x02\x20\x03\
    (\x0b2\x1f.api.core.v1.ComponentConditionR\nconditions\"\x8e\x01\n\x13Co\
    mponentStatusList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery\
    .pkg.apis.meta.v1.ListMetaR\x08metadata\x122\n\x05items\x18\x02\x20\x03(\
    \x0b2\x1c.api.core.v1.ComponentStatusR\x05items\"\xe6\x02\n\tConfigMap\
    \x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1\
    .ObjectMetaR\x08metadata\x12\x1c\n\timmutable\x18\x04\x20\x01(\x08R\timm\
    utable\x124\n\x04data\x18\x02\x20\x03(\x0b2\x20.api.core.v1.ConfigMap.Da\
    taEntryR\x04data\x12F\n\nbinaryData\x18\x03\x20\x03(\x0b2&.api.core.v1.C\
    onfigMap.BinaryDataEntryR\nbinaryData\x1a7\n\tDataEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\x1a=\n\x0fBinaryDataEntry\x12\x10\n\x03key\x18\x01\x20\x01\
    (\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\x05value:\x028\x01\
    \"\x87\x01\n\x12ConfigMapEnvSource\x12U\n\x14localObjectReference\x18\
    \x01\x20\x01(\x0b2!.api.core.v1.LocalObjectReferenceR\x14localObjectRefe\
    rence\x12\x1a\n\x08optional\x18\x02\x20\x01(\x08R\x08optional\"\x9b\x01\
    \n\x14ConfigMapKeySelector\x12U\n\x14localObjectReference\x18\x01\x20\
    \x01(\x0b2!.api.core.v1.LocalObjectReferenceR\x14localObjectReference\
    \x12\x10\n\x03key\x18\x02\x20\x01(\tR\x03key\x12\x1a\n\x08optional\x18\
    \x03\x20\x01(\x08R\x08optional\"\x82\x01\n\rConfigMapList\x12C\n\x08meta\
    data\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMetaR\x08m\
    etadata\x12,\n\x05items\x18\x02\x20\x03(\x0b2\x16.api.core.v1.ConfigMapR\
    \x05items\"\xb5\x01\n\x19ConfigMapNodeConfigSource\x12\x1c\n\tnamespace\
    \x18\x01\x20\x01(\tR\tnamespace\x12\x12\n\x04name\x18\x02\x20\x01(\tR\
    \x04name\x12\x10\n\x03uid\x18\x03\x20\x01(\tR\x03uid\x12(\n\x0fresourceV\
    ersion\x18\x04\x20\x01(\tR\x0fresourceVersion\x12*\n\x10kubeletConfigKey\
    \x18\x05\x20\x01(\tR\x10kubeletConfigKey\"\xb6\x01\n\x13ConfigMapProject\
    ion\x12U\n\x14localObjectReference\x18\x01\x20\x01(\x0b2!.api.core.v1.Lo\
    calObjectReferenceR\x14localObjectReference\x12,\n\x05items\x18\x02\x20\
    \x03(\x0b2\x16.api.core.v1.KeyToPathR\x05items\x12\x1a\n\x08optional\x18\
    \x04\x20\x01(\x08R\x08optional\"\xda\x01\n\x15ConfigMapVolumeSource\x12U\
    \n\x14localObjectReference\x18\x01\x20\x01(\x0b2!.api.core.v1.LocalObjec\
    tReferenceR\x14localObjectReference\x12,\n\x05items\x18\x02\x20\x03(\x0b\
    2\x16.api.core.v1.KeyToPathR\x05items\x12\x20\n\x0bdefaultMode\x18\x03\
    \x20\x01(\x05R\x0bdefaultMode\x12\x1a\n\x08optional\x18\x04\x20\x01(\x08\
    R\x08optional\"\xd0\x08\n\tContainer\x12\x12\n\x04name\x18\x01\x20\x01(\
    \tR\x04name\x12\x14\n\x05image\x18\x02\x20\x01(\tR\x05image\x12\x18\n\
    \x07command\x18\x03\x20\x03(\tR\x07command\x12\x12\n\x04args\x18\x04\x20\
    \x03(\tR\x04args\x12\x1e\n\nworkingDir\x18\x05\x20\x01(\tR\nworkingDir\
    \x120\n\x05ports\x18\x06\x20\x03(\x0b2\x1a.api.core.v1.ContainerPortR\
    \x05ports\x124\n\x07envFrom\x18\x13\x20\x03(\x0b2\x1a.api.core.v1.EnvFro\
    mSourceR\x07envFrom\x12%\n\x03env\x18\x07\x20\x03(\x0b2\x13.api.core.v1.\
    EnvVarR\x03env\x12?\n\tresources\x18\x08\x20\x01(\x0b2!.api.core.v1.Reso\
    urceRequirementsR\tresources\x12F\n\x0cresizePolicy\x18\x17\x20\x03(\x0b\
    2\".api.core.v1.ContainerResizePolicyR\x0cresizePolicy\x12$\n\rrestartPo\
    licy\x18\x18\x20\x01(\tR\rrestartPolicy\x12<\n\x0cvolumeMounts\x18\t\x20\
    \x03(\x0b2\x18.api.core.v1.VolumeMountR\x0cvolumeMounts\x12?\n\rvolumeDe\
    vices\x18\x15\x20\x03(\x0b2\x19.api.core.v1.VolumeDeviceR\rvolumeDevices\
    \x128\n\rlivenessProbe\x18\n\x20\x01(\x0b2\x12.api.core.v1.ProbeR\rliven\
    essProbe\x12:\n\x0ereadinessProbe\x18\x0b\x20\x01(\x0b2\x12.api.core.v1.\
    ProbeR\x0ereadinessProbe\x126\n\x0cstartupProbe\x18\x16\x20\x01(\x0b2\
    \x12.api.core.v1.ProbeR\x0cstartupProbe\x124\n\tlifecycle\x18\x0c\x20\
    \x01(\x0b2\x16.api.core.v1.LifecycleR\tlifecycle\x126\n\x16terminationMe\
    ssagePath\x18\r\x20\x01(\tR\x16terminationMessagePath\x12:\n\x18terminat\
    ionMessagePolicy\x18\x14\x20\x01(\tR\x18terminationMessagePolicy\x12(\n\
    \x0fimagePullPolicy\x18\x0e\x20\x01(\tR\x0fimagePullPolicy\x12F\n\x0fsec\
    urityContext\x18\x0f\x20\x01(\x0b2\x1c.api.core.v1.SecurityContextR\x0fs\
    ecurityContext\x12\x14\n\x05stdin\x18\x10\x20\x01(\x08R\x05stdin\x12\x1c\
    \n\tstdinOnce\x18\x11\x20\x01(\x08R\tstdinOnce\x12\x10\n\x03tty\x18\x12\
    \x20\x01(\x08R\x03tty\"D\n\x0eContainerImage\x12\x14\n\x05names\x18\x01\
    \x20\x03(\tR\x05names\x12\x1c\n\tsizeBytes\x18\x02\x20\x01(\x03R\tsizeBy\
    tes\"\x99\x01\n\rContainerPort\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04\
    name\x12\x1a\n\x08hostPort\x18\x02\x20\x01(\x05R\x08hostPort\x12$\n\rcon\
    tainerPort\x18\x03\x20\x01(\x05R\rcontainerPort\x12\x1a\n\x08protocol\
    \x18\x04\x20\x01(\tR\x08protocol\x12\x16\n\x06hostIP\x18\x05\x20\x01(\tR\
    \x06hostIP\"a\n\x15ContainerResizePolicy\x12\"\n\x0cresourceName\x18\x01\
    \x20\x01(\tR\x0cresourceName\x12$\n\rrestartPolicy\x18\x02\x20\x01(\tR\r\
    restartPolicy\"\xd3\x01\n\x0eContainerState\x12<\n\x07waiting\x18\x01\
    \x20\x01(\x0b2\".api.core.v1.ContainerStateWaitingR\x07waiting\x12<\n\
    \x07running\x18\x02\x20\x01(\x0b2\".api.core.v1.ContainerStateRunningR\
    \x07running\x12E\n\nterminated\x18\x03\x20\x01(\x0b2%.api.core.v1.Contai\
    nerStateTerminatedR\nterminated\"Z\n\x15ContainerStateRunning\x12A\n\tst\
    artedAt\x18\x01\x20\x01(\x0b2#.apimachinery.pkg.apis.meta.v1.TimeR\tstar\
    tedAt\"\xaa\x02\n\x18ContainerStateTerminated\x12\x1a\n\x08exitCode\x18\
    \x01\x20\x01(\x05R\x08exitCode\x12\x16\n\x06signal\x18\x02\x20\x01(\x05R\
    \x06signal\x12\x16\n\x06reason\x18\x03\x20\x01(\tR\x06reason\x12\x18\n\
    \x07message\x18\x04\x20\x01(\tR\x07message\x12A\n\tstartedAt\x18\x05\x20\
    \x01(\x0b2#.apimachinery.pkg.apis.meta.v1.TimeR\tstartedAt\x12C\n\nfinis\
    hedAt\x18\x06\x20\x01(\x0b2#.apimachinery.pkg.apis.meta.v1.TimeR\nfinish\
    edAt\x12\x20\n\x0bcontainerID\x18\x07\x20\x01(\tR\x0bcontainerID\"I\n\
    \x15ContainerStateWaiting\x12\x16\n\x06reason\x18\x01\x20\x01(\tR\x06rea\
    son\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\"\x94\x05\n\x0fC\
    ontainerStatus\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x121\n\x05s\
    tate\x18\x02\x20\x01(\x0b2\x1b.api.core.v1.ContainerStateR\x05state\x129\
    \n\tlastState\x18\x03\x20\x01(\x0b2\x1b.api.core.v1.ContainerStateR\tlas\
    tState\x12\x14\n\x05ready\x18\x04\x20\x01(\x08R\x05ready\x12\"\n\x0crest\
    artCount\x18\x05\x20\x01(\x05R\x0crestartCount\x12\x14\n\x05image\x18\
    \x06\x20\x01(\tR\x05image\x12\x18\n\x07imageID\x18\x07\x20\x01(\tR\x07im\
    ageID\x12\x20\n\x0bcontainerID\x18\x08\x20\x01(\tR\x0bcontainerID\x12\
    \x18\n\x07started\x18\t\x20\x01(\x08R\x07started\x12d\n\x12allocatedReso\
    urces\x18\n\x20\x03(\x0b24.api.core.v1.ContainerStatus.AllocatedResource\
    sEntryR\x12allocatedResources\x12?\n\tresources\x18\x0b\x20\x01(\x0b2!.a\
    pi.core.v1.ResourceRequirementsR\tresources\x12B\n\x0cvolumeMounts\x18\
    \x0c\x20\x03(\x0b2\x1e.api.core.v1.VolumeMountStatusR\x0cvolumeMounts\
    \x1an\n\x17AllocatedResourcesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12=\n\x05value\x18\x02\x20\x01(\x0b2'.apimachinery.pkg.api.reso\
    urce.QuantityR\x05value:\x028\x01\"$\n\x0eDaemonEndpoint\x12\x12\n\x04Po\
    rt\x18\x01\x20\x01(\x05R\x04Port\"Q\n\x15DownwardAPIProjection\x128\n\
    \x05items\x18\x01\x20\x03(\x0b2\".api.core.v1.DownwardAPIVolumeFileR\x05\
    items\"\xcd\x01\n\x15DownwardAPIVolumeFile\x12\x12\n\x04path\x18\x01\x20\
    \x01(\tR\x04path\x12<\n\x08fieldRef\x18\x02\x20\x01(\x0b2\x20.api.core.v\
    1.ObjectFieldSelectorR\x08fieldRef\x12N\n\x10resourceFieldRef\x18\x03\
    \x20\x01(\x0b2\".api.core.v1.ResourceFieldSelectorR\x10resourceFieldRef\
    \x12\x12\n\x04mode\x18\x04\x20\x01(\x05R\x04mode\"u\n\x17DownwardAPIVolu\
    meSource\x128\n\x05items\x18\x01\x20\x03(\x0b2\".api.core.v1.DownwardAPI\
    VolumeFileR\x05items\x12\x20\n\x0bdefaultMode\x18\x02\x20\x01(\x05R\x0bd\
    efaultMode\"u\n\x14EmptyDirVolumeSource\x12\x16\n\x06medium\x18\x01\x20\
    \x01(\tR\x06medium\x12E\n\tsizeLimit\x18\x02\x20\x01(\x0b2'.apimachinery\
    .pkg.api.resource.QuantityR\tsizeLimit\"\x95\x01\n\x0fEndpointAddress\
    \x12\x0e\n\x02ip\x18\x01\x20\x01(\tR\x02ip\x12\x1a\n\x08hostname\x18\x03\
    \x20\x01(\tR\x08hostname\x12\x1a\n\x08nodeName\x18\x04\x20\x01(\tR\x08no\
    deName\x12:\n\ttargetRef\x18\x02\x20\x01(\x0b2\x1c.api.core.v1.ObjectRef\
    erenceR\ttargetRef\"t\n\x0cEndpointPort\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12\x12\n\x04port\x18\x02\x20\x01(\x05R\x04port\x12\x1a\
    \n\x08protocol\x18\x03\x20\x01(\tR\x08protocol\x12\x20\n\x0bappProtocol\
    \x18\x04\x20\x01(\tR\x0bappProtocol\"\xc9\x01\n\x0eEndpointSubset\x12:\n\
    \taddresses\x18\x01\x20\x03(\x0b2\x1c.api.core.v1.EndpointAddressR\taddr\
    esses\x12J\n\x11notReadyAddresses\x18\x02\x20\x03(\x0b2\x1c.api.core.v1.\
    EndpointAddressR\x11notReadyAddresses\x12/\n\x05ports\x18\x03\x20\x03(\
    \x0b2\x19.api.core.v1.EndpointPortR\x05ports\"\x89\x01\n\tEndpoints\x12E\
    \n\x08metadata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.Obje\
    ctMetaR\x08metadata\x125\n\x07subsets\x18\x02\x20\x03(\x0b2\x1b.api.core\
    .v1.EndpointSubsetR\x07subsets\"\x82\x01\n\rEndpointsList\x12C\n\x08meta\
    data\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMetaR\x08m\
    etadata\x12,\n\x05items\x18\x02\x20\x03(\x0b2\x16.api.core.v1.EndpointsR\
    \x05items\"\xa8\x01\n\rEnvFromSource\x12\x16\n\x06prefix\x18\x01\x20\x01\
    (\tR\x06prefix\x12C\n\x0cconfigMapRef\x18\x02\x20\x01(\x0b2\x1f.api.core\
    .v1.ConfigMapEnvSourceR\x0cconfigMapRef\x12:\n\tsecretRef\x18\x03\x20\
    \x01(\x0b2\x1c.api.core.v1.SecretEnvSourceR\tsecretRef\"k\n\x06EnvVar\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value\x127\n\tvalueFrom\x18\x03\x20\x01(\x0b2\x19.ap\
    i.core.v1.EnvVarSourceR\tvalueFrom\"\xad\x02\n\x0cEnvVarSource\x12<\n\
    \x08fieldRef\x18\x01\x20\x01(\x0b2\x20.api.core.v1.ObjectFieldSelectorR\
    \x08fieldRef\x12N\n\x10resourceFieldRef\x18\x02\x20\x01(\x0b2\".api.core\
    .v1.ResourceFieldSelectorR\x10resourceFieldRef\x12K\n\x0fconfigMapKeyRef\
    \x18\x03\x20\x01(\x0b2!.api.core.v1.ConfigMapKeySelectorR\x0fconfigMapKe\
    yRef\x12B\n\x0csecretKeyRef\x18\x04\x20\x01(\x0b2\x1e.api.core.v1.Secret\
    KeySelectorR\x0csecretKeyRef\"\xa9\x01\n\x12EphemeralContainer\x12a\n\
    \x18ephemeralContainerCommon\x18\x01\x20\x01(\x0b2%.api.core.v1.Ephemera\
    lContainerCommonR\x18ephemeralContainerCommon\x120\n\x13targetContainerN\
    ame\x18\x02\x20\x01(\tR\x13targetContainerName\"\xdf\x08\n\x18EphemeralC\
    ontainerCommon\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\
    \x05image\x18\x02\x20\x01(\tR\x05image\x12\x18\n\x07command\x18\x03\x20\
    \x03(\tR\x07command\x12\x12\n\x04args\x18\x04\x20\x03(\tR\x04args\x12\
    \x1e\n\nworkingDir\x18\x05\x20\x01(\tR\nworkingDir\x120\n\x05ports\x18\
    \x06\x20\x03(\x0b2\x1a.api.core.v1.ContainerPortR\x05ports\x124\n\x07env\
    From\x18\x13\x20\x03(\x0b2\x1a.api.core.v1.EnvFromSourceR\x07envFrom\x12\
    %\n\x03env\x18\x07\x20\x03(\x0b2\x13.api.core.v1.EnvVarR\x03env\x12?\n\t\
    resources\x18\x08\x20\x01(\x0b2!.api.core.v1.ResourceRequirementsR\treso\
    urces\x12F\n\x0cresizePolicy\x18\x17\x20\x03(\x0b2\".api.core.v1.Contain\
    erResizePolicyR\x0cresizePolicy\x12$\n\rrestartPolicy\x18\x18\x20\x01(\t\
    R\rrestartPolicy\x12<\n\x0cvolumeMounts\x18\t\x20\x03(\x0b2\x18.api.core\
    .v1.VolumeMountR\x0cvolumeMounts\x12?\n\rvolumeDevices\x18\x15\x20\x03(\
    \x0b2\x19.api.core.v1.VolumeDeviceR\rvolumeDevices\x128\n\rlivenessProbe\
    \x18\n\x20\x01(\x0b2\x12.api.core.v1.ProbeR\rlivenessProbe\x12:\n\x0erea\
    dinessProbe\x18\x0b\x20\x01(\x0b2\x12.api.core.v1.ProbeR\x0ereadinessPro\
    be\x126\n\x0cstartupProbe\x18\x16\x20\x01(\x0b2\x12.api.core.v1.ProbeR\
    \x0cstartupProbe\x124\n\tlifecycle\x18\x0c\x20\x01(\x0b2\x16.api.core.v1\
    .LifecycleR\tlifecycle\x126\n\x16terminationMessagePath\x18\r\x20\x01(\t\
    R\x16terminationMessagePath\x12:\n\x18terminationMessagePolicy\x18\x14\
    \x20\x01(\tR\x18terminationMessagePolicy\x12(\n\x0fimagePullPolicy\x18\
    \x0e\x20\x01(\tR\x0fimagePullPolicy\x12F\n\x0fsecurityContext\x18\x0f\
    \x20\x01(\x0b2\x1c.api.core.v1.SecurityContextR\x0fsecurityContext\x12\
    \x14\n\x05stdin\x18\x10\x20\x01(\x08R\x05stdin\x12\x1c\n\tstdinOnce\x18\
    \x11\x20\x01(\x08R\tstdinOnce\x12\x10\n\x03tty\x18\x12\x20\x01(\x08R\x03\
    tty\"u\n\x15EphemeralVolumeSource\x12\\\n\x13volumeClaimTemplate\x18\x01\
    \x20\x01(\x0b2*.api.core.v1.PersistentVolumeClaimTemplateR\x13volumeClai\
    mTemplate\"\xe2\x05\n\x05Event\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2)\
    .apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12D\n\x0einvolve\
    dObject\x18\x02\x20\x01(\x0b2\x1c.api.core.v1.ObjectReferenceR\x0einvolv\
    edObject\x12\x16\n\x06reason\x18\x03\x20\x01(\tR\x06reason\x12\x18\n\x07\
    message\x18\x04\x20\x01(\tR\x07message\x120\n\x06source\x18\x05\x20\x01(\
    \x0b2\x18.api.core.v1.EventSourceR\x06source\x12K\n\x0efirstTimestamp\
    \x18\x06\x20\x01(\x0b2#.apimachinery.pkg.apis.meta.v1.TimeR\x0efirstTime\
    stamp\x12I\n\rlastTimestamp\x18\x07\x20\x01(\x0b2#.apimachinery.pkg.apis\
    .meta.v1.TimeR\rlastTimestamp\x12\x14\n\x05count\x18\x08\x20\x01(\x05R\
    \x05count\x12\x12\n\x04type\x18\t\x20\x01(\tR\x04type\x12F\n\teventTime\
    \x18\n\x20\x01(\x0b2(.apimachinery.pkg.apis.meta.v1.MicroTimeR\teventTim\
    e\x120\n\x06series\x18\x0b\x20\x01(\x0b2\x18.api.core.v1.EventSeriesR\
    \x06series\x12\x16\n\x06action\x18\x0c\x20\x01(\tR\x06action\x126\n\x07r\
    elated\x18\r\x20\x01(\x0b2\x1c.api.core.v1.ObjectReferenceR\x07related\
    \x12.\n\x12reportingComponent\x18\x0e\x20\x01(\tR\x12reportingComponent\
    \x12,\n\x11reportingInstance\x18\x0f\x20\x01(\tR\x11reportingInstance\"z\
    \n\tEventList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg\
    .apis.meta.v1.ListMetaR\x08metadata\x12(\n\x05items\x18\x02\x20\x03(\x0b\
    2\x12.api.core.v1.EventR\x05items\"y\n\x0bEventSeries\x12\x14\n\x05count\
    \x18\x01\x20\x01(\x05R\x05count\x12T\n\x10lastObservedTime\x18\x02\x20\
    \x01(\x0b2(.apimachinery.pkg.apis.meta.v1.MicroTimeR\x10lastObservedTime\
    \"?\n\x0bEventSource\x12\x1c\n\tcomponent\x18\x01\x20\x01(\tR\tcomponent\
    \x12\x12\n\x04host\x18\x02\x20\x01(\tR\x04host\"&\n\nExecAction\x12\x18\
    \n\x07command\x18\x01\x20\x03(\tR\x07command\"\x8c\x01\n\x0eFCVolumeSour\
    ce\x12\x1e\n\ntargetWWNs\x18\x01\x20\x03(\tR\ntargetWWNs\x12\x10\n\x03lu\
    n\x18\x02\x20\x01(\x05R\x03lun\x12\x16\n\x06fsType\x18\x03\x20\x01(\tR\
    \x06fsType\x12\x1a\n\x08readOnly\x18\x04\x20\x01(\x08R\x08readOnly\x12\
    \x14\n\x05wwids\x18\x05\x20\x03(\tR\x05wwids\"\xb0\x02\n\x1aFlexPersiste\
    ntVolumeSource\x12\x16\n\x06driver\x18\x01\x20\x01(\tR\x06driver\x12\x16\
    \n\x06fsType\x18\x02\x20\x01(\tR\x06fsType\x12:\n\tsecretRef\x18\x03\x20\
    \x01(\x0b2\x1c.api.core.v1.SecretReferenceR\tsecretRef\x12\x1a\n\x08read\
    Only\x18\x04\x20\x01(\x08R\x08readOnly\x12N\n\x07options\x18\x05\x20\x03\
    (\x0b24.api.core.v1.FlexPersistentVolumeSource.OptionsEntryR\x07options\
    \x1a:\n\x0cOptionsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xa1\x02\n\x10Fl\
    exVolumeSource\x12\x16\n\x06driver\x18\x01\x20\x01(\tR\x06driver\x12\x16\
    \n\x06fsType\x18\x02\x20\x01(\tR\x06fsType\x12?\n\tsecretRef\x18\x03\x20\
    \x01(\x0b2!.api.core.v1.LocalObjectReferenceR\tsecretRef\x12\x1a\n\x08re\
    adOnly\x18\x04\x20\x01(\x08R\x08readOnly\x12D\n\x07options\x18\x05\x20\
    \x03(\x0b2*.api.core.v1.FlexVolumeSource.OptionsEntryR\x07options\x1a:\n\
    \x0cOptionsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"Y\n\x13FlockerVolumeSo\
    urce\x12\x20\n\x0bdatasetName\x18\x01\x20\x01(\tR\x0bdatasetName\x12\x20\
    \n\x0bdatasetUUID\x18\x02\x20\x01(\tR\x0bdatasetUUID\"\x89\x01\n\x1dGCEP\
    ersistentDiskVolumeSource\x12\x16\n\x06pdName\x18\x01\x20\x01(\tR\x06pdN\
    ame\x12\x16\n\x06fsType\x18\x02\x20\x01(\tR\x06fsType\x12\x1c\n\tpartiti\
    on\x18\x03\x20\x01(\x05R\tpartition\x12\x1a\n\x08readOnly\x18\x04\x20\
    \x01(\x08R\x08readOnly\":\n\nGRPCAction\x12\x12\n\x04port\x18\x01\x20\
    \x01(\x05R\x04port\x12\x18\n\x07service\x18\x02\x20\x01(\tR\x07service\"\
    o\n\x13GitRepoVolumeSource\x12\x1e\n\nrepository\x18\x01\x20\x01(\tR\nre\
    pository\x12\x1a\n\x08revision\x18\x02\x20\x01(\tR\x08revision\x12\x1c\n\
    \tdirectory\x18\x03\x20\x01(\tR\tdirectory\"\x9f\x01\n\x1fGlusterfsPersi\
    stentVolumeSource\x12\x1c\n\tendpoints\x18\x01\x20\x01(\tR\tendpoints\
    \x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04path\x12\x1a\n\x08readOnly\x18\
    \x03\x20\x01(\x08R\x08readOnly\x12.\n\x12endpointsNamespace\x18\x04\x20\
    \x01(\tR\x12endpointsNamespace\"e\n\x15GlusterfsVolumeSource\x12\x1c\n\t\
    endpoints\x18\x01\x20\x01(\tR\tendpoints\x12\x12\n\x04path\x18\x02\x20\
    \x01(\tR\x04path\x12\x1a\n\x08readOnly\x18\x03\x20\x01(\x08R\x08readOnly\
    \"\xc9\x01\n\rHTTPGetAction\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04pat\
    h\x12=\n\x04port\x18\x02\x20\x01(\x0b2).apimachinery.pkg.util.intstr.Int\
    OrStringR\x04port\x12\x12\n\x04host\x18\x03\x20\x01(\tR\x04host\x12\x16\
    \n\x06scheme\x18\x04\x20\x01(\tR\x06scheme\x129\n\x0bhttpHeaders\x18\x05\
    \x20\x03(\x0b2\x17.api.core.v1.HTTPHeaderR\x0bhttpHeaders\"6\n\nHTTPHead\
    er\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value\"9\n\tHostAlias\x12\x0e\n\x02ip\x18\x01\x20\
    \x01(\tR\x02ip\x12\x1c\n\thostnames\x18\x02\x20\x03(\tR\thostnames\"\x18\
    \n\x06HostIP\x12\x0e\n\x02ip\x18\x01\x20\x01(\tR\x02ip\">\n\x14HostPathV\
    olumeSource\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\x12\x12\n\x04t\
    ype\x18\x02\x20\x01(\tR\x04type\"\x95\x03\n\x1bISCSIPersistentVolumeSour\
    ce\x12\"\n\x0ctargetPortal\x18\x01\x20\x01(\tR\x0ctargetPortal\x12\x10\n\
    \x03iqn\x18\x02\x20\x01(\tR\x03iqn\x12\x10\n\x03lun\x18\x03\x20\x01(\x05\
    R\x03lun\x12&\n\x0eiscsiInterface\x18\x04\x20\x01(\tR\x0eiscsiInterface\
    \x12\x16\n\x06fsType\x18\x05\x20\x01(\tR\x06fsType\x12\x1a\n\x08readOnly\
    \x18\x06\x20\x01(\x08R\x08readOnly\x12\x18\n\x07portals\x18\x07\x20\x03(\
    \tR\x07portals\x12,\n\x11chapAuthDiscovery\x18\x08\x20\x01(\x08R\x11chap\
    AuthDiscovery\x12(\n\x0fchapAuthSession\x18\x0b\x20\x01(\x08R\x0fchapAut\
    hSession\x12:\n\tsecretRef\x18\n\x20\x01(\x0b2\x1c.api.core.v1.SecretRef\
    erenceR\tsecretRef\x12$\n\rinitiatorName\x18\x0c\x20\x01(\tR\rinitiatorN\
    ame\"\x90\x03\n\x11ISCSIVolumeSource\x12\"\n\x0ctargetPortal\x18\x01\x20\
    \x01(\tR\x0ctargetPortal\x12\x10\n\x03iqn\x18\x02\x20\x01(\tR\x03iqn\x12\
    \x10\n\x03lun\x18\x03\x20\x01(\x05R\x03lun\x12&\n\x0eiscsiInterface\x18\
    \x04\x20\x01(\tR\x0eiscsiInterface\x12\x16\n\x06fsType\x18\x05\x20\x01(\
    \tR\x06fsType\x12\x1a\n\x08readOnly\x18\x06\x20\x01(\x08R\x08readOnly\
    \x12\x18\n\x07portals\x18\x07\x20\x03(\tR\x07portals\x12,\n\x11chapAuthD\
    iscovery\x18\x08\x20\x01(\x08R\x11chapAuthDiscovery\x12(\n\x0fchapAuthSe\
    ssion\x18\x0b\x20\x01(\x08R\x0fchapAuthSession\x12?\n\tsecretRef\x18\n\
    \x20\x01(\x0b2!.api.core.v1.LocalObjectReferenceR\tsecretRef\x12$\n\rini\
    tiatorName\x18\x0c\x20\x01(\tR\rinitiatorName\"E\n\tKeyToPath\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x12\n\x04path\x18\x02\x20\x01(\tR\
    \x04path\x12\x12\n\x04mode\x18\x03\x20\x01(\x05R\x04mode\"\x81\x01\n\tLi\
    fecycle\x12;\n\tpostStart\x18\x01\x20\x01(\x0b2\x1d.api.core.v1.Lifecycl\
    eHandlerR\tpostStart\x127\n\x07preStop\x18\x02\x20\x01(\x0b2\x1d.api.cor\
    e.v1.LifecycleHandlerR\x07preStop\"\xe1\x01\n\x10LifecycleHandler\x12+\n\
    \x04exec\x18\x01\x20\x01(\x0b2\x17.api.core.v1.ExecActionR\x04exec\x124\
    \n\x07httpGet\x18\x02\x20\x01(\x0b2\x1a.api.core.v1.HTTPGetActionR\x07ht\
    tpGet\x12:\n\ttcpSocket\x18\x03\x20\x01(\x0b2\x1c.api.core.v1.TCPSocketA\
    ctionR\ttcpSocket\x12.\n\x05sleep\x18\x04\x20\x01(\x0b2\x18.api.core.v1.\
    SleepActionR\x05sleep\"\x84\x01\n\nLimitRange\x12E\n\x08metadata\x18\x01\
    \x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\
    \x12/\n\x04spec\x18\x02\x20\x01(\x0b2\x1b.api.core.v1.LimitRangeSpecR\
    \x04spec\"\xa1\x07\n\x0eLimitRangeItem\x12\x12\n\x04type\x18\x01\x20\x01\
    (\tR\x04type\x126\n\x03max\x18\x02\x20\x03(\x0b2$.api.core.v1.LimitRange\
    Item.MaxEntryR\x03max\x126\n\x03min\x18\x03\x20\x03(\x0b2$.api.core.v1.L\
    imitRangeItem.MinEntryR\x03min\x12B\n\x07default\x18\x04\x20\x03(\x0b2(.\
    api.core.v1.LimitRangeItem.DefaultEntryR\x07default\x12W\n\x0edefaultReq\
    uest\x18\x05\x20\x03(\x0b2/.api.core.v1.LimitRangeItem.DefaultRequestEnt\
    ryR\x0edefaultRequest\x12i\n\x14maxLimitRequestRatio\x18\x06\x20\x03(\
    \x0b25.api.core.v1.LimitRangeItem.MaxLimitRequestRatioEntryR\x14maxLimit\
    RequestRatio\x1a_\n\x08MaxEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03\
    key\x12=\n\x05value\x18\x02\x20\x01(\x0b2'.apimachinery.pkg.api.resource\
    .QuantityR\x05value:\x028\x01\x1a_\n\x08MinEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12=\n\x05value\x18\x02\x20\x01(\x0b2'.apimachin\
    ery.pkg.api.resource.QuantityR\x05value:\x028\x01\x1ac\n\x0cDefaultEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12=\n\x05value\x18\x02\x20\
    \x01(\x0b2'.apimachinery.pkg.api.resource.QuantityR\x05value:\x028\x01\
    \x1aj\n\x13DefaultRequestEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03k\
    ey\x12=\n\x05value\x18\x02\x20\x01(\x0b2'.apimachinery.pkg.api.resource.\
    QuantityR\x05value:\x028\x01\x1ap\n\x19MaxLimitRequestRatioEntry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12=\n\x05value\x18\x02\x20\x01(\
    \x0b2'.apimachinery.pkg.api.resource.QuantityR\x05value:\x028\x01\"\x84\
    \x01\n\x0eLimitRangeList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apima\
    chinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12-\n\x05items\x18\x02\
    \x20\x03(\x0b2\x17.api.core.v1.LimitRangeR\x05items\"E\n\x0eLimitRangeSp\
    ec\x123\n\x06limits\x18\x01\x20\x03(\x0b2\x1b.api.core.v1.LimitRangeItem\
    R\x06limits\"\x89\x01\n\x04List\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2\
    '.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12<\n\x05items\
    \x18\x02\x20\x03(\x0b2&.apimachinery.pkg.runtime.RawExtensionR\x05items\
    \"\x88\x01\n\x13LoadBalancerIngress\x12\x0e\n\x02ip\x18\x01\x20\x01(\tR\
    \x02ip\x12\x1a\n\x08hostname\x18\x02\x20\x01(\tR\x08hostname\x12\x16\n\
    \x06ipMode\x18\x03\x20\x01(\tR\x06ipMode\x12-\n\x05ports\x18\x04\x20\x03\
    (\x0b2\x17.api.core.v1.PortStatusR\x05ports\"P\n\x12LoadBalancerStatus\
    \x12:\n\x07ingress\x18\x01\x20\x03(\x0b2\x20.api.core.v1.LoadBalancerIng\
    ressR\x07ingress\"*\n\x14LocalObjectReference\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\"?\n\x11LocalVolumeSource\x12\x12\n\x04path\x18\x01\
    \x20\x01(\tR\x04path\x12\x16\n\x06fsType\x18\x02\x20\x01(\tR\x06fsType\"\
    v\n\x12ModifyVolumeStatus\x12H\n\x1ftargetVolumeAttributesClassName\x18\
    \x01\x20\x01(\tR\x1ftargetVolumeAttributesClassName\x12\x16\n\x06status\
    \x18\x02\x20\x01(\tR\x06status\"Y\n\x0fNFSVolumeSource\x12\x16\n\x06serv\
    er\x18\x01\x20\x01(\tR\x06server\x12\x12\n\x04path\x18\x02\x20\x01(\tR\
    \x04path\x12\x1a\n\x08readOnly\x18\x03\x20\x01(\x08R\x08readOnly\"\xb8\
    \x01\n\tNamespace\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachinery\
    .pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12.\n\x04spec\x18\x02\x20\x01\
    (\x0b2\x1a.api.core.v1.NamespaceSpecR\x04spec\x124\n\x06status\x18\x03\
    \x20\x01(\x0b2\x1c.api.core.v1.NamespaceStatusR\x06status\"\xc7\x01\n\
    \x12NamespaceCondition\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12\
    \x16\n\x06status\x18\x02\x20\x01(\tR\x06status\x12S\n\x12lastTransitionT\
    ime\x18\x04\x20\x01(\x0b2#.apimachinery.pkg.apis.meta.v1.TimeR\x12lastTr\
    ansitionTime\x12\x16\n\x06reason\x18\x05\x20\x01(\tR\x06reason\x12\x18\n\
    \x07message\x18\x06\x20\x01(\tR\x07message\"\x82\x01\n\rNamespaceList\
    \x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1\
    .ListMetaR\x08metadata\x12,\n\x05items\x18\x02\x20\x03(\x0b2\x16.api.cor\
    e.v1.NamespaceR\x05items\"/\n\rNamespaceSpec\x12\x1e\n\nfinalizers\x18\
    \x01\x20\x03(\tR\nfinalizers\"h\n\x0fNamespaceStatus\x12\x14\n\x05phase\
    \x18\x01\x20\x01(\tR\x05phase\x12?\n\nconditions\x18\x02\x20\x03(\x0b2\
    \x1f.api.core.v1.NamespaceConditionR\nconditions\"\xa9\x01\n\x04Node\x12\
    E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.Obj\
    ectMetaR\x08metadata\x12)\n\x04spec\x18\x02\x20\x01(\x0b2\x15.api.core.v\
    1.NodeSpecR\x04spec\x12/\n\x06status\x18\x03\x20\x01(\x0b2\x17.api.core.\
    v1.NodeStatusR\x06status\";\n\x0bNodeAddress\x12\x12\n\x04type\x18\x01\
    \x20\x01(\tR\x04type\x12\x18\n\x07address\x18\x02\x20\x01(\tR\x07address\
    \"\xa3\x02\n\x0cNodeAffinity\x12\x81\x01\n.requiredDuringSchedulingIgnor\
    edDuringExecution\x18\x01\x20\x01(\x0b2\x19.api.core.v1.NodeSelectorR.re\
    quiredDuringSchedulingIgnoredDuringExecution\x12\x8e\x01\n/preferredDuri\
    ngSchedulingIgnoredDuringExecution\x18\x02\x20\x03(\x0b2$.api.core.v1.Pr\
    eferredSchedulingTermR/preferredDuringSchedulingIgnoredDuringExecution\"\
    \x95\x02\n\rNodeCondition\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\
    \x12\x16\n\x06status\x18\x02\x20\x01(\tR\x06status\x12Q\n\x11lastHeartbe\
    atTime\x18\x03\x20\x01(\x0b2#.apimachinery.pkg.apis.meta.v1.TimeR\x11las\
    tHeartbeatTime\x12S\n\x12lastTransitionTime\x18\x04\x20\x01(\x0b2#.apima\
    chinery.pkg.apis.meta.v1.TimeR\x12lastTransitionTime\x12\x16\n\x06reason\
    \x18\x05\x20\x01(\tR\x06reason\x12\x18\n\x07message\x18\x06\x20\x01(\tR\
    \x07message\"X\n\x10NodeConfigSource\x12D\n\tconfigMap\x18\x02\x20\x01(\
    \x0b2&.api.core.v1.ConfigMapNodeConfigSourceR\tconfigMap\"\xdf\x01\n\x10\
    NodeConfigStatus\x129\n\x08assigned\x18\x01\x20\x01(\x0b2\x1d.api.core.v\
    1.NodeConfigSourceR\x08assigned\x125\n\x06active\x18\x02\x20\x01(\x0b2\
    \x1d.api.core.v1.NodeConfigSourceR\x06active\x12C\n\rlastKnownGood\x18\
    \x03\x20\x01(\x0b2\x1d.api.core.v1.NodeConfigSourceR\rlastKnownGood\x12\
    \x14\n\x05error\x18\x04\x20\x01(\tR\x05error\"\\\n\x13NodeDaemonEndpoint\
    s\x12E\n\x0fkubeletEndpoint\x18\x01\x20\x01(\x0b2\x1b.api.core.v1.Daemon\
    EndpointR\x0fkubeletEndpoint\"x\n\x08NodeList\x12C\n\x08metadata\x18\x01\
    \x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12'\
    \n\x05items\x18\x02\x20\x03(\x0b2\x11.api.core.v1.NodeR\x05items\"&\n\
    \x10NodeProxyOptions\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\"m\n\
    \x12NodeRuntimeHandler\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\
    C\n\x08features\x18\x02\x20\x01(\x0b2'.api.core.v1.NodeRuntimeHandlerFea\
    turesR\x08features\"V\n\x1aNodeRuntimeHandlerFeatures\x128\n\x17recursiv\
    eReadOnlyMounts\x18\x01\x20\x01(\x08R\x17recursiveReadOnlyMounts\"[\n\
    \x0cNodeSelector\x12K\n\x11nodeSelectorTerms\x18\x01\x20\x03(\x0b2\x1d.a\
    pi.core.v1.NodeSelectorTermR\x11nodeSelectorTerms\"_\n\x17NodeSelectorRe\
    quirement\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x1a\n\x08opera\
    tor\x18\x02\x20\x01(\tR\x08operator\x12\x16\n\x06values\x18\x03\x20\x03(\
    \tR\x06values\"\xac\x01\n\x10NodeSelectorTerm\x12P\n\x10matchExpressions\
    \x18\x01\x20\x03(\x0b2$.api.core.v1.NodeSelectorRequirementR\x10matchExp\
    ressions\x12F\n\x0bmatchFields\x18\x02\x20\x03(\x0b2$.api.core.v1.NodeSe\
    lectorRequirementR\x0bmatchFields\"\x95\x02\n\x08NodeSpec\x12\x18\n\x07p\
    odCIDR\x18\x01\x20\x01(\tR\x07podCIDR\x12\x1a\n\x08podCIDRs\x18\x07\x20\
    \x03(\tR\x08podCIDRs\x12\x1e\n\nproviderID\x18\x03\x20\x01(\tR\nprovider\
    ID\x12$\n\runschedulable\x18\x04\x20\x01(\x08R\runschedulable\x12*\n\x06\
    taints\x18\x05\x20\x03(\x0b2\x12.api.core.v1.TaintR\x06taints\x12A\n\x0c\
    configSource\x18\x06\x20\x01(\x0b2\x1d.api.core.v1.NodeConfigSourceR\x0c\
    configSource\x12\x1e\n\nexternalID\x18\x02\x20\x01(\tR\nexternalID\"\x9b\
    \x07\n\nNodeStatus\x12A\n\x08capacity\x18\x01\x20\x03(\x0b2%.api.core.v1\
    .NodeStatus.CapacityEntryR\x08capacity\x12J\n\x0ballocatable\x18\x02\x20\
    \x03(\x0b2(.api.core.v1.NodeStatus.AllocatableEntryR\x0ballocatable\x12\
    \x14\n\x05phase\x18\x03\x20\x01(\tR\x05phase\x12:\n\nconditions\x18\x04\
    \x20\x03(\x0b2\x1a.api.core.v1.NodeConditionR\nconditions\x126\n\taddres\
    ses\x18\x05\x20\x03(\x0b2\x18.api.core.v1.NodeAddressR\taddresses\x12J\n\
    \x0fdaemonEndpoints\x18\x06\x20\x01(\x0b2\x20.api.core.v1.NodeDaemonEndp\
    ointsR\x0fdaemonEndpoints\x127\n\x08nodeInfo\x18\x07\x20\x01(\x0b2\x1b.a\
    pi.core.v1.NodeSystemInfoR\x08nodeInfo\x123\n\x06images\x18\x08\x20\x03(\
    \x0b2\x1b.api.core.v1.ContainerImageR\x06images\x12\"\n\x0cvolumesInUse\
    \x18\t\x20\x03(\tR\x0cvolumesInUse\x12E\n\x0fvolumesAttached\x18\n\x20\
    \x03(\x0b2\x1b.api.core.v1.AttachedVolumeR\x0fvolumesAttached\x125\n\x06\
    config\x18\x0b\x20\x01(\x0b2\x1d.api.core.v1.NodeConfigStatusR\x06config\
    \x12I\n\x0fruntimeHandlers\x18\x0c\x20\x03(\x0b2\x1f.api.core.v1.NodeRun\
    timeHandlerR\x0fruntimeHandlers\x1ad\n\rCapacityEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12=\n\x05value\x18\x02\x20\x01(\x0b2'.apima\
    chinery.pkg.api.resource.QuantityR\x05value:\x028\x01\x1ag\n\x10Allocata\
    bleEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12=\n\x05value\x18\
    \x02\x20\x01(\x0b2'.apimachinery.pkg.api.resource.QuantityR\x05value:\
    \x028\x01\"\x82\x03\n\x0eNodeSystemInfo\x12\x1c\n\tmachineID\x18\x01\x20\
    \x01(\tR\tmachineID\x12\x1e\n\nsystemUUID\x18\x02\x20\x01(\tR\nsystemUUI\
    D\x12\x16\n\x06bootID\x18\x03\x20\x01(\tR\x06bootID\x12$\n\rkernelVersio\
    n\x18\x04\x20\x01(\tR\rkernelVersion\x12\x18\n\x07osImage\x18\x05\x20\
    \x01(\tR\x07osImage\x128\n\x17containerRuntimeVersion\x18\x06\x20\x01(\t\
    R\x17containerRuntimeVersion\x12&\n\x0ekubeletVersion\x18\x07\x20\x01(\t\
    R\x0ekubeletVersion\x12*\n\x10kubeProxyVersion\x18\x08\x20\x01(\tR\x10ku\
    beProxyVersion\x12(\n\x0foperatingSystem\x18\t\x20\x01(\tR\x0foperatingS\
    ystem\x12\"\n\x0carchitecture\x18\n\x20\x01(\tR\x0carchitecture\"S\n\x13\
    ObjectFieldSelector\x12\x1e\n\napiVersion\x18\x01\x20\x01(\tR\napiVersio\
    n\x12\x1c\n\tfieldPath\x18\x02\x20\x01(\tR\tfieldPath\"\xd1\x01\n\x0fObj\
    ectReference\x12\x12\n\x04kind\x18\x01\x20\x01(\tR\x04kind\x12\x1c\n\tna\
    mespace\x18\x02\x20\x01(\tR\tnamespace\x12\x12\n\x04name\x18\x03\x20\x01\
    (\tR\x04name\x12\x10\n\x03uid\x18\x04\x20\x01(\tR\x03uid\x12\x1e\n\napiV\
    ersion\x18\x05\x20\x01(\tR\napiVersion\x12(\n\x0fresourceVersion\x18\x06\
    \x20\x01(\tR\x0fresourceVersion\x12\x1c\n\tfieldPath\x18\x07\x20\x01(\tR\
    \tfieldPath\"\xcd\x01\n\x10PersistentVolume\x12E\n\x08metadata\x18\x01\
    \x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\
    \x125\n\x04spec\x18\x02\x20\x01(\x0b2!.api.core.v1.PersistentVolumeSpecR\
    \x04spec\x12;\n\x06status\x18\x03\x20\x01(\x0b2#.api.core.v1.PersistentV\
    olumeStatusR\x06status\"\xdc\x01\n\x15PersistentVolumeClaim\x12E\n\x08me\
    tadata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\
    \x08metadata\x12:\n\x04spec\x18\x02\x20\x01(\x0b2&.api.core.v1.Persisten\
    tVolumeClaimSpecR\x04spec\x12@\n\x06status\x18\x03\x20\x01(\x0b2(.api.co\
    re.v1.PersistentVolumeClaimStatusR\x06status\"\x9e\x02\n\x1ePersistentVo\
    lumeClaimCondition\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12\x16\
    \n\x06status\x18\x02\x20\x01(\tR\x06status\x12I\n\rlastProbeTime\x18\x03\
    \x20\x01(\x0b2#.apimachinery.pkg.apis.meta.v1.TimeR\rlastProbeTime\x12S\
    \n\x12lastTransitionTime\x18\x04\x20\x01(\x0b2#.apimachinery.pkg.apis.me\
    ta.v1.TimeR\x12lastTransitionTime\x12\x16\n\x06reason\x18\x05\x20\x01(\t\
    R\x06reason\x12\x18\n\x07message\x18\x06\x20\x01(\tR\x07message\"\x9a\
    \x01\n\x19PersistentVolumeClaimList\x12C\n\x08metadata\x18\x01\x20\x01(\
    \x0b2'.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x128\n\x05ite\
    ms\x18\x02\x20\x03(\x0b2\".api.core.v1.PersistentVolumeClaimR\x05items\"\
    \x89\x04\n\x19PersistentVolumeClaimSpec\x12\x20\n\x0baccessModes\x18\x01\
    \x20\x03(\tR\x0baccessModes\x12H\n\x08selector\x18\x04\x20\x01(\x0b2,.ap\
    imachinery.pkg.apis.meta.v1.LabelSelectorR\x08selector\x12E\n\tresources\
    \x18\x02\x20\x01(\x0b2'.api.core.v1.VolumeResourceRequirementsR\tresourc\
    es\x12\x1e\n\nvolumeName\x18\x03\x20\x01(\tR\nvolumeName\x12*\n\x10stora\
    geClassName\x18\x05\x20\x01(\tR\x10storageClassName\x12\x1e\n\nvolumeMod\
    e\x18\x06\x20\x01(\tR\nvolumeMode\x12F\n\ndataSource\x18\x07\x20\x01(\
    \x0b2&.api.core.v1.TypedLocalObjectReferenceR\ndataSource\x12G\n\rdataSo\
    urceRef\x18\x08\x20\x01(\x0b2!.api.core.v1.TypedObjectReferenceR\rdataSo\
    urceRef\x12<\n\x19volumeAttributesClassName\x18\t\x20\x01(\tR\x19volumeA\
    ttributesClassName\"\xb1\x07\n\x1bPersistentVolumeClaimStatus\x12\x14\n\
    \x05phase\x18\x01\x20\x01(\tR\x05phase\x12\x20\n\x0baccessModes\x18\x02\
    \x20\x03(\tR\x0baccessModes\x12R\n\x08capacity\x18\x03\x20\x03(\x0b26.ap\
    i.core.v1.PersistentVolumeClaimStatus.CapacityEntryR\x08capacity\x12K\n\
    \nconditions\x18\x04\x20\x03(\x0b2+.api.core.v1.PersistentVolumeClaimCon\
    ditionR\nconditions\x12p\n\x12allocatedResources\x18\x05\x20\x03(\x0b2@.\
    api.core.v1.PersistentVolumeClaimStatus.AllocatedResourcesEntryR\x12allo\
    catedResources\x12\x85\x01\n\x19allocatedResourceStatuses\x18\x07\x20\
    \x03(\x0b2G.api.core.v1.PersistentVolumeClaimStatus.AllocatedResourceSta\
    tusesEntryR\x19allocatedResourceStatuses\x12J\n\x20currentVolumeAttribut\
    esClassName\x18\x08\x20\x01(\tR\x20currentVolumeAttributesClassName\x12O\
    \n\x12modifyVolumeStatus\x18\t\x20\x01(\x0b2\x1f.api.core.v1.ModifyVolum\
    eStatusR\x12modifyVolumeStatus\x1ad\n\rCapacityEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12=\n\x05value\x18\x02\x20\x01(\x0b2'.apima\
    chinery.pkg.api.resource.QuantityR\x05value:\x028\x01\x1an\n\x17Allocate\
    dResourcesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12=\n\x05va\
    lue\x18\x02\x20\x01(\x0b2'.apimachinery.pkg.api.resource.QuantityR\x05va\
    lue:\x028\x01\x1aL\n\x1eAllocatedResourceStatusesEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\"\xa2\x01\n\x1dPersistentVolumeClaimTemplate\x12E\n\x08met\
    adata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\
    \x08metadata\x12:\n\x04spec\x18\x02\x20\x01(\x0b2&.api.core.v1.Persisten\
    tVolumeClaimSpecR\x04spec\"]\n!PersistentVolumeClaimVolumeSource\x12\x1c\
    \n\tclaimName\x18\x01\x20\x01(\tR\tclaimName\x12\x1a\n\x08readOnly\x18\
    \x02\x20\x01(\x08R\x08readOnly\"\x90\x01\n\x14PersistentVolumeList\x12C\
    \n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.List\
    MetaR\x08metadata\x123\n\x05items\x18\x02\x20\x03(\x0b2\x1d.api.core.v1.\
    PersistentVolumeR\x05items\"\x8f\x0c\n\x16PersistentVolumeSource\x12X\n\
    \x11gcePersistentDisk\x18\x01\x20\x01(\x0b2*.api.core.v1.GCEPersistentDi\
    skVolumeSourceR\x11gcePersistentDisk\x12a\n\x14awsElasticBlockStore\x18\
    \x02\x20\x01(\x0b2-.api.core.v1.AWSElasticBlockStoreVolumeSourceR\x14aws\
    ElasticBlockStore\x12=\n\x08hostPath\x18\x03\x20\x01(\x0b2!.api.core.v1.\
    HostPathVolumeSourceR\x08hostPath\x12J\n\tglusterfs\x18\x04\x20\x01(\x0b\
    2,.api.core.v1.GlusterfsPersistentVolumeSourceR\tglusterfs\x12.\n\x03nfs\
    \x18\x05\x20\x01(\x0b2\x1c.api.core.v1.NFSVolumeSourceR\x03nfs\x128\n\
    \x03rbd\x18\x06\x20\x01(\x0b2&.api.core.v1.RBDPersistentVolumeSourceR\
    \x03rbd\x12>\n\x05iscsi\x18\x07\x20\x01(\x0b2(.api.core.v1.ISCSIPersiste\
    ntVolumeSourceR\x05iscsi\x12A\n\x06cinder\x18\x08\x20\x01(\x0b2).api.cor\
    e.v1.CinderPersistentVolumeSourceR\x06cinder\x12A\n\x06cephfs\x18\t\x20\
    \x01(\x0b2).api.core.v1.CephFSPersistentVolumeSourceR\x06cephfs\x12+\n\
    \x02fc\x18\n\x20\x01(\x0b2\x1b.api.core.v1.FCVolumeSourceR\x02fc\x12:\n\
    \x07flocker\x18\x0b\x20\x01(\x0b2\x20.api.core.v1.FlockerVolumeSourceR\
    \x07flocker\x12G\n\nflexVolume\x18\x0c\x20\x01(\x0b2'.api.core.v1.FlexPe\
    rsistentVolumeSourceR\nflexVolume\x12J\n\tazureFile\x18\r\x20\x01(\x0b2,\
    .api.core.v1.AzureFilePersistentVolumeSourceR\tazureFile\x12Q\n\rvsphere\
    Volume\x18\x0e\x20\x01(\x0b2+.api.core.v1.VsphereVirtualDiskVolumeSource\
    R\rvsphereVolume\x12:\n\x07quobyte\x18\x0f\x20\x01(\x0b2\x20.api.core.v1\
    .QuobyteVolumeSourceR\x07quobyte\x12@\n\tazureDisk\x18\x10\x20\x01(\x0b2\
    \".api.core.v1.AzureDiskVolumeSourceR\tazureDisk\x12a\n\x14photonPersist\
    entDisk\x18\x11\x20\x01(\x0b2-.api.core.v1.PhotonPersistentDiskVolumeSou\
    rceR\x14photonPersistentDisk\x12I\n\x0eportworxVolume\x18\x12\x20\x01(\
    \x0b2!.api.core.v1.PortworxVolumeSourceR\x0eportworxVolume\x12D\n\x07sca\
    leIO\x18\x13\x20\x01(\x0b2*.api.core.v1.ScaleIOPersistentVolumeSourceR\
    \x07scaleIO\x124\n\x05local\x18\x14\x20\x01(\x0b2\x1e.api.core.v1.LocalV\
    olumeSourceR\x05local\x12J\n\tstorageos\x18\x15\x20\x01(\x0b2,.api.core.\
    v1.StorageOSPersistentVolumeSourceR\tstorageos\x128\n\x03csi\x18\x16\x20\
    \x01(\x0b2&.api.core.v1.CSIPersistentVolumeSourceR\x03csi\"\xbb\x05\n\
    \x14PersistentVolumeSpec\x12K\n\x08capacity\x18\x01\x20\x03(\x0b2/.api.c\
    ore.v1.PersistentVolumeSpec.CapacityEntryR\x08capacity\x12[\n\x16persist\
    entVolumeSource\x18\x02\x20\x01(\x0b2#.api.core.v1.PersistentVolumeSourc\
    eR\x16persistentVolumeSource\x12\x20\n\x0baccessModes\x18\x03\x20\x03(\t\
    R\x0baccessModes\x128\n\x08claimRef\x18\x04\x20\x01(\x0b2\x1c.api.core.v\
    1.ObjectReferenceR\x08claimRef\x12D\n\x1dpersistentVolumeReclaimPolicy\
    \x18\x05\x20\x01(\tR\x1dpersistentVolumeReclaimPolicy\x12*\n\x10storageC\
    lassName\x18\x06\x20\x01(\tR\x10storageClassName\x12\"\n\x0cmountOptions\
    \x18\x07\x20\x03(\tR\x0cmountOptions\x12\x1e\n\nvolumeMode\x18\x08\x20\
    \x01(\tR\nvolumeMode\x12C\n\x0cnodeAffinity\x18\t\x20\x01(\x0b2\x1f.api.\
    core.v1.VolumeNodeAffinityR\x0cnodeAffinity\x12<\n\x19volumeAttributesCl\
    assName\x18\n\x20\x01(\tR\x19volumeAttributesClassName\x1ad\n\rCapacityE\
    ntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12=\n\x05value\x18\x02\
    \x20\x01(\x0b2'.apimachinery.pkg.api.resource.QuantityR\x05value:\x028\
    \x01\"\xbf\x01\n\x16PersistentVolumeStatus\x12\x14\n\x05phase\x18\x01\
    \x20\x01(\tR\x05phase\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07messag\
    e\x12\x16\n\x06reason\x18\x03\x20\x01(\tR\x06reason\x12]\n\x17lastPhaseT\
    ransitionTime\x18\x04\x20\x01(\x0b2#.apimachinery.pkg.apis.meta.v1.TimeR\
    \x17lastPhaseTransitionTime\"N\n\x20PhotonPersistentDiskVolumeSource\x12\
    \x12\n\x04pdID\x18\x01\x20\x01(\tR\x04pdID\x12\x16\n\x06fsType\x18\x02\
    \x20\x01(\tR\x06fsType\"\xa6\x01\n\x03Pod\x12E\n\x08metadata\x18\x01\x20\
    \x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12(\n\
    \x04spec\x18\x02\x20\x01(\x0b2\x14.api.core.v1.PodSpecR\x04spec\x12.\n\
    \x06status\x18\x03\x20\x01(\x0b2\x16.api.core.v1.PodStatusR\x06status\"\
    \xa5\x02\n\x0bPodAffinity\x12\x84\x01\n.requiredDuringSchedulingIgnoredD\
    uringExecution\x18\x01\x20\x03(\x0b2\x1c.api.core.v1.PodAffinityTermR.re\
    quiredDuringSchedulingIgnoredDuringExecution\x12\x8e\x01\n/preferredDuri\
    ngSchedulingIgnoredDuringExecution\x18\x02\x20\x03(\x0b2$.api.core.v1.We\
    ightedPodAffinityTermR/preferredDuringSchedulingIgnoredDuringExecution\"\
    \xd9\x02\n\x0fPodAffinityTerm\x12R\n\rlabelSelector\x18\x01\x20\x01(\x0b\
    2,.apimachinery.pkg.apis.meta.v1.LabelSelectorR\rlabelSelector\x12\x1e\n\
    \nnamespaces\x18\x02\x20\x03(\tR\nnamespaces\x12\x20\n\x0btopologyKey\
    \x18\x03\x20\x01(\tR\x0btopologyKey\x12Z\n\x11namespaceSelector\x18\x04\
    \x20\x01(\x0b2,.apimachinery.pkg.apis.meta.v1.LabelSelectorR\x11namespac\
    eSelector\x12&\n\x0ematchLabelKeys\x18\x05\x20\x03(\tR\x0ematchLabelKeys\
    \x12,\n\x11mismatchLabelKeys\x18\x06\x20\x03(\tR\x11mismatchLabelKeys\"\
    \xa9\x02\n\x0fPodAntiAffinity\x12\x84\x01\n.requiredDuringSchedulingIgno\
    redDuringExecution\x18\x01\x20\x03(\x0b2\x1c.api.core.v1.PodAffinityTerm\
    R.requiredDuringSchedulingIgnoredDuringExecution\x12\x8e\x01\n/preferred\
    DuringSchedulingIgnoredDuringExecution\x18\x02\x20\x03(\x0b2$.api.core.v\
    1.WeightedPodAffinityTermR/preferredDuringSchedulingIgnoredDuringExecuti\
    on\"\x88\x01\n\x10PodAttachOptions\x12\x14\n\x05stdin\x18\x01\x20\x01(\
    \x08R\x05stdin\x12\x16\n\x06stdout\x18\x02\x20\x01(\x08R\x06stdout\x12\
    \x16\n\x06stderr\x18\x03\x20\x01(\x08R\x06stderr\x12\x10\n\x03tty\x18\
    \x04\x20\x01(\x08R\x03tty\x12\x1c\n\tcontainer\x18\x05\x20\x01(\tR\tcont\
    ainer\"\x8c\x02\n\x0cPodCondition\x12\x12\n\x04type\x18\x01\x20\x01(\tR\
    \x04type\x12\x16\n\x06status\x18\x02\x20\x01(\tR\x06status\x12I\n\rlastP\
    robeTime\x18\x03\x20\x01(\x0b2#.apimachinery.pkg.apis.meta.v1.TimeR\rlas\
    tProbeTime\x12S\n\x12lastTransitionTime\x18\x04\x20\x01(\x0b2#.apimachin\
    ery.pkg.apis.meta.v1.TimeR\x12lastTransitionTime\x12\x16\n\x06reason\x18\
    \x05\x20\x01(\tR\x06reason\x12\x18\n\x07message\x18\x06\x20\x01(\tR\x07m\
    essage\"\x87\x01\n\x0cPodDNSConfig\x12\x20\n\x0bnameservers\x18\x01\x20\
    \x03(\tR\x0bnameservers\x12\x1a\n\x08searches\x18\x02\x20\x03(\tR\x08sea\
    rches\x129\n\x07options\x18\x03\x20\x03(\x0b2\x1f.api.core.v1.PodDNSConf\
    igOptionR\x07options\">\n\x12PodDNSConfigOption\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\
    \"\xa0\x01\n\x0ePodExecOptions\x12\x14\n\x05stdin\x18\x01\x20\x01(\x08R\
    \x05stdin\x12\x16\n\x06stdout\x18\x02\x20\x01(\x08R\x06stdout\x12\x16\n\
    \x06stderr\x18\x03\x20\x01(\x08R\x06stderr\x12\x10\n\x03tty\x18\x04\x20\
    \x01(\x08R\x03tty\x12\x1c\n\tcontainer\x18\x05\x20\x01(\tR\tcontainer\
    \x12\x18\n\x07command\x18\x06\x20\x03(\tR\x07command\"\x17\n\x05PodIP\
    \x12\x0e\n\x02ip\x18\x01\x20\x01(\tR\x02ip\"v\n\x07PodList\x12C\n\x08met\
    adata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMetaR\x08\
    metadata\x12&\n\x05items\x18\x02\x20\x03(\x0b2\x10.api.core.v1.PodR\x05i\
    tems\"\xea\x02\n\rPodLogOptions\x12\x1c\n\tcontainer\x18\x01\x20\x01(\tR\
    \tcontainer\x12\x16\n\x06follow\x18\x02\x20\x01(\x08R\x06follow\x12\x1a\
    \n\x08previous\x18\x03\x20\x01(\x08R\x08previous\x12\"\n\x0csinceSeconds\
    \x18\x04\x20\x01(\x03R\x0csinceSeconds\x12A\n\tsinceTime\x18\x05\x20\x01\
    (\x0b2#.apimachinery.pkg.apis.meta.v1.TimeR\tsinceTime\x12\x1e\n\ntimest\
    amps\x18\x06\x20\x01(\x08R\ntimestamps\x12\x1c\n\ttailLines\x18\x07\x20\
    \x01(\x03R\ttailLines\x12\x1e\n\nlimitBytes\x18\x08\x20\x01(\x03R\nlimit\
    Bytes\x12B\n\x1cinsecureSkipTLSVerifyBackend\x18\t\x20\x01(\x08R\x1cinse\
    cureSkipTLSVerifyBackend\"\x1b\n\x05PodOS\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\"-\n\x15PodPortForwardOptions\x12\x14\n\x05ports\x18\
    \x01\x20\x03(\x05R\x05ports\"%\n\x0fPodProxyOptions\x12\x12\n\x04path\
    \x18\x01\x20\x01(\tR\x04path\"8\n\x10PodReadinessGate\x12$\n\rconditionT\
    ype\x18\x01\x20\x01(\tR\rconditionType\"X\n\x10PodResourceClaim\x12\x12\
    \n\x04name\x18\x01\x20\x01(\tR\x04name\x120\n\x06source\x18\x02\x20\x01(\
    \x0b2\x18.api.core.v1.ClaimSourceR\x06source\"Z\n\x16PodResourceClaimSta\
    tus\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12,\n\x11resourceClai\
    mName\x18\x02\x20\x01(\tR\x11resourceClaimName\"'\n\x11PodSchedulingGate\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"\xc7\x04\n\x12PodSecurit\
    yContext\x12C\n\x0eseLinuxOptions\x18\x01\x20\x01(\x0b2\x1b.api.core.v1.\
    SELinuxOptionsR\x0eseLinuxOptions\x12R\n\x0ewindowsOptions\x18\x08\x20\
    \x01(\x0b2*.api.core.v1.WindowsSecurityContextOptionsR\x0ewindowsOptions\
    \x12\x1c\n\trunAsUser\x18\x02\x20\x01(\x03R\trunAsUser\x12\x1e\n\nrunAsG\
    roup\x18\x06\x20\x01(\x03R\nrunAsGroup\x12\"\n\x0crunAsNonRoot\x18\x03\
    \x20\x01(\x08R\x0crunAsNonRoot\x12.\n\x12supplementalGroups\x18\x04\x20\
    \x03(\x03R\x12supplementalGroups\x12\x18\n\x07fsGroup\x18\x05\x20\x01(\
    \x03R\x07fsGroup\x12-\n\x07sysctls\x18\x07\x20\x03(\x0b2\x13.api.core.v1\
    .SysctlR\x07sysctls\x120\n\x13fsGroupChangePolicy\x18\t\x20\x01(\tR\x13f\
    sGroupChangePolicy\x12C\n\x0eseccompProfile\x18\n\x20\x01(\x0b2\x1b.api.\
    core.v1.SeccompProfileR\x0eseccompProfile\x12F\n\x0fappArmorProfile\x18\
    \x0b\x20\x01(\x0b2\x1c.api.core.v1.AppArmorProfileR\x0fappArmorProfile\"\
    c\n\x0cPodSignature\x12S\n\rpodController\x18\x01\x20\x01(\x0b2-.apimach\
    inery.pkg.apis.meta.v1.OwnerReferenceR\rpodController\"\x94\x11\n\x07Pod\
    Spec\x12-\n\x07volumes\x18\x01\x20\x03(\x0b2\x13.api.core.v1.VolumeR\x07\
    volumes\x12>\n\x0einitContainers\x18\x14\x20\x03(\x0b2\x16.api.core.v1.C\
    ontainerR\x0einitContainers\x126\n\ncontainers\x18\x02\x20\x03(\x0b2\x16\
    .api.core.v1.ContainerR\ncontainers\x12Q\n\x13ephemeralContainers\x18\"\
    \x20\x03(\x0b2\x1f.api.core.v1.EphemeralContainerR\x13ephemeralContainer\
    s\x12$\n\rrestartPolicy\x18\x03\x20\x01(\tR\rrestartPolicy\x12D\n\x1dter\
    minationGracePeriodSeconds\x18\x04\x20\x01(\x03R\x1dterminationGracePeri\
    odSeconds\x124\n\x15activeDeadlineSeconds\x18\x05\x20\x01(\x03R\x15activ\
    eDeadlineSeconds\x12\x1c\n\tdnsPolicy\x18\x06\x20\x01(\tR\tdnsPolicy\x12\
    J\n\x0cnodeSelector\x18\x07\x20\x03(\x0b2&.api.core.v1.PodSpec.NodeSelec\
    torEntryR\x0cnodeSelector\x12.\n\x12serviceAccountName\x18\x08\x20\x01(\
    \tR\x12serviceAccountName\x12&\n\x0eserviceAccount\x18\t\x20\x01(\tR\x0e\
    serviceAccount\x12B\n\x1cautomountServiceAccountToken\x18\x15\x20\x01(\
    \x08R\x1cautomountServiceAccountToken\x12\x1a\n\x08nodeName\x18\n\x20\
    \x01(\tR\x08nodeName\x12\x20\n\x0bhostNetwork\x18\x0b\x20\x01(\x08R\x0bh\
    ostNetwork\x12\x18\n\x07hostPID\x18\x0c\x20\x01(\x08R\x07hostPID\x12\x18\
    \n\x07hostIPC\x18\r\x20\x01(\x08R\x07hostIPC\x124\n\x15shareProcessNames\
    pace\x18\x1b\x20\x01(\x08R\x15shareProcessNamespace\x12I\n\x0fsecurityCo\
    ntext\x18\x0e\x20\x01(\x0b2\x1f.api.core.v1.PodSecurityContextR\x0fsecur\
    ityContext\x12M\n\x10imagePullSecrets\x18\x0f\x20\x03(\x0b2!.api.core.v1\
    .LocalObjectReferenceR\x10imagePullSecrets\x12\x1a\n\x08hostname\x18\x10\
    \x20\x01(\tR\x08hostname\x12\x1c\n\tsubdomain\x18\x11\x20\x01(\tR\tsubdo\
    main\x121\n\x08affinity\x18\x12\x20\x01(\x0b2\x15.api.core.v1.AffinityR\
    \x08affinity\x12$\n\rschedulerName\x18\x13\x20\x01(\tR\rschedulerName\
    \x129\n\x0btolerations\x18\x16\x20\x03(\x0b2\x17.api.core.v1.TolerationR\
    \x0btolerations\x128\n\x0bhostAliases\x18\x17\x20\x03(\x0b2\x16.api.core\
    .v1.HostAliasR\x0bhostAliases\x12,\n\x11priorityClassName\x18\x18\x20\
    \x01(\tR\x11priorityClassName\x12\x1a\n\x08priority\x18\x19\x20\x01(\x05\
    R\x08priority\x127\n\tdnsConfig\x18\x1a\x20\x01(\x0b2\x19.api.core.v1.Po\
    dDNSConfigR\tdnsConfig\x12E\n\x0ereadinessGates\x18\x1c\x20\x03(\x0b2\
    \x1d.api.core.v1.PodReadinessGateR\x0ereadinessGates\x12*\n\x10runtimeCl\
    assName\x18\x1d\x20\x01(\tR\x10runtimeClassName\x12.\n\x12enableServiceL\
    inks\x18\x1e\x20\x01(\x08R\x12enableServiceLinks\x12*\n\x10preemptionPol\
    icy\x18\x1f\x20\x01(\tR\x10preemptionPolicy\x12>\n\x08overhead\x18\x20\
    \x20\x03(\x0b2\".api.core.v1.PodSpec.OverheadEntryR\x08overhead\x12c\n\
    \x19topologySpreadConstraints\x18!\x20\x03(\x0b2%.api.core.v1.TopologySp\
    readConstraintR\x19topologySpreadConstraints\x12,\n\x11setHostnameAsFQDN\
    \x18#\x20\x01(\x08R\x11setHostnameAsFQDN\x12\"\n\x02os\x18$\x20\x01(\x0b\
    2\x12.api.core.v1.PodOSR\x02os\x12\x1c\n\thostUsers\x18%\x20\x01(\x08R\t\
    hostUsers\x12H\n\x0fschedulingGates\x18&\x20\x03(\x0b2\x1e.api.core.v1.P\
    odSchedulingGateR\x0fschedulingGates\x12E\n\x0eresourceClaims\x18'\x20\
    \x03(\x0b2\x1d.api.core.v1.PodResourceClaimR\x0eresourceClaims\x1a?\n\
    \x11NodeSelectorEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1ad\n\rOverheadE\
    ntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12=\n\x05value\x18\x02\
    \x20\x01(\x0b2'.apimachinery.pkg.api.resource.QuantityR\x05value:\x028\
    \x01\"\x95\x06\n\tPodStatus\x12\x14\n\x05phase\x18\x01\x20\x01(\tR\x05ph\
    ase\x129\n\nconditions\x18\x02\x20\x03(\x0b2\x19.api.core.v1.PodConditio\
    nR\nconditions\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07message\x12\
    \x16\n\x06reason\x18\x04\x20\x01(\tR\x06reason\x12,\n\x11nominatedNodeNa\
    me\x18\x0b\x20\x01(\tR\x11nominatedNodeName\x12\x16\n\x06hostIP\x18\x05\
    \x20\x01(\tR\x06hostIP\x12-\n\x07hostIPs\x18\x10\x20\x03(\x0b2\x13.api.c\
    ore.v1.HostIPR\x07hostIPs\x12\x14\n\x05podIP\x18\x06\x20\x01(\tR\x05podI\
    P\x12*\n\x06podIPs\x18\x0c\x20\x03(\x0b2\x12.api.core.v1.PodIPR\x06podIP\
    s\x12A\n\tstartTime\x18\x07\x20\x01(\x0b2#.apimachinery.pkg.apis.meta.v1\
    .TimeR\tstartTime\x12R\n\x15initContainerStatuses\x18\n\x20\x03(\x0b2\
    \x1c.api.core.v1.ContainerStatusR\x15initContainerStatuses\x12J\n\x11con\
    tainerStatuses\x18\x08\x20\x03(\x0b2\x1c.api.core.v1.ContainerStatusR\
    \x11containerStatuses\x12\x1a\n\x08qosClass\x18\t\x20\x01(\tR\x08qosClas\
    s\x12\\\n\x1aephemeralContainerStatuses\x18\r\x20\x03(\x0b2\x1c.api.core\
    .v1.ContainerStatusR\x1aephemeralContainerStatuses\x12\x16\n\x06resize\
    \x18\x0e\x20\x01(\tR\x06resize\x12Y\n\x15resourceClaimStatuses\x18\x0f\
    \x20\x03(\x0b2#.api.core.v1.PodResourceClaimStatusR\x15resourceClaimStat\
    uses\"\x88\x01\n\x0fPodStatusResult\x12E\n\x08metadata\x18\x01\x20\x01(\
    \x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12.\n\x06s\
    tatus\x18\x02\x20\x01(\x0b2\x16.api.core.v1.PodStatusR\x06status\"\x8e\
    \x01\n\x0bPodTemplate\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachi\
    nery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x128\n\x08template\x18\x02\
    \x20\x01(\x0b2\x1c.api.core.v1.PodTemplateSpecR\x08template\"\x86\x01\n\
    \x0fPodTemplateList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachine\
    ry.pkg.apis.meta.v1.ListMetaR\x08metadata\x12.\n\x05items\x18\x02\x20\
    \x03(\x0b2\x18.api.core.v1.PodTemplateR\x05items\"\x82\x01\n\x0fPodTempl\
    ateSpec\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.\
    meta.v1.ObjectMetaR\x08metadata\x12(\n\x04spec\x18\x02\x20\x01(\x0b2\x14\
    .api.core.v1.PodSpecR\x04spec\"R\n\nPortStatus\x12\x12\n\x04port\x18\x01\
    \x20\x01(\x05R\x04port\x12\x1a\n\x08protocol\x18\x02\x20\x01(\tR\x08prot\
    ocol\x12\x14\n\x05error\x18\x03\x20\x01(\tR\x05error\"f\n\x14PortworxVol\
    umeSource\x12\x1a\n\x08volumeID\x18\x01\x20\x01(\tR\x08volumeID\x12\x16\
    \n\x06fsType\x18\x02\x20\x01(\tR\x06fsType\x12\x1a\n\x08readOnly\x18\x03\
    \x20\x01(\x08R\x08readOnly\"!\n\rPreconditions\x12\x10\n\x03uid\x18\x01\
    \x20\x01(\tR\x03uid\"\xd0\x01\n\x14PreferAvoidPodsEntry\x12=\n\x0cpodSig\
    nature\x18\x01\x20\x01(\x0b2\x19.api.core.v1.PodSignatureR\x0cpodSignatu\
    re\x12G\n\x0cevictionTime\x18\x02\x20\x01(\x0b2#.apimachinery.pkg.apis.m\
    eta.v1.TimeR\x0cevictionTime\x12\x16\n\x06reason\x18\x03\x20\x01(\tR\x06\
    reason\x12\x18\n\x07message\x18\x04\x20\x01(\tR\x07message\"p\n\x17Prefe\
    rredSchedulingTerm\x12\x16\n\x06weight\x18\x01\x20\x01(\x05R\x06weight\
    \x12=\n\npreference\x18\x02\x20\x01(\x0b2\x1d.api.core.v1.NodeSelectorTe\
    rmR\npreference\"\xda\x02\n\x05Probe\x123\n\x07handler\x18\x01\x20\x01(\
    \x0b2\x19.api.core.v1.ProbeHandlerR\x07handler\x120\n\x13initialDelaySec\
    onds\x18\x02\x20\x01(\x05R\x13initialDelaySeconds\x12&\n\x0etimeoutSecon\
    ds\x18\x03\x20\x01(\x05R\x0etimeoutSeconds\x12$\n\rperiodSeconds\x18\x04\
    \x20\x01(\x05R\rperiodSeconds\x12*\n\x10successThreshold\x18\x05\x20\x01\
    (\x05R\x10successThreshold\x12*\n\x10failureThreshold\x18\x06\x20\x01(\
    \x05R\x10failureThreshold\x12D\n\x1dterminationGracePeriodSeconds\x18\
    \x07\x20\x01(\x03R\x1dterminationGracePeriodSeconds\"\xda\x01\n\x0cProbe\
    Handler\x12+\n\x04exec\x18\x01\x20\x01(\x0b2\x17.api.core.v1.ExecActionR\
    \x04exec\x124\n\x07httpGet\x18\x02\x20\x01(\x0b2\x1a.api.core.v1.HTTPGet\
    ActionR\x07httpGet\x12:\n\ttcpSocket\x18\x03\x20\x01(\x0b2\x1c.api.core.\
    v1.TCPSocketActionR\ttcpSocket\x12+\n\x04grpc\x18\x04\x20\x01(\x0b2\x17.\
    api.core.v1.GRPCActionR\x04grpc\"r\n\x15ProjectedVolumeSource\x127\n\x07\
    sources\x18\x01\x20\x03(\x0b2\x1d.api.core.v1.VolumeProjectionR\x07sourc\
    es\x12\x20\n\x0bdefaultMode\x18\x02\x20\x01(\x05R\x0bdefaultMode\"\xa7\
    \x01\n\x13QuobyteVolumeSource\x12\x1a\n\x08registry\x18\x01\x20\x01(\tR\
    \x08registry\x12\x16\n\x06volume\x18\x02\x20\x01(\tR\x06volume\x12\x1a\n\
    \x08readOnly\x18\x03\x20\x01(\x08R\x08readOnly\x12\x12\n\x04user\x18\x04\
    \x20\x01(\tR\x04user\x12\x14\n\x05group\x18\x05\x20\x01(\tR\x05group\x12\
    \x16\n\x06tenant\x18\x06\x20\x01(\tR\x06tenant\"\xff\x01\n\x19RBDPersist\
    entVolumeSource\x12\x1a\n\x08monitors\x18\x01\x20\x03(\tR\x08monitors\
    \x12\x14\n\x05image\x18\x02\x20\x01(\tR\x05image\x12\x16\n\x06fsType\x18\
    \x03\x20\x01(\tR\x06fsType\x12\x12\n\x04pool\x18\x04\x20\x01(\tR\x04pool\
    \x12\x12\n\x04user\x18\x05\x20\x01(\tR\x04user\x12\x18\n\x07keyring\x18\
    \x06\x20\x01(\tR\x07keyring\x12:\n\tsecretRef\x18\x07\x20\x01(\x0b2\x1c.\
    api.core.v1.SecretReferenceR\tsecretRef\x12\x1a\n\x08readOnly\x18\x08\
    \x20\x01(\x08R\x08readOnly\"\xfa\x01\n\x0fRBDVolumeSource\x12\x1a\n\x08m\
    onitors\x18\x01\x20\x03(\tR\x08monitors\x12\x14\n\x05image\x18\x02\x20\
    \x01(\tR\x05image\x12\x16\n\x06fsType\x18\x03\x20\x01(\tR\x06fsType\x12\
    \x12\n\x04pool\x18\x04\x20\x01(\tR\x04pool\x12\x12\n\x04user\x18\x05\x20\
    \x01(\tR\x04user\x12\x18\n\x07keyring\x18\x06\x20\x01(\tR\x07keyring\x12\
    ?\n\tsecretRef\x18\x07\x20\x01(\x0b2!.api.core.v1.LocalObjectReferenceR\
    \tsecretRef\x12\x1a\n\x08readOnly\x18\x08\x20\x01(\x08R\x08readOnly\"\
    \x82\x01\n\x0fRangeAllocation\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).\
    apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12\x14\n\x05range\
    \x18\x02\x20\x01(\tR\x05range\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\
    \x04data\"\xdc\x01\n\x15ReplicationController\x12E\n\x08metadata\x18\x01\
    \x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\
    \x12:\n\x04spec\x18\x02\x20\x01(\x0b2&.api.core.v1.ReplicationController\
    SpecR\x04spec\x12@\n\x06status\x18\x03\x20\x01(\x0b2(.api.core.v1.Replic\
    ationControllerStatusR\x06status\"\xd3\x01\n\x1eReplicationControllerCon\
    dition\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12\x16\n\x06status\
    \x18\x02\x20\x01(\tR\x06status\x12S\n\x12lastTransitionTime\x18\x03\x20\
    \x01(\x0b2#.apimachinery.pkg.apis.meta.v1.TimeR\x12lastTransitionTime\
    \x12\x16\n\x06reason\x18\x04\x20\x01(\tR\x06reason\x12\x18\n\x07message\
    \x18\x05\x20\x01(\tR\x07message\"\x9a\x01\n\x19ReplicationControllerList\
    \x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1\
    .ListMetaR\x08metadata\x128\n\x05items\x18\x02\x20\x03(\x0b2\".api.core.\
    v1.ReplicationControllerR\x05items\"\xaa\x02\n\x19ReplicationControllerS\
    pec\x12\x1a\n\x08replicas\x18\x01\x20\x01(\x05R\x08replicas\x12(\n\x0fmi\
    nReadySeconds\x18\x04\x20\x01(\x05R\x0fminReadySeconds\x12P\n\x08selecto\
    r\x18\x02\x20\x03(\x0b24.api.core.v1.ReplicationControllerSpec.SelectorE\
    ntryR\x08selector\x128\n\x08template\x18\x03\x20\x01(\x0b2\x1c.api.core.\
    v1.PodTemplateSpecR\x08template\x1a;\n\rSelectorEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\"\xbe\x02\n\x1bReplicationControllerStatus\x12\x1a\n\x08re\
    plicas\x18\x01\x20\x01(\x05R\x08replicas\x122\n\x14fullyLabeledReplicas\
    \x18\x02\x20\x01(\x05R\x14fullyLabeledReplicas\x12$\n\rreadyReplicas\x18\
    \x04\x20\x01(\x05R\rreadyReplicas\x12,\n\x11availableReplicas\x18\x05\
    \x20\x01(\x05R\x11availableReplicas\x12.\n\x12observedGeneration\x18\x03\
    \x20\x01(\x03R\x12observedGeneration\x12K\n\nconditions\x18\x06\x20\x03(\
    \x0b2+.api.core.v1.ReplicationControllerConditionR\nconditions\"#\n\rRes\
    ourceClaim\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"\x9c\x01\n\x15\
    ResourceFieldSelector\x12$\n\rcontainerName\x18\x01\x20\x01(\tR\rcontain\
    erName\x12\x1a\n\x08resource\x18\x02\x20\x01(\tR\x08resource\x12A\n\x07d\
    ivisor\x18\x03\x20\x01(\x0b2'.apimachinery.pkg.api.resource.QuantityR\
    \x07divisor\"\xc4\x01\n\rResourceQuota\x12E\n\x08metadata\x18\x01\x20\
    \x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x122\n\
    \x04spec\x18\x02\x20\x01(\x0b2\x1e.api.core.v1.ResourceQuotaSpecR\x04spe\
    c\x128\n\x06status\x18\x03\x20\x01(\x0b2\x20.api.core.v1.ResourceQuotaSt\
    atusR\x06status\"\x8a\x01\n\x11ResourceQuotaList\x12C\n\x08metadata\x18\
    \x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\
    \x120\n\x05items\x18\x02\x20\x03(\x0b2\x1a.api.core.v1.ResourceQuotaR\
    \x05items\"\x8d\x02\n\x11ResourceQuotaSpec\x12<\n\x04hard\x18\x01\x20\
    \x03(\x0b2(.api.core.v1.ResourceQuotaSpec.HardEntryR\x04hard\x12\x16\n\
    \x06scopes\x18\x02\x20\x03(\tR\x06scopes\x12@\n\rscopeSelector\x18\x03\
    \x20\x01(\x0b2\x1a.api.core.v1.ScopeSelectorR\rscopeSelector\x1a`\n\tHar\
    dEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12=\n\x05value\x18\
    \x02\x20\x01(\x0b2'.apimachinery.pkg.api.resource.QuantityR\x05value:\
    \x028\x01\"\xd9\x02\n\x13ResourceQuotaStatus\x12>\n\x04hard\x18\x01\x20\
    \x03(\x0b2*.api.core.v1.ResourceQuotaStatus.HardEntryR\x04hard\x12>\n\
    \x04used\x18\x02\x20\x03(\x0b2*.api.core.v1.ResourceQuotaStatus.UsedEntr\
    yR\x04used\x1a`\n\tHardEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12=\n\x05value\x18\x02\x20\x01(\x0b2'.apimachinery.pkg.api.resource.Qu\
    antityR\x05value:\x028\x01\x1a`\n\tUsedEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12=\n\x05value\x18\x02\x20\x01(\x0b2'.apimachinery.\
    pkg.api.resource.QuantityR\x05value:\x028\x01\"\xa8\x03\n\x14ResourceReq\
    uirements\x12E\n\x06limits\x18\x01\x20\x03(\x0b2-.api.core.v1.ResourceRe\
    quirements.LimitsEntryR\x06limits\x12K\n\x08requests\x18\x02\x20\x03(\
    \x0b2/.api.core.v1.ResourceRequirements.RequestsEntryR\x08requests\x122\
    \n\x06claims\x18\x03\x20\x03(\x0b2\x1a.api.core.v1.ResourceClaimR\x06cla\
    ims\x1ab\n\x0bLimitsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12=\n\x05value\x18\x02\x20\x01(\x0b2'.apimachinery.pkg.api.resource.Qu\
    antityR\x05value:\x028\x01\x1ad\n\rRequestsEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12=\n\x05value\x18\x02\x20\x01(\x0b2'.apimachin\
    ery.pkg.api.resource.QuantityR\x05value:\x028\x01\"b\n\x0eSELinuxOptions\
    \x12\x12\n\x04user\x18\x01\x20\x01(\tR\x04user\x12\x12\n\x04role\x18\x02\
    \x20\x01(\tR\x04role\x12\x12\n\x04type\x18\x03\x20\x01(\tR\x04type\x12\
    \x14\n\x05level\x18\x04\x20\x01(\tR\x05level\"\xf1\x02\n\x1dScaleIOPersi\
    stentVolumeSource\x12\x18\n\x07gateway\x18\x01\x20\x01(\tR\x07gateway\
    \x12\x16\n\x06system\x18\x02\x20\x01(\tR\x06system\x12:\n\tsecretRef\x18\
    \x03\x20\x01(\x0b2\x1c.api.core.v1.SecretReferenceR\tsecretRef\x12\x1e\n\
    \nsslEnabled\x18\x04\x20\x01(\x08R\nsslEnabled\x12*\n\x10protectionDomai\
    n\x18\x05\x20\x01(\tR\x10protectionDomain\x12\x20\n\x0bstoragePool\x18\
    \x06\x20\x01(\tR\x0bstoragePool\x12\x20\n\x0bstorageMode\x18\x07\x20\x01\
    (\tR\x0bstorageMode\x12\x1e\n\nvolumeName\x18\x08\x20\x01(\tR\nvolumeNam\
    e\x12\x16\n\x06fsType\x18\t\x20\x01(\tR\x06fsType\x12\x1a\n\x08readOnly\
    \x18\n\x20\x01(\x08R\x08readOnly\"\xec\x02\n\x13ScaleIOVolumeSource\x12\
    \x18\n\x07gateway\x18\x01\x20\x01(\tR\x07gateway\x12\x16\n\x06system\x18\
    \x02\x20\x01(\tR\x06system\x12?\n\tsecretRef\x18\x03\x20\x01(\x0b2!.api.\
    core.v1.LocalObjectReferenceR\tsecretRef\x12\x1e\n\nsslEnabled\x18\x04\
    \x20\x01(\x08R\nsslEnabled\x12*\n\x10protectionDomain\x18\x05\x20\x01(\t\
    R\x10protectionDomain\x12\x20\n\x0bstoragePool\x18\x06\x20\x01(\tR\x0bst\
    oragePool\x12\x20\n\x0bstorageMode\x18\x07\x20\x01(\tR\x0bstorageMode\
    \x12\x1e\n\nvolumeName\x18\x08\x20\x01(\tR\nvolumeName\x12\x16\n\x06fsTy\
    pe\x18\t\x20\x01(\tR\x06fsType\x12\x1a\n\x08readOnly\x18\n\x20\x01(\x08R\
    \x08readOnly\"k\n\rScopeSelector\x12Z\n\x10matchExpressions\x18\x01\x20\
    \x03(\x0b2..api.core.v1.ScopedResourceSelectorRequirementR\x10matchExpre\
    ssions\"u\n!ScopedResourceSelectorRequirement\x12\x1c\n\tscopeName\x18\
    \x01\x20\x01(\tR\tscopeName\x12\x1a\n\x08operator\x18\x02\x20\x01(\tR\
    \x08operator\x12\x16\n\x06values\x18\x03\x20\x03(\tR\x06values\"P\n\x0eS\
    eccompProfile\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12*\n\x10lo\
    calhostProfile\x18\x02\x20\x01(\tR\x10localhostProfile\"\xf1\x02\n\x06Se\
    cret\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.met\
    a.v1.ObjectMetaR\x08metadata\x12\x1c\n\timmutable\x18\x05\x20\x01(\x08R\
    \timmutable\x121\n\x04data\x18\x02\x20\x03(\x0b2\x1d.api.core.v1.Secret.\
    DataEntryR\x04data\x12C\n\nstringData\x18\x04\x20\x03(\x0b2#.api.core.v1\
    .Secret.StringDataEntryR\nstringData\x12\x12\n\x04type\x18\x03\x20\x01(\
    \tR\x04type\x1a7\n\tDataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03ke\
    y\x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\x05value:\x028\x01\x1a=\n\x0f\
    StringDataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\x84\x01\n\x0fSecretEn\
    vSource\x12U\n\x14localObjectReference\x18\x01\x20\x01(\x0b2!.api.core.v\
    1.LocalObjectReferenceR\x14localObjectReference\x12\x1a\n\x08optional\
    \x18\x02\x20\x01(\x08R\x08optional\"\x98\x01\n\x11SecretKeySelector\x12U\
    \n\x14localObjectReference\x18\x01\x20\x01(\x0b2!.api.core.v1.LocalObjec\
    tReferenceR\x14localObjectReference\x12\x10\n\x03key\x18\x02\x20\x01(\tR\
    \x03key\x12\x1a\n\x08optional\x18\x03\x20\x01(\x08R\x08optional\"|\n\nSe\
    cretList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis\
    .meta.v1.ListMetaR\x08metadata\x12)\n\x05items\x18\x02\x20\x03(\x0b2\x13\
    .api.core.v1.SecretR\x05items\"\xb3\x01\n\x10SecretProjection\x12U\n\x14\
    localObjectReference\x18\x01\x20\x01(\x0b2!.api.core.v1.LocalObjectRefer\
    enceR\x14localObjectReference\x12,\n\x05items\x18\x02\x20\x03(\x0b2\x16.\
    api.core.v1.KeyToPathR\x05items\x12\x1a\n\x08optional\x18\x04\x20\x01(\
    \x08R\x08optional\"C\n\x0fSecretReference\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12\x1c\n\tnamespace\x18\x02\x20\x01(\tR\tnamespace\"\
    \xa0\x01\n\x12SecretVolumeSource\x12\x1e\n\nsecretName\x18\x01\x20\x01(\
    \tR\nsecretName\x12,\n\x05items\x18\x02\x20\x03(\x0b2\x16.api.core.v1.Ke\
    yToPathR\x05items\x12\x20\n\x0bdefaultMode\x18\x03\x20\x01(\x05R\x0bdefa\
    ultMode\x12\x1a\n\x08optional\x18\x04\x20\x01(\x08R\x08optional\"\x8a\
    \x05\n\x0fSecurityContext\x12=\n\x0ccapabilities\x18\x01\x20\x01(\x0b2\
    \x19.api.core.v1.CapabilitiesR\x0ccapabilities\x12\x1e\n\nprivileged\x18\
    \x02\x20\x01(\x08R\nprivileged\x12C\n\x0eseLinuxOptions\x18\x03\x20\x01(\
    \x0b2\x1b.api.core.v1.SELinuxOptionsR\x0eseLinuxOptions\x12R\n\x0ewindow\
    sOptions\x18\n\x20\x01(\x0b2*.api.core.v1.WindowsSecurityContextOptionsR\
    \x0ewindowsOptions\x12\x1c\n\trunAsUser\x18\x04\x20\x01(\x03R\trunAsUser\
    \x12\x1e\n\nrunAsGroup\x18\x08\x20\x01(\x03R\nrunAsGroup\x12\"\n\x0crunA\
    sNonRoot\x18\x05\x20\x01(\x08R\x0crunAsNonRoot\x126\n\x16readOnlyRootFil\
    esystem\x18\x06\x20\x01(\x08R\x16readOnlyRootFilesystem\x12:\n\x18allowP\
    rivilegeEscalation\x18\x07\x20\x01(\x08R\x18allowPrivilegeEscalation\x12\
    \x1c\n\tprocMount\x18\t\x20\x01(\tR\tprocMount\x12C\n\x0eseccompProfile\
    \x18\x0b\x20\x01(\x0b2\x1b.api.core.v1.SeccompProfileR\x0eseccompProfile\
    \x12F\n\x0fappArmorProfile\x18\x0c\x20\x01(\x0b2\x1c.api.core.v1.AppArmo\
    rProfileR\x0fappArmorProfile\"Q\n\x13SerializedReference\x12:\n\treferen\
    ce\x18\x01\x20\x01(\x0b2\x1c.api.core.v1.ObjectReferenceR\treference\"\
    \xb2\x01\n\x07Service\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachi\
    nery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12,\n\x04spec\x18\x02\x20\
    \x01(\x0b2\x18.api.core.v1.ServiceSpecR\x04spec\x122\n\x06status\x18\x03\
    \x20\x01(\x0b2\x1a.api.core.v1.ServiceStatusR\x06status\"\xa2\x02\n\x0eS\
    erviceAccount\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachinery.pkg\
    .apis.meta.v1.ObjectMetaR\x08metadata\x126\n\x07secrets\x18\x02\x20\x03(\
    \x0b2\x1c.api.core.v1.ObjectReferenceR\x07secrets\x12M\n\x10imagePullSec\
    rets\x18\x03\x20\x03(\x0b2!.api.core.v1.LocalObjectReferenceR\x10imagePu\
    llSecrets\x12B\n\x1cautomountServiceAccountToken\x18\x04\x20\x01(\x08R\
    \x1cautomountServiceAccountToken\"\x8c\x01\n\x12ServiceAccountList\x12C\
    \n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.List\
    MetaR\x08metadata\x121\n\x05items\x18\x02\x20\x03(\x0b2\x1b.api.core.v1.\
    ServiceAccountR\x05items\"}\n\x1dServiceAccountTokenProjection\x12\x1a\n\
    \x08audience\x18\x01\x20\x01(\tR\x08audience\x12,\n\x11expirationSeconds\
    \x18\x02\x20\x01(\x03R\x11expirationSeconds\x12\x12\n\x04path\x18\x03\
    \x20\x01(\tR\x04path\"~\n\x0bServiceList\x12C\n\x08metadata\x18\x01\x20\
    \x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12*\n\
    \x05items\x18\x02\x20\x03(\x0b2\x14.api.core.v1.ServiceR\x05items\"\xda\
    \x01\n\x0bServicePort\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\
    \x1a\n\x08protocol\x18\x02\x20\x01(\tR\x08protocol\x12\x20\n\x0bappProto\
    col\x18\x06\x20\x01(\tR\x0bappProtocol\x12\x12\n\x04port\x18\x03\x20\x01\
    (\x05R\x04port\x12I\n\ntargetPort\x18\x04\x20\x01(\x0b2).apimachinery.pk\
    g.util.intstr.IntOrStringR\ntargetPort\x12\x1a\n\x08nodePort\x18\x05\x20\
    \x01(\x05R\x08nodePort\")\n\x13ServiceProxyOptions\x12\x12\n\x04path\x18\
    \x01\x20\x01(\tR\x04path\"\x86\x08\n\x0bServiceSpec\x12.\n\x05ports\x18\
    \x01\x20\x03(\x0b2\x18.api.core.v1.ServicePortR\x05ports\x12B\n\x08selec\
    tor\x18\x02\x20\x03(\x0b2&.api.core.v1.ServiceSpec.SelectorEntryR\x08sel\
    ector\x12\x1c\n\tclusterIP\x18\x03\x20\x01(\tR\tclusterIP\x12\x1e\n\nclu\
    sterIPs\x18\x12\x20\x03(\tR\nclusterIPs\x12\x12\n\x04type\x18\x04\x20\
    \x01(\tR\x04type\x12\x20\n\x0bexternalIPs\x18\x05\x20\x03(\tR\x0bexterna\
    lIPs\x12(\n\x0fsessionAffinity\x18\x07\x20\x01(\tR\x0fsessionAffinity\
    \x12&\n\x0eloadBalancerIP\x18\x08\x20\x01(\tR\x0eloadBalancerIP\x12:\n\
    \x18loadBalancerSourceRanges\x18\t\x20\x03(\tR\x18loadBalancerSourceRang\
    es\x12\"\n\x0cexternalName\x18\n\x20\x01(\tR\x0cexternalName\x124\n\x15e\
    xternalTrafficPolicy\x18\x0b\x20\x01(\tR\x15externalTrafficPolicy\x120\n\
    \x13healthCheckNodePort\x18\x0c\x20\x01(\x05R\x13healthCheckNodePort\x12\
    :\n\x18publishNotReadyAddresses\x18\r\x20\x01(\x08R\x18publishNotReadyAd\
    dresses\x12X\n\x15sessionAffinityConfig\x18\x0e\x20\x01(\x0b2\".api.core\
    .v1.SessionAffinityConfigR\x15sessionAffinityConfig\x12\x1e\n\nipFamilie\
    s\x18\x13\x20\x03(\tR\nipFamilies\x12&\n\x0eipFamilyPolicy\x18\x11\x20\
    \x01(\tR\x0eipFamilyPolicy\x12D\n\x1dallocateLoadBalancerNodePorts\x18\
    \x14\x20\x01(\x08R\x1dallocateLoadBalancerNodePorts\x12,\n\x11loadBalanc\
    erClass\x18\x15\x20\x01(\tR\x11loadBalancerClass\x124\n\x15internalTraff\
    icPolicy\x18\x16\x20\x01(\tR\x15internalTrafficPolicy\x120\n\x13trafficD\
    istribution\x18\x17\x20\x01(\tR\x13trafficDistribution\x1a;\n\rSelectorE\
    ntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\"\x9e\x01\n\rServiceStatus\x12C\n\
    \x0cloadBalancer\x18\x01\x20\x01(\x0b2\x1f.api.core.v1.LoadBalancerStatu\
    sR\x0cloadBalancer\x12H\n\nconditions\x18\x02\x20\x03(\x0b2(.apimachiner\
    y.pkg.apis.meta.v1.ConditionR\nconditions\"P\n\x15SessionAffinityConfig\
    \x127\n\x08clientIP\x18\x01\x20\x01(\x0b2\x1b.api.core.v1.ClientIPConfig\
    R\x08clientIP\"'\n\x0bSleepAction\x12\x18\n\x07seconds\x18\x01\x20\x01(\
    \x03R\x07seconds\"\xdb\x01\n\x1fStorageOSPersistentVolumeSource\x12\x1e\
    \n\nvolumeName\x18\x01\x20\x01(\tR\nvolumeName\x12(\n\x0fvolumeNamespace\
    \x18\x02\x20\x01(\tR\x0fvolumeNamespace\x12\x16\n\x06fsType\x18\x03\x20\
    \x01(\tR\x06fsType\x12\x1a\n\x08readOnly\x18\x04\x20\x01(\x08R\x08readOn\
    ly\x12:\n\tsecretRef\x18\x05\x20\x01(\x0b2\x1c.api.core.v1.ObjectReferen\
    ceR\tsecretRef\"\xd6\x01\n\x15StorageOSVolumeSource\x12\x1e\n\nvolumeNam\
    e\x18\x01\x20\x01(\tR\nvolumeName\x12(\n\x0fvolumeNamespace\x18\x02\x20\
    \x01(\tR\x0fvolumeNamespace\x12\x16\n\x06fsType\x18\x03\x20\x01(\tR\x06f\
    sType\x12\x1a\n\x08readOnly\x18\x04\x20\x01(\x08R\x08readOnly\x12?\n\tse\
    cretRef\x18\x05\x20\x01(\x0b2!.api.core.v1.LocalObjectReferenceR\tsecret\
    Ref\"2\n\x06Sysctl\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\
    \n\x05value\x18\x02\x20\x01(\tR\x05value\"d\n\x0fTCPSocketAction\x12=\n\
    \x04port\x18\x01\x20\x01(\x0b2).apimachinery.pkg.util.intstr.IntOrString\
    R\x04port\x12\x12\n\x04host\x18\x02\x20\x01(\tR\x04host\"\x8a\x01\n\x05T\
    aint\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value\x12\x16\n\x06effect\x18\x03\x20\x01(\tR\x06eff\
    ect\x12A\n\ttimeAdded\x18\x04\x20\x01(\x0b2#.apimachinery.pkg.apis.meta.\
    v1.TimeR\ttimeAdded\"\x96\x01\n\nToleration\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x1a\n\x08operator\x18\x02\x20\x01(\tR\x08operator\
    \x12\x14\n\x05value\x18\x03\x20\x01(\tR\x05value\x12\x16\n\x06effect\x18\
    \x04\x20\x01(\tR\x06effect\x12,\n\x11tolerationSeconds\x18\x05\x20\x01(\
    \x03R\x11tolerationSeconds\"L\n\x20TopologySelectorLabelRequirement\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x16\n\x06values\x18\x02\x20\
    \x03(\tR\x06values\"{\n\x14TopologySelectorTerm\x12c\n\x15matchLabelExpr\
    essions\x18\x01\x20\x03(\x0b2-.api.core.v1.TopologySelectorLabelRequirem\
    entR\x15matchLabelExpressions\"\xfc\x02\n\x18TopologySpreadConstraint\
    \x12\x18\n\x07maxSkew\x18\x01\x20\x01(\x05R\x07maxSkew\x12\x20\n\x0btopo\
    logyKey\x18\x02\x20\x01(\tR\x0btopologyKey\x12,\n\x11whenUnsatisfiable\
    \x18\x03\x20\x01(\tR\x11whenUnsatisfiable\x12R\n\rlabelSelector\x18\x04\
    \x20\x01(\x0b2,.apimachinery.pkg.apis.meta.v1.LabelSelectorR\rlabelSelec\
    tor\x12\x1e\n\nminDomains\x18\x05\x20\x01(\x05R\nminDomains\x12.\n\x12no\
    deAffinityPolicy\x18\x06\x20\x01(\tR\x12nodeAffinityPolicy\x12*\n\x10nod\
    eTaintsPolicy\x18\x07\x20\x01(\tR\x10nodeTaintsPolicy\x12&\n\x0ematchLab\
    elKeys\x18\x08\x20\x03(\tR\x0ematchLabelKeys\"_\n\x19TypedLocalObjectRef\
    erence\x12\x1a\n\x08apiGroup\x18\x01\x20\x01(\tR\x08apiGroup\x12\x12\n\
    \x04kind\x18\x02\x20\x01(\tR\x04kind\x12\x12\n\x04name\x18\x03\x20\x01(\
    \tR\x04name\"x\n\x14TypedObjectReference\x12\x1a\n\x08apiGroup\x18\x01\
    \x20\x01(\tR\x08apiGroup\x12\x12\n\x04kind\x18\x02\x20\x01(\tR\x04kind\
    \x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1c\n\tnamespace\x18\
    \x04\x20\x01(\tR\tnamespace\"[\n\x06Volume\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12=\n\x0cvolumeSource\x18\x02\x20\x01(\x0b2\x19.api.co\
    re.v1.VolumeSourceR\x0cvolumeSource\"B\n\x0cVolumeDevice\x12\x12\n\x04na\
    me\x18\x01\x20\x01(\tR\x04name\x12\x1e\n\ndevicePath\x18\x02\x20\x01(\tR\
    \ndevicePath\"\xf1\x01\n\x0bVolumeMount\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12\x1a\n\x08readOnly\x18\x02\x20\x01(\x08R\x08readOnly\
    \x12,\n\x11recursiveReadOnly\x18\x07\x20\x01(\tR\x11recursiveReadOnly\
    \x12\x1c\n\tmountPath\x18\x03\x20\x01(\tR\tmountPath\x12\x18\n\x07subPat\
    h\x18\x04\x20\x01(\tR\x07subPath\x12*\n\x10mountPropagation\x18\x05\x20\
    \x01(\tR\x10mountPropagation\x12\x20\n\x0bsubPathExpr\x18\x06\x20\x01(\t\
    R\x0bsubPathExpr\"\x8f\x01\n\x11VolumeMountStatus\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12\x1c\n\tmountPath\x18\x02\x20\x01(\tR\tmount\
    Path\x12\x1a\n\x08readOnly\x18\x03\x20\x01(\x08R\x08readOnly\x12,\n\x11r\
    ecursiveReadOnly\x18\x04\x20\x01(\tR\x11recursiveReadOnly\"K\n\x12Volume\
    NodeAffinity\x125\n\x08required\x18\x01\x20\x01(\x0b2\x19.api.core.v1.No\
    deSelectorR\x08required\"\x88\x03\n\x10VolumeProjection\x125\n\x06secret\
    \x18\x01\x20\x01(\x0b2\x1d.api.core.v1.SecretProjectionR\x06secret\x12D\
    \n\x0bdownwardAPI\x18\x02\x20\x01(\x0b2\".api.core.v1.DownwardAPIProject\
    ionR\x0bdownwardAPI\x12>\n\tconfigMap\x18\x03\x20\x01(\x0b2\x20.api.core\
    .v1.ConfigMapProjectionR\tconfigMap\x12\\\n\x13serviceAccountToken\x18\
    \x04\x20\x01(\x0b2*.api.core.v1.ServiceAccountTokenProjectionR\x13servic\
    eAccountToken\x12Y\n\x12clusterTrustBundle\x18\x05\x20\x01(\x0b2).api.co\
    re.v1.ClusterTrustBundleProjectionR\x12clusterTrustBundle\"\x86\x03\n\
    \x1aVolumeResourceRequirements\x12K\n\x06limits\x18\x01\x20\x03(\x0b23.a\
    pi.core.v1.VolumeResourceRequirements.LimitsEntryR\x06limits\x12Q\n\x08r\
    equests\x18\x02\x20\x03(\x0b25.api.core.v1.VolumeResourceRequirements.Re\
    questsEntryR\x08requests\x1ab\n\x0bLimitsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12=\n\x05value\x18\x02\x20\x01(\x0b2'.apimachinery.\
    pkg.api.resource.QuantityR\x05value:\x028\x01\x1ad\n\rRequestsEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12=\n\x05value\x18\x02\x20\x01\
    (\x0b2'.apimachinery.pkg.api.resource.QuantityR\x05value:\x028\x01\"\x93\
    \x0f\n\x0cVolumeSource\x12=\n\x08hostPath\x18\x01\x20\x01(\x0b2!.api.cor\
    e.v1.HostPathVolumeSourceR\x08hostPath\x12=\n\x08emptyDir\x18\x02\x20\
    \x01(\x0b2!.api.core.v1.EmptyDirVolumeSourceR\x08emptyDir\x12X\n\x11gceP\
    ersistentDisk\x18\x03\x20\x01(\x0b2*.api.core.v1.GCEPersistentDiskVolume\
    SourceR\x11gcePersistentDisk\x12a\n\x14awsElasticBlockStore\x18\x04\x20\
    \x01(\x0b2-.api.core.v1.AWSElasticBlockStoreVolumeSourceR\x14awsElasticB\
    lockStore\x12:\n\x07gitRepo\x18\x05\x20\x01(\x0b2\x20.api.core.v1.GitRep\
    oVolumeSourceR\x07gitRepo\x127\n\x06secret\x18\x06\x20\x01(\x0b2\x1f.api\
    .core.v1.SecretVolumeSourceR\x06secret\x12.\n\x03nfs\x18\x07\x20\x01(\
    \x0b2\x1c.api.core.v1.NFSVolumeSourceR\x03nfs\x124\n\x05iscsi\x18\x08\
    \x20\x01(\x0b2\x1e.api.core.v1.ISCSIVolumeSourceR\x05iscsi\x12@\n\tglust\
    erfs\x18\t\x20\x01(\x0b2\".api.core.v1.GlusterfsVolumeSourceR\tglusterfs\
    \x12d\n\x15persistentVolumeClaim\x18\n\x20\x01(\x0b2..api.core.v1.Persis\
    tentVolumeClaimVolumeSourceR\x15persistentVolumeClaim\x12.\n\x03rbd\x18\
    \x0b\x20\x01(\x0b2\x1c.api.core.v1.RBDVolumeSourceR\x03rbd\x12=\n\nflexV\
    olume\x18\x0c\x20\x01(\x0b2\x1d.api.core.v1.FlexVolumeSourceR\nflexVolum\
    e\x127\n\x06cinder\x18\r\x20\x01(\x0b2\x1f.api.core.v1.CinderVolumeSourc\
    eR\x06cinder\x127\n\x06cephfs\x18\x0e\x20\x01(\x0b2\x1f.api.core.v1.Ceph\
    FSVolumeSourceR\x06cephfs\x12:\n\x07flocker\x18\x0f\x20\x01(\x0b2\x20.ap\
    i.core.v1.FlockerVolumeSourceR\x07flocker\x12F\n\x0bdownwardAPI\x18\x10\
    \x20\x01(\x0b2$.api.core.v1.DownwardAPIVolumeSourceR\x0bdownwardAPI\x12+\
    \n\x02fc\x18\x11\x20\x01(\x0b2\x1b.api.core.v1.FCVolumeSourceR\x02fc\x12\
    @\n\tazureFile\x18\x12\x20\x01(\x0b2\".api.core.v1.AzureFileVolumeSource\
    R\tazureFile\x12@\n\tconfigMap\x18\x13\x20\x01(\x0b2\".api.core.v1.Confi\
    gMapVolumeSourceR\tconfigMap\x12Q\n\rvsphereVolume\x18\x14\x20\x01(\x0b2\
    +.api.core.v1.VsphereVirtualDiskVolumeSourceR\rvsphereVolume\x12:\n\x07q\
    uobyte\x18\x15\x20\x01(\x0b2\x20.api.core.v1.QuobyteVolumeSourceR\x07quo\
    byte\x12@\n\tazureDisk\x18\x16\x20\x01(\x0b2\".api.core.v1.AzureDiskVolu\
    meSourceR\tazureDisk\x12a\n\x14photonPersistentDisk\x18\x17\x20\x01(\x0b\
    2-.api.core.v1.PhotonPersistentDiskVolumeSourceR\x14photonPersistentDisk\
    \x12@\n\tprojected\x18\x1a\x20\x01(\x0b2\".api.core.v1.ProjectedVolumeSo\
    urceR\tprojected\x12I\n\x0eportworxVolume\x18\x18\x20\x01(\x0b2!.api.cor\
    e.v1.PortworxVolumeSourceR\x0eportworxVolume\x12:\n\x07scaleIO\x18\x19\
    \x20\x01(\x0b2\x20.api.core.v1.ScaleIOVolumeSourceR\x07scaleIO\x12@\n\ts\
    torageos\x18\x1b\x20\x01(\x0b2\".api.core.v1.StorageOSVolumeSourceR\tsto\
    rageos\x12.\n\x03csi\x18\x1c\x20\x01(\x0b2\x1c.api.core.v1.CSIVolumeSour\
    ceR\x03csi\x12@\n\tephemeral\x18\x1d\x20\x01(\x0b2\".api.core.v1.Ephemer\
    alVolumeSourceR\tephemeral\"\xb0\x01\n\x1eVsphereVirtualDiskVolumeSource\
    \x12\x1e\n\nvolumePath\x18\x01\x20\x01(\tR\nvolumePath\x12\x16\n\x06fsTy\
    pe\x18\x02\x20\x01(\tR\x06fsType\x12,\n\x11storagePolicyName\x18\x03\x20\
    \x01(\tR\x11storagePolicyName\x12(\n\x0fstoragePolicyID\x18\x04\x20\x01(\
    \tR\x0fstoragePolicyID\"y\n\x17WeightedPodAffinityTerm\x12\x16\n\x06weig\
    ht\x18\x01\x20\x01(\x05R\x06weight\x12F\n\x0fpodAffinityTerm\x18\x02\x20\
    \x01(\x0b2\x1c.api.core.v1.PodAffinityTermR\x0fpodAffinityTerm\"\xcf\x01\
    \n\x1dWindowsSecurityContextOptions\x126\n\x16gmsaCredentialSpecName\x18\
    \x01\x20\x01(\tR\x16gmsaCredentialSpecName\x12.\n\x12gmsaCredentialSpec\
    \x18\x02\x20\x01(\tR\x12gmsaCredentialSpec\x12$\n\rrunAsUserName\x18\x03\
    \x20\x01(\tR\rrunAsUserName\x12\x20\n\x0bhostProcess\x18\x04\x20\x01(\
    \x08R\x0bhostProcessB\x14Z\x12k8s.io/api/core/v1\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(5);
            deps.push(super::v1::file_descriptor().clone());
            deps.push(super::v1::file_descriptor().clone());
            deps.push(super::v1::file_descriptor().clone());
            deps.push(super::v1::file_descriptor().clone());
            deps.push(super::v1::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(225);
            messages.push(AWSElasticBlockStoreVolumeSource::generated_message_descriptor_data());
            messages.push(Affinity::generated_message_descriptor_data());
            messages.push(AppArmorProfile::generated_message_descriptor_data());
            messages.push(AttachedVolume::generated_message_descriptor_data());
            messages.push(AvoidPods::generated_message_descriptor_data());
            messages.push(AzureDiskVolumeSource::generated_message_descriptor_data());
            messages.push(AzureFilePersistentVolumeSource::generated_message_descriptor_data());
            messages.push(AzureFileVolumeSource::generated_message_descriptor_data());
            messages.push(Binding::generated_message_descriptor_data());
            messages.push(CSIPersistentVolumeSource::generated_message_descriptor_data());
            messages.push(CSIVolumeSource::generated_message_descriptor_data());
            messages.push(Capabilities::generated_message_descriptor_data());
            messages.push(CephFSPersistentVolumeSource::generated_message_descriptor_data());
            messages.push(CephFSVolumeSource::generated_message_descriptor_data());
            messages.push(CinderPersistentVolumeSource::generated_message_descriptor_data());
            messages.push(CinderVolumeSource::generated_message_descriptor_data());
            messages.push(ClaimSource::generated_message_descriptor_data());
            messages.push(ClientIPConfig::generated_message_descriptor_data());
            messages.push(ClusterTrustBundleProjection::generated_message_descriptor_data());
            messages.push(ComponentCondition::generated_message_descriptor_data());
            messages.push(ComponentStatus::generated_message_descriptor_data());
            messages.push(ComponentStatusList::generated_message_descriptor_data());
            messages.push(ConfigMap::generated_message_descriptor_data());
            messages.push(ConfigMapEnvSource::generated_message_descriptor_data());
            messages.push(ConfigMapKeySelector::generated_message_descriptor_data());
            messages.push(ConfigMapList::generated_message_descriptor_data());
            messages.push(ConfigMapNodeConfigSource::generated_message_descriptor_data());
            messages.push(ConfigMapProjection::generated_message_descriptor_data());
            messages.push(ConfigMapVolumeSource::generated_message_descriptor_data());
            messages.push(Container::generated_message_descriptor_data());
            messages.push(ContainerImage::generated_message_descriptor_data());
            messages.push(ContainerPort::generated_message_descriptor_data());
            messages.push(ContainerResizePolicy::generated_message_descriptor_data());
            messages.push(ContainerState::generated_message_descriptor_data());
            messages.push(ContainerStateRunning::generated_message_descriptor_data());
            messages.push(ContainerStateTerminated::generated_message_descriptor_data());
            messages.push(ContainerStateWaiting::generated_message_descriptor_data());
            messages.push(ContainerStatus::generated_message_descriptor_data());
            messages.push(DaemonEndpoint::generated_message_descriptor_data());
            messages.push(DownwardAPIProjection::generated_message_descriptor_data());
            messages.push(DownwardAPIVolumeFile::generated_message_descriptor_data());
            messages.push(DownwardAPIVolumeSource::generated_message_descriptor_data());
            messages.push(EmptyDirVolumeSource::generated_message_descriptor_data());
            messages.push(EndpointAddress::generated_message_descriptor_data());
            messages.push(EndpointPort::generated_message_descriptor_data());
            messages.push(EndpointSubset::generated_message_descriptor_data());
            messages.push(Endpoints::generated_message_descriptor_data());
            messages.push(EndpointsList::generated_message_descriptor_data());
            messages.push(EnvFromSource::generated_message_descriptor_data());
            messages.push(EnvVar::generated_message_descriptor_data());
            messages.push(EnvVarSource::generated_message_descriptor_data());
            messages.push(EphemeralContainer::generated_message_descriptor_data());
            messages.push(EphemeralContainerCommon::generated_message_descriptor_data());
            messages.push(EphemeralVolumeSource::generated_message_descriptor_data());
            messages.push(Event::generated_message_descriptor_data());
            messages.push(EventList::generated_message_descriptor_data());
            messages.push(EventSeries::generated_message_descriptor_data());
            messages.push(EventSource::generated_message_descriptor_data());
            messages.push(ExecAction::generated_message_descriptor_data());
            messages.push(FCVolumeSource::generated_message_descriptor_data());
            messages.push(FlexPersistentVolumeSource::generated_message_descriptor_data());
            messages.push(FlexVolumeSource::generated_message_descriptor_data());
            messages.push(FlockerVolumeSource::generated_message_descriptor_data());
            messages.push(GCEPersistentDiskVolumeSource::generated_message_descriptor_data());
            messages.push(GRPCAction::generated_message_descriptor_data());
            messages.push(GitRepoVolumeSource::generated_message_descriptor_data());
            messages.push(GlusterfsPersistentVolumeSource::generated_message_descriptor_data());
            messages.push(GlusterfsVolumeSource::generated_message_descriptor_data());
            messages.push(HTTPGetAction::generated_message_descriptor_data());
            messages.push(HTTPHeader::generated_message_descriptor_data());
            messages.push(HostAlias::generated_message_descriptor_data());
            messages.push(HostIP::generated_message_descriptor_data());
            messages.push(HostPathVolumeSource::generated_message_descriptor_data());
            messages.push(ISCSIPersistentVolumeSource::generated_message_descriptor_data());
            messages.push(ISCSIVolumeSource::generated_message_descriptor_data());
            messages.push(KeyToPath::generated_message_descriptor_data());
            messages.push(Lifecycle::generated_message_descriptor_data());
            messages.push(LifecycleHandler::generated_message_descriptor_data());
            messages.push(LimitRange::generated_message_descriptor_data());
            messages.push(LimitRangeItem::generated_message_descriptor_data());
            messages.push(LimitRangeList::generated_message_descriptor_data());
            messages.push(LimitRangeSpec::generated_message_descriptor_data());
            messages.push(List::generated_message_descriptor_data());
            messages.push(LoadBalancerIngress::generated_message_descriptor_data());
            messages.push(LoadBalancerStatus::generated_message_descriptor_data());
            messages.push(LocalObjectReference::generated_message_descriptor_data());
            messages.push(LocalVolumeSource::generated_message_descriptor_data());
            messages.push(ModifyVolumeStatus::generated_message_descriptor_data());
            messages.push(NFSVolumeSource::generated_message_descriptor_data());
            messages.push(Namespace::generated_message_descriptor_data());
            messages.push(NamespaceCondition::generated_message_descriptor_data());
            messages.push(NamespaceList::generated_message_descriptor_data());
            messages.push(NamespaceSpec::generated_message_descriptor_data());
            messages.push(NamespaceStatus::generated_message_descriptor_data());
            messages.push(Node::generated_message_descriptor_data());
            messages.push(NodeAddress::generated_message_descriptor_data());
            messages.push(NodeAffinity::generated_message_descriptor_data());
            messages.push(NodeCondition::generated_message_descriptor_data());
            messages.push(NodeConfigSource::generated_message_descriptor_data());
            messages.push(NodeConfigStatus::generated_message_descriptor_data());
            messages.push(NodeDaemonEndpoints::generated_message_descriptor_data());
            messages.push(NodeList::generated_message_descriptor_data());
            messages.push(NodeProxyOptions::generated_message_descriptor_data());
            messages.push(NodeRuntimeHandler::generated_message_descriptor_data());
            messages.push(NodeRuntimeHandlerFeatures::generated_message_descriptor_data());
            messages.push(NodeSelector::generated_message_descriptor_data());
            messages.push(NodeSelectorRequirement::generated_message_descriptor_data());
            messages.push(NodeSelectorTerm::generated_message_descriptor_data());
            messages.push(NodeSpec::generated_message_descriptor_data());
            messages.push(NodeStatus::generated_message_descriptor_data());
            messages.push(NodeSystemInfo::generated_message_descriptor_data());
            messages.push(ObjectFieldSelector::generated_message_descriptor_data());
            messages.push(ObjectReference::generated_message_descriptor_data());
            messages.push(PersistentVolume::generated_message_descriptor_data());
            messages.push(PersistentVolumeClaim::generated_message_descriptor_data());
            messages.push(PersistentVolumeClaimCondition::generated_message_descriptor_data());
            messages.push(PersistentVolumeClaimList::generated_message_descriptor_data());
            messages.push(PersistentVolumeClaimSpec::generated_message_descriptor_data());
            messages.push(PersistentVolumeClaimStatus::generated_message_descriptor_data());
            messages.push(PersistentVolumeClaimTemplate::generated_message_descriptor_data());
            messages.push(PersistentVolumeClaimVolumeSource::generated_message_descriptor_data());
            messages.push(PersistentVolumeList::generated_message_descriptor_data());
            messages.push(PersistentVolumeSource::generated_message_descriptor_data());
            messages.push(PersistentVolumeSpec::generated_message_descriptor_data());
            messages.push(PersistentVolumeStatus::generated_message_descriptor_data());
            messages.push(PhotonPersistentDiskVolumeSource::generated_message_descriptor_data());
            messages.push(Pod::generated_message_descriptor_data());
            messages.push(PodAffinity::generated_message_descriptor_data());
            messages.push(PodAffinityTerm::generated_message_descriptor_data());
            messages.push(PodAntiAffinity::generated_message_descriptor_data());
            messages.push(PodAttachOptions::generated_message_descriptor_data());
            messages.push(PodCondition::generated_message_descriptor_data());
            messages.push(PodDNSConfig::generated_message_descriptor_data());
            messages.push(PodDNSConfigOption::generated_message_descriptor_data());
            messages.push(PodExecOptions::generated_message_descriptor_data());
            messages.push(PodIP::generated_message_descriptor_data());
            messages.push(PodList::generated_message_descriptor_data());
            messages.push(PodLogOptions::generated_message_descriptor_data());
            messages.push(PodOS::generated_message_descriptor_data());
            messages.push(PodPortForwardOptions::generated_message_descriptor_data());
            messages.push(PodProxyOptions::generated_message_descriptor_data());
            messages.push(PodReadinessGate::generated_message_descriptor_data());
            messages.push(PodResourceClaim::generated_message_descriptor_data());
            messages.push(PodResourceClaimStatus::generated_message_descriptor_data());
            messages.push(PodSchedulingGate::generated_message_descriptor_data());
            messages.push(PodSecurityContext::generated_message_descriptor_data());
            messages.push(PodSignature::generated_message_descriptor_data());
            messages.push(PodSpec::generated_message_descriptor_data());
            messages.push(PodStatus::generated_message_descriptor_data());
            messages.push(PodStatusResult::generated_message_descriptor_data());
            messages.push(PodTemplate::generated_message_descriptor_data());
            messages.push(PodTemplateList::generated_message_descriptor_data());
            messages.push(PodTemplateSpec::generated_message_descriptor_data());
            messages.push(PortStatus::generated_message_descriptor_data());
            messages.push(PortworxVolumeSource::generated_message_descriptor_data());
            messages.push(Preconditions::generated_message_descriptor_data());
            messages.push(PreferAvoidPodsEntry::generated_message_descriptor_data());
            messages.push(PreferredSchedulingTerm::generated_message_descriptor_data());
            messages.push(Probe::generated_message_descriptor_data());
            messages.push(ProbeHandler::generated_message_descriptor_data());
            messages.push(ProjectedVolumeSource::generated_message_descriptor_data());
            messages.push(QuobyteVolumeSource::generated_message_descriptor_data());
            messages.push(RBDPersistentVolumeSource::generated_message_descriptor_data());
            messages.push(RBDVolumeSource::generated_message_descriptor_data());
            messages.push(RangeAllocation::generated_message_descriptor_data());
            messages.push(ReplicationController::generated_message_descriptor_data());
            messages.push(ReplicationControllerCondition::generated_message_descriptor_data());
            messages.push(ReplicationControllerList::generated_message_descriptor_data());
            messages.push(ReplicationControllerSpec::generated_message_descriptor_data());
            messages.push(ReplicationControllerStatus::generated_message_descriptor_data());
            messages.push(ResourceClaim::generated_message_descriptor_data());
            messages.push(ResourceFieldSelector::generated_message_descriptor_data());
            messages.push(ResourceQuota::generated_message_descriptor_data());
            messages.push(ResourceQuotaList::generated_message_descriptor_data());
            messages.push(ResourceQuotaSpec::generated_message_descriptor_data());
            messages.push(ResourceQuotaStatus::generated_message_descriptor_data());
            messages.push(ResourceRequirements::generated_message_descriptor_data());
            messages.push(SELinuxOptions::generated_message_descriptor_data());
            messages.push(ScaleIOPersistentVolumeSource::generated_message_descriptor_data());
            messages.push(ScaleIOVolumeSource::generated_message_descriptor_data());
            messages.push(ScopeSelector::generated_message_descriptor_data());
            messages.push(ScopedResourceSelectorRequirement::generated_message_descriptor_data());
            messages.push(SeccompProfile::generated_message_descriptor_data());
            messages.push(Secret::generated_message_descriptor_data());
            messages.push(SecretEnvSource::generated_message_descriptor_data());
            messages.push(SecretKeySelector::generated_message_descriptor_data());
            messages.push(SecretList::generated_message_descriptor_data());
            messages.push(SecretProjection::generated_message_descriptor_data());
            messages.push(SecretReference::generated_message_descriptor_data());
            messages.push(SecretVolumeSource::generated_message_descriptor_data());
            messages.push(SecurityContext::generated_message_descriptor_data());
            messages.push(SerializedReference::generated_message_descriptor_data());
            messages.push(Service::generated_message_descriptor_data());
            messages.push(ServiceAccount::generated_message_descriptor_data());
            messages.push(ServiceAccountList::generated_message_descriptor_data());
            messages.push(ServiceAccountTokenProjection::generated_message_descriptor_data());
            messages.push(ServiceList::generated_message_descriptor_data());
            messages.push(ServicePort::generated_message_descriptor_data());
            messages.push(ServiceProxyOptions::generated_message_descriptor_data());
            messages.push(ServiceSpec::generated_message_descriptor_data());
            messages.push(ServiceStatus::generated_message_descriptor_data());
            messages.push(SessionAffinityConfig::generated_message_descriptor_data());
            messages.push(SleepAction::generated_message_descriptor_data());
            messages.push(StorageOSPersistentVolumeSource::generated_message_descriptor_data());
            messages.push(StorageOSVolumeSource::generated_message_descriptor_data());
            messages.push(Sysctl::generated_message_descriptor_data());
            messages.push(TCPSocketAction::generated_message_descriptor_data());
            messages.push(Taint::generated_message_descriptor_data());
            messages.push(Toleration::generated_message_descriptor_data());
            messages.push(TopologySelectorLabelRequirement::generated_message_descriptor_data());
            messages.push(TopologySelectorTerm::generated_message_descriptor_data());
            messages.push(TopologySpreadConstraint::generated_message_descriptor_data());
            messages.push(TypedLocalObjectReference::generated_message_descriptor_data());
            messages.push(TypedObjectReference::generated_message_descriptor_data());
            messages.push(Volume::generated_message_descriptor_data());
            messages.push(VolumeDevice::generated_message_descriptor_data());
            messages.push(VolumeMount::generated_message_descriptor_data());
            messages.push(VolumeMountStatus::generated_message_descriptor_data());
            messages.push(VolumeNodeAffinity::generated_message_descriptor_data());
            messages.push(VolumeProjection::generated_message_descriptor_data());
            messages.push(VolumeResourceRequirements::generated_message_descriptor_data());
            messages.push(VolumeSource::generated_message_descriptor_data());
            messages.push(VsphereVirtualDiskVolumeSource::generated_message_descriptor_data());
            messages.push(WeightedPodAffinityTerm::generated_message_descriptor_data());
            messages.push(WindowsSecurityContextOptions::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
