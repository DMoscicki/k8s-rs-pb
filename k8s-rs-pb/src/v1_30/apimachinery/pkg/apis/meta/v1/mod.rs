// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc 30.2
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `apimachinery/pkg/apis/meta/v1/generated.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.APIGroup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct APIGroup {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.APIGroup.name)
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.APIGroup.versions)
    pub versions: ::std::vec::Vec<GroupVersionForDiscovery>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.APIGroup.preferredVersion)
    pub preferredVersion: ::protobuf::MessageField<GroupVersionForDiscovery>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.APIGroup.serverAddressByClientCIDRs)
    pub serverAddressByClientCIDRs: ::std::vec::Vec<ServerAddressByClientCIDR>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.APIGroup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a APIGroup {
    fn default() -> &'a APIGroup {
        <APIGroup as ::protobuf::Message>::default_instance()
    }
}

impl APIGroup {
    pub fn new() -> APIGroup {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;

    pub fn versions(&self) -> &[GroupVersionForDiscovery] {
        &self.versions
    }

    pub fn clear_versions(&mut self) {
        self.versions.clear();
    }

    // Param is passed by value, moved
    pub fn set_versions(&mut self, v: ::std::vec::Vec<GroupVersionForDiscovery>) {
        self.versions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_versions(&mut self) -> &mut ::std::vec::Vec<GroupVersionForDiscovery> {
        &mut self.versions
    }

    // Take field
    pub fn take_versions(&mut self) -> ::std::vec::Vec<GroupVersionForDiscovery> {
        ::std::mem::replace(&mut self.versions, ::std::vec::Vec::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery preferredVersion = 3;

    pub fn preferredVersion(&self) -> &GroupVersionForDiscovery {
        self.preferredVersion.as_ref().unwrap_or_else(|| <GroupVersionForDiscovery as ::protobuf::Message>::default_instance())
    }

    pub fn clear_preferredVersion(&mut self) {
        self.preferredVersion.clear();
    }

    pub fn has_preferredVersion(&self) -> bool {
        self.preferredVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferredVersion(&mut self, v: GroupVersionForDiscovery) {
        self.preferredVersion = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preferredVersion(&mut self) -> &mut GroupVersionForDiscovery {
        self.preferredVersion.mut_or_insert_default()
    }

    // Take field
    pub fn take_preferredVersion(&mut self) -> GroupVersionForDiscovery {
        self.preferredVersion.take().unwrap_or_else(|| GroupVersionForDiscovery::new())
    }

    // repeated .apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;

    pub fn serverAddressByClientCIDRs(&self) -> &[ServerAddressByClientCIDR] {
        &self.serverAddressByClientCIDRs
    }

    pub fn clear_serverAddressByClientCIDRs(&mut self) {
        self.serverAddressByClientCIDRs.clear();
    }

    // Param is passed by value, moved
    pub fn set_serverAddressByClientCIDRs(&mut self, v: ::std::vec::Vec<ServerAddressByClientCIDR>) {
        self.serverAddressByClientCIDRs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_serverAddressByClientCIDRs(&mut self) -> &mut ::std::vec::Vec<ServerAddressByClientCIDR> {
        &mut self.serverAddressByClientCIDRs
    }

    // Take field
    pub fn take_serverAddressByClientCIDRs(&mut self) -> ::std::vec::Vec<ServerAddressByClientCIDR> {
        ::std::mem::replace(&mut self.serverAddressByClientCIDRs, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &APIGroup| { &m.name },
            |m: &mut APIGroup| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "versions",
            |m: &APIGroup| { &m.versions },
            |m: &mut APIGroup| { &mut m.versions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GroupVersionForDiscovery>(
            "preferredVersion",
            |m: &APIGroup| { &m.preferredVersion },
            |m: &mut APIGroup| { &mut m.preferredVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "serverAddressByClientCIDRs",
            |m: &APIGroup| { &m.serverAddressByClientCIDRs },
            |m: &mut APIGroup| { &mut m.serverAddressByClientCIDRs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<APIGroup>(
            "APIGroup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for APIGroup {
    const NAME: &'static str = "APIGroup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.versions.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.preferredVersion)?;
                },
                34 => {
                    self.serverAddressByClientCIDRs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.preferredVersion.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.serverAddressByClientCIDRs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.versions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.preferredVersion.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.serverAddressByClientCIDRs {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> APIGroup {
        APIGroup::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.versions.clear();
        self.preferredVersion.clear();
        self.serverAddressByClientCIDRs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static APIGroup {
        static instance: APIGroup = APIGroup {
            name: ::std::option::Option::None,
            versions: ::std::vec::Vec::new(),
            preferredVersion: ::protobuf::MessageField::none(),
            serverAddressByClientCIDRs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for APIGroup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("APIGroup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for APIGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for APIGroup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.APIGroupList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct APIGroupList {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.APIGroupList.groups)
    pub groups: ::std::vec::Vec<APIGroup>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.APIGroupList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a APIGroupList {
    fn default() -> &'a APIGroupList {
        <APIGroupList as ::protobuf::Message>::default_instance()
    }
}

impl APIGroupList {
    pub fn new() -> APIGroupList {
        ::std::default::Default::default()
    }

    // repeated .apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;

    pub fn groups(&self) -> &[APIGroup] {
        &self.groups
    }

    pub fn clear_groups(&mut self) {
        self.groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_groups(&mut self, v: ::std::vec::Vec<APIGroup>) {
        self.groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_groups(&mut self) -> &mut ::std::vec::Vec<APIGroup> {
        &mut self.groups
    }

    // Take field
    pub fn take_groups(&mut self) -> ::std::vec::Vec<APIGroup> {
        ::std::mem::replace(&mut self.groups, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "groups",
            |m: &APIGroupList| { &m.groups },
            |m: &mut APIGroupList| { &mut m.groups },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<APIGroupList>(
            "APIGroupList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for APIGroupList {
    const NAME: &'static str = "APIGroupList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.groups.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.groups {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> APIGroupList {
        APIGroupList::new()
    }

    fn clear(&mut self) {
        self.groups.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static APIGroupList {
        static instance: APIGroupList = APIGroupList {
            groups: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for APIGroupList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("APIGroupList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for APIGroupList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for APIGroupList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.APIResource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct APIResource {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.APIResource.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.APIResource.singularName)
    pub singularName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.APIResource.namespaced)
    pub namespaced: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.APIResource.group)
    pub group: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.APIResource.version)
    pub version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.APIResource.kind)
    pub kind: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.APIResource.verbs)
    pub verbs: ::protobuf::MessageField<Verbs>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.APIResource.shortNames)
    pub shortNames: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.APIResource.categories)
    pub categories: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.APIResource.storageVersionHash)
    pub storageVersionHash: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.APIResource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a APIResource {
    fn default() -> &'a APIResource {
        <APIResource as ::protobuf::Message>::default_instance()
    }
}

impl APIResource {
    pub fn new() -> APIResource {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string singularName = 6;

    pub fn singularName(&self) -> &str {
        match self.singularName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_singularName(&mut self) {
        self.singularName = ::std::option::Option::None;
    }

    pub fn has_singularName(&self) -> bool {
        self.singularName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_singularName(&mut self, v: ::std::string::String) {
        self.singularName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_singularName(&mut self) -> &mut ::std::string::String {
        if self.singularName.is_none() {
            self.singularName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.singularName.as_mut().unwrap()
    }

    // Take field
    pub fn take_singularName(&mut self) -> ::std::string::String {
        self.singularName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool namespaced = 2;

    pub fn namespaced(&self) -> bool {
        self.namespaced.unwrap_or(false)
    }

    pub fn clear_namespaced(&mut self) {
        self.namespaced = ::std::option::Option::None;
    }

    pub fn has_namespaced(&self) -> bool {
        self.namespaced.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespaced(&mut self, v: bool) {
        self.namespaced = ::std::option::Option::Some(v);
    }

    // optional string group = 8;

    pub fn group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_group(&mut self) {
        self.group = ::std::option::Option::None;
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group = ::std::option::Option::Some(::std::string::String::new());
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 9;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kind = 3;

    pub fn kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Verbs verbs = 4;

    pub fn verbs(&self) -> &Verbs {
        self.verbs.as_ref().unwrap_or_else(|| <Verbs as ::protobuf::Message>::default_instance())
    }

    pub fn clear_verbs(&mut self) {
        self.verbs.clear();
    }

    pub fn has_verbs(&self) -> bool {
        self.verbs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_verbs(&mut self, v: Verbs) {
        self.verbs = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_verbs(&mut self) -> &mut Verbs {
        self.verbs.mut_or_insert_default()
    }

    // Take field
    pub fn take_verbs(&mut self) -> Verbs {
        self.verbs.take().unwrap_or_else(|| Verbs::new())
    }

    // repeated string shortNames = 5;

    pub fn shortNames(&self) -> &[::std::string::String] {
        &self.shortNames
    }

    pub fn clear_shortNames(&mut self) {
        self.shortNames.clear();
    }

    // Param is passed by value, moved
    pub fn set_shortNames(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.shortNames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_shortNames(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.shortNames
    }

    // Take field
    pub fn take_shortNames(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.shortNames, ::std::vec::Vec::new())
    }

    // repeated string categories = 7;

    pub fn categories(&self) -> &[::std::string::String] {
        &self.categories
    }

    pub fn clear_categories(&mut self) {
        self.categories.clear();
    }

    // Param is passed by value, moved
    pub fn set_categories(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.categories = v;
    }

    // Mutable pointer to the field.
    pub fn mut_categories(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.categories
    }

    // Take field
    pub fn take_categories(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.categories, ::std::vec::Vec::new())
    }

    // optional string storageVersionHash = 10;

    pub fn storageVersionHash(&self) -> &str {
        match self.storageVersionHash.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_storageVersionHash(&mut self) {
        self.storageVersionHash = ::std::option::Option::None;
    }

    pub fn has_storageVersionHash(&self) -> bool {
        self.storageVersionHash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageVersionHash(&mut self, v: ::std::string::String) {
        self.storageVersionHash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageVersionHash(&mut self) -> &mut ::std::string::String {
        if self.storageVersionHash.is_none() {
            self.storageVersionHash = ::std::option::Option::Some(::std::string::String::new());
        }
        self.storageVersionHash.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageVersionHash(&mut self) -> ::std::string::String {
        self.storageVersionHash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &APIResource| { &m.name },
            |m: &mut APIResource| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "singularName",
            |m: &APIResource| { &m.singularName },
            |m: &mut APIResource| { &mut m.singularName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "namespaced",
            |m: &APIResource| { &m.namespaced },
            |m: &mut APIResource| { &mut m.namespaced },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "group",
            |m: &APIResource| { &m.group },
            |m: &mut APIResource| { &mut m.group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &APIResource| { &m.version },
            |m: &mut APIResource| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &APIResource| { &m.kind },
            |m: &mut APIResource| { &mut m.kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Verbs>(
            "verbs",
            |m: &APIResource| { &m.verbs },
            |m: &mut APIResource| { &mut m.verbs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "shortNames",
            |m: &APIResource| { &m.shortNames },
            |m: &mut APIResource| { &mut m.shortNames },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "categories",
            |m: &APIResource| { &m.categories },
            |m: &mut APIResource| { &mut m.categories },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "storageVersionHash",
            |m: &APIResource| { &m.storageVersionHash },
            |m: &mut APIResource| { &mut m.storageVersionHash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<APIResource>(
            "APIResource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for APIResource {
    const NAME: &'static str = "APIResource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.singularName = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.namespaced = ::std::option::Option::Some(is.read_bool()?);
                },
                66 => {
                    self.group = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.kind = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.verbs)?;
                },
                42 => {
                    self.shortNames.push(is.read_string()?);
                },
                58 => {
                    self.categories.push(is.read_string()?);
                },
                82 => {
                    self.storageVersionHash = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.singularName.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.namespaced {
            my_size += 1 + 1;
        }
        if let Some(v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.verbs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.shortNames {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.categories {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.storageVersionHash.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.singularName.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.namespaced {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.group.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.kind.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.verbs.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for v in &self.shortNames {
            os.write_string(5, &v)?;
        };
        for v in &self.categories {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.storageVersionHash.as_ref() {
            os.write_string(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> APIResource {
        APIResource::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.singularName = ::std::option::Option::None;
        self.namespaced = ::std::option::Option::None;
        self.group = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.verbs.clear();
        self.shortNames.clear();
        self.categories.clear();
        self.storageVersionHash = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static APIResource {
        static instance: APIResource = APIResource {
            name: ::std::option::Option::None,
            singularName: ::std::option::Option::None,
            namespaced: ::std::option::Option::None,
            group: ::std::option::Option::None,
            version: ::std::option::Option::None,
            kind: ::std::option::Option::None,
            verbs: ::protobuf::MessageField::none(),
            shortNames: ::std::vec::Vec::new(),
            categories: ::std::vec::Vec::new(),
            storageVersionHash: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for APIResource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("APIResource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for APIResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for APIResource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.APIResourceList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct APIResourceList {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.APIResourceList.groupVersion)
    pub groupVersion: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.APIResourceList.resources)
    pub resources: ::std::vec::Vec<APIResource>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.APIResourceList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a APIResourceList {
    fn default() -> &'a APIResourceList {
        <APIResourceList as ::protobuf::Message>::default_instance()
    }
}

impl APIResourceList {
    pub fn new() -> APIResourceList {
        ::std::default::Default::default()
    }

    // optional string groupVersion = 1;

    pub fn groupVersion(&self) -> &str {
        match self.groupVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_groupVersion(&mut self) {
        self.groupVersion = ::std::option::Option::None;
    }

    pub fn has_groupVersion(&self) -> bool {
        self.groupVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupVersion(&mut self, v: ::std::string::String) {
        self.groupVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupVersion(&mut self) -> &mut ::std::string::String {
        if self.groupVersion.is_none() {
            self.groupVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.groupVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupVersion(&mut self) -> ::std::string::String {
        self.groupVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .apimachinery.pkg.apis.meta.v1.APIResource resources = 2;

    pub fn resources(&self) -> &[APIResource] {
        &self.resources
    }

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::std::vec::Vec<APIResource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources(&mut self) -> &mut ::std::vec::Vec<APIResource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::std::vec::Vec<APIResource> {
        ::std::mem::replace(&mut self.resources, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupVersion",
            |m: &APIResourceList| { &m.groupVersion },
            |m: &mut APIResourceList| { &mut m.groupVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resources",
            |m: &APIResourceList| { &m.resources },
            |m: &mut APIResourceList| { &mut m.resources },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<APIResourceList>(
            "APIResourceList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for APIResourceList {
    const NAME: &'static str = "APIResourceList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.groupVersion = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.resources.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.groupVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.resources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.groupVersion.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.resources {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> APIResourceList {
        APIResourceList::new()
    }

    fn clear(&mut self) {
        self.groupVersion = ::std::option::Option::None;
        self.resources.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static APIResourceList {
        static instance: APIResourceList = APIResourceList {
            groupVersion: ::std::option::Option::None,
            resources: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for APIResourceList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("APIResourceList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for APIResourceList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for APIResourceList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.APIVersions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct APIVersions {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.APIVersions.versions)
    pub versions: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.APIVersions.serverAddressByClientCIDRs)
    pub serverAddressByClientCIDRs: ::std::vec::Vec<ServerAddressByClientCIDR>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.APIVersions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a APIVersions {
    fn default() -> &'a APIVersions {
        <APIVersions as ::protobuf::Message>::default_instance()
    }
}

impl APIVersions {
    pub fn new() -> APIVersions {
        ::std::default::Default::default()
    }

    // repeated string versions = 1;

    pub fn versions(&self) -> &[::std::string::String] {
        &self.versions
    }

    pub fn clear_versions(&mut self) {
        self.versions.clear();
    }

    // Param is passed by value, moved
    pub fn set_versions(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.versions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_versions(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.versions
    }

    // Take field
    pub fn take_versions(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.versions, ::std::vec::Vec::new())
    }

    // repeated .apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;

    pub fn serverAddressByClientCIDRs(&self) -> &[ServerAddressByClientCIDR] {
        &self.serverAddressByClientCIDRs
    }

    pub fn clear_serverAddressByClientCIDRs(&mut self) {
        self.serverAddressByClientCIDRs.clear();
    }

    // Param is passed by value, moved
    pub fn set_serverAddressByClientCIDRs(&mut self, v: ::std::vec::Vec<ServerAddressByClientCIDR>) {
        self.serverAddressByClientCIDRs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_serverAddressByClientCIDRs(&mut self) -> &mut ::std::vec::Vec<ServerAddressByClientCIDR> {
        &mut self.serverAddressByClientCIDRs
    }

    // Take field
    pub fn take_serverAddressByClientCIDRs(&mut self) -> ::std::vec::Vec<ServerAddressByClientCIDR> {
        ::std::mem::replace(&mut self.serverAddressByClientCIDRs, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "versions",
            |m: &APIVersions| { &m.versions },
            |m: &mut APIVersions| { &mut m.versions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "serverAddressByClientCIDRs",
            |m: &APIVersions| { &m.serverAddressByClientCIDRs },
            |m: &mut APIVersions| { &mut m.serverAddressByClientCIDRs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<APIVersions>(
            "APIVersions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for APIVersions {
    const NAME: &'static str = "APIVersions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.versions.push(is.read_string()?);
                },
                18 => {
                    self.serverAddressByClientCIDRs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.versions {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.serverAddressByClientCIDRs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.versions {
            os.write_string(1, &v)?;
        };
        for v in &self.serverAddressByClientCIDRs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> APIVersions {
        APIVersions::new()
    }

    fn clear(&mut self) {
        self.versions.clear();
        self.serverAddressByClientCIDRs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static APIVersions {
        static instance: APIVersions = APIVersions {
            versions: ::std::vec::Vec::new(),
            serverAddressByClientCIDRs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for APIVersions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("APIVersions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for APIVersions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for APIVersions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.ApplyOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ApplyOptions {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ApplyOptions.dryRun)
    pub dryRun: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ApplyOptions.force)
    pub force: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ApplyOptions.fieldManager)
    pub fieldManager: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.ApplyOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ApplyOptions {
    fn default() -> &'a ApplyOptions {
        <ApplyOptions as ::protobuf::Message>::default_instance()
    }
}

impl ApplyOptions {
    pub fn new() -> ApplyOptions {
        ::std::default::Default::default()
    }

    // repeated string dryRun = 1;

    pub fn dryRun(&self) -> &[::std::string::String] {
        &self.dryRun
    }

    pub fn clear_dryRun(&mut self) {
        self.dryRun.clear();
    }

    // Param is passed by value, moved
    pub fn set_dryRun(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.dryRun = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dryRun(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.dryRun
    }

    // Take field
    pub fn take_dryRun(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.dryRun, ::std::vec::Vec::new())
    }

    // optional bool force = 2;

    pub fn force(&self) -> bool {
        self.force.unwrap_or(false)
    }

    pub fn clear_force(&mut self) {
        self.force = ::std::option::Option::None;
    }

    pub fn has_force(&self) -> bool {
        self.force.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force(&mut self, v: bool) {
        self.force = ::std::option::Option::Some(v);
    }

    // optional string fieldManager = 3;

    pub fn fieldManager(&self) -> &str {
        match self.fieldManager.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fieldManager(&mut self) {
        self.fieldManager = ::std::option::Option::None;
    }

    pub fn has_fieldManager(&self) -> bool {
        self.fieldManager.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldManager(&mut self, v: ::std::string::String) {
        self.fieldManager = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldManager(&mut self) -> &mut ::std::string::String {
        if self.fieldManager.is_none() {
            self.fieldManager = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fieldManager.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldManager(&mut self) -> ::std::string::String {
        self.fieldManager.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dryRun",
            |m: &ApplyOptions| { &m.dryRun },
            |m: &mut ApplyOptions| { &mut m.dryRun },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "force",
            |m: &ApplyOptions| { &m.force },
            |m: &mut ApplyOptions| { &mut m.force },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fieldManager",
            |m: &ApplyOptions| { &m.fieldManager },
            |m: &mut ApplyOptions| { &mut m.fieldManager },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ApplyOptions>(
            "ApplyOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ApplyOptions {
    const NAME: &'static str = "ApplyOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.dryRun.push(is.read_string()?);
                },
                16 => {
                    self.force = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.fieldManager = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.dryRun {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.force {
            my_size += 1 + 1;
        }
        if let Some(v) = self.fieldManager.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.dryRun {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.force {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.fieldManager.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ApplyOptions {
        ApplyOptions::new()
    }

    fn clear(&mut self) {
        self.dryRun.clear();
        self.force = ::std::option::Option::None;
        self.fieldManager = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ApplyOptions {
        static instance: ApplyOptions = ApplyOptions {
            dryRun: ::std::vec::Vec::new(),
            force: ::std::option::Option::None,
            fieldManager: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ApplyOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ApplyOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ApplyOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApplyOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.Condition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Condition {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.Condition.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.Condition.status)
    pub status: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.Condition.observedGeneration)
    pub observedGeneration: ::std::option::Option<i64>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.Condition.lastTransitionTime)
    pub lastTransitionTime: ::protobuf::MessageField<Time>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.Condition.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.Condition.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.Condition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Condition {
    fn default() -> &'a Condition {
        <Condition as ::protobuf::Message>::default_instance()
    }
}

impl Condition {
    pub fn new() -> Condition {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 observedGeneration = 3;

    pub fn observedGeneration(&self) -> i64 {
        self.observedGeneration.unwrap_or(0)
    }

    pub fn clear_observedGeneration(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
    }

    pub fn has_observedGeneration(&self) -> bool {
        self.observedGeneration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observedGeneration(&mut self, v: i64) {
        self.observedGeneration = ::std::option::Option::Some(v);
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;

    pub fn lastTransitionTime(&self) -> &Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: Time) {
        self.lastTransitionTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut Time {
        self.lastTransitionTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> Time {
        self.lastTransitionTime.take().unwrap_or_else(|| Time::new())
    }

    // optional string reason = 5;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 6;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &Condition| { &m.type_ },
            |m: &mut Condition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &Condition| { &m.status },
            |m: &mut Condition| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "observedGeneration",
            |m: &Condition| { &m.observedGeneration },
            |m: &mut Condition| { &mut m.observedGeneration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Time>(
            "lastTransitionTime",
            |m: &Condition| { &m.lastTransitionTime },
            |m: &mut Condition| { &mut m.lastTransitionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &Condition| { &m.reason },
            |m: &mut Condition| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &Condition| { &m.message },
            |m: &mut Condition| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Condition>(
            "Condition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Condition {
    const NAME: &'static str = "Condition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.observedGeneration = ::std::option::Option::Some(is.read_int64()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTransitionTime)?;
                },
                42 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.observedGeneration {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.observedGeneration {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Condition {
        Condition::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.observedGeneration = ::std::option::Option::None;
        self.lastTransitionTime.clear();
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Condition {
        static instance: Condition = Condition {
            type_: ::std::option::Option::None,
            status: ::std::option::Option::None,
            observedGeneration: ::std::option::Option::None,
            lastTransitionTime: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Condition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Condition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Condition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Condition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.CreateOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CreateOptions {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.CreateOptions.dryRun)
    pub dryRun: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.CreateOptions.fieldManager)
    pub fieldManager: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.CreateOptions.fieldValidation)
    pub fieldValidation: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.CreateOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateOptions {
    fn default() -> &'a CreateOptions {
        <CreateOptions as ::protobuf::Message>::default_instance()
    }
}

impl CreateOptions {
    pub fn new() -> CreateOptions {
        ::std::default::Default::default()
    }

    // repeated string dryRun = 1;

    pub fn dryRun(&self) -> &[::std::string::String] {
        &self.dryRun
    }

    pub fn clear_dryRun(&mut self) {
        self.dryRun.clear();
    }

    // Param is passed by value, moved
    pub fn set_dryRun(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.dryRun = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dryRun(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.dryRun
    }

    // Take field
    pub fn take_dryRun(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.dryRun, ::std::vec::Vec::new())
    }

    // optional string fieldManager = 3;

    pub fn fieldManager(&self) -> &str {
        match self.fieldManager.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fieldManager(&mut self) {
        self.fieldManager = ::std::option::Option::None;
    }

    pub fn has_fieldManager(&self) -> bool {
        self.fieldManager.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldManager(&mut self, v: ::std::string::String) {
        self.fieldManager = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldManager(&mut self) -> &mut ::std::string::String {
        if self.fieldManager.is_none() {
            self.fieldManager = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fieldManager.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldManager(&mut self) -> ::std::string::String {
        self.fieldManager.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fieldValidation = 4;

    pub fn fieldValidation(&self) -> &str {
        match self.fieldValidation.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fieldValidation(&mut self) {
        self.fieldValidation = ::std::option::Option::None;
    }

    pub fn has_fieldValidation(&self) -> bool {
        self.fieldValidation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldValidation(&mut self, v: ::std::string::String) {
        self.fieldValidation = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldValidation(&mut self) -> &mut ::std::string::String {
        if self.fieldValidation.is_none() {
            self.fieldValidation = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fieldValidation.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldValidation(&mut self) -> ::std::string::String {
        self.fieldValidation.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dryRun",
            |m: &CreateOptions| { &m.dryRun },
            |m: &mut CreateOptions| { &mut m.dryRun },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fieldManager",
            |m: &CreateOptions| { &m.fieldManager },
            |m: &mut CreateOptions| { &mut m.fieldManager },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fieldValidation",
            |m: &CreateOptions| { &m.fieldValidation },
            |m: &mut CreateOptions| { &mut m.fieldValidation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateOptions>(
            "CreateOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateOptions {
    const NAME: &'static str = "CreateOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.dryRun.push(is.read_string()?);
                },
                26 => {
                    self.fieldManager = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.fieldValidation = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.dryRun {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.fieldManager.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.fieldValidation.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.dryRun {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.fieldManager.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.fieldValidation.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateOptions {
        CreateOptions::new()
    }

    fn clear(&mut self) {
        self.dryRun.clear();
        self.fieldManager = ::std::option::Option::None;
        self.fieldValidation = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateOptions {
        static instance: CreateOptions = CreateOptions {
            dryRun: ::std::vec::Vec::new(),
            fieldManager: ::std::option::Option::None,
            fieldValidation: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.DeleteOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteOptions {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.DeleteOptions.gracePeriodSeconds)
    pub gracePeriodSeconds: ::std::option::Option<i64>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.DeleteOptions.preconditions)
    pub preconditions: ::protobuf::MessageField<Preconditions>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.DeleteOptions.orphanDependents)
    pub orphanDependents: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.DeleteOptions.propagationPolicy)
    pub propagationPolicy: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.DeleteOptions.dryRun)
    pub dryRun: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.DeleteOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteOptions {
    fn default() -> &'a DeleteOptions {
        <DeleteOptions as ::protobuf::Message>::default_instance()
    }
}

impl DeleteOptions {
    pub fn new() -> DeleteOptions {
        ::std::default::Default::default()
    }

    // optional int64 gracePeriodSeconds = 1;

    pub fn gracePeriodSeconds(&self) -> i64 {
        self.gracePeriodSeconds.unwrap_or(0)
    }

    pub fn clear_gracePeriodSeconds(&mut self) {
        self.gracePeriodSeconds = ::std::option::Option::None;
    }

    pub fn has_gracePeriodSeconds(&self) -> bool {
        self.gracePeriodSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gracePeriodSeconds(&mut self, v: i64) {
        self.gracePeriodSeconds = ::std::option::Option::Some(v);
    }

    // optional .apimachinery.pkg.apis.meta.v1.Preconditions preconditions = 2;

    pub fn preconditions(&self) -> &Preconditions {
        self.preconditions.as_ref().unwrap_or_else(|| <Preconditions as ::protobuf::Message>::default_instance())
    }

    pub fn clear_preconditions(&mut self) {
        self.preconditions.clear();
    }

    pub fn has_preconditions(&self) -> bool {
        self.preconditions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preconditions(&mut self, v: Preconditions) {
        self.preconditions = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preconditions(&mut self) -> &mut Preconditions {
        self.preconditions.mut_or_insert_default()
    }

    // Take field
    pub fn take_preconditions(&mut self) -> Preconditions {
        self.preconditions.take().unwrap_or_else(|| Preconditions::new())
    }

    // optional bool orphanDependents = 3;

    pub fn orphanDependents(&self) -> bool {
        self.orphanDependents.unwrap_or(false)
    }

    pub fn clear_orphanDependents(&mut self) {
        self.orphanDependents = ::std::option::Option::None;
    }

    pub fn has_orphanDependents(&self) -> bool {
        self.orphanDependents.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orphanDependents(&mut self, v: bool) {
        self.orphanDependents = ::std::option::Option::Some(v);
    }

    // optional string propagationPolicy = 4;

    pub fn propagationPolicy(&self) -> &str {
        match self.propagationPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_propagationPolicy(&mut self) {
        self.propagationPolicy = ::std::option::Option::None;
    }

    pub fn has_propagationPolicy(&self) -> bool {
        self.propagationPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_propagationPolicy(&mut self, v: ::std::string::String) {
        self.propagationPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_propagationPolicy(&mut self) -> &mut ::std::string::String {
        if self.propagationPolicy.is_none() {
            self.propagationPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.propagationPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_propagationPolicy(&mut self) -> ::std::string::String {
        self.propagationPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string dryRun = 5;

    pub fn dryRun(&self) -> &[::std::string::String] {
        &self.dryRun
    }

    pub fn clear_dryRun(&mut self) {
        self.dryRun.clear();
    }

    // Param is passed by value, moved
    pub fn set_dryRun(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.dryRun = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dryRun(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.dryRun
    }

    // Take field
    pub fn take_dryRun(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.dryRun, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gracePeriodSeconds",
            |m: &DeleteOptions| { &m.gracePeriodSeconds },
            |m: &mut DeleteOptions| { &mut m.gracePeriodSeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Preconditions>(
            "preconditions",
            |m: &DeleteOptions| { &m.preconditions },
            |m: &mut DeleteOptions| { &mut m.preconditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "orphanDependents",
            |m: &DeleteOptions| { &m.orphanDependents },
            |m: &mut DeleteOptions| { &mut m.orphanDependents },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "propagationPolicy",
            |m: &DeleteOptions| { &m.propagationPolicy },
            |m: &mut DeleteOptions| { &mut m.propagationPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dryRun",
            |m: &DeleteOptions| { &m.dryRun },
            |m: &mut DeleteOptions| { &mut m.dryRun },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteOptions>(
            "DeleteOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteOptions {
    const NAME: &'static str = "DeleteOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gracePeriodSeconds = ::std::option::Option::Some(is.read_int64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.preconditions)?;
                },
                24 => {
                    self.orphanDependents = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.propagationPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.dryRun.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gracePeriodSeconds {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.preconditions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.orphanDependents {
            my_size += 1 + 1;
        }
        if let Some(v) = self.propagationPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.dryRun {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gracePeriodSeconds {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.preconditions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.orphanDependents {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.propagationPolicy.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.dryRun {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteOptions {
        DeleteOptions::new()
    }

    fn clear(&mut self) {
        self.gracePeriodSeconds = ::std::option::Option::None;
        self.preconditions.clear();
        self.orphanDependents = ::std::option::Option::None;
        self.propagationPolicy = ::std::option::Option::None;
        self.dryRun.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteOptions {
        static instance: DeleteOptions = DeleteOptions {
            gracePeriodSeconds: ::std::option::Option::None,
            preconditions: ::protobuf::MessageField::none(),
            orphanDependents: ::std::option::Option::None,
            propagationPolicy: ::std::option::Option::None,
            dryRun: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.Duration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Duration {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.Duration.duration)
    pub duration: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.Duration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Duration {
    fn default() -> &'a Duration {
        <Duration as ::protobuf::Message>::default_instance()
    }
}

impl Duration {
    pub fn new() -> Duration {
        ::std::default::Default::default()
    }

    // optional int64 duration = 1;

    pub fn duration(&self) -> i64 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i64) {
        self.duration = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &Duration| { &m.duration },
            |m: &mut Duration| { &mut m.duration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Duration>(
            "Duration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Duration {
    const NAME: &'static str = "Duration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.duration = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.duration {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Duration {
        Duration::new()
    }

    fn clear(&mut self) {
        self.duration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Duration {
        static instance: Duration = Duration {
            duration: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Duration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Duration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Duration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Duration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.FieldsV1)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FieldsV1 {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.FieldsV1.Raw)
    pub Raw: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.FieldsV1.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FieldsV1 {
    fn default() -> &'a FieldsV1 {
        <FieldsV1 as ::protobuf::Message>::default_instance()
    }
}

impl FieldsV1 {
    pub fn new() -> FieldsV1 {
        ::std::default::Default::default()
    }

    // optional bytes Raw = 1;

    pub fn Raw(&self) -> &[u8] {
        match self.Raw.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_Raw(&mut self) {
        self.Raw = ::std::option::Option::None;
    }

    pub fn has_Raw(&self) -> bool {
        self.Raw.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Raw(&mut self, v: ::std::vec::Vec<u8>) {
        self.Raw = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Raw(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.Raw.is_none() {
            self.Raw = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.Raw.as_mut().unwrap()
    }

    // Take field
    pub fn take_Raw(&mut self) -> ::std::vec::Vec<u8> {
        self.Raw.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "Raw",
            |m: &FieldsV1| { &m.Raw },
            |m: &mut FieldsV1| { &mut m.Raw },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FieldsV1>(
            "FieldsV1",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FieldsV1 {
    const NAME: &'static str = "FieldsV1";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Raw = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.Raw.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.Raw.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FieldsV1 {
        FieldsV1::new()
    }

    fn clear(&mut self) {
        self.Raw = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FieldsV1 {
        static instance: FieldsV1 = FieldsV1 {
            Raw: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FieldsV1 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FieldsV1").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FieldsV1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FieldsV1 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.GetOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetOptions {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.GetOptions.resourceVersion)
    pub resourceVersion: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.GetOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetOptions {
    fn default() -> &'a GetOptions {
        <GetOptions as ::protobuf::Message>::default_instance()
    }
}

impl GetOptions {
    pub fn new() -> GetOptions {
        ::std::default::Default::default()
    }

    // optional string resourceVersion = 1;

    pub fn resourceVersion(&self) -> &str {
        match self.resourceVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resourceVersion(&mut self) {
        self.resourceVersion = ::std::option::Option::None;
    }

    pub fn has_resourceVersion(&self) -> bool {
        self.resourceVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceVersion(&mut self, v: ::std::string::String) {
        self.resourceVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceVersion(&mut self) -> &mut ::std::string::String {
        if self.resourceVersion.is_none() {
            self.resourceVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resourceVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceVersion(&mut self) -> ::std::string::String {
        self.resourceVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resourceVersion",
            |m: &GetOptions| { &m.resourceVersion },
            |m: &mut GetOptions| { &mut m.resourceVersion },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetOptions>(
            "GetOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetOptions {
    const NAME: &'static str = "GetOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.resourceVersion = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.resourceVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.resourceVersion.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetOptions {
        GetOptions::new()
    }

    fn clear(&mut self) {
        self.resourceVersion = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetOptions {
        static instance: GetOptions = GetOptions {
            resourceVersion: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.GroupKind)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GroupKind {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.GroupKind.group)
    pub group: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.GroupKind.kind)
    pub kind: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.GroupKind.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GroupKind {
    fn default() -> &'a GroupKind {
        <GroupKind as ::protobuf::Message>::default_instance()
    }
}

impl GroupKind {
    pub fn new() -> GroupKind {
        ::std::default::Default::default()
    }

    // optional string group = 1;

    pub fn group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_group(&mut self) {
        self.group = ::std::option::Option::None;
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group = ::std::option::Option::Some(::std::string::String::new());
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kind = 2;

    pub fn kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "group",
            |m: &GroupKind| { &m.group },
            |m: &mut GroupKind| { &mut m.group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &GroupKind| { &m.kind },
            |m: &mut GroupKind| { &mut m.kind },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupKind>(
            "GroupKind",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GroupKind {
    const NAME: &'static str = "GroupKind";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.group = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.kind = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.group.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.kind.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GroupKind {
        GroupKind::new()
    }

    fn clear(&mut self) {
        self.group = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GroupKind {
        static instance: GroupKind = GroupKind {
            group: ::std::option::Option::None,
            kind: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GroupKind {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GroupKind").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GroupKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupKind {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.GroupResource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GroupResource {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.GroupResource.group)
    pub group: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.GroupResource.resource)
    pub resource: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.GroupResource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GroupResource {
    fn default() -> &'a GroupResource {
        <GroupResource as ::protobuf::Message>::default_instance()
    }
}

impl GroupResource {
    pub fn new() -> GroupResource {
        ::std::default::Default::default()
    }

    // optional string group = 1;

    pub fn group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_group(&mut self) {
        self.group = ::std::option::Option::None;
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group = ::std::option::Option::Some(::std::string::String::new());
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resource = 2;

    pub fn resource(&self) -> &str {
        match self.resource.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resource(&mut self) {
        self.resource = ::std::option::Option::None;
    }

    pub fn has_resource(&self) -> bool {
        self.resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: ::std::string::String) {
        self.resource = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut ::std::string::String {
        if self.resource.is_none() {
            self.resource = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resource.as_mut().unwrap()
    }

    // Take field
    pub fn take_resource(&mut self) -> ::std::string::String {
        self.resource.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "group",
            |m: &GroupResource| { &m.group },
            |m: &mut GroupResource| { &mut m.group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resource",
            |m: &GroupResource| { &m.resource },
            |m: &mut GroupResource| { &mut m.resource },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupResource>(
            "GroupResource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GroupResource {
    const NAME: &'static str = "GroupResource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.group = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.resource = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.resource.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.group.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.resource.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GroupResource {
        GroupResource::new()
    }

    fn clear(&mut self) {
        self.group = ::std::option::Option::None;
        self.resource = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GroupResource {
        static instance: GroupResource = GroupResource {
            group: ::std::option::Option::None,
            resource: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GroupResource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GroupResource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GroupResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupResource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.GroupVersion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GroupVersion {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.GroupVersion.group)
    pub group: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.GroupVersion.version)
    pub version: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.GroupVersion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GroupVersion {
    fn default() -> &'a GroupVersion {
        <GroupVersion as ::protobuf::Message>::default_instance()
    }
}

impl GroupVersion {
    pub fn new() -> GroupVersion {
        ::std::default::Default::default()
    }

    // optional string group = 1;

    pub fn group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_group(&mut self) {
        self.group = ::std::option::Option::None;
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group = ::std::option::Option::Some(::std::string::String::new());
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 2;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "group",
            |m: &GroupVersion| { &m.group },
            |m: &mut GroupVersion| { &mut m.group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &GroupVersion| { &m.version },
            |m: &mut GroupVersion| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupVersion>(
            "GroupVersion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GroupVersion {
    const NAME: &'static str = "GroupVersion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.group = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.group.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GroupVersion {
        GroupVersion::new()
    }

    fn clear(&mut self) {
        self.group = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GroupVersion {
        static instance: GroupVersion = GroupVersion {
            group: ::std::option::Option::None,
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GroupVersion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GroupVersion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GroupVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupVersion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GroupVersionForDiscovery {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery.groupVersion)
    pub groupVersion: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery.version)
    pub version: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GroupVersionForDiscovery {
    fn default() -> &'a GroupVersionForDiscovery {
        <GroupVersionForDiscovery as ::protobuf::Message>::default_instance()
    }
}

impl GroupVersionForDiscovery {
    pub fn new() -> GroupVersionForDiscovery {
        ::std::default::Default::default()
    }

    // optional string groupVersion = 1;

    pub fn groupVersion(&self) -> &str {
        match self.groupVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_groupVersion(&mut self) {
        self.groupVersion = ::std::option::Option::None;
    }

    pub fn has_groupVersion(&self) -> bool {
        self.groupVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupVersion(&mut self, v: ::std::string::String) {
        self.groupVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupVersion(&mut self) -> &mut ::std::string::String {
        if self.groupVersion.is_none() {
            self.groupVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.groupVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupVersion(&mut self) -> ::std::string::String {
        self.groupVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 2;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupVersion",
            |m: &GroupVersionForDiscovery| { &m.groupVersion },
            |m: &mut GroupVersionForDiscovery| { &mut m.groupVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &GroupVersionForDiscovery| { &m.version },
            |m: &mut GroupVersionForDiscovery| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupVersionForDiscovery>(
            "GroupVersionForDiscovery",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GroupVersionForDiscovery {
    const NAME: &'static str = "GroupVersionForDiscovery";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.groupVersion = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.groupVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.groupVersion.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GroupVersionForDiscovery {
        GroupVersionForDiscovery::new()
    }

    fn clear(&mut self) {
        self.groupVersion = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GroupVersionForDiscovery {
        static instance: GroupVersionForDiscovery = GroupVersionForDiscovery {
            groupVersion: ::std::option::Option::None,
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GroupVersionForDiscovery {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GroupVersionForDiscovery").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GroupVersionForDiscovery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupVersionForDiscovery {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.GroupVersionKind)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GroupVersionKind {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.GroupVersionKind.group)
    pub group: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.GroupVersionKind.version)
    pub version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.GroupVersionKind.kind)
    pub kind: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.GroupVersionKind.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GroupVersionKind {
    fn default() -> &'a GroupVersionKind {
        <GroupVersionKind as ::protobuf::Message>::default_instance()
    }
}

impl GroupVersionKind {
    pub fn new() -> GroupVersionKind {
        ::std::default::Default::default()
    }

    // optional string group = 1;

    pub fn group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_group(&mut self) {
        self.group = ::std::option::Option::None;
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group = ::std::option::Option::Some(::std::string::String::new());
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 2;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kind = 3;

    pub fn kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "group",
            |m: &GroupVersionKind| { &m.group },
            |m: &mut GroupVersionKind| { &mut m.group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &GroupVersionKind| { &m.version },
            |m: &mut GroupVersionKind| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &GroupVersionKind| { &m.kind },
            |m: &mut GroupVersionKind| { &mut m.kind },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupVersionKind>(
            "GroupVersionKind",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GroupVersionKind {
    const NAME: &'static str = "GroupVersionKind";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.group = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.kind = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.group.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.kind.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GroupVersionKind {
        GroupVersionKind::new()
    }

    fn clear(&mut self) {
        self.group = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GroupVersionKind {
        static instance: GroupVersionKind = GroupVersionKind {
            group: ::std::option::Option::None,
            version: ::std::option::Option::None,
            kind: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GroupVersionKind {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GroupVersionKind").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GroupVersionKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupVersionKind {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.GroupVersionResource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GroupVersionResource {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.GroupVersionResource.group)
    pub group: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.GroupVersionResource.version)
    pub version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.GroupVersionResource.resource)
    pub resource: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.GroupVersionResource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GroupVersionResource {
    fn default() -> &'a GroupVersionResource {
        <GroupVersionResource as ::protobuf::Message>::default_instance()
    }
}

impl GroupVersionResource {
    pub fn new() -> GroupVersionResource {
        ::std::default::Default::default()
    }

    // optional string group = 1;

    pub fn group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_group(&mut self) {
        self.group = ::std::option::Option::None;
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group = ::std::option::Option::Some(::std::string::String::new());
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 2;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resource = 3;

    pub fn resource(&self) -> &str {
        match self.resource.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resource(&mut self) {
        self.resource = ::std::option::Option::None;
    }

    pub fn has_resource(&self) -> bool {
        self.resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: ::std::string::String) {
        self.resource = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut ::std::string::String {
        if self.resource.is_none() {
            self.resource = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resource.as_mut().unwrap()
    }

    // Take field
    pub fn take_resource(&mut self) -> ::std::string::String {
        self.resource.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "group",
            |m: &GroupVersionResource| { &m.group },
            |m: &mut GroupVersionResource| { &mut m.group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &GroupVersionResource| { &m.version },
            |m: &mut GroupVersionResource| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resource",
            |m: &GroupVersionResource| { &m.resource },
            |m: &mut GroupVersionResource| { &mut m.resource },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupVersionResource>(
            "GroupVersionResource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GroupVersionResource {
    const NAME: &'static str = "GroupVersionResource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.group = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.resource = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.resource.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.group.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.resource.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GroupVersionResource {
        GroupVersionResource::new()
    }

    fn clear(&mut self) {
        self.group = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.resource = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GroupVersionResource {
        static instance: GroupVersionResource = GroupVersionResource {
            group: ::std::option::Option::None,
            version: ::std::option::Option::None,
            resource: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GroupVersionResource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GroupVersionResource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GroupVersionResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupVersionResource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.LabelSelector)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LabelSelector {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.LabelSelector.matchLabels)
    pub matchLabels: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.LabelSelector.matchExpressions)
    pub matchExpressions: ::std::vec::Vec<LabelSelectorRequirement>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.LabelSelector.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LabelSelector {
    fn default() -> &'a LabelSelector {
        <LabelSelector as ::protobuf::Message>::default_instance()
    }
}

impl LabelSelector {
    pub fn new() -> LabelSelector {
        ::std::default::Default::default()
    }

    // repeated .apimachinery.pkg.apis.meta.v1.LabelSelector.MatchLabelsEntry matchLabels = 1;

    pub fn matchLabels(&self) -> &::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &self.matchLabels
    }

    pub fn clear_matchLabels(&mut self) {
        self.matchLabels.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchLabels(&mut self, v: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
        self.matchLabels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchLabels(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &mut self.matchLabels
    }

    // Take field
    pub fn take_matchLabels(&mut self) -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.matchLabels, ::std::collections::BTreeMap::new())
    }

    // repeated .apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;

    pub fn matchExpressions(&self) -> &[LabelSelectorRequirement] {
        &self.matchExpressions
    }

    pub fn clear_matchExpressions(&mut self) {
        self.matchExpressions.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchExpressions(&mut self, v: ::std::vec::Vec<LabelSelectorRequirement>) {
        self.matchExpressions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchExpressions(&mut self) -> &mut ::std::vec::Vec<LabelSelectorRequirement> {
        &mut self.matchExpressions
    }

    // Take field
    pub fn take_matchExpressions(&mut self) -> ::std::vec::Vec<LabelSelectorRequirement> {
        ::std::mem::replace(&mut self.matchExpressions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "matchLabels",
            |m: &LabelSelector| { &m.matchLabels },
            |m: &mut LabelSelector| { &mut m.matchLabels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matchExpressions",
            |m: &LabelSelector| { &m.matchExpressions },
            |m: &mut LabelSelector| { &mut m.matchExpressions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LabelSelector>(
            "LabelSelector",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LabelSelector {
    const NAME: &'static str = "LabelSelector";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.matchLabels.insert(key, value);
                },
                18 => {
                    self.matchExpressions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.matchLabels {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for value in &self.matchExpressions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.matchLabels {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for v in &self.matchExpressions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LabelSelector {
        LabelSelector::new()
    }

    fn clear(&mut self) {
        self.matchLabels.clear();
        self.matchExpressions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LabelSelector {
        static instance: ::protobuf::rt::Lazy<LabelSelector> = ::protobuf::rt::Lazy::new();
        instance.get(LabelSelector::new)
    }
}

impl ::protobuf::MessageFull for LabelSelector {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LabelSelector").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LabelSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelSelector {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LabelSelectorRequirement {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.operator)
    pub operator: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.values)
    pub values: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LabelSelectorRequirement {
    fn default() -> &'a LabelSelectorRequirement {
        <LabelSelectorRequirement as ::protobuf::Message>::default_instance()
    }
}

impl LabelSelectorRequirement {
    pub fn new() -> LabelSelectorRequirement {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string operator = 2;

    pub fn operator(&self) -> &str {
        match self.operator.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_operator(&mut self) {
        self.operator = ::std::option::Option::None;
    }

    pub fn has_operator(&self) -> bool {
        self.operator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operator(&mut self, v: ::std::string::String) {
        self.operator = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operator(&mut self) -> &mut ::std::string::String {
        if self.operator.is_none() {
            self.operator = ::std::option::Option::Some(::std::string::String::new());
        }
        self.operator.as_mut().unwrap()
    }

    // Take field
    pub fn take_operator(&mut self) -> ::std::string::String {
        self.operator.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string values = 3;

    pub fn values(&self) -> &[::std::string::String] {
        &self.values
    }

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &LabelSelectorRequirement| { &m.key },
            |m: &mut LabelSelectorRequirement| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "operator",
            |m: &LabelSelectorRequirement| { &m.operator },
            |m: &mut LabelSelectorRequirement| { &mut m.operator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &LabelSelectorRequirement| { &m.values },
            |m: &mut LabelSelectorRequirement| { &mut m.values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LabelSelectorRequirement>(
            "LabelSelectorRequirement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LabelSelectorRequirement {
    const NAME: &'static str = "LabelSelectorRequirement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.operator = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.values.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.operator.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.values {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.operator.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.values {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LabelSelectorRequirement {
        LabelSelectorRequirement::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.operator = ::std::option::Option::None;
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LabelSelectorRequirement {
        static instance: LabelSelectorRequirement = LabelSelectorRequirement {
            key: ::std::option::Option::None,
            operator: ::std::option::Option::None,
            values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LabelSelectorRequirement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LabelSelectorRequirement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LabelSelectorRequirement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelSelectorRequirement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.List)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct List {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.List.metadata)
    pub metadata: ::protobuf::MessageField<ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.List.items)
    pub items: ::std::vec::Vec<crate::v1_30::apimachinery::pkg::runtime::RawExtension>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.List.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a List {
    fn default() -> &'a List {
        <List as ::protobuf::Message>::default_instance()
    }
}

impl List {
    pub fn new() -> List {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ListMeta {
        self.metadata.take().unwrap_or_else(|| ListMeta::new())
    }

    // repeated .apimachinery.pkg.runtime.RawExtension items = 2;

    pub fn items(&self) -> &[crate::v1_30::apimachinery::pkg::runtime::RawExtension] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<crate::v1_30::apimachinery::pkg::runtime::RawExtension>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<crate::v1_30::apimachinery::pkg::runtime::RawExtension> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<crate::v1_30::apimachinery::pkg::runtime::RawExtension> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ListMeta>(
            "metadata",
            |m: &List| { &m.metadata },
            |m: &mut List| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &List| { &m.items },
            |m: &mut List| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<List>(
            "List",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for List {
    const NAME: &'static str = "List";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> List {
        List::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static List {
        static instance: List = List {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for List {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("List").unwrap()).clone()
    }
}

impl ::std::fmt::Display for List {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for List {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.ListMeta)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListMeta {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ListMeta.selfLink)
    pub selfLink: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ListMeta.resourceVersion)
    pub resourceVersion: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ListMeta.continue)
    pub continue_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ListMeta.remainingItemCount)
    pub remainingItemCount: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.ListMeta.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListMeta {
    fn default() -> &'a ListMeta {
        <ListMeta as ::protobuf::Message>::default_instance()
    }
}

impl ListMeta {
    pub fn new() -> ListMeta {
        ::std::default::Default::default()
    }

    // optional string selfLink = 1;

    pub fn selfLink(&self) -> &str {
        match self.selfLink.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_selfLink(&mut self) {
        self.selfLink = ::std::option::Option::None;
    }

    pub fn has_selfLink(&self) -> bool {
        self.selfLink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selfLink(&mut self, v: ::std::string::String) {
        self.selfLink = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selfLink(&mut self) -> &mut ::std::string::String {
        if self.selfLink.is_none() {
            self.selfLink = ::std::option::Option::Some(::std::string::String::new());
        }
        self.selfLink.as_mut().unwrap()
    }

    // Take field
    pub fn take_selfLink(&mut self) -> ::std::string::String {
        self.selfLink.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resourceVersion = 2;

    pub fn resourceVersion(&self) -> &str {
        match self.resourceVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resourceVersion(&mut self) {
        self.resourceVersion = ::std::option::Option::None;
    }

    pub fn has_resourceVersion(&self) -> bool {
        self.resourceVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceVersion(&mut self, v: ::std::string::String) {
        self.resourceVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceVersion(&mut self) -> &mut ::std::string::String {
        if self.resourceVersion.is_none() {
            self.resourceVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resourceVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceVersion(&mut self) -> ::std::string::String {
        self.resourceVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string continue = 3;

    pub fn continue_(&self) -> &str {
        match self.continue_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_continue_(&mut self) {
        self.continue_ = ::std::option::Option::None;
    }

    pub fn has_continue(&self) -> bool {
        self.continue_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_continue(&mut self, v: ::std::string::String) {
        self.continue_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_continue(&mut self) -> &mut ::std::string::String {
        if self.continue_.is_none() {
            self.continue_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.continue_.as_mut().unwrap()
    }

    // Take field
    pub fn take_continue_(&mut self) -> ::std::string::String {
        self.continue_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 remainingItemCount = 4;

    pub fn remainingItemCount(&self) -> i64 {
        self.remainingItemCount.unwrap_or(0)
    }

    pub fn clear_remainingItemCount(&mut self) {
        self.remainingItemCount = ::std::option::Option::None;
    }

    pub fn has_remainingItemCount(&self) -> bool {
        self.remainingItemCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remainingItemCount(&mut self, v: i64) {
        self.remainingItemCount = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selfLink",
            |m: &ListMeta| { &m.selfLink },
            |m: &mut ListMeta| { &mut m.selfLink },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resourceVersion",
            |m: &ListMeta| { &m.resourceVersion },
            |m: &mut ListMeta| { &mut m.resourceVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "continue",
            |m: &ListMeta| { &m.continue_ },
            |m: &mut ListMeta| { &mut m.continue_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "remainingItemCount",
            |m: &ListMeta| { &m.remainingItemCount },
            |m: &mut ListMeta| { &mut m.remainingItemCount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListMeta>(
            "ListMeta",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListMeta {
    const NAME: &'static str = "ListMeta";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.selfLink = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.resourceVersion = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.continue_ = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.remainingItemCount = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.selfLink.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.resourceVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.continue_.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.remainingItemCount {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.selfLink.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.resourceVersion.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.continue_.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.remainingItemCount {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListMeta {
        ListMeta::new()
    }

    fn clear(&mut self) {
        self.selfLink = ::std::option::Option::None;
        self.resourceVersion = ::std::option::Option::None;
        self.continue_ = ::std::option::Option::None;
        self.remainingItemCount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListMeta {
        static instance: ListMeta = ListMeta {
            selfLink: ::std::option::Option::None,
            resourceVersion: ::std::option::Option::None,
            continue_: ::std::option::Option::None,
            remainingItemCount: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListMeta {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListMeta").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListMeta {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.ListOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListOptions {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ListOptions.labelSelector)
    pub labelSelector: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ListOptions.fieldSelector)
    pub fieldSelector: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ListOptions.watch)
    pub watch: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ListOptions.allowWatchBookmarks)
    pub allowWatchBookmarks: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ListOptions.resourceVersion)
    pub resourceVersion: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ListOptions.resourceVersionMatch)
    pub resourceVersionMatch: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ListOptions.timeoutSeconds)
    pub timeoutSeconds: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ListOptions.limit)
    pub limit: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ListOptions.continue)
    pub continue_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ListOptions.sendInitialEvents)
    pub sendInitialEvents: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.ListOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListOptions {
    fn default() -> &'a ListOptions {
        <ListOptions as ::protobuf::Message>::default_instance()
    }
}

impl ListOptions {
    pub fn new() -> ListOptions {
        ::std::default::Default::default()
    }

    // optional string labelSelector = 1;

    pub fn labelSelector(&self) -> &str {
        match self.labelSelector.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_labelSelector(&mut self) {
        self.labelSelector = ::std::option::Option::None;
    }

    pub fn has_labelSelector(&self) -> bool {
        self.labelSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labelSelector(&mut self, v: ::std::string::String) {
        self.labelSelector = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labelSelector(&mut self) -> &mut ::std::string::String {
        if self.labelSelector.is_none() {
            self.labelSelector = ::std::option::Option::Some(::std::string::String::new());
        }
        self.labelSelector.as_mut().unwrap()
    }

    // Take field
    pub fn take_labelSelector(&mut self) -> ::std::string::String {
        self.labelSelector.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fieldSelector = 2;

    pub fn fieldSelector(&self) -> &str {
        match self.fieldSelector.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fieldSelector(&mut self) {
        self.fieldSelector = ::std::option::Option::None;
    }

    pub fn has_fieldSelector(&self) -> bool {
        self.fieldSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldSelector(&mut self, v: ::std::string::String) {
        self.fieldSelector = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldSelector(&mut self) -> &mut ::std::string::String {
        if self.fieldSelector.is_none() {
            self.fieldSelector = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fieldSelector.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldSelector(&mut self) -> ::std::string::String {
        self.fieldSelector.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool watch = 3;

    pub fn watch(&self) -> bool {
        self.watch.unwrap_or(false)
    }

    pub fn clear_watch(&mut self) {
        self.watch = ::std::option::Option::None;
    }

    pub fn has_watch(&self) -> bool {
        self.watch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watch(&mut self, v: bool) {
        self.watch = ::std::option::Option::Some(v);
    }

    // optional bool allowWatchBookmarks = 9;

    pub fn allowWatchBookmarks(&self) -> bool {
        self.allowWatchBookmarks.unwrap_or(false)
    }

    pub fn clear_allowWatchBookmarks(&mut self) {
        self.allowWatchBookmarks = ::std::option::Option::None;
    }

    pub fn has_allowWatchBookmarks(&self) -> bool {
        self.allowWatchBookmarks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allowWatchBookmarks(&mut self, v: bool) {
        self.allowWatchBookmarks = ::std::option::Option::Some(v);
    }

    // optional string resourceVersion = 4;

    pub fn resourceVersion(&self) -> &str {
        match self.resourceVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resourceVersion(&mut self) {
        self.resourceVersion = ::std::option::Option::None;
    }

    pub fn has_resourceVersion(&self) -> bool {
        self.resourceVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceVersion(&mut self, v: ::std::string::String) {
        self.resourceVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceVersion(&mut self) -> &mut ::std::string::String {
        if self.resourceVersion.is_none() {
            self.resourceVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resourceVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceVersion(&mut self) -> ::std::string::String {
        self.resourceVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resourceVersionMatch = 10;

    pub fn resourceVersionMatch(&self) -> &str {
        match self.resourceVersionMatch.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resourceVersionMatch(&mut self) {
        self.resourceVersionMatch = ::std::option::Option::None;
    }

    pub fn has_resourceVersionMatch(&self) -> bool {
        self.resourceVersionMatch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceVersionMatch(&mut self, v: ::std::string::String) {
        self.resourceVersionMatch = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceVersionMatch(&mut self) -> &mut ::std::string::String {
        if self.resourceVersionMatch.is_none() {
            self.resourceVersionMatch = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resourceVersionMatch.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceVersionMatch(&mut self) -> ::std::string::String {
        self.resourceVersionMatch.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 timeoutSeconds = 5;

    pub fn timeoutSeconds(&self) -> i64 {
        self.timeoutSeconds.unwrap_or(0)
    }

    pub fn clear_timeoutSeconds(&mut self) {
        self.timeoutSeconds = ::std::option::Option::None;
    }

    pub fn has_timeoutSeconds(&self) -> bool {
        self.timeoutSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeoutSeconds(&mut self, v: i64) {
        self.timeoutSeconds = ::std::option::Option::Some(v);
    }

    // optional int64 limit = 7;

    pub fn limit(&self) -> i64 {
        self.limit.unwrap_or(0)
    }

    pub fn clear_limit(&mut self) {
        self.limit = ::std::option::Option::None;
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i64) {
        self.limit = ::std::option::Option::Some(v);
    }

    // optional string continue = 8;

    pub fn continue_(&self) -> &str {
        match self.continue_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_continue_(&mut self) {
        self.continue_ = ::std::option::Option::None;
    }

    pub fn has_continue(&self) -> bool {
        self.continue_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_continue(&mut self, v: ::std::string::String) {
        self.continue_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_continue(&mut self) -> &mut ::std::string::String {
        if self.continue_.is_none() {
            self.continue_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.continue_.as_mut().unwrap()
    }

    // Take field
    pub fn take_continue_(&mut self) -> ::std::string::String {
        self.continue_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool sendInitialEvents = 11;

    pub fn sendInitialEvents(&self) -> bool {
        self.sendInitialEvents.unwrap_or(false)
    }

    pub fn clear_sendInitialEvents(&mut self) {
        self.sendInitialEvents = ::std::option::Option::None;
    }

    pub fn has_sendInitialEvents(&self) -> bool {
        self.sendInitialEvents.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sendInitialEvents(&mut self, v: bool) {
        self.sendInitialEvents = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "labelSelector",
            |m: &ListOptions| { &m.labelSelector },
            |m: &mut ListOptions| { &mut m.labelSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fieldSelector",
            |m: &ListOptions| { &m.fieldSelector },
            |m: &mut ListOptions| { &mut m.fieldSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "watch",
            |m: &ListOptions| { &m.watch },
            |m: &mut ListOptions| { &mut m.watch },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allowWatchBookmarks",
            |m: &ListOptions| { &m.allowWatchBookmarks },
            |m: &mut ListOptions| { &mut m.allowWatchBookmarks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resourceVersion",
            |m: &ListOptions| { &m.resourceVersion },
            |m: &mut ListOptions| { &mut m.resourceVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resourceVersionMatch",
            |m: &ListOptions| { &m.resourceVersionMatch },
            |m: &mut ListOptions| { &mut m.resourceVersionMatch },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timeoutSeconds",
            |m: &ListOptions| { &m.timeoutSeconds },
            |m: &mut ListOptions| { &mut m.timeoutSeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "limit",
            |m: &ListOptions| { &m.limit },
            |m: &mut ListOptions| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "continue",
            |m: &ListOptions| { &m.continue_ },
            |m: &mut ListOptions| { &mut m.continue_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sendInitialEvents",
            |m: &ListOptions| { &m.sendInitialEvents },
            |m: &mut ListOptions| { &mut m.sendInitialEvents },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListOptions>(
            "ListOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListOptions {
    const NAME: &'static str = "ListOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.labelSelector = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.fieldSelector = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.watch = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.allowWatchBookmarks = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.resourceVersion = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.resourceVersionMatch = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.timeoutSeconds = ::std::option::Option::Some(is.read_int64()?);
                },
                56 => {
                    self.limit = ::std::option::Option::Some(is.read_int64()?);
                },
                66 => {
                    self.continue_ = ::std::option::Option::Some(is.read_string()?);
                },
                88 => {
                    self.sendInitialEvents = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.labelSelector.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fieldSelector.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.watch {
            my_size += 1 + 1;
        }
        if let Some(v) = self.allowWatchBookmarks {
            my_size += 1 + 1;
        }
        if let Some(v) = self.resourceVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.resourceVersionMatch.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.timeoutSeconds {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.limit {
            my_size += ::protobuf::rt::int64_size(7, v);
        }
        if let Some(v) = self.continue_.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.sendInitialEvents {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.labelSelector.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.fieldSelector.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.watch {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.allowWatchBookmarks {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.resourceVersion.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.resourceVersionMatch.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.timeoutSeconds {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.limit {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.continue_.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.sendInitialEvents {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListOptions {
        ListOptions::new()
    }

    fn clear(&mut self) {
        self.labelSelector = ::std::option::Option::None;
        self.fieldSelector = ::std::option::Option::None;
        self.watch = ::std::option::Option::None;
        self.allowWatchBookmarks = ::std::option::Option::None;
        self.resourceVersion = ::std::option::Option::None;
        self.resourceVersionMatch = ::std::option::Option::None;
        self.timeoutSeconds = ::std::option::Option::None;
        self.limit = ::std::option::Option::None;
        self.continue_ = ::std::option::Option::None;
        self.sendInitialEvents = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListOptions {
        static instance: ListOptions = ListOptions {
            labelSelector: ::std::option::Option::None,
            fieldSelector: ::std::option::Option::None,
            watch: ::std::option::Option::None,
            allowWatchBookmarks: ::std::option::Option::None,
            resourceVersion: ::std::option::Option::None,
            resourceVersionMatch: ::std::option::Option::None,
            timeoutSeconds: ::std::option::Option::None,
            limit: ::std::option::Option::None,
            continue_: ::std::option::Option::None,
            sendInitialEvents: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ManagedFieldsEntry {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.manager)
    pub manager: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.operation)
    pub operation: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.apiVersion)
    pub apiVersion: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.time)
    pub time: ::protobuf::MessageField<Time>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.fieldsType)
    pub fieldsType: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.fieldsV1)
    pub fieldsV1: ::protobuf::MessageField<FieldsV1>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.subresource)
    pub subresource: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ManagedFieldsEntry {
    fn default() -> &'a ManagedFieldsEntry {
        <ManagedFieldsEntry as ::protobuf::Message>::default_instance()
    }
}

impl ManagedFieldsEntry {
    pub fn new() -> ManagedFieldsEntry {
        ::std::default::Default::default()
    }

    // optional string manager = 1;

    pub fn manager(&self) -> &str {
        match self.manager.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_manager(&mut self) {
        self.manager = ::std::option::Option::None;
    }

    pub fn has_manager(&self) -> bool {
        self.manager.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manager(&mut self, v: ::std::string::String) {
        self.manager = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_manager(&mut self) -> &mut ::std::string::String {
        if self.manager.is_none() {
            self.manager = ::std::option::Option::Some(::std::string::String::new());
        }
        self.manager.as_mut().unwrap()
    }

    // Take field
    pub fn take_manager(&mut self) -> ::std::string::String {
        self.manager.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string operation = 2;

    pub fn operation(&self) -> &str {
        match self.operation.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_operation(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: ::std::string::String) {
        self.operation = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation(&mut self) -> &mut ::std::string::String {
        if self.operation.is_none() {
            self.operation = ::std::option::Option::Some(::std::string::String::new());
        }
        self.operation.as_mut().unwrap()
    }

    // Take field
    pub fn take_operation(&mut self) -> ::std::string::String {
        self.operation.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string apiVersion = 3;

    pub fn apiVersion(&self) -> &str {
        match self.apiVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_apiVersion(&mut self) {
        self.apiVersion = ::std::option::Option::None;
    }

    pub fn has_apiVersion(&self) -> bool {
        self.apiVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiVersion(&mut self, v: ::std::string::String) {
        self.apiVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiVersion(&mut self) -> &mut ::std::string::String {
        if self.apiVersion.is_none() {
            self.apiVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.apiVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiVersion(&mut self) -> ::std::string::String {
        self.apiVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time time = 4;

    pub fn time(&self) -> &Time {
        self.time.as_ref().unwrap_or_else(|| <Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_time(&mut self) {
        self.time.clear();
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: Time) {
        self.time = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time(&mut self) -> &mut Time {
        self.time.mut_or_insert_default()
    }

    // Take field
    pub fn take_time(&mut self) -> Time {
        self.time.take().unwrap_or_else(|| Time::new())
    }

    // optional string fieldsType = 6;

    pub fn fieldsType(&self) -> &str {
        match self.fieldsType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fieldsType(&mut self) {
        self.fieldsType = ::std::option::Option::None;
    }

    pub fn has_fieldsType(&self) -> bool {
        self.fieldsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldsType(&mut self, v: ::std::string::String) {
        self.fieldsType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldsType(&mut self) -> &mut ::std::string::String {
        if self.fieldsType.is_none() {
            self.fieldsType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fieldsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldsType(&mut self) -> ::std::string::String {
        self.fieldsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.FieldsV1 fieldsV1 = 7;

    pub fn fieldsV1(&self) -> &FieldsV1 {
        self.fieldsV1.as_ref().unwrap_or_else(|| <FieldsV1 as ::protobuf::Message>::default_instance())
    }

    pub fn clear_fieldsV1(&mut self) {
        self.fieldsV1.clear();
    }

    pub fn has_fieldsV1(&self) -> bool {
        self.fieldsV1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldsV1(&mut self, v: FieldsV1) {
        self.fieldsV1 = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldsV1(&mut self) -> &mut FieldsV1 {
        self.fieldsV1.mut_or_insert_default()
    }

    // Take field
    pub fn take_fieldsV1(&mut self) -> FieldsV1 {
        self.fieldsV1.take().unwrap_or_else(|| FieldsV1::new())
    }

    // optional string subresource = 8;

    pub fn subresource(&self) -> &str {
        match self.subresource.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_subresource(&mut self) {
        self.subresource = ::std::option::Option::None;
    }

    pub fn has_subresource(&self) -> bool {
        self.subresource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subresource(&mut self, v: ::std::string::String) {
        self.subresource = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subresource(&mut self) -> &mut ::std::string::String {
        if self.subresource.is_none() {
            self.subresource = ::std::option::Option::Some(::std::string::String::new());
        }
        self.subresource.as_mut().unwrap()
    }

    // Take field
    pub fn take_subresource(&mut self) -> ::std::string::String {
        self.subresource.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "manager",
            |m: &ManagedFieldsEntry| { &m.manager },
            |m: &mut ManagedFieldsEntry| { &mut m.manager },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "operation",
            |m: &ManagedFieldsEntry| { &m.operation },
            |m: &mut ManagedFieldsEntry| { &mut m.operation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "apiVersion",
            |m: &ManagedFieldsEntry| { &m.apiVersion },
            |m: &mut ManagedFieldsEntry| { &mut m.apiVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Time>(
            "time",
            |m: &ManagedFieldsEntry| { &m.time },
            |m: &mut ManagedFieldsEntry| { &mut m.time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fieldsType",
            |m: &ManagedFieldsEntry| { &m.fieldsType },
            |m: &mut ManagedFieldsEntry| { &mut m.fieldsType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FieldsV1>(
            "fieldsV1",
            |m: &ManagedFieldsEntry| { &m.fieldsV1 },
            |m: &mut ManagedFieldsEntry| { &mut m.fieldsV1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subresource",
            |m: &ManagedFieldsEntry| { &m.subresource },
            |m: &mut ManagedFieldsEntry| { &mut m.subresource },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ManagedFieldsEntry>(
            "ManagedFieldsEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ManagedFieldsEntry {
    const NAME: &'static str = "ManagedFieldsEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.manager = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.operation = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.apiVersion = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.time)?;
                },
                50 => {
                    self.fieldsType = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fieldsV1)?;
                },
                66 => {
                    self.subresource = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.manager.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.operation.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.apiVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fieldsType.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.fieldsV1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.subresource.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.manager.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.operation.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.apiVersion.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.fieldsType.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.fieldsV1.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.subresource.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ManagedFieldsEntry {
        ManagedFieldsEntry::new()
    }

    fn clear(&mut self) {
        self.manager = ::std::option::Option::None;
        self.operation = ::std::option::Option::None;
        self.apiVersion = ::std::option::Option::None;
        self.time.clear();
        self.fieldsType = ::std::option::Option::None;
        self.fieldsV1.clear();
        self.subresource = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ManagedFieldsEntry {
        static instance: ManagedFieldsEntry = ManagedFieldsEntry {
            manager: ::std::option::Option::None,
            operation: ::std::option::Option::None,
            apiVersion: ::std::option::Option::None,
            time: ::protobuf::MessageField::none(),
            fieldsType: ::std::option::Option::None,
            fieldsV1: ::protobuf::MessageField::none(),
            subresource: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ManagedFieldsEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ManagedFieldsEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ManagedFieldsEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ManagedFieldsEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.MicroTime)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MicroTime {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.MicroTime.seconds)
    pub seconds: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.MicroTime.nanos)
    pub nanos: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.MicroTime.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MicroTime {
    fn default() -> &'a MicroTime {
        <MicroTime as ::protobuf::Message>::default_instance()
    }
}

impl MicroTime {
    pub fn new() -> MicroTime {
        ::std::default::Default::default()
    }

    // optional int64 seconds = 1;

    pub fn seconds(&self) -> i64 {
        self.seconds.unwrap_or(0)
    }

    pub fn clear_seconds(&mut self) {
        self.seconds = ::std::option::Option::None;
    }

    pub fn has_seconds(&self) -> bool {
        self.seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds(&mut self, v: i64) {
        self.seconds = ::std::option::Option::Some(v);
    }

    // optional int32 nanos = 2;

    pub fn nanos(&self) -> i32 {
        self.nanos.unwrap_or(0)
    }

    pub fn clear_nanos(&mut self) {
        self.nanos = ::std::option::Option::None;
    }

    pub fn has_nanos(&self) -> bool {
        self.nanos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nanos(&mut self, v: i32) {
        self.nanos = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds",
            |m: &MicroTime| { &m.seconds },
            |m: &mut MicroTime| { &mut m.seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nanos",
            |m: &MicroTime| { &m.nanos },
            |m: &mut MicroTime| { &mut m.nanos },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MicroTime>(
            "MicroTime",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MicroTime {
    const NAME: &'static str = "MicroTime";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.seconds = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.nanos = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.seconds {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.nanos {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.seconds {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.nanos {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MicroTime {
        MicroTime::new()
    }

    fn clear(&mut self) {
        self.seconds = ::std::option::Option::None;
        self.nanos = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MicroTime {
        static instance: MicroTime = MicroTime {
            seconds: ::std::option::Option::None,
            nanos: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MicroTime {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MicroTime").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MicroTime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MicroTime {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.ObjectMeta)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ObjectMeta {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ObjectMeta.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ObjectMeta.generateName)
    pub generateName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ObjectMeta.namespace)
    pub namespace: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ObjectMeta.selfLink)
    pub selfLink: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ObjectMeta.uid)
    pub uid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ObjectMeta.resourceVersion)
    pub resourceVersion: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ObjectMeta.generation)
    pub generation: ::std::option::Option<i64>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ObjectMeta.creationTimestamp)
    pub creationTimestamp: ::protobuf::MessageField<Time>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ObjectMeta.deletionTimestamp)
    pub deletionTimestamp: ::protobuf::MessageField<Time>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ObjectMeta.deletionGracePeriodSeconds)
    pub deletionGracePeriodSeconds: ::std::option::Option<i64>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ObjectMeta.labels)
    pub labels: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ObjectMeta.annotations)
    pub annotations: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ObjectMeta.ownerReferences)
    pub ownerReferences: ::std::vec::Vec<OwnerReference>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ObjectMeta.finalizers)
    pub finalizers: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ObjectMeta.managedFields)
    pub managedFields: ::std::vec::Vec<ManagedFieldsEntry>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.ObjectMeta.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ObjectMeta {
    fn default() -> &'a ObjectMeta {
        <ObjectMeta as ::protobuf::Message>::default_instance()
    }
}

impl ObjectMeta {
    pub fn new() -> ObjectMeta {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string generateName = 2;

    pub fn generateName(&self) -> &str {
        match self.generateName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_generateName(&mut self) {
        self.generateName = ::std::option::Option::None;
    }

    pub fn has_generateName(&self) -> bool {
        self.generateName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generateName(&mut self, v: ::std::string::String) {
        self.generateName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_generateName(&mut self) -> &mut ::std::string::String {
        if self.generateName.is_none() {
            self.generateName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.generateName.as_mut().unwrap()
    }

    // Take field
    pub fn take_generateName(&mut self) -> ::std::string::String {
        self.generateName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string namespace = 3;

    pub fn namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_namespace(&mut self) {
        self.namespace = ::std::option::Option::None;
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string selfLink = 4;

    pub fn selfLink(&self) -> &str {
        match self.selfLink.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_selfLink(&mut self) {
        self.selfLink = ::std::option::Option::None;
    }

    pub fn has_selfLink(&self) -> bool {
        self.selfLink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selfLink(&mut self, v: ::std::string::String) {
        self.selfLink = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selfLink(&mut self) -> &mut ::std::string::String {
        if self.selfLink.is_none() {
            self.selfLink = ::std::option::Option::Some(::std::string::String::new());
        }
        self.selfLink.as_mut().unwrap()
    }

    // Take field
    pub fn take_selfLink(&mut self) -> ::std::string::String {
        self.selfLink.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string uid = 5;

    pub fn uid(&self) -> &str {
        match self.uid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_uid(&mut self) {
        self.uid = ::std::option::Option::None;
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if self.uid.is_none() {
            self.uid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        self.uid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resourceVersion = 6;

    pub fn resourceVersion(&self) -> &str {
        match self.resourceVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resourceVersion(&mut self) {
        self.resourceVersion = ::std::option::Option::None;
    }

    pub fn has_resourceVersion(&self) -> bool {
        self.resourceVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceVersion(&mut self, v: ::std::string::String) {
        self.resourceVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceVersion(&mut self) -> &mut ::std::string::String {
        if self.resourceVersion.is_none() {
            self.resourceVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resourceVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceVersion(&mut self) -> ::std::string::String {
        self.resourceVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 generation = 7;

    pub fn generation(&self) -> i64 {
        self.generation.unwrap_or(0)
    }

    pub fn clear_generation(&mut self) {
        self.generation = ::std::option::Option::None;
    }

    pub fn has_generation(&self) -> bool {
        self.generation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generation(&mut self, v: i64) {
        self.generation = ::std::option::Option::Some(v);
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time creationTimestamp = 8;

    pub fn creationTimestamp(&self) -> &Time {
        self.creationTimestamp.as_ref().unwrap_or_else(|| <Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_creationTimestamp(&mut self) {
        self.creationTimestamp.clear();
    }

    pub fn has_creationTimestamp(&self) -> bool {
        self.creationTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creationTimestamp(&mut self, v: Time) {
        self.creationTimestamp = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creationTimestamp(&mut self) -> &mut Time {
        self.creationTimestamp.mut_or_insert_default()
    }

    // Take field
    pub fn take_creationTimestamp(&mut self) -> Time {
        self.creationTimestamp.take().unwrap_or_else(|| Time::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time deletionTimestamp = 9;

    pub fn deletionTimestamp(&self) -> &Time {
        self.deletionTimestamp.as_ref().unwrap_or_else(|| <Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_deletionTimestamp(&mut self) {
        self.deletionTimestamp.clear();
    }

    pub fn has_deletionTimestamp(&self) -> bool {
        self.deletionTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deletionTimestamp(&mut self, v: Time) {
        self.deletionTimestamp = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deletionTimestamp(&mut self) -> &mut Time {
        self.deletionTimestamp.mut_or_insert_default()
    }

    // Take field
    pub fn take_deletionTimestamp(&mut self) -> Time {
        self.deletionTimestamp.take().unwrap_or_else(|| Time::new())
    }

    // optional int64 deletionGracePeriodSeconds = 10;

    pub fn deletionGracePeriodSeconds(&self) -> i64 {
        self.deletionGracePeriodSeconds.unwrap_or(0)
    }

    pub fn clear_deletionGracePeriodSeconds(&mut self) {
        self.deletionGracePeriodSeconds = ::std::option::Option::None;
    }

    pub fn has_deletionGracePeriodSeconds(&self) -> bool {
        self.deletionGracePeriodSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deletionGracePeriodSeconds(&mut self, v: i64) {
        self.deletionGracePeriodSeconds = ::std::option::Option::Some(v);
    }

    // repeated .apimachinery.pkg.apis.meta.v1.ObjectMeta.LabelsEntry labels = 11;

    pub fn labels(&self) -> &::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &self.labels
    }

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::BTreeMap::new())
    }

    // repeated .apimachinery.pkg.apis.meta.v1.ObjectMeta.AnnotationsEntry annotations = 12;

    pub fn annotations(&self) -> &::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &self.annotations
    }

    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::std::collections::BTreeMap::new())
    }

    // repeated .apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;

    pub fn ownerReferences(&self) -> &[OwnerReference] {
        &self.ownerReferences
    }

    pub fn clear_ownerReferences(&mut self) {
        self.ownerReferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_ownerReferences(&mut self, v: ::std::vec::Vec<OwnerReference>) {
        self.ownerReferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ownerReferences(&mut self) -> &mut ::std::vec::Vec<OwnerReference> {
        &mut self.ownerReferences
    }

    // Take field
    pub fn take_ownerReferences(&mut self) -> ::std::vec::Vec<OwnerReference> {
        ::std::mem::replace(&mut self.ownerReferences, ::std::vec::Vec::new())
    }

    // repeated string finalizers = 14;

    pub fn finalizers(&self) -> &[::std::string::String] {
        &self.finalizers
    }

    pub fn clear_finalizers(&mut self) {
        self.finalizers.clear();
    }

    // Param is passed by value, moved
    pub fn set_finalizers(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.finalizers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_finalizers(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.finalizers
    }

    // Take field
    pub fn take_finalizers(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.finalizers, ::std::vec::Vec::new())
    }

    // repeated .apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;

    pub fn managedFields(&self) -> &[ManagedFieldsEntry] {
        &self.managedFields
    }

    pub fn clear_managedFields(&mut self) {
        self.managedFields.clear();
    }

    // Param is passed by value, moved
    pub fn set_managedFields(&mut self, v: ::std::vec::Vec<ManagedFieldsEntry>) {
        self.managedFields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_managedFields(&mut self) -> &mut ::std::vec::Vec<ManagedFieldsEntry> {
        &mut self.managedFields
    }

    // Take field
    pub fn take_managedFields(&mut self) -> ::std::vec::Vec<ManagedFieldsEntry> {
        ::std::mem::replace(&mut self.managedFields, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ObjectMeta| { &m.name },
            |m: &mut ObjectMeta| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "generateName",
            |m: &ObjectMeta| { &m.generateName },
            |m: &mut ObjectMeta| { &mut m.generateName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "namespace",
            |m: &ObjectMeta| { &m.namespace },
            |m: &mut ObjectMeta| { &mut m.namespace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selfLink",
            |m: &ObjectMeta| { &m.selfLink },
            |m: &mut ObjectMeta| { &mut m.selfLink },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uid",
            |m: &ObjectMeta| { &m.uid },
            |m: &mut ObjectMeta| { &mut m.uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resourceVersion",
            |m: &ObjectMeta| { &m.resourceVersion },
            |m: &mut ObjectMeta| { &mut m.resourceVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "generation",
            |m: &ObjectMeta| { &m.generation },
            |m: &mut ObjectMeta| { &mut m.generation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Time>(
            "creationTimestamp",
            |m: &ObjectMeta| { &m.creationTimestamp },
            |m: &mut ObjectMeta| { &mut m.creationTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Time>(
            "deletionTimestamp",
            |m: &ObjectMeta| { &m.deletionTimestamp },
            |m: &mut ObjectMeta| { &mut m.deletionTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deletionGracePeriodSeconds",
            |m: &ObjectMeta| { &m.deletionGracePeriodSeconds },
            |m: &mut ObjectMeta| { &mut m.deletionGracePeriodSeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "labels",
            |m: &ObjectMeta| { &m.labels },
            |m: &mut ObjectMeta| { &mut m.labels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "annotations",
            |m: &ObjectMeta| { &m.annotations },
            |m: &mut ObjectMeta| { &mut m.annotations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ownerReferences",
            |m: &ObjectMeta| { &m.ownerReferences },
            |m: &mut ObjectMeta| { &mut m.ownerReferences },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "finalizers",
            |m: &ObjectMeta| { &m.finalizers },
            |m: &mut ObjectMeta| { &mut m.finalizers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "managedFields",
            |m: &ObjectMeta| { &m.managedFields },
            |m: &mut ObjectMeta| { &mut m.managedFields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ObjectMeta>(
            "ObjectMeta",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ObjectMeta {
    const NAME: &'static str = "ObjectMeta";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.generateName = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.namespace = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.selfLink = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.uid = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.resourceVersion = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.generation = ::std::option::Option::Some(is.read_int64()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.creationTimestamp)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.deletionTimestamp)?;
                },
                80 => {
                    self.deletionGracePeriodSeconds = ::std::option::Option::Some(is.read_int64()?);
                },
                90 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.labels.insert(key, value);
                },
                98 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.annotations.insert(key, value);
                },
                106 => {
                    self.ownerReferences.push(is.read_message()?);
                },
                114 => {
                    self.finalizers.push(is.read_string()?);
                },
                138 => {
                    self.managedFields.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.generateName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.selfLink.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.uid.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.resourceVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.generation {
            my_size += ::protobuf::rt::int64_size(7, v);
        }
        if let Some(v) = self.creationTimestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.deletionTimestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.deletionGracePeriodSeconds {
            my_size += ::protobuf::rt::int64_size(10, v);
        }
        for (k, v) in &self.labels {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.annotations {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for value in &self.ownerReferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.finalizers {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        for value in &self.managedFields {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.generateName.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.namespace.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.selfLink.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.uid.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.resourceVersion.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.generation {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.creationTimestamp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.deletionTimestamp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.deletionGracePeriodSeconds {
            os.write_int64(10, v)?;
        }
        for (k, v) in &self.labels {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(90)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for (k, v) in &self.annotations {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(98)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for v in &self.ownerReferences {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        for v in &self.finalizers {
            os.write_string(14, &v)?;
        };
        for v in &self.managedFields {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ObjectMeta {
        ObjectMeta::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.generateName = ::std::option::Option::None;
        self.namespace = ::std::option::Option::None;
        self.selfLink = ::std::option::Option::None;
        self.uid = ::std::option::Option::None;
        self.resourceVersion = ::std::option::Option::None;
        self.generation = ::std::option::Option::None;
        self.creationTimestamp.clear();
        self.deletionTimestamp.clear();
        self.deletionGracePeriodSeconds = ::std::option::Option::None;
        self.labels.clear();
        self.annotations.clear();
        self.ownerReferences.clear();
        self.finalizers.clear();
        self.managedFields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ObjectMeta {
        static instance: ::protobuf::rt::Lazy<ObjectMeta> = ::protobuf::rt::Lazy::new();
        instance.get(ObjectMeta::new)
    }
}

impl ::protobuf::MessageFull for ObjectMeta {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ObjectMeta").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ObjectMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObjectMeta {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.OwnerReference)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OwnerReference {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.OwnerReference.apiVersion)
    pub apiVersion: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.OwnerReference.kind)
    pub kind: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.OwnerReference.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.OwnerReference.uid)
    pub uid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.OwnerReference.controller)
    pub controller: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.OwnerReference.blockOwnerDeletion)
    pub blockOwnerDeletion: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.OwnerReference.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OwnerReference {
    fn default() -> &'a OwnerReference {
        <OwnerReference as ::protobuf::Message>::default_instance()
    }
}

impl OwnerReference {
    pub fn new() -> OwnerReference {
        ::std::default::Default::default()
    }

    // optional string apiVersion = 5;

    pub fn apiVersion(&self) -> &str {
        match self.apiVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_apiVersion(&mut self) {
        self.apiVersion = ::std::option::Option::None;
    }

    pub fn has_apiVersion(&self) -> bool {
        self.apiVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiVersion(&mut self, v: ::std::string::String) {
        self.apiVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiVersion(&mut self) -> &mut ::std::string::String {
        if self.apiVersion.is_none() {
            self.apiVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.apiVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiVersion(&mut self) -> ::std::string::String {
        self.apiVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kind = 1;

    pub fn kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string uid = 4;

    pub fn uid(&self) -> &str {
        match self.uid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_uid(&mut self) {
        self.uid = ::std::option::Option::None;
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if self.uid.is_none() {
            self.uid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        self.uid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool controller = 6;

    pub fn controller(&self) -> bool {
        self.controller.unwrap_or(false)
    }

    pub fn clear_controller(&mut self) {
        self.controller = ::std::option::Option::None;
    }

    pub fn has_controller(&self) -> bool {
        self.controller.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller(&mut self, v: bool) {
        self.controller = ::std::option::Option::Some(v);
    }

    // optional bool blockOwnerDeletion = 7;

    pub fn blockOwnerDeletion(&self) -> bool {
        self.blockOwnerDeletion.unwrap_or(false)
    }

    pub fn clear_blockOwnerDeletion(&mut self) {
        self.blockOwnerDeletion = ::std::option::Option::None;
    }

    pub fn has_blockOwnerDeletion(&self) -> bool {
        self.blockOwnerDeletion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockOwnerDeletion(&mut self, v: bool) {
        self.blockOwnerDeletion = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "apiVersion",
            |m: &OwnerReference| { &m.apiVersion },
            |m: &mut OwnerReference| { &mut m.apiVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &OwnerReference| { &m.kind },
            |m: &mut OwnerReference| { &mut m.kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &OwnerReference| { &m.name },
            |m: &mut OwnerReference| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uid",
            |m: &OwnerReference| { &m.uid },
            |m: &mut OwnerReference| { &mut m.uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "controller",
            |m: &OwnerReference| { &m.controller },
            |m: &mut OwnerReference| { &mut m.controller },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "blockOwnerDeletion",
            |m: &OwnerReference| { &m.blockOwnerDeletion },
            |m: &mut OwnerReference| { &mut m.blockOwnerDeletion },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OwnerReference>(
            "OwnerReference",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OwnerReference {
    const NAME: &'static str = "OwnerReference";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                42 => {
                    self.apiVersion = ::std::option::Option::Some(is.read_string()?);
                },
                10 => {
                    self.kind = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.uid = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.controller = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.blockOwnerDeletion = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.apiVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.uid.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.controller {
            my_size += 1 + 1;
        }
        if let Some(v) = self.blockOwnerDeletion {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.apiVersion.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.kind.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.uid.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.controller {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.blockOwnerDeletion {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OwnerReference {
        OwnerReference::new()
    }

    fn clear(&mut self) {
        self.apiVersion = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.uid = ::std::option::Option::None;
        self.controller = ::std::option::Option::None;
        self.blockOwnerDeletion = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OwnerReference {
        static instance: OwnerReference = OwnerReference {
            apiVersion: ::std::option::Option::None,
            kind: ::std::option::Option::None,
            name: ::std::option::Option::None,
            uid: ::std::option::Option::None,
            controller: ::std::option::Option::None,
            blockOwnerDeletion: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OwnerReference {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OwnerReference").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OwnerReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OwnerReference {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.PartialObjectMetadata)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PartialObjectMetadata {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.PartialObjectMetadata.metadata)
    pub metadata: ::protobuf::MessageField<ObjectMeta>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.PartialObjectMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PartialObjectMetadata {
    fn default() -> &'a PartialObjectMetadata {
        <PartialObjectMetadata as ::protobuf::Message>::default_instance()
    }
}

impl PartialObjectMetadata {
    pub fn new() -> PartialObjectMetadata {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ObjectMeta {
        self.metadata.take().unwrap_or_else(|| ObjectMeta::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ObjectMeta>(
            "metadata",
            |m: &PartialObjectMetadata| { &m.metadata },
            |m: &mut PartialObjectMetadata| { &mut m.metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PartialObjectMetadata>(
            "PartialObjectMetadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PartialObjectMetadata {
    const NAME: &'static str = "PartialObjectMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PartialObjectMetadata {
        PartialObjectMetadata::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PartialObjectMetadata {
        static instance: PartialObjectMetadata = PartialObjectMetadata {
            metadata: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PartialObjectMetadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PartialObjectMetadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PartialObjectMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PartialObjectMetadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.PartialObjectMetadataList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PartialObjectMetadataList {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.PartialObjectMetadataList.metadata)
    pub metadata: ::protobuf::MessageField<ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.PartialObjectMetadataList.items)
    pub items: ::std::vec::Vec<PartialObjectMetadata>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.PartialObjectMetadataList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PartialObjectMetadataList {
    fn default() -> &'a PartialObjectMetadataList {
        <PartialObjectMetadataList as ::protobuf::Message>::default_instance()
    }
}

impl PartialObjectMetadataList {
    pub fn new() -> PartialObjectMetadataList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ListMeta {
        self.metadata.take().unwrap_or_else(|| ListMeta::new())
    }

    // repeated .apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;

    pub fn items(&self) -> &[PartialObjectMetadata] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<PartialObjectMetadata>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<PartialObjectMetadata> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<PartialObjectMetadata> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ListMeta>(
            "metadata",
            |m: &PartialObjectMetadataList| { &m.metadata },
            |m: &mut PartialObjectMetadataList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &PartialObjectMetadataList| { &m.items },
            |m: &mut PartialObjectMetadataList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PartialObjectMetadataList>(
            "PartialObjectMetadataList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PartialObjectMetadataList {
    const NAME: &'static str = "PartialObjectMetadataList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PartialObjectMetadataList {
        PartialObjectMetadataList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PartialObjectMetadataList {
        static instance: PartialObjectMetadataList = PartialObjectMetadataList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PartialObjectMetadataList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PartialObjectMetadataList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PartialObjectMetadataList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PartialObjectMetadataList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.Patch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Patch {
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.Patch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Patch {
    fn default() -> &'a Patch {
        <Patch as ::protobuf::Message>::default_instance()
    }
}

impl Patch {
    pub fn new() -> Patch {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Patch>(
            "Patch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Patch {
    const NAME: &'static str = "Patch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Patch {
        Patch::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Patch {
        static instance: Patch = Patch {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Patch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Patch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Patch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Patch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.PatchOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchOptions {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.PatchOptions.dryRun)
    pub dryRun: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.PatchOptions.force)
    pub force: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.PatchOptions.fieldManager)
    pub fieldManager: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.PatchOptions.fieldValidation)
    pub fieldValidation: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.PatchOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchOptions {
    fn default() -> &'a PatchOptions {
        <PatchOptions as ::protobuf::Message>::default_instance()
    }
}

impl PatchOptions {
    pub fn new() -> PatchOptions {
        ::std::default::Default::default()
    }

    // repeated string dryRun = 1;

    pub fn dryRun(&self) -> &[::std::string::String] {
        &self.dryRun
    }

    pub fn clear_dryRun(&mut self) {
        self.dryRun.clear();
    }

    // Param is passed by value, moved
    pub fn set_dryRun(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.dryRun = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dryRun(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.dryRun
    }

    // Take field
    pub fn take_dryRun(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.dryRun, ::std::vec::Vec::new())
    }

    // optional bool force = 2;

    pub fn force(&self) -> bool {
        self.force.unwrap_or(false)
    }

    pub fn clear_force(&mut self) {
        self.force = ::std::option::Option::None;
    }

    pub fn has_force(&self) -> bool {
        self.force.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force(&mut self, v: bool) {
        self.force = ::std::option::Option::Some(v);
    }

    // optional string fieldManager = 3;

    pub fn fieldManager(&self) -> &str {
        match self.fieldManager.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fieldManager(&mut self) {
        self.fieldManager = ::std::option::Option::None;
    }

    pub fn has_fieldManager(&self) -> bool {
        self.fieldManager.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldManager(&mut self, v: ::std::string::String) {
        self.fieldManager = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldManager(&mut self) -> &mut ::std::string::String {
        if self.fieldManager.is_none() {
            self.fieldManager = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fieldManager.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldManager(&mut self) -> ::std::string::String {
        self.fieldManager.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fieldValidation = 4;

    pub fn fieldValidation(&self) -> &str {
        match self.fieldValidation.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fieldValidation(&mut self) {
        self.fieldValidation = ::std::option::Option::None;
    }

    pub fn has_fieldValidation(&self) -> bool {
        self.fieldValidation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldValidation(&mut self, v: ::std::string::String) {
        self.fieldValidation = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldValidation(&mut self) -> &mut ::std::string::String {
        if self.fieldValidation.is_none() {
            self.fieldValidation = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fieldValidation.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldValidation(&mut self) -> ::std::string::String {
        self.fieldValidation.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dryRun",
            |m: &PatchOptions| { &m.dryRun },
            |m: &mut PatchOptions| { &mut m.dryRun },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "force",
            |m: &PatchOptions| { &m.force },
            |m: &mut PatchOptions| { &mut m.force },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fieldManager",
            |m: &PatchOptions| { &m.fieldManager },
            |m: &mut PatchOptions| { &mut m.fieldManager },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fieldValidation",
            |m: &PatchOptions| { &m.fieldValidation },
            |m: &mut PatchOptions| { &mut m.fieldValidation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchOptions>(
            "PatchOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchOptions {
    const NAME: &'static str = "PatchOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.dryRun.push(is.read_string()?);
                },
                16 => {
                    self.force = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.fieldManager = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.fieldValidation = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.dryRun {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.force {
            my_size += 1 + 1;
        }
        if let Some(v) = self.fieldManager.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.fieldValidation.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.dryRun {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.force {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.fieldManager.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.fieldValidation.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchOptions {
        PatchOptions::new()
    }

    fn clear(&mut self) {
        self.dryRun.clear();
        self.force = ::std::option::Option::None;
        self.fieldManager = ::std::option::Option::None;
        self.fieldValidation = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchOptions {
        static instance: PatchOptions = PatchOptions {
            dryRun: ::std::vec::Vec::new(),
            force: ::std::option::Option::None,
            fieldManager: ::std::option::Option::None,
            fieldValidation: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.Preconditions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Preconditions {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.Preconditions.uid)
    pub uid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.Preconditions.resourceVersion)
    pub resourceVersion: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.Preconditions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Preconditions {
    fn default() -> &'a Preconditions {
        <Preconditions as ::protobuf::Message>::default_instance()
    }
}

impl Preconditions {
    pub fn new() -> Preconditions {
        ::std::default::Default::default()
    }

    // optional string uid = 1;

    pub fn uid(&self) -> &str {
        match self.uid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_uid(&mut self) {
        self.uid = ::std::option::Option::None;
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if self.uid.is_none() {
            self.uid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        self.uid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resourceVersion = 2;

    pub fn resourceVersion(&self) -> &str {
        match self.resourceVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resourceVersion(&mut self) {
        self.resourceVersion = ::std::option::Option::None;
    }

    pub fn has_resourceVersion(&self) -> bool {
        self.resourceVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceVersion(&mut self, v: ::std::string::String) {
        self.resourceVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceVersion(&mut self) -> &mut ::std::string::String {
        if self.resourceVersion.is_none() {
            self.resourceVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resourceVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceVersion(&mut self) -> ::std::string::String {
        self.resourceVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uid",
            |m: &Preconditions| { &m.uid },
            |m: &mut Preconditions| { &mut m.uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resourceVersion",
            |m: &Preconditions| { &m.resourceVersion },
            |m: &mut Preconditions| { &mut m.resourceVersion },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Preconditions>(
            "Preconditions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Preconditions {
    const NAME: &'static str = "Preconditions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uid = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.resourceVersion = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.uid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.resourceVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.uid.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.resourceVersion.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Preconditions {
        Preconditions::new()
    }

    fn clear(&mut self) {
        self.uid = ::std::option::Option::None;
        self.resourceVersion = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Preconditions {
        static instance: Preconditions = Preconditions {
            uid: ::std::option::Option::None,
            resourceVersion: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Preconditions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Preconditions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Preconditions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Preconditions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.RootPaths)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RootPaths {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.RootPaths.paths)
    pub paths: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.RootPaths.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RootPaths {
    fn default() -> &'a RootPaths {
        <RootPaths as ::protobuf::Message>::default_instance()
    }
}

impl RootPaths {
    pub fn new() -> RootPaths {
        ::std::default::Default::default()
    }

    // repeated string paths = 1;

    pub fn paths(&self) -> &[::std::string::String] {
        &self.paths
    }

    pub fn clear_paths(&mut self) {
        self.paths.clear();
    }

    // Param is passed by value, moved
    pub fn set_paths(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.paths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_paths(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.paths
    }

    // Take field
    pub fn take_paths(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.paths, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "paths",
            |m: &RootPaths| { &m.paths },
            |m: &mut RootPaths| { &mut m.paths },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RootPaths>(
            "RootPaths",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RootPaths {
    const NAME: &'static str = "RootPaths";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.paths.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.paths {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.paths {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RootPaths {
        RootPaths::new()
    }

    fn clear(&mut self) {
        self.paths.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RootPaths {
        static instance: RootPaths = RootPaths {
            paths: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RootPaths {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RootPaths").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RootPaths {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RootPaths {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServerAddressByClientCIDR {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR.clientCIDR)
    pub clientCIDR: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR.serverAddress)
    pub serverAddress: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerAddressByClientCIDR {
    fn default() -> &'a ServerAddressByClientCIDR {
        <ServerAddressByClientCIDR as ::protobuf::Message>::default_instance()
    }
}

impl ServerAddressByClientCIDR {
    pub fn new() -> ServerAddressByClientCIDR {
        ::std::default::Default::default()
    }

    // optional string clientCIDR = 1;

    pub fn clientCIDR(&self) -> &str {
        match self.clientCIDR.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_clientCIDR(&mut self) {
        self.clientCIDR = ::std::option::Option::None;
    }

    pub fn has_clientCIDR(&self) -> bool {
        self.clientCIDR.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientCIDR(&mut self, v: ::std::string::String) {
        self.clientCIDR = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientCIDR(&mut self) -> &mut ::std::string::String {
        if self.clientCIDR.is_none() {
            self.clientCIDR = ::std::option::Option::Some(::std::string::String::new());
        }
        self.clientCIDR.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientCIDR(&mut self) -> ::std::string::String {
        self.clientCIDR.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string serverAddress = 2;

    pub fn serverAddress(&self) -> &str {
        match self.serverAddress.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_serverAddress(&mut self) {
        self.serverAddress = ::std::option::Option::None;
    }

    pub fn has_serverAddress(&self) -> bool {
        self.serverAddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverAddress(&mut self, v: ::std::string::String) {
        self.serverAddress = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverAddress(&mut self) -> &mut ::std::string::String {
        if self.serverAddress.is_none() {
            self.serverAddress = ::std::option::Option::Some(::std::string::String::new());
        }
        self.serverAddress.as_mut().unwrap()
    }

    // Take field
    pub fn take_serverAddress(&mut self) -> ::std::string::String {
        self.serverAddress.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clientCIDR",
            |m: &ServerAddressByClientCIDR| { &m.clientCIDR },
            |m: &mut ServerAddressByClientCIDR| { &mut m.clientCIDR },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serverAddress",
            |m: &ServerAddressByClientCIDR| { &m.serverAddress },
            |m: &mut ServerAddressByClientCIDR| { &mut m.serverAddress },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServerAddressByClientCIDR>(
            "ServerAddressByClientCIDR",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServerAddressByClientCIDR {
    const NAME: &'static str = "ServerAddressByClientCIDR";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.clientCIDR = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.serverAddress = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.clientCIDR.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.serverAddress.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.clientCIDR.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.serverAddress.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerAddressByClientCIDR {
        ServerAddressByClientCIDR::new()
    }

    fn clear(&mut self) {
        self.clientCIDR = ::std::option::Option::None;
        self.serverAddress = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerAddressByClientCIDR {
        static instance: ServerAddressByClientCIDR = ServerAddressByClientCIDR {
            clientCIDR: ::std::option::Option::None,
            serverAddress: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServerAddressByClientCIDR {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerAddressByClientCIDR").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerAddressByClientCIDR {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerAddressByClientCIDR {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.Status)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Status {
    // message fields
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.Status.metadata)
    pub metadata: ::protobuf::MessageField<ListMeta>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.Status.status)
    pub status: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.Status.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.Status.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.Status.details)
    pub details: ::protobuf::MessageField<StatusDetails>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.Status.code)
    pub code: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.Status.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Status {
    fn default() -> &'a Status {
        <Status as ::protobuf::Message>::default_instance()
    }
}

impl Status {
    pub fn new() -> Status {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ListMeta {
        self.metadata.take().unwrap_or_else(|| ListMeta::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 3;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reason = 4;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.StatusDetails details = 5;

    pub fn details(&self) -> &StatusDetails {
        self.details.as_ref().unwrap_or_else(|| <StatusDetails as ::protobuf::Message>::default_instance())
    }

    pub fn clear_details(&mut self) {
        self.details.clear();
    }

    pub fn has_details(&self) -> bool {
        self.details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: StatusDetails) {
        self.details = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut StatusDetails {
        self.details.mut_or_insert_default()
    }

    // Take field
    pub fn take_details(&mut self) -> StatusDetails {
        self.details.take().unwrap_or_else(|| StatusDetails::new())
    }

    // optional int32 code = 6;

    pub fn code(&self) -> i32 {
        self.code.unwrap_or(0)
    }

    pub fn clear_code(&mut self) {
        self.code = ::std::option::Option::None;
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: i32) {
        self.code = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ListMeta>(
            "metadata",
            |m: &Status| { &m.metadata },
            |m: &mut Status| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &Status| { &m.status },
            |m: &mut Status| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &Status| { &m.message },
            |m: &mut Status| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &Status| { &m.reason },
            |m: &mut Status| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StatusDetails>(
            "details",
            |m: &Status| { &m.details },
            |m: &mut Status| { &mut m.details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "code",
            |m: &Status| { &m.code },
            |m: &mut Status| { &mut m.code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Status>(
            "Status",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Status {
    const NAME: &'static str = "Status";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.details)?;
                },
                48 => {
                    self.code = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.code {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.details.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.code {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Status {
        Status::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.status = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.details.clear();
        self.code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Status {
        static instance: Status = Status {
            metadata: ::protobuf::MessageField::none(),
            status: ::std::option::Option::None,
            message: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            details: ::protobuf::MessageField::none(),
            code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Status {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Status").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Status {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Status {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.StatusCause)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatusCause {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.StatusCause.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.StatusCause.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.StatusCause.field)
    pub field: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.StatusCause.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatusCause {
    fn default() -> &'a StatusCause {
        <StatusCause as ::protobuf::Message>::default_instance()
    }
}

impl StatusCause {
    pub fn new() -> StatusCause {
        ::std::default::Default::default()
    }

    // optional string reason = 1;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string field = 3;

    pub fn field(&self) -> &str {
        match self.field.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_field(&mut self) {
        self.field = ::std::option::Option::None;
    }

    pub fn has_field(&self) -> bool {
        self.field.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: ::std::string::String) {
        self.field = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field(&mut self) -> &mut ::std::string::String {
        if self.field.is_none() {
            self.field = ::std::option::Option::Some(::std::string::String::new());
        }
        self.field.as_mut().unwrap()
    }

    // Take field
    pub fn take_field(&mut self) -> ::std::string::String {
        self.field.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &StatusCause| { &m.reason },
            |m: &mut StatusCause| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &StatusCause| { &m.message },
            |m: &mut StatusCause| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "field",
            |m: &StatusCause| { &m.field },
            |m: &mut StatusCause| { &mut m.field },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatusCause>(
            "StatusCause",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatusCause {
    const NAME: &'static str = "StatusCause";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.field = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.field.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reason.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.field.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatusCause {
        StatusCause::new()
    }

    fn clear(&mut self) {
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.field = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatusCause {
        static instance: StatusCause = StatusCause {
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            field: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatusCause {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatusCause").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatusCause {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusCause {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.StatusDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatusDetails {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.StatusDetails.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.StatusDetails.group)
    pub group: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.StatusDetails.kind)
    pub kind: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.StatusDetails.uid)
    pub uid: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.StatusDetails.causes)
    pub causes: ::std::vec::Vec<StatusCause>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.StatusDetails.retryAfterSeconds)
    pub retryAfterSeconds: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.StatusDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatusDetails {
    fn default() -> &'a StatusDetails {
        <StatusDetails as ::protobuf::Message>::default_instance()
    }
}

impl StatusDetails {
    pub fn new() -> StatusDetails {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string group = 2;

    pub fn group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_group(&mut self) {
        self.group = ::std::option::Option::None;
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group = ::std::option::Option::Some(::std::string::String::new());
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kind = 3;

    pub fn kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string uid = 6;

    pub fn uid(&self) -> &str {
        match self.uid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_uid(&mut self) {
        self.uid = ::std::option::Option::None;
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if self.uid.is_none() {
            self.uid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        self.uid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;

    pub fn causes(&self) -> &[StatusCause] {
        &self.causes
    }

    pub fn clear_causes(&mut self) {
        self.causes.clear();
    }

    // Param is passed by value, moved
    pub fn set_causes(&mut self, v: ::std::vec::Vec<StatusCause>) {
        self.causes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_causes(&mut self) -> &mut ::std::vec::Vec<StatusCause> {
        &mut self.causes
    }

    // Take field
    pub fn take_causes(&mut self) -> ::std::vec::Vec<StatusCause> {
        ::std::mem::replace(&mut self.causes, ::std::vec::Vec::new())
    }

    // optional int32 retryAfterSeconds = 5;

    pub fn retryAfterSeconds(&self) -> i32 {
        self.retryAfterSeconds.unwrap_or(0)
    }

    pub fn clear_retryAfterSeconds(&mut self) {
        self.retryAfterSeconds = ::std::option::Option::None;
    }

    pub fn has_retryAfterSeconds(&self) -> bool {
        self.retryAfterSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retryAfterSeconds(&mut self, v: i32) {
        self.retryAfterSeconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &StatusDetails| { &m.name },
            |m: &mut StatusDetails| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "group",
            |m: &StatusDetails| { &m.group },
            |m: &mut StatusDetails| { &mut m.group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &StatusDetails| { &m.kind },
            |m: &mut StatusDetails| { &mut m.kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uid",
            |m: &StatusDetails| { &m.uid },
            |m: &mut StatusDetails| { &mut m.uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "causes",
            |m: &StatusDetails| { &m.causes },
            |m: &mut StatusDetails| { &mut m.causes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "retryAfterSeconds",
            |m: &StatusDetails| { &m.retryAfterSeconds },
            |m: &mut StatusDetails| { &mut m.retryAfterSeconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatusDetails>(
            "StatusDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatusDetails {
    const NAME: &'static str = "StatusDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.group = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.kind = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.uid = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.causes.push(is.read_message()?);
                },
                40 => {
                    self.retryAfterSeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.uid.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.causes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.retryAfterSeconds {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.group.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.kind.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.uid.as_ref() {
            os.write_string(6, v)?;
        }
        for v in &self.causes {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.retryAfterSeconds {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatusDetails {
        StatusDetails::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.group = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.uid = ::std::option::Option::None;
        self.causes.clear();
        self.retryAfterSeconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatusDetails {
        static instance: StatusDetails = StatusDetails {
            name: ::std::option::Option::None,
            group: ::std::option::Option::None,
            kind: ::std::option::Option::None,
            uid: ::std::option::Option::None,
            causes: ::std::vec::Vec::new(),
            retryAfterSeconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatusDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatusDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatusDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.TableOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TableOptions {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.TableOptions.includeObject)
    pub includeObject: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.TableOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TableOptions {
    fn default() -> &'a TableOptions {
        <TableOptions as ::protobuf::Message>::default_instance()
    }
}

impl TableOptions {
    pub fn new() -> TableOptions {
        ::std::default::Default::default()
    }

    // optional string includeObject = 1;

    pub fn includeObject(&self) -> &str {
        match self.includeObject.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_includeObject(&mut self) {
        self.includeObject = ::std::option::Option::None;
    }

    pub fn has_includeObject(&self) -> bool {
        self.includeObject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_includeObject(&mut self, v: ::std::string::String) {
        self.includeObject = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_includeObject(&mut self) -> &mut ::std::string::String {
        if self.includeObject.is_none() {
            self.includeObject = ::std::option::Option::Some(::std::string::String::new());
        }
        self.includeObject.as_mut().unwrap()
    }

    // Take field
    pub fn take_includeObject(&mut self) -> ::std::string::String {
        self.includeObject.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "includeObject",
            |m: &TableOptions| { &m.includeObject },
            |m: &mut TableOptions| { &mut m.includeObject },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TableOptions>(
            "TableOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TableOptions {
    const NAME: &'static str = "TableOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.includeObject = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.includeObject.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.includeObject.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TableOptions {
        TableOptions::new()
    }

    fn clear(&mut self) {
        self.includeObject = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TableOptions {
        static instance: TableOptions = TableOptions {
            includeObject: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TableOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TableOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TableOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TableOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.Time)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Time {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.Time.seconds)
    pub seconds: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.Time.nanos)
    pub nanos: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.Time.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Time {
    fn default() -> &'a Time {
        <Time as ::protobuf::Message>::default_instance()
    }
}

impl Time {
    pub fn new() -> Time {
        ::std::default::Default::default()
    }

    // optional int64 seconds = 1;

    pub fn seconds(&self) -> i64 {
        self.seconds.unwrap_or(0)
    }

    pub fn clear_seconds(&mut self) {
        self.seconds = ::std::option::Option::None;
    }

    pub fn has_seconds(&self) -> bool {
        self.seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds(&mut self, v: i64) {
        self.seconds = ::std::option::Option::Some(v);
    }

    // optional int32 nanos = 2;

    pub fn nanos(&self) -> i32 {
        self.nanos.unwrap_or(0)
    }

    pub fn clear_nanos(&mut self) {
        self.nanos = ::std::option::Option::None;
    }

    pub fn has_nanos(&self) -> bool {
        self.nanos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nanos(&mut self, v: i32) {
        self.nanos = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds",
            |m: &Time| { &m.seconds },
            |m: &mut Time| { &mut m.seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nanos",
            |m: &Time| { &m.nanos },
            |m: &mut Time| { &mut m.nanos },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Time>(
            "Time",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Time {
    const NAME: &'static str = "Time";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.seconds = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.nanos = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.seconds {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.nanos {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.seconds {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.nanos {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Time {
        Time::new()
    }

    fn clear(&mut self) {
        self.seconds = ::std::option::Option::None;
        self.nanos = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Time {
        static instance: Time = Time {
            seconds: ::std::option::Option::None,
            nanos: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Time {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Time").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Time {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Time {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.Timestamp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Timestamp {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.Timestamp.seconds)
    pub seconds: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.Timestamp.nanos)
    pub nanos: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.Timestamp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Timestamp {
    fn default() -> &'a Timestamp {
        <Timestamp as ::protobuf::Message>::default_instance()
    }
}

impl Timestamp {
    pub fn new() -> Timestamp {
        ::std::default::Default::default()
    }

    // optional int64 seconds = 1;

    pub fn seconds(&self) -> i64 {
        self.seconds.unwrap_or(0)
    }

    pub fn clear_seconds(&mut self) {
        self.seconds = ::std::option::Option::None;
    }

    pub fn has_seconds(&self) -> bool {
        self.seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds(&mut self, v: i64) {
        self.seconds = ::std::option::Option::Some(v);
    }

    // optional int32 nanos = 2;

    pub fn nanos(&self) -> i32 {
        self.nanos.unwrap_or(0)
    }

    pub fn clear_nanos(&mut self) {
        self.nanos = ::std::option::Option::None;
    }

    pub fn has_nanos(&self) -> bool {
        self.nanos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nanos(&mut self, v: i32) {
        self.nanos = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds",
            |m: &Timestamp| { &m.seconds },
            |m: &mut Timestamp| { &mut m.seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nanos",
            |m: &Timestamp| { &m.nanos },
            |m: &mut Timestamp| { &mut m.nanos },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Timestamp>(
            "Timestamp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Timestamp {
    const NAME: &'static str = "Timestamp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.seconds = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.nanos = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.seconds {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.nanos {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.seconds {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.nanos {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Timestamp {
        Timestamp::new()
    }

    fn clear(&mut self) {
        self.seconds = ::std::option::Option::None;
        self.nanos = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Timestamp {
        static instance: Timestamp = Timestamp {
            seconds: ::std::option::Option::None,
            nanos: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Timestamp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Timestamp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Timestamp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Timestamp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.TypeMeta)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TypeMeta {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.TypeMeta.kind)
    pub kind: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.TypeMeta.apiVersion)
    pub apiVersion: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.TypeMeta.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TypeMeta {
    fn default() -> &'a TypeMeta {
        <TypeMeta as ::protobuf::Message>::default_instance()
    }
}

impl TypeMeta {
    pub fn new() -> TypeMeta {
        ::std::default::Default::default()
    }

    // optional string kind = 1;

    pub fn kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string apiVersion = 2;

    pub fn apiVersion(&self) -> &str {
        match self.apiVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_apiVersion(&mut self) {
        self.apiVersion = ::std::option::Option::None;
    }

    pub fn has_apiVersion(&self) -> bool {
        self.apiVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiVersion(&mut self, v: ::std::string::String) {
        self.apiVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiVersion(&mut self) -> &mut ::std::string::String {
        if self.apiVersion.is_none() {
            self.apiVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.apiVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiVersion(&mut self) -> ::std::string::String {
        self.apiVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &TypeMeta| { &m.kind },
            |m: &mut TypeMeta| { &mut m.kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "apiVersion",
            |m: &TypeMeta| { &m.apiVersion },
            |m: &mut TypeMeta| { &mut m.apiVersion },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TypeMeta>(
            "TypeMeta",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TypeMeta {
    const NAME: &'static str = "TypeMeta";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.kind = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.apiVersion = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.apiVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.kind.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.apiVersion.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TypeMeta {
        TypeMeta::new()
    }

    fn clear(&mut self) {
        self.kind = ::std::option::Option::None;
        self.apiVersion = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TypeMeta {
        static instance: TypeMeta = TypeMeta {
            kind: ::std::option::Option::None,
            apiVersion: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TypeMeta {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TypeMeta").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TypeMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeMeta {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.UpdateOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateOptions {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.UpdateOptions.dryRun)
    pub dryRun: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.UpdateOptions.fieldManager)
    pub fieldManager: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.UpdateOptions.fieldValidation)
    pub fieldValidation: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.UpdateOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateOptions {
    fn default() -> &'a UpdateOptions {
        <UpdateOptions as ::protobuf::Message>::default_instance()
    }
}

impl UpdateOptions {
    pub fn new() -> UpdateOptions {
        ::std::default::Default::default()
    }

    // repeated string dryRun = 1;

    pub fn dryRun(&self) -> &[::std::string::String] {
        &self.dryRun
    }

    pub fn clear_dryRun(&mut self) {
        self.dryRun.clear();
    }

    // Param is passed by value, moved
    pub fn set_dryRun(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.dryRun = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dryRun(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.dryRun
    }

    // Take field
    pub fn take_dryRun(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.dryRun, ::std::vec::Vec::new())
    }

    // optional string fieldManager = 2;

    pub fn fieldManager(&self) -> &str {
        match self.fieldManager.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fieldManager(&mut self) {
        self.fieldManager = ::std::option::Option::None;
    }

    pub fn has_fieldManager(&self) -> bool {
        self.fieldManager.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldManager(&mut self, v: ::std::string::String) {
        self.fieldManager = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldManager(&mut self) -> &mut ::std::string::String {
        if self.fieldManager.is_none() {
            self.fieldManager = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fieldManager.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldManager(&mut self) -> ::std::string::String {
        self.fieldManager.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fieldValidation = 3;

    pub fn fieldValidation(&self) -> &str {
        match self.fieldValidation.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fieldValidation(&mut self) {
        self.fieldValidation = ::std::option::Option::None;
    }

    pub fn has_fieldValidation(&self) -> bool {
        self.fieldValidation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldValidation(&mut self, v: ::std::string::String) {
        self.fieldValidation = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldValidation(&mut self) -> &mut ::std::string::String {
        if self.fieldValidation.is_none() {
            self.fieldValidation = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fieldValidation.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldValidation(&mut self) -> ::std::string::String {
        self.fieldValidation.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dryRun",
            |m: &UpdateOptions| { &m.dryRun },
            |m: &mut UpdateOptions| { &mut m.dryRun },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fieldManager",
            |m: &UpdateOptions| { &m.fieldManager },
            |m: &mut UpdateOptions| { &mut m.fieldManager },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fieldValidation",
            |m: &UpdateOptions| { &m.fieldValidation },
            |m: &mut UpdateOptions| { &mut m.fieldValidation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateOptions>(
            "UpdateOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateOptions {
    const NAME: &'static str = "UpdateOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.dryRun.push(is.read_string()?);
                },
                18 => {
                    self.fieldManager = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.fieldValidation = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.dryRun {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.fieldManager.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.fieldValidation.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.dryRun {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.fieldManager.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.fieldValidation.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateOptions {
        UpdateOptions::new()
    }

    fn clear(&mut self) {
        self.dryRun.clear();
        self.fieldManager = ::std::option::Option::None;
        self.fieldValidation = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateOptions {
        static instance: UpdateOptions = UpdateOptions {
            dryRun: ::std::vec::Vec::new(),
            fieldManager: ::std::option::Option::None,
            fieldValidation: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.Verbs)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Verbs {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.Verbs.items)
    pub items: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.Verbs.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Verbs {
    fn default() -> &'a Verbs {
        <Verbs as ::protobuf::Message>::default_instance()
    }
}

impl Verbs {
    pub fn new() -> Verbs {
        ::std::default::Default::default()
    }

    // repeated string items = 1;

    pub fn items(&self) -> &[::std::string::String] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &Verbs| { &m.items },
            |m: &mut Verbs| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Verbs>(
            "Verbs",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Verbs {
    const NAME: &'static str = "Verbs";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.items.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.items {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.items {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Verbs {
        Verbs::new()
    }

    fn clear(&mut self) {
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Verbs {
        static instance: Verbs = Verbs {
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Verbs {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Verbs").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Verbs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Verbs {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apimachinery.pkg.apis.meta.v1.WatchEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WatchEvent {
    // message fields
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.WatchEvent.type)
    pub type_: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_30::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apimachinery.pkg.apis.meta.v1.WatchEvent.object)
    pub object: ::protobuf::MessageField<crate::v1_30::apimachinery::pkg::runtime::RawExtension>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apimachinery.pkg.apis.meta.v1.WatchEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WatchEvent {
    fn default() -> &'a WatchEvent {
        <WatchEvent as ::protobuf::Message>::default_instance()
    }
}

impl WatchEvent {
    pub fn new() -> WatchEvent {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.runtime.RawExtension object = 2;

    pub fn object(&self) -> &crate::v1_30::apimachinery::pkg::runtime::RawExtension {
        self.object.as_ref().unwrap_or_else(|| <crate::v1_30::apimachinery::pkg::runtime::RawExtension as ::protobuf::Message>::default_instance())
    }

    pub fn clear_object(&mut self) {
        self.object.clear();
    }

    pub fn has_object(&self) -> bool {
        self.object.is_some()
    }

    // Param is passed by value, moved
    pub fn set_object(&mut self, v: crate::v1_30::apimachinery::pkg::runtime::RawExtension) {
        self.object = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object(&mut self) -> &mut crate::v1_30::apimachinery::pkg::runtime::RawExtension {
        self.object.mut_or_insert_default()
    }

    // Take field
    pub fn take_object(&mut self) -> crate::v1_30::apimachinery::pkg::runtime::RawExtension {
        self.object.take().unwrap_or_else(|| crate::v1_30::apimachinery::pkg::runtime::RawExtension::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &WatchEvent| { &m.type_ },
            |m: &mut WatchEvent| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_30::apimachinery::pkg::runtime::RawExtension>(
            "object",
            |m: &WatchEvent| { &m.object },
            |m: &mut WatchEvent| { &mut m.object },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WatchEvent>(
            "WatchEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WatchEvent {
    const NAME: &'static str = "WatchEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.object)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.object.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.object.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WatchEvent {
        WatchEvent::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.object.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WatchEvent {
        static instance: WatchEvent = WatchEvent {
            type_: ::std::option::Option::None,
            object: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WatchEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WatchEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WatchEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WatchEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n-apimachinery/pkg/apis/meta/v1/generated.proto\x12\x1dapimachinery.pkg\
    .apis.meta.v1\x1a(apimachinery/pkg/runtime/generated.proto\x1a/apimachin\
    ery/pkg/runtime/schema/generated.proto\"\xd2\x02\n\x08APIGroup\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x12S\n\x08versions\x18\x02\x20\x03(\
    \x0b27.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscoveryR\x08versio\
    ns\x12c\n\x10preferredVersion\x18\x03\x20\x01(\x0b27.apimachinery.pkg.ap\
    is.meta.v1.GroupVersionForDiscoveryR\x10preferredVersion\x12x\n\x1aserve\
    rAddressByClientCIDRs\x18\x04\x20\x03(\x0b28.apimachinery.pkg.apis.meta.\
    v1.ServerAddressByClientCIDRR\x1aserverAddressByClientCIDRs\"O\n\x0cAPIG\
    roupList\x12?\n\x06groups\x18\x01\x20\x03(\x0b2'.apimachinery.pkg.apis.m\
    eta.v1.APIGroupR\x06groups\"\xd5\x02\n\x0bAPIResource\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12\"\n\x0csingularName\x18\x06\x20\x01(\tR\
    \x0csingularName\x12\x1e\n\nnamespaced\x18\x02\x20\x01(\x08R\nnamespaced\
    \x12\x14\n\x05group\x18\x08\x20\x01(\tR\x05group\x12\x18\n\x07version\
    \x18\t\x20\x01(\tR\x07version\x12\x12\n\x04kind\x18\x03\x20\x01(\tR\x04k\
    ind\x12:\n\x05verbs\x18\x04\x20\x01(\x0b2$.apimachinery.pkg.apis.meta.v1\
    .VerbsR\x05verbs\x12\x1e\n\nshortNames\x18\x05\x20\x03(\tR\nshortNames\
    \x12\x1e\n\ncategories\x18\x07\x20\x03(\tR\ncategories\x12.\n\x12storage\
    VersionHash\x18\n\x20\x01(\tR\x12storageVersionHash\"\x7f\n\x0fAPIResour\
    ceList\x12\"\n\x0cgroupVersion\x18\x01\x20\x01(\tR\x0cgroupVersion\x12H\
    \n\tresources\x18\x02\x20\x03(\x0b2*.apimachinery.pkg.apis.meta.v1.APIRe\
    sourceR\tresources\"\xa3\x01\n\x0bAPIVersions\x12\x1a\n\x08versions\x18\
    \x01\x20\x03(\tR\x08versions\x12x\n\x1aserverAddressByClientCIDRs\x18\
    \x02\x20\x03(\x0b28.apimachinery.pkg.apis.meta.v1.ServerAddressByClientC\
    IDRR\x1aserverAddressByClientCIDRs\"`\n\x0cApplyOptions\x12\x16\n\x06dry\
    Run\x18\x01\x20\x03(\tR\x06dryRun\x12\x14\n\x05force\x18\x02\x20\x01(\
    \x08R\x05force\x12\"\n\x0cfieldManager\x18\x03\x20\x01(\tR\x0cfieldManag\
    er\"\xee\x01\n\tCondition\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\
    \x12\x16\n\x06status\x18\x02\x20\x01(\tR\x06status\x12.\n\x12observedGen\
    eration\x18\x03\x20\x01(\x03R\x12observedGeneration\x12S\n\x12lastTransi\
    tionTime\x18\x04\x20\x01(\x0b2#.apimachinery.pkg.apis.meta.v1.TimeR\x12l\
    astTransitionTime\x12\x16\n\x06reason\x18\x05\x20\x01(\tR\x06reason\x12\
    \x18\n\x07message\x18\x06\x20\x01(\tR\x07message\"u\n\rCreateOptions\x12\
    \x16\n\x06dryRun\x18\x01\x20\x03(\tR\x06dryRun\x12\"\n\x0cfieldManager\
    \x18\x03\x20\x01(\tR\x0cfieldManager\x12(\n\x0ffieldValidation\x18\x04\
    \x20\x01(\tR\x0ffieldValidation\"\x85\x02\n\rDeleteOptions\x12.\n\x12gra\
    cePeriodSeconds\x18\x01\x20\x01(\x03R\x12gracePeriodSeconds\x12R\n\rprec\
    onditions\x18\x02\x20\x01(\x0b2,.apimachinery.pkg.apis.meta.v1.Precondit\
    ionsR\rpreconditions\x12*\n\x10orphanDependents\x18\x03\x20\x01(\x08R\
    \x10orphanDependents\x12,\n\x11propagationPolicy\x18\x04\x20\x01(\tR\x11\
    propagationPolicy\x12\x16\n\x06dryRun\x18\x05\x20\x03(\tR\x06dryRun\"&\n\
    \x08Duration\x12\x1a\n\x08duration\x18\x01\x20\x01(\x03R\x08duration\"\
    \x1c\n\x08FieldsV1\x12\x10\n\x03Raw\x18\x01\x20\x01(\x0cR\x03Raw\"6\n\nG\
    etOptions\x12(\n\x0fresourceVersion\x18\x01\x20\x01(\tR\x0fresourceVersi\
    on\"5\n\tGroupKind\x12\x14\n\x05group\x18\x01\x20\x01(\tR\x05group\x12\
    \x12\n\x04kind\x18\x02\x20\x01(\tR\x04kind\"A\n\rGroupResource\x12\x14\n\
    \x05group\x18\x01\x20\x01(\tR\x05group\x12\x1a\n\x08resource\x18\x02\x20\
    \x01(\tR\x08resource\">\n\x0cGroupVersion\x12\x14\n\x05group\x18\x01\x20\
    \x01(\tR\x05group\x12\x18\n\x07version\x18\x02\x20\x01(\tR\x07version\"X\
    \n\x18GroupVersionForDiscovery\x12\"\n\x0cgroupVersion\x18\x01\x20\x01(\
    \tR\x0cgroupVersion\x12\x18\n\x07version\x18\x02\x20\x01(\tR\x07version\
    \"V\n\x10GroupVersionKind\x12\x14\n\x05group\x18\x01\x20\x01(\tR\x05grou\
    p\x12\x18\n\x07version\x18\x02\x20\x01(\tR\x07version\x12\x12\n\x04kind\
    \x18\x03\x20\x01(\tR\x04kind\"b\n\x14GroupVersionResource\x12\x14\n\x05g\
    roup\x18\x01\x20\x01(\tR\x05group\x12\x18\n\x07version\x18\x02\x20\x01(\
    \tR\x07version\x12\x1a\n\x08resource\x18\x03\x20\x01(\tR\x08resource\"\
    \x95\x02\n\rLabelSelector\x12_\n\x0bmatchLabels\x18\x01\x20\x03(\x0b2=.a\
    pimachinery.pkg.apis.meta.v1.LabelSelector.MatchLabelsEntryR\x0bmatchLab\
    els\x12c\n\x10matchExpressions\x18\x02\x20\x03(\x0b27.apimachinery.pkg.a\
    pis.meta.v1.LabelSelectorRequirementR\x10matchExpressions\x1a>\n\x10Matc\
    hLabelsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05va\
    lue\x18\x02\x20\x01(\tR\x05value:\x028\x01\"`\n\x18LabelSelectorRequirem\
    ent\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x1a\n\x08operator\
    \x18\x02\x20\x01(\tR\x08operator\x12\x16\n\x06values\x18\x03\x20\x03(\tR\
    \x06values\"\x89\x01\n\x04List\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'\
    .apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12<\n\x05items\x18\
    \x02\x20\x03(\x0b2&.apimachinery.pkg.runtime.RawExtensionR\x05items\"\
    \x9c\x01\n\x08ListMeta\x12\x1a\n\x08selfLink\x18\x01\x20\x01(\tR\x08self\
    Link\x12(\n\x0fresourceVersion\x18\x02\x20\x01(\tR\x0fresourceVersion\
    \x12\x1a\n\x08continue\x18\x03\x20\x01(\tR\x08continue\x12.\n\x12remaini\
    ngItemCount\x18\x04\x20\x01(\x03R\x12remainingItemCount\"\x87\x03\n\x0bL\
    istOptions\x12$\n\rlabelSelector\x18\x01\x20\x01(\tR\rlabelSelector\x12$\
    \n\rfieldSelector\x18\x02\x20\x01(\tR\rfieldSelector\x12\x14\n\x05watch\
    \x18\x03\x20\x01(\x08R\x05watch\x120\n\x13allowWatchBookmarks\x18\t\x20\
    \x01(\x08R\x13allowWatchBookmarks\x12(\n\x0fresourceVersion\x18\x04\x20\
    \x01(\tR\x0fresourceVersion\x122\n\x14resourceVersionMatch\x18\n\x20\x01\
    (\tR\x14resourceVersionMatch\x12&\n\x0etimeoutSeconds\x18\x05\x20\x01(\
    \x03R\x0etimeoutSeconds\x12\x14\n\x05limit\x18\x07\x20\x01(\x03R\x05limi\
    t\x12\x1a\n\x08continue\x18\x08\x20\x01(\tR\x08continue\x12,\n\x11sendIn\
    itialEvents\x18\x0b\x20\x01(\x08R\x11sendInitialEvents\"\xac\x02\n\x12Ma\
    nagedFieldsEntry\x12\x18\n\x07manager\x18\x01\x20\x01(\tR\x07manager\x12\
    \x1c\n\toperation\x18\x02\x20\x01(\tR\toperation\x12\x1e\n\napiVersion\
    \x18\x03\x20\x01(\tR\napiVersion\x127\n\x04time\x18\x04\x20\x01(\x0b2#.a\
    pimachinery.pkg.apis.meta.v1.TimeR\x04time\x12\x1e\n\nfieldsType\x18\x06\
    \x20\x01(\tR\nfieldsType\x12C\n\x08fieldsV1\x18\x07\x20\x01(\x0b2'.apima\
    chinery.pkg.apis.meta.v1.FieldsV1R\x08fieldsV1\x12\x20\n\x0bsubresource\
    \x18\x08\x20\x01(\tR\x0bsubresource\";\n\tMicroTime\x12\x18\n\x07seconds\
    \x18\x01\x20\x01(\x03R\x07seconds\x12\x14\n\x05nanos\x18\x02\x20\x01(\
    \x05R\x05nanos\"\xba\x07\n\nObjectMeta\x12\x12\n\x04name\x18\x01\x20\x01\
    (\tR\x04name\x12\"\n\x0cgenerateName\x18\x02\x20\x01(\tR\x0cgenerateName\
    \x12\x1c\n\tnamespace\x18\x03\x20\x01(\tR\tnamespace\x12\x1a\n\x08selfLi\
    nk\x18\x04\x20\x01(\tR\x08selfLink\x12\x10\n\x03uid\x18\x05\x20\x01(\tR\
    \x03uid\x12(\n\x0fresourceVersion\x18\x06\x20\x01(\tR\x0fresourceVersion\
    \x12\x1e\n\ngeneration\x18\x07\x20\x01(\x03R\ngeneration\x12Q\n\x11creat\
    ionTimestamp\x18\x08\x20\x01(\x0b2#.apimachinery.pkg.apis.meta.v1.TimeR\
    \x11creationTimestamp\x12Q\n\x11deletionTimestamp\x18\t\x20\x01(\x0b2#.a\
    pimachinery.pkg.apis.meta.v1.TimeR\x11deletionTimestamp\x12>\n\x1adeleti\
    onGracePeriodSeconds\x18\n\x20\x01(\x03R\x1adeletionGracePeriodSeconds\
    \x12M\n\x06labels\x18\x0b\x20\x03(\x0b25.apimachinery.pkg.apis.meta.v1.O\
    bjectMeta.LabelsEntryR\x06labels\x12\\\n\x0bannotations\x18\x0c\x20\x03(\
    \x0b2:.apimachinery.pkg.apis.meta.v1.ObjectMeta.AnnotationsEntryR\x0bann\
    otations\x12W\n\x0fownerReferences\x18\r\x20\x03(\x0b2-.apimachinery.pkg\
    .apis.meta.v1.OwnerReferenceR\x0fownerReferences\x12\x1e\n\nfinalizers\
    \x18\x0e\x20\x03(\tR\nfinalizers\x12W\n\rmanagedFields\x18\x11\x20\x03(\
    \x0b21.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntryR\rmanagedFields\
    \x1a9\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a>\n\x10Annotat\
    ionsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xba\x01\n\x0eOwnerReference\
    \x12\x1e\n\napiVersion\x18\x05\x20\x01(\tR\napiVersion\x12\x12\n\x04kind\
    \x18\x01\x20\x01(\tR\x04kind\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04na\
    me\x12\x10\n\x03uid\x18\x04\x20\x01(\tR\x03uid\x12\x1e\n\ncontroller\x18\
    \x06\x20\x01(\x08R\ncontroller\x12.\n\x12blockOwnerDeletion\x18\x07\x20\
    \x01(\x08R\x12blockOwnerDeletion\"^\n\x15PartialObjectMetadata\x12E\n\
    \x08metadata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.Object\
    MetaR\x08metadata\"\xac\x01\n\x19PartialObjectMetadataList\x12C\n\x08met\
    adata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMetaR\x08\
    metadata\x12J\n\x05items\x18\x02\x20\x03(\x0b24.apimachinery.pkg.apis.me\
    ta.v1.PartialObjectMetadataR\x05items\"\x07\n\x05Patch\"\x8a\x01\n\x0cPa\
    tchOptions\x12\x16\n\x06dryRun\x18\x01\x20\x03(\tR\x06dryRun\x12\x14\n\
    \x05force\x18\x02\x20\x01(\x08R\x05force\x12\"\n\x0cfieldManager\x18\x03\
    \x20\x01(\tR\x0cfieldManager\x12(\n\x0ffieldValidation\x18\x04\x20\x01(\
    \tR\x0ffieldValidation\"K\n\rPreconditions\x12\x10\n\x03uid\x18\x01\x20\
    \x01(\tR\x03uid\x12(\n\x0fresourceVersion\x18\x02\x20\x01(\tR\x0fresourc\
    eVersion\"!\n\tRootPaths\x12\x14\n\x05paths\x18\x01\x20\x03(\tR\x05paths\
    \"a\n\x19ServerAddressByClientCIDR\x12\x1e\n\nclientCIDR\x18\x01\x20\x01\
    (\tR\nclientCIDR\x12$\n\rserverAddress\x18\x02\x20\x01(\tR\rserverAddres\
    s\"\xf3\x01\n\x06Status\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimac\
    hinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12\x16\n\x06status\x18\
    \x02\x20\x01(\tR\x06status\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07m\
    essage\x12\x16\n\x06reason\x18\x04\x20\x01(\tR\x06reason\x12F\n\x07detai\
    ls\x18\x05\x20\x01(\x0b2,.apimachinery.pkg.apis.meta.v1.StatusDetailsR\
    \x07details\x12\x12\n\x04code\x18\x06\x20\x01(\x05R\x04code\"U\n\x0bStat\
    usCause\x12\x16\n\x06reason\x18\x01\x20\x01(\tR\x06reason\x12\x18\n\x07m\
    essage\x18\x02\x20\x01(\tR\x07message\x12\x14\n\x05field\x18\x03\x20\x01\
    (\tR\x05field\"\xd1\x01\n\rStatusDetails\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12\x14\n\x05group\x18\x02\x20\x01(\tR\x05group\x12\x12\
    \n\x04kind\x18\x03\x20\x01(\tR\x04kind\x12\x10\n\x03uid\x18\x06\x20\x01(\
    \tR\x03uid\x12B\n\x06causes\x18\x04\x20\x03(\x0b2*.apimachinery.pkg.apis\
    .meta.v1.StatusCauseR\x06causes\x12,\n\x11retryAfterSeconds\x18\x05\x20\
    \x01(\x05R\x11retryAfterSeconds\"4\n\x0cTableOptions\x12$\n\rincludeObje\
    ct\x18\x01\x20\x01(\tR\rincludeObject\"6\n\x04Time\x12\x18\n\x07seconds\
    \x18\x01\x20\x01(\x03R\x07seconds\x12\x14\n\x05nanos\x18\x02\x20\x01(\
    \x05R\x05nanos\";\n\tTimestamp\x12\x18\n\x07seconds\x18\x01\x20\x01(\x03\
    R\x07seconds\x12\x14\n\x05nanos\x18\x02\x20\x01(\x05R\x05nanos\">\n\x08T\
    ypeMeta\x12\x12\n\x04kind\x18\x01\x20\x01(\tR\x04kind\x12\x1e\n\napiVers\
    ion\x18\x02\x20\x01(\tR\napiVersion\"u\n\rUpdateOptions\x12\x16\n\x06dry\
    Run\x18\x01\x20\x03(\tR\x06dryRun\x12\"\n\x0cfieldManager\x18\x02\x20\
    \x01(\tR\x0cfieldManager\x12(\n\x0ffieldValidation\x18\x03\x20\x01(\tR\
    \x0ffieldValidation\"\x1d\n\x05Verbs\x12\x14\n\x05items\x18\x01\x20\x03(\
    \tR\x05items\"`\n\nWatchEvent\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04t\
    ype\x12>\n\x06object\x18\x02\x20\x01(\x0b2&.apimachinery.pkg.runtime.Raw\
    ExtensionR\x06objectB&Z$k8s.io/apimachinery/pkg/apis/meta/v1\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::v1::file_descriptor().clone());
            deps.push(super::v1::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(44);
            messages.push(APIGroup::generated_message_descriptor_data());
            messages.push(APIGroupList::generated_message_descriptor_data());
            messages.push(APIResource::generated_message_descriptor_data());
            messages.push(APIResourceList::generated_message_descriptor_data());
            messages.push(APIVersions::generated_message_descriptor_data());
            messages.push(ApplyOptions::generated_message_descriptor_data());
            messages.push(Condition::generated_message_descriptor_data());
            messages.push(CreateOptions::generated_message_descriptor_data());
            messages.push(DeleteOptions::generated_message_descriptor_data());
            messages.push(Duration::generated_message_descriptor_data());
            messages.push(FieldsV1::generated_message_descriptor_data());
            messages.push(GetOptions::generated_message_descriptor_data());
            messages.push(GroupKind::generated_message_descriptor_data());
            messages.push(GroupResource::generated_message_descriptor_data());
            messages.push(GroupVersion::generated_message_descriptor_data());
            messages.push(GroupVersionForDiscovery::generated_message_descriptor_data());
            messages.push(GroupVersionKind::generated_message_descriptor_data());
            messages.push(GroupVersionResource::generated_message_descriptor_data());
            messages.push(LabelSelector::generated_message_descriptor_data());
            messages.push(LabelSelectorRequirement::generated_message_descriptor_data());
            messages.push(List::generated_message_descriptor_data());
            messages.push(ListMeta::generated_message_descriptor_data());
            messages.push(ListOptions::generated_message_descriptor_data());
            messages.push(ManagedFieldsEntry::generated_message_descriptor_data());
            messages.push(MicroTime::generated_message_descriptor_data());
            messages.push(ObjectMeta::generated_message_descriptor_data());
            messages.push(OwnerReference::generated_message_descriptor_data());
            messages.push(PartialObjectMetadata::generated_message_descriptor_data());
            messages.push(PartialObjectMetadataList::generated_message_descriptor_data());
            messages.push(Patch::generated_message_descriptor_data());
            messages.push(PatchOptions::generated_message_descriptor_data());
            messages.push(Preconditions::generated_message_descriptor_data());
            messages.push(RootPaths::generated_message_descriptor_data());
            messages.push(ServerAddressByClientCIDR::generated_message_descriptor_data());
            messages.push(Status::generated_message_descriptor_data());
            messages.push(StatusCause::generated_message_descriptor_data());
            messages.push(StatusDetails::generated_message_descriptor_data());
            messages.push(TableOptions::generated_message_descriptor_data());
            messages.push(Time::generated_message_descriptor_data());
            messages.push(Timestamp::generated_message_descriptor_data());
            messages.push(TypeMeta::generated_message_descriptor_data());
            messages.push(UpdateOptions::generated_message_descriptor_data());
            messages.push(Verbs::generated_message_descriptor_data());
            messages.push(WatchEvent::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
