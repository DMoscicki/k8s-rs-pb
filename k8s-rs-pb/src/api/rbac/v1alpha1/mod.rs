// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc 3.21.12
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `api/rbac/v1alpha1/generated.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.rbac.v1alpha1.AggregationRule)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AggregationRule {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.AggregationRule.clusterRoleSelectors)
    pub clusterRoleSelectors: ::std::vec::Vec<crate::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.rbac.v1alpha1.AggregationRule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AggregationRule {
    fn default() -> &'a AggregationRule {
        <AggregationRule as ::protobuf::Message>::default_instance()
    }
}

impl AggregationRule {
    pub fn new() -> AggregationRule {
        ::std::default::Default::default()
    }

    // repeated .apimachinery.pkg.apis.meta.v1.LabelSelector clusterRoleSelectors = 1;

    pub fn clusterRoleSelectors(&self) -> &[crate::apimachinery::pkg::apis::meta::v1::LabelSelector] {
        &self.clusterRoleSelectors
    }

    pub fn clear_clusterRoleSelectors(&mut self) {
        self.clusterRoleSelectors.clear();
    }

    // Param is passed by value, moved
    pub fn set_clusterRoleSelectors(&mut self, v: ::std::vec::Vec<crate::apimachinery::pkg::apis::meta::v1::LabelSelector>) {
        self.clusterRoleSelectors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_clusterRoleSelectors(&mut self) -> &mut ::std::vec::Vec<crate::apimachinery::pkg::apis::meta::v1::LabelSelector> {
        &mut self.clusterRoleSelectors
    }

    // Take field
    pub fn take_clusterRoleSelectors(&mut self) -> ::std::vec::Vec<crate::apimachinery::pkg::apis::meta::v1::LabelSelector> {
        ::std::mem::replace(&mut self.clusterRoleSelectors, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "clusterRoleSelectors",
            |m: &AggregationRule| { &m.clusterRoleSelectors },
            |m: &mut AggregationRule| { &mut m.clusterRoleSelectors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AggregationRule>(
            "AggregationRule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AggregationRule {
    const NAME: &'static str = "AggregationRule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.clusterRoleSelectors.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.clusterRoleSelectors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.clusterRoleSelectors {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AggregationRule {
        AggregationRule::new()
    }

    fn clear(&mut self) {
        self.clusterRoleSelectors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AggregationRule {
        static instance: AggregationRule = AggregationRule {
            clusterRoleSelectors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AggregationRule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AggregationRule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AggregationRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AggregationRule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.rbac.v1alpha1.ClusterRole)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClusterRole {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.ClusterRole.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.ClusterRole.rules)
    pub rules: ::std::vec::Vec<PolicyRule>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.ClusterRole.aggregationRule)
    pub aggregationRule: ::protobuf::MessageField<AggregationRule>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.rbac.v1alpha1.ClusterRole.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClusterRole {
    fn default() -> &'a ClusterRole {
        <ClusterRole as ::protobuf::Message>::default_instance()
    }
}

impl ClusterRole {
    pub fn new() -> ClusterRole {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // repeated .api.rbac.v1alpha1.PolicyRule rules = 2;

    pub fn rules(&self) -> &[PolicyRule] {
        &self.rules
    }

    pub fn clear_rules(&mut self) {
        self.rules.clear();
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: ::std::vec::Vec<PolicyRule>) {
        self.rules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rules(&mut self) -> &mut ::std::vec::Vec<PolicyRule> {
        &mut self.rules
    }

    // Take field
    pub fn take_rules(&mut self) -> ::std::vec::Vec<PolicyRule> {
        ::std::mem::replace(&mut self.rules, ::std::vec::Vec::new())
    }

    // optional .api.rbac.v1alpha1.AggregationRule aggregationRule = 3;

    pub fn aggregationRule(&self) -> &AggregationRule {
        self.aggregationRule.as_ref().unwrap_or_else(|| <AggregationRule as ::protobuf::Message>::default_instance())
    }

    pub fn clear_aggregationRule(&mut self) {
        self.aggregationRule.clear();
    }

    pub fn has_aggregationRule(&self) -> bool {
        self.aggregationRule.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aggregationRule(&mut self, v: AggregationRule) {
        self.aggregationRule = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aggregationRule(&mut self) -> &mut AggregationRule {
        self.aggregationRule.mut_or_insert_default()
    }

    // Take field
    pub fn take_aggregationRule(&mut self) -> AggregationRule {
        self.aggregationRule.take().unwrap_or_else(|| AggregationRule::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ClusterRole| { &m.metadata },
            |m: &mut ClusterRole| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rules",
            |m: &ClusterRole| { &m.rules },
            |m: &mut ClusterRole| { &mut m.rules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AggregationRule>(
            "aggregationRule",
            |m: &ClusterRole| { &m.aggregationRule },
            |m: &mut ClusterRole| { &mut m.aggregationRule },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClusterRole>(
            "ClusterRole",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClusterRole {
    const NAME: &'static str = "ClusterRole";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.rules.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.aggregationRule)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.aggregationRule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.rules {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.aggregationRule.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClusterRole {
        ClusterRole::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.rules.clear();
        self.aggregationRule.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClusterRole {
        static instance: ClusterRole = ClusterRole {
            metadata: ::protobuf::MessageField::none(),
            rules: ::std::vec::Vec::new(),
            aggregationRule: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClusterRole {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClusterRole").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClusterRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClusterRole {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.rbac.v1alpha1.ClusterRoleBinding)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClusterRoleBinding {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.ClusterRoleBinding.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.ClusterRoleBinding.subjects)
    pub subjects: ::std::vec::Vec<Subject>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.ClusterRoleBinding.roleRef)
    pub roleRef: ::protobuf::MessageField<RoleRef>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.rbac.v1alpha1.ClusterRoleBinding.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClusterRoleBinding {
    fn default() -> &'a ClusterRoleBinding {
        <ClusterRoleBinding as ::protobuf::Message>::default_instance()
    }
}

impl ClusterRoleBinding {
    pub fn new() -> ClusterRoleBinding {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // repeated .api.rbac.v1alpha1.Subject subjects = 2;

    pub fn subjects(&self) -> &[Subject] {
        &self.subjects
    }

    pub fn clear_subjects(&mut self) {
        self.subjects.clear();
    }

    // Param is passed by value, moved
    pub fn set_subjects(&mut self, v: ::std::vec::Vec<Subject>) {
        self.subjects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subjects(&mut self) -> &mut ::std::vec::Vec<Subject> {
        &mut self.subjects
    }

    // Take field
    pub fn take_subjects(&mut self) -> ::std::vec::Vec<Subject> {
        ::std::mem::replace(&mut self.subjects, ::std::vec::Vec::new())
    }

    // optional .api.rbac.v1alpha1.RoleRef roleRef = 3;

    pub fn roleRef(&self) -> &RoleRef {
        self.roleRef.as_ref().unwrap_or_else(|| <RoleRef as ::protobuf::Message>::default_instance())
    }

    pub fn clear_roleRef(&mut self) {
        self.roleRef.clear();
    }

    pub fn has_roleRef(&self) -> bool {
        self.roleRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roleRef(&mut self, v: RoleRef) {
        self.roleRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_roleRef(&mut self) -> &mut RoleRef {
        self.roleRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_roleRef(&mut self) -> RoleRef {
        self.roleRef.take().unwrap_or_else(|| RoleRef::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ClusterRoleBinding| { &m.metadata },
            |m: &mut ClusterRoleBinding| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subjects",
            |m: &ClusterRoleBinding| { &m.subjects },
            |m: &mut ClusterRoleBinding| { &mut m.subjects },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RoleRef>(
            "roleRef",
            |m: &ClusterRoleBinding| { &m.roleRef },
            |m: &mut ClusterRoleBinding| { &mut m.roleRef },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClusterRoleBinding>(
            "ClusterRoleBinding",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClusterRoleBinding {
    const NAME: &'static str = "ClusterRoleBinding";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.subjects.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.roleRef)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.subjects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.roleRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.subjects {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.roleRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClusterRoleBinding {
        ClusterRoleBinding::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.subjects.clear();
        self.roleRef.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClusterRoleBinding {
        static instance: ClusterRoleBinding = ClusterRoleBinding {
            metadata: ::protobuf::MessageField::none(),
            subjects: ::std::vec::Vec::new(),
            roleRef: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClusterRoleBinding {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClusterRoleBinding").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClusterRoleBinding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClusterRoleBinding {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.rbac.v1alpha1.ClusterRoleBindingList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClusterRoleBindingList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.ClusterRoleBindingList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.ClusterRoleBindingList.items)
    pub items: ::std::vec::Vec<ClusterRoleBinding>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.rbac.v1alpha1.ClusterRoleBindingList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClusterRoleBindingList {
    fn default() -> &'a ClusterRoleBindingList {
        <ClusterRoleBindingList as ::protobuf::Message>::default_instance()
    }
}

impl ClusterRoleBindingList {
    pub fn new() -> ClusterRoleBindingList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.rbac.v1alpha1.ClusterRoleBinding items = 2;

    pub fn items(&self) -> &[ClusterRoleBinding] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ClusterRoleBinding>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ClusterRoleBinding> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ClusterRoleBinding> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ClusterRoleBindingList| { &m.metadata },
            |m: &mut ClusterRoleBindingList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ClusterRoleBindingList| { &m.items },
            |m: &mut ClusterRoleBindingList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClusterRoleBindingList>(
            "ClusterRoleBindingList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClusterRoleBindingList {
    const NAME: &'static str = "ClusterRoleBindingList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClusterRoleBindingList {
        ClusterRoleBindingList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClusterRoleBindingList {
        static instance: ClusterRoleBindingList = ClusterRoleBindingList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClusterRoleBindingList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClusterRoleBindingList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClusterRoleBindingList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClusterRoleBindingList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.rbac.v1alpha1.ClusterRoleList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClusterRoleList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.ClusterRoleList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.ClusterRoleList.items)
    pub items: ::std::vec::Vec<ClusterRole>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.rbac.v1alpha1.ClusterRoleList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClusterRoleList {
    fn default() -> &'a ClusterRoleList {
        <ClusterRoleList as ::protobuf::Message>::default_instance()
    }
}

impl ClusterRoleList {
    pub fn new() -> ClusterRoleList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.rbac.v1alpha1.ClusterRole items = 2;

    pub fn items(&self) -> &[ClusterRole] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ClusterRole>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ClusterRole> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ClusterRole> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ClusterRoleList| { &m.metadata },
            |m: &mut ClusterRoleList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ClusterRoleList| { &m.items },
            |m: &mut ClusterRoleList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClusterRoleList>(
            "ClusterRoleList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClusterRoleList {
    const NAME: &'static str = "ClusterRoleList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClusterRoleList {
        ClusterRoleList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClusterRoleList {
        static instance: ClusterRoleList = ClusterRoleList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClusterRoleList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClusterRoleList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClusterRoleList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClusterRoleList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.rbac.v1alpha1.PolicyRule)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PolicyRule {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.PolicyRule.verbs)
    pub verbs: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.PolicyRule.apiGroups)
    pub apiGroups: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.PolicyRule.resources)
    pub resources: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.PolicyRule.resourceNames)
    pub resourceNames: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.PolicyRule.nonResourceURLs)
    pub nonResourceURLs: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.rbac.v1alpha1.PolicyRule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PolicyRule {
    fn default() -> &'a PolicyRule {
        <PolicyRule as ::protobuf::Message>::default_instance()
    }
}

impl PolicyRule {
    pub fn new() -> PolicyRule {
        ::std::default::Default::default()
    }

    // repeated string verbs = 1;

    pub fn verbs(&self) -> &[::std::string::String] {
        &self.verbs
    }

    pub fn clear_verbs(&mut self) {
        self.verbs.clear();
    }

    // Param is passed by value, moved
    pub fn set_verbs(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.verbs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_verbs(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.verbs
    }

    // Take field
    pub fn take_verbs(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.verbs, ::std::vec::Vec::new())
    }

    // repeated string apiGroups = 3;

    pub fn apiGroups(&self) -> &[::std::string::String] {
        &self.apiGroups
    }

    pub fn clear_apiGroups(&mut self) {
        self.apiGroups.clear();
    }

    // Param is passed by value, moved
    pub fn set_apiGroups(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.apiGroups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apiGroups(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.apiGroups
    }

    // Take field
    pub fn take_apiGroups(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.apiGroups, ::std::vec::Vec::new())
    }

    // repeated string resources = 4;

    pub fn resources(&self) -> &[::std::string::String] {
        &self.resources
    }

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.resources, ::std::vec::Vec::new())
    }

    // repeated string resourceNames = 5;

    pub fn resourceNames(&self) -> &[::std::string::String] {
        &self.resourceNames
    }

    pub fn clear_resourceNames(&mut self) {
        self.resourceNames.clear();
    }

    // Param is passed by value, moved
    pub fn set_resourceNames(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.resourceNames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resourceNames(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.resourceNames
    }

    // Take field
    pub fn take_resourceNames(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.resourceNames, ::std::vec::Vec::new())
    }

    // repeated string nonResourceURLs = 6;

    pub fn nonResourceURLs(&self) -> &[::std::string::String] {
        &self.nonResourceURLs
    }

    pub fn clear_nonResourceURLs(&mut self) {
        self.nonResourceURLs.clear();
    }

    // Param is passed by value, moved
    pub fn set_nonResourceURLs(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.nonResourceURLs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nonResourceURLs(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.nonResourceURLs
    }

    // Take field
    pub fn take_nonResourceURLs(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.nonResourceURLs, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "verbs",
            |m: &PolicyRule| { &m.verbs },
            |m: &mut PolicyRule| { &mut m.verbs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apiGroups",
            |m: &PolicyRule| { &m.apiGroups },
            |m: &mut PolicyRule| { &mut m.apiGroups },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resources",
            |m: &PolicyRule| { &m.resources },
            |m: &mut PolicyRule| { &mut m.resources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resourceNames",
            |m: &PolicyRule| { &m.resourceNames },
            |m: &mut PolicyRule| { &mut m.resourceNames },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nonResourceURLs",
            |m: &PolicyRule| { &m.nonResourceURLs },
            |m: &mut PolicyRule| { &mut m.nonResourceURLs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PolicyRule>(
            "PolicyRule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PolicyRule {
    const NAME: &'static str = "PolicyRule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.verbs.push(is.read_string()?);
                },
                26 => {
                    self.apiGroups.push(is.read_string()?);
                },
                34 => {
                    self.resources.push(is.read_string()?);
                },
                42 => {
                    self.resourceNames.push(is.read_string()?);
                },
                50 => {
                    self.nonResourceURLs.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.verbs {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.apiGroups {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.resources {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.resourceNames {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.nonResourceURLs {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.verbs {
            os.write_string(1, &v)?;
        };
        for v in &self.apiGroups {
            os.write_string(3, &v)?;
        };
        for v in &self.resources {
            os.write_string(4, &v)?;
        };
        for v in &self.resourceNames {
            os.write_string(5, &v)?;
        };
        for v in &self.nonResourceURLs {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PolicyRule {
        PolicyRule::new()
    }

    fn clear(&mut self) {
        self.verbs.clear();
        self.apiGroups.clear();
        self.resources.clear();
        self.resourceNames.clear();
        self.nonResourceURLs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PolicyRule {
        static instance: PolicyRule = PolicyRule {
            verbs: ::std::vec::Vec::new(),
            apiGroups: ::std::vec::Vec::new(),
            resources: ::std::vec::Vec::new(),
            resourceNames: ::std::vec::Vec::new(),
            nonResourceURLs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PolicyRule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PolicyRule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PolicyRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PolicyRule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.rbac.v1alpha1.Role)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Role {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.Role.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.Role.rules)
    pub rules: ::std::vec::Vec<PolicyRule>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.rbac.v1alpha1.Role.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Role {
    fn default() -> &'a Role {
        <Role as ::protobuf::Message>::default_instance()
    }
}

impl Role {
    pub fn new() -> Role {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // repeated .api.rbac.v1alpha1.PolicyRule rules = 2;

    pub fn rules(&self) -> &[PolicyRule] {
        &self.rules
    }

    pub fn clear_rules(&mut self) {
        self.rules.clear();
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: ::std::vec::Vec<PolicyRule>) {
        self.rules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rules(&mut self) -> &mut ::std::vec::Vec<PolicyRule> {
        &mut self.rules
    }

    // Take field
    pub fn take_rules(&mut self) -> ::std::vec::Vec<PolicyRule> {
        ::std::mem::replace(&mut self.rules, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &Role| { &m.metadata },
            |m: &mut Role| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rules",
            |m: &Role| { &m.rules },
            |m: &mut Role| { &mut m.rules },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Role>(
            "Role",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Role {
    const NAME: &'static str = "Role";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.rules.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.rules {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Role {
        Role::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.rules.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Role {
        static instance: Role = Role {
            metadata: ::protobuf::MessageField::none(),
            rules: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Role {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Role").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Role {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Role {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.rbac.v1alpha1.RoleBinding)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RoleBinding {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.RoleBinding.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.RoleBinding.subjects)
    pub subjects: ::std::vec::Vec<Subject>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.RoleBinding.roleRef)
    pub roleRef: ::protobuf::MessageField<RoleRef>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.rbac.v1alpha1.RoleBinding.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RoleBinding {
    fn default() -> &'a RoleBinding {
        <RoleBinding as ::protobuf::Message>::default_instance()
    }
}

impl RoleBinding {
    pub fn new() -> RoleBinding {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // repeated .api.rbac.v1alpha1.Subject subjects = 2;

    pub fn subjects(&self) -> &[Subject] {
        &self.subjects
    }

    pub fn clear_subjects(&mut self) {
        self.subjects.clear();
    }

    // Param is passed by value, moved
    pub fn set_subjects(&mut self, v: ::std::vec::Vec<Subject>) {
        self.subjects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subjects(&mut self) -> &mut ::std::vec::Vec<Subject> {
        &mut self.subjects
    }

    // Take field
    pub fn take_subjects(&mut self) -> ::std::vec::Vec<Subject> {
        ::std::mem::replace(&mut self.subjects, ::std::vec::Vec::new())
    }

    // optional .api.rbac.v1alpha1.RoleRef roleRef = 3;

    pub fn roleRef(&self) -> &RoleRef {
        self.roleRef.as_ref().unwrap_or_else(|| <RoleRef as ::protobuf::Message>::default_instance())
    }

    pub fn clear_roleRef(&mut self) {
        self.roleRef.clear();
    }

    pub fn has_roleRef(&self) -> bool {
        self.roleRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roleRef(&mut self, v: RoleRef) {
        self.roleRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_roleRef(&mut self) -> &mut RoleRef {
        self.roleRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_roleRef(&mut self) -> RoleRef {
        self.roleRef.take().unwrap_or_else(|| RoleRef::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &RoleBinding| { &m.metadata },
            |m: &mut RoleBinding| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subjects",
            |m: &RoleBinding| { &m.subjects },
            |m: &mut RoleBinding| { &mut m.subjects },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RoleRef>(
            "roleRef",
            |m: &RoleBinding| { &m.roleRef },
            |m: &mut RoleBinding| { &mut m.roleRef },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RoleBinding>(
            "RoleBinding",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RoleBinding {
    const NAME: &'static str = "RoleBinding";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.subjects.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.roleRef)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.subjects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.roleRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.subjects {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.roleRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RoleBinding {
        RoleBinding::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.subjects.clear();
        self.roleRef.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RoleBinding {
        static instance: RoleBinding = RoleBinding {
            metadata: ::protobuf::MessageField::none(),
            subjects: ::std::vec::Vec::new(),
            roleRef: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RoleBinding {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RoleBinding").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RoleBinding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoleBinding {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.rbac.v1alpha1.RoleBindingList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RoleBindingList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.RoleBindingList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.RoleBindingList.items)
    pub items: ::std::vec::Vec<RoleBinding>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.rbac.v1alpha1.RoleBindingList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RoleBindingList {
    fn default() -> &'a RoleBindingList {
        <RoleBindingList as ::protobuf::Message>::default_instance()
    }
}

impl RoleBindingList {
    pub fn new() -> RoleBindingList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.rbac.v1alpha1.RoleBinding items = 2;

    pub fn items(&self) -> &[RoleBinding] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<RoleBinding>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<RoleBinding> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<RoleBinding> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &RoleBindingList| { &m.metadata },
            |m: &mut RoleBindingList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &RoleBindingList| { &m.items },
            |m: &mut RoleBindingList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RoleBindingList>(
            "RoleBindingList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RoleBindingList {
    const NAME: &'static str = "RoleBindingList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RoleBindingList {
        RoleBindingList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RoleBindingList {
        static instance: RoleBindingList = RoleBindingList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RoleBindingList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RoleBindingList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RoleBindingList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoleBindingList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.rbac.v1alpha1.RoleList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RoleList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.RoleList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.RoleList.items)
    pub items: ::std::vec::Vec<Role>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.rbac.v1alpha1.RoleList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RoleList {
    fn default() -> &'a RoleList {
        <RoleList as ::protobuf::Message>::default_instance()
    }
}

impl RoleList {
    pub fn new() -> RoleList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.rbac.v1alpha1.Role items = 2;

    pub fn items(&self) -> &[Role] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<Role>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<Role> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<Role> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &RoleList| { &m.metadata },
            |m: &mut RoleList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &RoleList| { &m.items },
            |m: &mut RoleList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RoleList>(
            "RoleList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RoleList {
    const NAME: &'static str = "RoleList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RoleList {
        RoleList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RoleList {
        static instance: RoleList = RoleList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RoleList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RoleList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RoleList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoleList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.rbac.v1alpha1.RoleRef)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RoleRef {
    // message fields
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.RoleRef.apiGroup)
    pub apiGroup: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.RoleRef.kind)
    pub kind: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.RoleRef.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.rbac.v1alpha1.RoleRef.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RoleRef {
    fn default() -> &'a RoleRef {
        <RoleRef as ::protobuf::Message>::default_instance()
    }
}

impl RoleRef {
    pub fn new() -> RoleRef {
        ::std::default::Default::default()
    }

    // optional string apiGroup = 1;

    pub fn apiGroup(&self) -> &str {
        match self.apiGroup.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_apiGroup(&mut self) {
        self.apiGroup = ::std::option::Option::None;
    }

    pub fn has_apiGroup(&self) -> bool {
        self.apiGroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiGroup(&mut self, v: ::std::string::String) {
        self.apiGroup = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiGroup(&mut self) -> &mut ::std::string::String {
        if self.apiGroup.is_none() {
            self.apiGroup = ::std::option::Option::Some(::std::string::String::new());
        }
        self.apiGroup.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiGroup(&mut self) -> ::std::string::String {
        self.apiGroup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kind = 2;

    pub fn kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "apiGroup",
            |m: &RoleRef| { &m.apiGroup },
            |m: &mut RoleRef| { &mut m.apiGroup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &RoleRef| { &m.kind },
            |m: &mut RoleRef| { &mut m.kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &RoleRef| { &m.name },
            |m: &mut RoleRef| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RoleRef>(
            "RoleRef",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RoleRef {
    const NAME: &'static str = "RoleRef";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.apiGroup = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.kind = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.apiGroup.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.apiGroup.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.kind.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RoleRef {
        RoleRef::new()
    }

    fn clear(&mut self) {
        self.apiGroup = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RoleRef {
        static instance: RoleRef = RoleRef {
            apiGroup: ::std::option::Option::None,
            kind: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RoleRef {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RoleRef").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RoleRef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoleRef {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.rbac.v1alpha1.Subject)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Subject {
    // message fields
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.Subject.kind)
    pub kind: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.Subject.apiVersion)
    pub apiVersion: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.Subject.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.rbac.v1alpha1.Subject.namespace)
    pub namespace: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.rbac.v1alpha1.Subject.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Subject {
    fn default() -> &'a Subject {
        <Subject as ::protobuf::Message>::default_instance()
    }
}

impl Subject {
    pub fn new() -> Subject {
        ::std::default::Default::default()
    }

    // optional string kind = 1;

    pub fn kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string apiVersion = 2;

    pub fn apiVersion(&self) -> &str {
        match self.apiVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_apiVersion(&mut self) {
        self.apiVersion = ::std::option::Option::None;
    }

    pub fn has_apiVersion(&self) -> bool {
        self.apiVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiVersion(&mut self, v: ::std::string::String) {
        self.apiVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiVersion(&mut self) -> &mut ::std::string::String {
        if self.apiVersion.is_none() {
            self.apiVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.apiVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiVersion(&mut self) -> ::std::string::String {
        self.apiVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string namespace = 4;

    pub fn namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_namespace(&mut self) {
        self.namespace = ::std::option::Option::None;
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &Subject| { &m.kind },
            |m: &mut Subject| { &mut m.kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "apiVersion",
            |m: &Subject| { &m.apiVersion },
            |m: &mut Subject| { &mut m.apiVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Subject| { &m.name },
            |m: &mut Subject| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "namespace",
            |m: &Subject| { &m.namespace },
            |m: &mut Subject| { &mut m.namespace },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Subject>(
            "Subject",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Subject {
    const NAME: &'static str = "Subject";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.kind = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.apiVersion = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.namespace = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.apiVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.kind.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.apiVersion.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.namespace.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Subject {
        Subject::new()
    }

    fn clear(&mut self) {
        self.kind = ::std::option::Option::None;
        self.apiVersion = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.namespace = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Subject {
        static instance: Subject = Subject {
            kind: ::std::option::Option::None,
            apiVersion: ::std::option::Option::None,
            name: ::std::option::Option::None,
            namespace: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Subject {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Subject").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Subject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Subject {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n!api/rbac/v1alpha1/generated.proto\x12\x11api.rbac.v1alpha1\x1a-apimac\
    hinery/pkg/apis/meta/v1/generated.proto\x1a(apimachinery/pkg/runtime/gen\
    erated.proto\x1a/apimachinery/pkg/runtime/schema/generated.proto\"s\n\
    \x0fAggregationRule\x12`\n\x14clusterRoleSelectors\x18\x01\x20\x03(\x0b2\
    ,.apimachinery.pkg.apis.meta.v1.LabelSelectorR\x14clusterRoleSelectors\"\
    \xd7\x01\n\x0bClusterRole\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apim\
    achinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x123\n\x05rules\x18\
    \x02\x20\x03(\x0b2\x1d.api.rbac.v1alpha1.PolicyRuleR\x05rules\x12L\n\x0f\
    aggregationRule\x18\x03\x20\x01(\x0b2\".api.rbac.v1alpha1.AggregationRul\
    eR\x0faggregationRule\"\xc9\x01\n\x12ClusterRoleBinding\x12E\n\x08metada\
    ta\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08m\
    etadata\x126\n\x08subjects\x18\x02\x20\x03(\x0b2\x1a.api.rbac.v1alpha1.S\
    ubjectR\x08subjects\x124\n\x07roleRef\x18\x03\x20\x01(\x0b2\x1a.api.rbac\
    .v1alpha1.RoleRefR\x07roleRef\"\x9a\x01\n\x16ClusterRoleBindingList\x12C\
    \n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.List\
    MetaR\x08metadata\x12;\n\x05items\x18\x02\x20\x03(\x0b2%.api.rbac.v1alph\
    a1.ClusterRoleBindingR\x05items\"\x8c\x01\n\x0fClusterRoleList\x12C\n\
    \x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMe\
    taR\x08metadata\x124\n\x05items\x18\x02\x20\x03(\x0b2\x1e.api.rbac.v1alp\
    ha1.ClusterRoleR\x05items\"\xae\x01\n\nPolicyRule\x12\x14\n\x05verbs\x18\
    \x01\x20\x03(\tR\x05verbs\x12\x1c\n\tapiGroups\x18\x03\x20\x03(\tR\tapiG\
    roups\x12\x1c\n\tresources\x18\x04\x20\x03(\tR\tresources\x12$\n\rresour\
    ceNames\x18\x05\x20\x03(\tR\rresourceNames\x12(\n\x0fnonResourceURLs\x18\
    \x06\x20\x03(\tR\x0fnonResourceURLs\"\x82\x01\n\x04Role\x12E\n\x08metada\
    ta\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08m\
    etadata\x123\n\x05rules\x18\x02\x20\x03(\x0b2\x1d.api.rbac.v1alpha1.Poli\
    cyRuleR\x05rules\"\xc2\x01\n\x0bRoleBinding\x12E\n\x08metadata\x18\x01\
    \x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\
    \x126\n\x08subjects\x18\x02\x20\x03(\x0b2\x1a.api.rbac.v1alpha1.SubjectR\
    \x08subjects\x124\n\x07roleRef\x18\x03\x20\x01(\x0b2\x1a.api.rbac.v1alph\
    a1.RoleRefR\x07roleRef\"\x8c\x01\n\x0fRoleBindingList\x12C\n\x08metadata\
    \x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metad\
    ata\x124\n\x05items\x18\x02\x20\x03(\x0b2\x1e.api.rbac.v1alpha1.RoleBind\
    ingR\x05items\"~\n\x08RoleList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'\
    .apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12-\n\x05items\x18\
    \x02\x20\x03(\x0b2\x17.api.rbac.v1alpha1.RoleR\x05items\"M\n\x07RoleRef\
    \x12\x1a\n\x08apiGroup\x18\x01\x20\x01(\tR\x08apiGroup\x12\x12\n\x04kind\
    \x18\x02\x20\x01(\tR\x04kind\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04na\
    me\"o\n\x07Subject\x12\x12\n\x04kind\x18\x01\x20\x01(\tR\x04kind\x12\x1e\
    \n\napiVersion\x18\x02\x20\x01(\tR\napiVersion\x12\x12\n\x04name\x18\x03\
    \x20\x01(\tR\x04name\x12\x1c\n\tnamespace\x18\x04\x20\x01(\tR\tnamespace\
    B\x1aZ\x18k8s.io/api/rbac/v1alpha1\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::v1alpha1::file_descriptor().clone());
            deps.push(super::v1alpha1::file_descriptor().clone());
            deps.push(super::v1alpha1::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(12);
            messages.push(AggregationRule::generated_message_descriptor_data());
            messages.push(ClusterRole::generated_message_descriptor_data());
            messages.push(ClusterRoleBinding::generated_message_descriptor_data());
            messages.push(ClusterRoleBindingList::generated_message_descriptor_data());
            messages.push(ClusterRoleList::generated_message_descriptor_data());
            messages.push(PolicyRule::generated_message_descriptor_data());
            messages.push(Role::generated_message_descriptor_data());
            messages.push(RoleBinding::generated_message_descriptor_data());
            messages.push(RoleBindingList::generated_message_descriptor_data());
            messages.push(RoleList::generated_message_descriptor_data());
            messages.push(RoleRef::generated_message_descriptor_data());
            messages.push(Subject::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
