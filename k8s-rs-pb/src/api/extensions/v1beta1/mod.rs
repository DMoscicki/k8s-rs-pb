// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc 3.21.12
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `api/extensions/v1beta1/generated.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.DaemonSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DaemonSet {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSet.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSet.spec)
    pub spec: ::protobuf::MessageField<DaemonSetSpec>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSet.status)
    pub status: ::protobuf::MessageField<DaemonSetStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.DaemonSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DaemonSet {
    fn default() -> &'a DaemonSet {
        <DaemonSet as ::protobuf::Message>::default_instance()
    }
}

impl DaemonSet {
    pub fn new() -> DaemonSet {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.extensions.v1beta1.DaemonSetSpec spec = 2;

    pub fn spec(&self) -> &DaemonSetSpec {
        self.spec.as_ref().unwrap_or_else(|| <DaemonSetSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: DaemonSetSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut DaemonSetSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> DaemonSetSpec {
        self.spec.take().unwrap_or_else(|| DaemonSetSpec::new())
    }

    // optional .api.extensions.v1beta1.DaemonSetStatus status = 3;

    pub fn status(&self) -> &DaemonSetStatus {
        self.status.as_ref().unwrap_or_else(|| <DaemonSetStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: DaemonSetStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut DaemonSetStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> DaemonSetStatus {
        self.status.take().unwrap_or_else(|| DaemonSetStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &DaemonSet| { &m.metadata },
            |m: &mut DaemonSet| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DaemonSetSpec>(
            "spec",
            |m: &DaemonSet| { &m.spec },
            |m: &mut DaemonSet| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DaemonSetStatus>(
            "status",
            |m: &DaemonSet| { &m.status },
            |m: &mut DaemonSet| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DaemonSet>(
            "DaemonSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DaemonSet {
    const NAME: &'static str = "DaemonSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DaemonSet {
        DaemonSet::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DaemonSet {
        static instance: DaemonSet = DaemonSet {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DaemonSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DaemonSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DaemonSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaemonSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.DaemonSetCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DaemonSetCondition {
    // message fields
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSetCondition.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSetCondition.status)
    pub status: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSetCondition.lastTransitionTime)
    pub lastTransitionTime: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSetCondition.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSetCondition.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.DaemonSetCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DaemonSetCondition {
    fn default() -> &'a DaemonSetCondition {
        <DaemonSetCondition as ::protobuf::Message>::default_instance()
    }
}

impl DaemonSetCondition {
    pub fn new() -> DaemonSetCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

    pub fn lastTransitionTime(&self) -> &crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastTransitionTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional string reason = 4;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 5;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &DaemonSetCondition| { &m.type_ },
            |m: &mut DaemonSetCondition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &DaemonSetCondition| { &m.status },
            |m: &mut DaemonSetCondition| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::Time>(
            "lastTransitionTime",
            |m: &DaemonSetCondition| { &m.lastTransitionTime },
            |m: &mut DaemonSetCondition| { &mut m.lastTransitionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &DaemonSetCondition| { &m.reason },
            |m: &mut DaemonSetCondition| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &DaemonSetCondition| { &m.message },
            |m: &mut DaemonSetCondition| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DaemonSetCondition>(
            "DaemonSetCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DaemonSetCondition {
    const NAME: &'static str = "DaemonSetCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTransitionTime)?;
                },
                34 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DaemonSetCondition {
        DaemonSetCondition::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.lastTransitionTime.clear();
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DaemonSetCondition {
        static instance: DaemonSetCondition = DaemonSetCondition {
            type_: ::std::option::Option::None,
            status: ::std::option::Option::None,
            lastTransitionTime: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DaemonSetCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DaemonSetCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DaemonSetCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaemonSetCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.DaemonSetList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DaemonSetList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSetList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSetList.items)
    pub items: ::std::vec::Vec<DaemonSet>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.DaemonSetList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DaemonSetList {
    fn default() -> &'a DaemonSetList {
        <DaemonSetList as ::protobuf::Message>::default_instance()
    }
}

impl DaemonSetList {
    pub fn new() -> DaemonSetList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.extensions.v1beta1.DaemonSet items = 2;

    pub fn items(&self) -> &[DaemonSet] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<DaemonSet>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<DaemonSet> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<DaemonSet> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &DaemonSetList| { &m.metadata },
            |m: &mut DaemonSetList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &DaemonSetList| { &m.items },
            |m: &mut DaemonSetList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DaemonSetList>(
            "DaemonSetList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DaemonSetList {
    const NAME: &'static str = "DaemonSetList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DaemonSetList {
        DaemonSetList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DaemonSetList {
        static instance: DaemonSetList = DaemonSetList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DaemonSetList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DaemonSetList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DaemonSetList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaemonSetList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.DaemonSetSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DaemonSetSpec {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSetSpec.selector)
    pub selector: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSetSpec.template)
    pub template: ::protobuf::MessageField<crate::api::core::v1::PodTemplateSpec>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSetSpec.updateStrategy)
    pub updateStrategy: ::protobuf::MessageField<DaemonSetUpdateStrategy>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSetSpec.minReadySeconds)
    pub minReadySeconds: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSetSpec.templateGeneration)
    pub templateGeneration: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSetSpec.revisionHistoryLimit)
    pub revisionHistoryLimit: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.DaemonSetSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DaemonSetSpec {
    fn default() -> &'a DaemonSetSpec {
        <DaemonSetSpec as ::protobuf::Message>::default_instance()
    }
}

impl DaemonSetSpec {
    pub fn new() -> DaemonSetSpec {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;

    pub fn selector(&self) -> &crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    pub fn has_selector(&self) -> bool {
        self.selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.selector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selector(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.mut_or_insert_default()
    }

    // Take field
    pub fn take_selector(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional .api.core.v1.PodTemplateSpec template = 2;

    pub fn template(&self) -> &crate::api::core::v1::PodTemplateSpec {
        self.template.as_ref().unwrap_or_else(|| <crate::api::core::v1::PodTemplateSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_template(&mut self) {
        self.template.clear();
    }

    pub fn has_template(&self) -> bool {
        self.template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template(&mut self, v: crate::api::core::v1::PodTemplateSpec) {
        self.template = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template(&mut self) -> &mut crate::api::core::v1::PodTemplateSpec {
        self.template.mut_or_insert_default()
    }

    // Take field
    pub fn take_template(&mut self) -> crate::api::core::v1::PodTemplateSpec {
        self.template.take().unwrap_or_else(|| crate::api::core::v1::PodTemplateSpec::new())
    }

    // optional .api.extensions.v1beta1.DaemonSetUpdateStrategy updateStrategy = 3;

    pub fn updateStrategy(&self) -> &DaemonSetUpdateStrategy {
        self.updateStrategy.as_ref().unwrap_or_else(|| <DaemonSetUpdateStrategy as ::protobuf::Message>::default_instance())
    }

    pub fn clear_updateStrategy(&mut self) {
        self.updateStrategy.clear();
    }

    pub fn has_updateStrategy(&self) -> bool {
        self.updateStrategy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updateStrategy(&mut self, v: DaemonSetUpdateStrategy) {
        self.updateStrategy = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updateStrategy(&mut self) -> &mut DaemonSetUpdateStrategy {
        self.updateStrategy.mut_or_insert_default()
    }

    // Take field
    pub fn take_updateStrategy(&mut self) -> DaemonSetUpdateStrategy {
        self.updateStrategy.take().unwrap_or_else(|| DaemonSetUpdateStrategy::new())
    }

    // optional int32 minReadySeconds = 4;

    pub fn minReadySeconds(&self) -> i32 {
        self.minReadySeconds.unwrap_or(0)
    }

    pub fn clear_minReadySeconds(&mut self) {
        self.minReadySeconds = ::std::option::Option::None;
    }

    pub fn has_minReadySeconds(&self) -> bool {
        self.minReadySeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minReadySeconds(&mut self, v: i32) {
        self.minReadySeconds = ::std::option::Option::Some(v);
    }

    // optional int64 templateGeneration = 5;

    pub fn templateGeneration(&self) -> i64 {
        self.templateGeneration.unwrap_or(0)
    }

    pub fn clear_templateGeneration(&mut self) {
        self.templateGeneration = ::std::option::Option::None;
    }

    pub fn has_templateGeneration(&self) -> bool {
        self.templateGeneration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_templateGeneration(&mut self, v: i64) {
        self.templateGeneration = ::std::option::Option::Some(v);
    }

    // optional int32 revisionHistoryLimit = 6;

    pub fn revisionHistoryLimit(&self) -> i32 {
        self.revisionHistoryLimit.unwrap_or(0)
    }

    pub fn clear_revisionHistoryLimit(&mut self) {
        self.revisionHistoryLimit = ::std::option::Option::None;
    }

    pub fn has_revisionHistoryLimit(&self) -> bool {
        self.revisionHistoryLimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revisionHistoryLimit(&mut self, v: i32) {
        self.revisionHistoryLimit = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "selector",
            |m: &DaemonSetSpec| { &m.selector },
            |m: &mut DaemonSetSpec| { &mut m.selector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::api::core::v1::PodTemplateSpec>(
            "template",
            |m: &DaemonSetSpec| { &m.template },
            |m: &mut DaemonSetSpec| { &mut m.template },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DaemonSetUpdateStrategy>(
            "updateStrategy",
            |m: &DaemonSetSpec| { &m.updateStrategy },
            |m: &mut DaemonSetSpec| { &mut m.updateStrategy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minReadySeconds",
            |m: &DaemonSetSpec| { &m.minReadySeconds },
            |m: &mut DaemonSetSpec| { &mut m.minReadySeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "templateGeneration",
            |m: &DaemonSetSpec| { &m.templateGeneration },
            |m: &mut DaemonSetSpec| { &mut m.templateGeneration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revisionHistoryLimit",
            |m: &DaemonSetSpec| { &m.revisionHistoryLimit },
            |m: &mut DaemonSetSpec| { &mut m.revisionHistoryLimit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DaemonSetSpec>(
            "DaemonSetSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DaemonSetSpec {
    const NAME: &'static str = "DaemonSetSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.selector)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.template)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.updateStrategy)?;
                },
                32 => {
                    self.minReadySeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.templateGeneration = ::std::option::Option::Some(is.read_int64()?);
                },
                48 => {
                    self.revisionHistoryLimit = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.updateStrategy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.minReadySeconds {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.templateGeneration {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.revisionHistoryLimit {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.selector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.template.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.updateStrategy.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.minReadySeconds {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.templateGeneration {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.revisionHistoryLimit {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DaemonSetSpec {
        DaemonSetSpec::new()
    }

    fn clear(&mut self) {
        self.selector.clear();
        self.template.clear();
        self.updateStrategy.clear();
        self.minReadySeconds = ::std::option::Option::None;
        self.templateGeneration = ::std::option::Option::None;
        self.revisionHistoryLimit = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DaemonSetSpec {
        static instance: DaemonSetSpec = DaemonSetSpec {
            selector: ::protobuf::MessageField::none(),
            template: ::protobuf::MessageField::none(),
            updateStrategy: ::protobuf::MessageField::none(),
            minReadySeconds: ::std::option::Option::None,
            templateGeneration: ::std::option::Option::None,
            revisionHistoryLimit: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DaemonSetSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DaemonSetSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DaemonSetSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaemonSetSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.DaemonSetStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DaemonSetStatus {
    // message fields
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSetStatus.currentNumberScheduled)
    pub currentNumberScheduled: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSetStatus.numberMisscheduled)
    pub numberMisscheduled: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSetStatus.desiredNumberScheduled)
    pub desiredNumberScheduled: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSetStatus.numberReady)
    pub numberReady: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSetStatus.observedGeneration)
    pub observedGeneration: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSetStatus.updatedNumberScheduled)
    pub updatedNumberScheduled: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSetStatus.numberAvailable)
    pub numberAvailable: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSetStatus.numberUnavailable)
    pub numberUnavailable: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSetStatus.collisionCount)
    pub collisionCount: ::std::option::Option<i32>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSetStatus.conditions)
    pub conditions: ::std::vec::Vec<DaemonSetCondition>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.DaemonSetStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DaemonSetStatus {
    fn default() -> &'a DaemonSetStatus {
        <DaemonSetStatus as ::protobuf::Message>::default_instance()
    }
}

impl DaemonSetStatus {
    pub fn new() -> DaemonSetStatus {
        ::std::default::Default::default()
    }

    // optional int32 currentNumberScheduled = 1;

    pub fn currentNumberScheduled(&self) -> i32 {
        self.currentNumberScheduled.unwrap_or(0)
    }

    pub fn clear_currentNumberScheduled(&mut self) {
        self.currentNumberScheduled = ::std::option::Option::None;
    }

    pub fn has_currentNumberScheduled(&self) -> bool {
        self.currentNumberScheduled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currentNumberScheduled(&mut self, v: i32) {
        self.currentNumberScheduled = ::std::option::Option::Some(v);
    }

    // optional int32 numberMisscheduled = 2;

    pub fn numberMisscheduled(&self) -> i32 {
        self.numberMisscheduled.unwrap_or(0)
    }

    pub fn clear_numberMisscheduled(&mut self) {
        self.numberMisscheduled = ::std::option::Option::None;
    }

    pub fn has_numberMisscheduled(&self) -> bool {
        self.numberMisscheduled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numberMisscheduled(&mut self, v: i32) {
        self.numberMisscheduled = ::std::option::Option::Some(v);
    }

    // optional int32 desiredNumberScheduled = 3;

    pub fn desiredNumberScheduled(&self) -> i32 {
        self.desiredNumberScheduled.unwrap_or(0)
    }

    pub fn clear_desiredNumberScheduled(&mut self) {
        self.desiredNumberScheduled = ::std::option::Option::None;
    }

    pub fn has_desiredNumberScheduled(&self) -> bool {
        self.desiredNumberScheduled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desiredNumberScheduled(&mut self, v: i32) {
        self.desiredNumberScheduled = ::std::option::Option::Some(v);
    }

    // optional int32 numberReady = 4;

    pub fn numberReady(&self) -> i32 {
        self.numberReady.unwrap_or(0)
    }

    pub fn clear_numberReady(&mut self) {
        self.numberReady = ::std::option::Option::None;
    }

    pub fn has_numberReady(&self) -> bool {
        self.numberReady.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numberReady(&mut self, v: i32) {
        self.numberReady = ::std::option::Option::Some(v);
    }

    // optional int64 observedGeneration = 5;

    pub fn observedGeneration(&self) -> i64 {
        self.observedGeneration.unwrap_or(0)
    }

    pub fn clear_observedGeneration(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
    }

    pub fn has_observedGeneration(&self) -> bool {
        self.observedGeneration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observedGeneration(&mut self, v: i64) {
        self.observedGeneration = ::std::option::Option::Some(v);
    }

    // optional int32 updatedNumberScheduled = 6;

    pub fn updatedNumberScheduled(&self) -> i32 {
        self.updatedNumberScheduled.unwrap_or(0)
    }

    pub fn clear_updatedNumberScheduled(&mut self) {
        self.updatedNumberScheduled = ::std::option::Option::None;
    }

    pub fn has_updatedNumberScheduled(&self) -> bool {
        self.updatedNumberScheduled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updatedNumberScheduled(&mut self, v: i32) {
        self.updatedNumberScheduled = ::std::option::Option::Some(v);
    }

    // optional int32 numberAvailable = 7;

    pub fn numberAvailable(&self) -> i32 {
        self.numberAvailable.unwrap_or(0)
    }

    pub fn clear_numberAvailable(&mut self) {
        self.numberAvailable = ::std::option::Option::None;
    }

    pub fn has_numberAvailable(&self) -> bool {
        self.numberAvailable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numberAvailable(&mut self, v: i32) {
        self.numberAvailable = ::std::option::Option::Some(v);
    }

    // optional int32 numberUnavailable = 8;

    pub fn numberUnavailable(&self) -> i32 {
        self.numberUnavailable.unwrap_or(0)
    }

    pub fn clear_numberUnavailable(&mut self) {
        self.numberUnavailable = ::std::option::Option::None;
    }

    pub fn has_numberUnavailable(&self) -> bool {
        self.numberUnavailable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numberUnavailable(&mut self, v: i32) {
        self.numberUnavailable = ::std::option::Option::Some(v);
    }

    // optional int32 collisionCount = 9;

    pub fn collisionCount(&self) -> i32 {
        self.collisionCount.unwrap_or(0)
    }

    pub fn clear_collisionCount(&mut self) {
        self.collisionCount = ::std::option::Option::None;
    }

    pub fn has_collisionCount(&self) -> bool {
        self.collisionCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_collisionCount(&mut self, v: i32) {
        self.collisionCount = ::std::option::Option::Some(v);
    }

    // repeated .api.extensions.v1beta1.DaemonSetCondition conditions = 10;

    pub fn conditions(&self) -> &[DaemonSetCondition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<DaemonSetCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<DaemonSetCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<DaemonSetCondition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currentNumberScheduled",
            |m: &DaemonSetStatus| { &m.currentNumberScheduled },
            |m: &mut DaemonSetStatus| { &mut m.currentNumberScheduled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "numberMisscheduled",
            |m: &DaemonSetStatus| { &m.numberMisscheduled },
            |m: &mut DaemonSetStatus| { &mut m.numberMisscheduled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desiredNumberScheduled",
            |m: &DaemonSetStatus| { &m.desiredNumberScheduled },
            |m: &mut DaemonSetStatus| { &mut m.desiredNumberScheduled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "numberReady",
            |m: &DaemonSetStatus| { &m.numberReady },
            |m: &mut DaemonSetStatus| { &mut m.numberReady },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "observedGeneration",
            |m: &DaemonSetStatus| { &m.observedGeneration },
            |m: &mut DaemonSetStatus| { &mut m.observedGeneration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "updatedNumberScheduled",
            |m: &DaemonSetStatus| { &m.updatedNumberScheduled },
            |m: &mut DaemonSetStatus| { &mut m.updatedNumberScheduled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "numberAvailable",
            |m: &DaemonSetStatus| { &m.numberAvailable },
            |m: &mut DaemonSetStatus| { &mut m.numberAvailable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "numberUnavailable",
            |m: &DaemonSetStatus| { &m.numberUnavailable },
            |m: &mut DaemonSetStatus| { &mut m.numberUnavailable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "collisionCount",
            |m: &DaemonSetStatus| { &m.collisionCount },
            |m: &mut DaemonSetStatus| { &mut m.collisionCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &DaemonSetStatus| { &m.conditions },
            |m: &mut DaemonSetStatus| { &mut m.conditions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DaemonSetStatus>(
            "DaemonSetStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DaemonSetStatus {
    const NAME: &'static str = "DaemonSetStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.currentNumberScheduled = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.numberMisscheduled = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.desiredNumberScheduled = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.numberReady = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.observedGeneration = ::std::option::Option::Some(is.read_int64()?);
                },
                48 => {
                    self.updatedNumberScheduled = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.numberAvailable = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.numberUnavailable = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.collisionCount = ::std::option::Option::Some(is.read_int32()?);
                },
                82 => {
                    self.conditions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.currentNumberScheduled {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.numberMisscheduled {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.desiredNumberScheduled {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.numberReady {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.observedGeneration {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.updatedNumberScheduled {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.numberAvailable {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.numberUnavailable {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.collisionCount {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.currentNumberScheduled {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.numberMisscheduled {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.desiredNumberScheduled {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.numberReady {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.observedGeneration {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.updatedNumberScheduled {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.numberAvailable {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.numberUnavailable {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.collisionCount {
            os.write_int32(9, v)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DaemonSetStatus {
        DaemonSetStatus::new()
    }

    fn clear(&mut self) {
        self.currentNumberScheduled = ::std::option::Option::None;
        self.numberMisscheduled = ::std::option::Option::None;
        self.desiredNumberScheduled = ::std::option::Option::None;
        self.numberReady = ::std::option::Option::None;
        self.observedGeneration = ::std::option::Option::None;
        self.updatedNumberScheduled = ::std::option::Option::None;
        self.numberAvailable = ::std::option::Option::None;
        self.numberUnavailable = ::std::option::Option::None;
        self.collisionCount = ::std::option::Option::None;
        self.conditions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DaemonSetStatus {
        static instance: DaemonSetStatus = DaemonSetStatus {
            currentNumberScheduled: ::std::option::Option::None,
            numberMisscheduled: ::std::option::Option::None,
            desiredNumberScheduled: ::std::option::Option::None,
            numberReady: ::std::option::Option::None,
            observedGeneration: ::std::option::Option::None,
            updatedNumberScheduled: ::std::option::Option::None,
            numberAvailable: ::std::option::Option::None,
            numberUnavailable: ::std::option::Option::None,
            collisionCount: ::std::option::Option::None,
            conditions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DaemonSetStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DaemonSetStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DaemonSetStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaemonSetStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.DaemonSetUpdateStrategy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DaemonSetUpdateStrategy {
    // message fields
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSetUpdateStrategy.type)
    pub type_: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DaemonSetUpdateStrategy.rollingUpdate)
    pub rollingUpdate: ::protobuf::MessageField<RollingUpdateDaemonSet>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.DaemonSetUpdateStrategy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DaemonSetUpdateStrategy {
    fn default() -> &'a DaemonSetUpdateStrategy {
        <DaemonSetUpdateStrategy as ::protobuf::Message>::default_instance()
    }
}

impl DaemonSetUpdateStrategy {
    pub fn new() -> DaemonSetUpdateStrategy {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.extensions.v1beta1.RollingUpdateDaemonSet rollingUpdate = 2;

    pub fn rollingUpdate(&self) -> &RollingUpdateDaemonSet {
        self.rollingUpdate.as_ref().unwrap_or_else(|| <RollingUpdateDaemonSet as ::protobuf::Message>::default_instance())
    }

    pub fn clear_rollingUpdate(&mut self) {
        self.rollingUpdate.clear();
    }

    pub fn has_rollingUpdate(&self) -> bool {
        self.rollingUpdate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollingUpdate(&mut self, v: RollingUpdateDaemonSet) {
        self.rollingUpdate = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollingUpdate(&mut self) -> &mut RollingUpdateDaemonSet {
        self.rollingUpdate.mut_or_insert_default()
    }

    // Take field
    pub fn take_rollingUpdate(&mut self) -> RollingUpdateDaemonSet {
        self.rollingUpdate.take().unwrap_or_else(|| RollingUpdateDaemonSet::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &DaemonSetUpdateStrategy| { &m.type_ },
            |m: &mut DaemonSetUpdateStrategy| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RollingUpdateDaemonSet>(
            "rollingUpdate",
            |m: &DaemonSetUpdateStrategy| { &m.rollingUpdate },
            |m: &mut DaemonSetUpdateStrategy| { &mut m.rollingUpdate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DaemonSetUpdateStrategy>(
            "DaemonSetUpdateStrategy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DaemonSetUpdateStrategy {
    const NAME: &'static str = "DaemonSetUpdateStrategy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rollingUpdate)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.rollingUpdate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.rollingUpdate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DaemonSetUpdateStrategy {
        DaemonSetUpdateStrategy::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.rollingUpdate.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DaemonSetUpdateStrategy {
        static instance: DaemonSetUpdateStrategy = DaemonSetUpdateStrategy {
            type_: ::std::option::Option::None,
            rollingUpdate: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DaemonSetUpdateStrategy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DaemonSetUpdateStrategy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DaemonSetUpdateStrategy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaemonSetUpdateStrategy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.Deployment)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Deployment {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.Deployment.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.Deployment.spec)
    pub spec: ::protobuf::MessageField<DeploymentSpec>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.Deployment.status)
    pub status: ::protobuf::MessageField<DeploymentStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.Deployment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Deployment {
    fn default() -> &'a Deployment {
        <Deployment as ::protobuf::Message>::default_instance()
    }
}

impl Deployment {
    pub fn new() -> Deployment {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.extensions.v1beta1.DeploymentSpec spec = 2;

    pub fn spec(&self) -> &DeploymentSpec {
        self.spec.as_ref().unwrap_or_else(|| <DeploymentSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: DeploymentSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut DeploymentSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> DeploymentSpec {
        self.spec.take().unwrap_or_else(|| DeploymentSpec::new())
    }

    // optional .api.extensions.v1beta1.DeploymentStatus status = 3;

    pub fn status(&self) -> &DeploymentStatus {
        self.status.as_ref().unwrap_or_else(|| <DeploymentStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: DeploymentStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut DeploymentStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> DeploymentStatus {
        self.status.take().unwrap_or_else(|| DeploymentStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &Deployment| { &m.metadata },
            |m: &mut Deployment| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeploymentSpec>(
            "spec",
            |m: &Deployment| { &m.spec },
            |m: &mut Deployment| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeploymentStatus>(
            "status",
            |m: &Deployment| { &m.status },
            |m: &mut Deployment| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Deployment>(
            "Deployment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Deployment {
    const NAME: &'static str = "Deployment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Deployment {
        Deployment::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Deployment {
        static instance: Deployment = Deployment {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Deployment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Deployment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Deployment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Deployment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.DeploymentCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeploymentCondition {
    // message fields
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentCondition.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentCondition.status)
    pub status: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentCondition.lastUpdateTime)
    pub lastUpdateTime: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::Time>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentCondition.lastTransitionTime)
    pub lastTransitionTime: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentCondition.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentCondition.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.DeploymentCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeploymentCondition {
    fn default() -> &'a DeploymentCondition {
        <DeploymentCondition as ::protobuf::Message>::default_instance()
    }
}

impl DeploymentCondition {
    pub fn new() -> DeploymentCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;

    pub fn lastUpdateTime(&self) -> &crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastUpdateTime.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastUpdateTime(&mut self) {
        self.lastUpdateTime.clear();
    }

    pub fn has_lastUpdateTime(&self) -> bool {
        self.lastUpdateTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastUpdateTime(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastUpdateTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastUpdateTime(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastUpdateTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastUpdateTime(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastUpdateTime.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;

    pub fn lastTransitionTime(&self) -> &crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastTransitionTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional string reason = 4;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 5;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &DeploymentCondition| { &m.type_ },
            |m: &mut DeploymentCondition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &DeploymentCondition| { &m.status },
            |m: &mut DeploymentCondition| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::Time>(
            "lastUpdateTime",
            |m: &DeploymentCondition| { &m.lastUpdateTime },
            |m: &mut DeploymentCondition| { &mut m.lastUpdateTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::Time>(
            "lastTransitionTime",
            |m: &DeploymentCondition| { &m.lastTransitionTime },
            |m: &mut DeploymentCondition| { &mut m.lastTransitionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &DeploymentCondition| { &m.reason },
            |m: &mut DeploymentCondition| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &DeploymentCondition| { &m.message },
            |m: &mut DeploymentCondition| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeploymentCondition>(
            "DeploymentCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeploymentCondition {
    const NAME: &'static str = "DeploymentCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastUpdateTime)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTransitionTime)?;
                },
                34 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastUpdateTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lastUpdateTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeploymentCondition {
        DeploymentCondition::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.lastUpdateTime.clear();
        self.lastTransitionTime.clear();
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeploymentCondition {
        static instance: DeploymentCondition = DeploymentCondition {
            type_: ::std::option::Option::None,
            status: ::std::option::Option::None,
            lastUpdateTime: ::protobuf::MessageField::none(),
            lastTransitionTime: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeploymentCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeploymentCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeploymentCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeploymentCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.DeploymentList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeploymentList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentList.items)
    pub items: ::std::vec::Vec<Deployment>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.DeploymentList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeploymentList {
    fn default() -> &'a DeploymentList {
        <DeploymentList as ::protobuf::Message>::default_instance()
    }
}

impl DeploymentList {
    pub fn new() -> DeploymentList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.extensions.v1beta1.Deployment items = 2;

    pub fn items(&self) -> &[Deployment] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<Deployment>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<Deployment> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<Deployment> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &DeploymentList| { &m.metadata },
            |m: &mut DeploymentList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &DeploymentList| { &m.items },
            |m: &mut DeploymentList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeploymentList>(
            "DeploymentList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeploymentList {
    const NAME: &'static str = "DeploymentList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeploymentList {
        DeploymentList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeploymentList {
        static instance: DeploymentList = DeploymentList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeploymentList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeploymentList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeploymentList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeploymentList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.DeploymentRollback)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeploymentRollback {
    // message fields
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentRollback.name)
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentRollback.updatedAnnotations)
    pub updatedAnnotations: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentRollback.rollbackTo)
    pub rollbackTo: ::protobuf::MessageField<RollbackConfig>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.DeploymentRollback.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeploymentRollback {
    fn default() -> &'a DeploymentRollback {
        <DeploymentRollback as ::protobuf::Message>::default_instance()
    }
}

impl DeploymentRollback {
    pub fn new() -> DeploymentRollback {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.extensions.v1beta1.DeploymentRollback.UpdatedAnnotationsEntry updatedAnnotations = 2;

    pub fn updatedAnnotations(&self) -> &::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &self.updatedAnnotations
    }

    pub fn clear_updatedAnnotations(&mut self) {
        self.updatedAnnotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_updatedAnnotations(&mut self, v: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
        self.updatedAnnotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_updatedAnnotations(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &mut self.updatedAnnotations
    }

    // Take field
    pub fn take_updatedAnnotations(&mut self) -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.updatedAnnotations, ::std::collections::BTreeMap::new())
    }

    // optional .api.extensions.v1beta1.RollbackConfig rollbackTo = 3;

    pub fn rollbackTo(&self) -> &RollbackConfig {
        self.rollbackTo.as_ref().unwrap_or_else(|| <RollbackConfig as ::protobuf::Message>::default_instance())
    }

    pub fn clear_rollbackTo(&mut self) {
        self.rollbackTo.clear();
    }

    pub fn has_rollbackTo(&self) -> bool {
        self.rollbackTo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollbackTo(&mut self, v: RollbackConfig) {
        self.rollbackTo = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollbackTo(&mut self) -> &mut RollbackConfig {
        self.rollbackTo.mut_or_insert_default()
    }

    // Take field
    pub fn take_rollbackTo(&mut self) -> RollbackConfig {
        self.rollbackTo.take().unwrap_or_else(|| RollbackConfig::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &DeploymentRollback| { &m.name },
            |m: &mut DeploymentRollback| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "updatedAnnotations",
            |m: &DeploymentRollback| { &m.updatedAnnotations },
            |m: &mut DeploymentRollback| { &mut m.updatedAnnotations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RollbackConfig>(
            "rollbackTo",
            |m: &DeploymentRollback| { &m.rollbackTo },
            |m: &mut DeploymentRollback| { &mut m.rollbackTo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeploymentRollback>(
            "DeploymentRollback",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeploymentRollback {
    const NAME: &'static str = "DeploymentRollback";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.updatedAnnotations.insert(key, value);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rollbackTo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for (k, v) in &self.updatedAnnotations {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.rollbackTo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for (k, v) in &self.updatedAnnotations {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.rollbackTo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeploymentRollback {
        DeploymentRollback::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.updatedAnnotations.clear();
        self.rollbackTo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeploymentRollback {
        static instance: ::protobuf::rt::Lazy<DeploymentRollback> = ::protobuf::rt::Lazy::new();
        instance.get(DeploymentRollback::new)
    }
}

impl ::protobuf::MessageFull for DeploymentRollback {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeploymentRollback").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeploymentRollback {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeploymentRollback {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.DeploymentSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeploymentSpec {
    // message fields
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentSpec.replicas)
    pub replicas: ::std::option::Option<i32>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentSpec.selector)
    pub selector: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentSpec.template)
    pub template: ::protobuf::MessageField<crate::api::core::v1::PodTemplateSpec>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentSpec.strategy)
    pub strategy: ::protobuf::MessageField<DeploymentStrategy>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentSpec.minReadySeconds)
    pub minReadySeconds: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentSpec.revisionHistoryLimit)
    pub revisionHistoryLimit: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentSpec.paused)
    pub paused: ::std::option::Option<bool>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentSpec.rollbackTo)
    pub rollbackTo: ::protobuf::MessageField<RollbackConfig>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentSpec.progressDeadlineSeconds)
    pub progressDeadlineSeconds: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.DeploymentSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeploymentSpec {
    fn default() -> &'a DeploymentSpec {
        <DeploymentSpec as ::protobuf::Message>::default_instance()
    }
}

impl DeploymentSpec {
    pub fn new() -> DeploymentSpec {
        ::std::default::Default::default()
    }

    // optional int32 replicas = 1;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;

    pub fn selector(&self) -> &crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    pub fn has_selector(&self) -> bool {
        self.selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.selector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selector(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.mut_or_insert_default()
    }

    // Take field
    pub fn take_selector(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional .api.core.v1.PodTemplateSpec template = 3;

    pub fn template(&self) -> &crate::api::core::v1::PodTemplateSpec {
        self.template.as_ref().unwrap_or_else(|| <crate::api::core::v1::PodTemplateSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_template(&mut self) {
        self.template.clear();
    }

    pub fn has_template(&self) -> bool {
        self.template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template(&mut self, v: crate::api::core::v1::PodTemplateSpec) {
        self.template = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template(&mut self) -> &mut crate::api::core::v1::PodTemplateSpec {
        self.template.mut_or_insert_default()
    }

    // Take field
    pub fn take_template(&mut self) -> crate::api::core::v1::PodTemplateSpec {
        self.template.take().unwrap_or_else(|| crate::api::core::v1::PodTemplateSpec::new())
    }

    // optional .api.extensions.v1beta1.DeploymentStrategy strategy = 4;

    pub fn strategy(&self) -> &DeploymentStrategy {
        self.strategy.as_ref().unwrap_or_else(|| <DeploymentStrategy as ::protobuf::Message>::default_instance())
    }

    pub fn clear_strategy(&mut self) {
        self.strategy.clear();
    }

    pub fn has_strategy(&self) -> bool {
        self.strategy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strategy(&mut self, v: DeploymentStrategy) {
        self.strategy = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_strategy(&mut self) -> &mut DeploymentStrategy {
        self.strategy.mut_or_insert_default()
    }

    // Take field
    pub fn take_strategy(&mut self) -> DeploymentStrategy {
        self.strategy.take().unwrap_or_else(|| DeploymentStrategy::new())
    }

    // optional int32 minReadySeconds = 5;

    pub fn minReadySeconds(&self) -> i32 {
        self.minReadySeconds.unwrap_or(0)
    }

    pub fn clear_minReadySeconds(&mut self) {
        self.minReadySeconds = ::std::option::Option::None;
    }

    pub fn has_minReadySeconds(&self) -> bool {
        self.minReadySeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minReadySeconds(&mut self, v: i32) {
        self.minReadySeconds = ::std::option::Option::Some(v);
    }

    // optional int32 revisionHistoryLimit = 6;

    pub fn revisionHistoryLimit(&self) -> i32 {
        self.revisionHistoryLimit.unwrap_or(0)
    }

    pub fn clear_revisionHistoryLimit(&mut self) {
        self.revisionHistoryLimit = ::std::option::Option::None;
    }

    pub fn has_revisionHistoryLimit(&self) -> bool {
        self.revisionHistoryLimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revisionHistoryLimit(&mut self, v: i32) {
        self.revisionHistoryLimit = ::std::option::Option::Some(v);
    }

    // optional bool paused = 7;

    pub fn paused(&self) -> bool {
        self.paused.unwrap_or(false)
    }

    pub fn clear_paused(&mut self) {
        self.paused = ::std::option::Option::None;
    }

    pub fn has_paused(&self) -> bool {
        self.paused.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paused(&mut self, v: bool) {
        self.paused = ::std::option::Option::Some(v);
    }

    // optional .api.extensions.v1beta1.RollbackConfig rollbackTo = 8;

    pub fn rollbackTo(&self) -> &RollbackConfig {
        self.rollbackTo.as_ref().unwrap_or_else(|| <RollbackConfig as ::protobuf::Message>::default_instance())
    }

    pub fn clear_rollbackTo(&mut self) {
        self.rollbackTo.clear();
    }

    pub fn has_rollbackTo(&self) -> bool {
        self.rollbackTo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollbackTo(&mut self, v: RollbackConfig) {
        self.rollbackTo = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollbackTo(&mut self) -> &mut RollbackConfig {
        self.rollbackTo.mut_or_insert_default()
    }

    // Take field
    pub fn take_rollbackTo(&mut self) -> RollbackConfig {
        self.rollbackTo.take().unwrap_or_else(|| RollbackConfig::new())
    }

    // optional int32 progressDeadlineSeconds = 9;

    pub fn progressDeadlineSeconds(&self) -> i32 {
        self.progressDeadlineSeconds.unwrap_or(0)
    }

    pub fn clear_progressDeadlineSeconds(&mut self) {
        self.progressDeadlineSeconds = ::std::option::Option::None;
    }

    pub fn has_progressDeadlineSeconds(&self) -> bool {
        self.progressDeadlineSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progressDeadlineSeconds(&mut self, v: i32) {
        self.progressDeadlineSeconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &DeploymentSpec| { &m.replicas },
            |m: &mut DeploymentSpec| { &mut m.replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "selector",
            |m: &DeploymentSpec| { &m.selector },
            |m: &mut DeploymentSpec| { &mut m.selector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::api::core::v1::PodTemplateSpec>(
            "template",
            |m: &DeploymentSpec| { &m.template },
            |m: &mut DeploymentSpec| { &mut m.template },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeploymentStrategy>(
            "strategy",
            |m: &DeploymentSpec| { &m.strategy },
            |m: &mut DeploymentSpec| { &mut m.strategy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minReadySeconds",
            |m: &DeploymentSpec| { &m.minReadySeconds },
            |m: &mut DeploymentSpec| { &mut m.minReadySeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revisionHistoryLimit",
            |m: &DeploymentSpec| { &m.revisionHistoryLimit },
            |m: &mut DeploymentSpec| { &mut m.revisionHistoryLimit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "paused",
            |m: &DeploymentSpec| { &m.paused },
            |m: &mut DeploymentSpec| { &mut m.paused },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RollbackConfig>(
            "rollbackTo",
            |m: &DeploymentSpec| { &m.rollbackTo },
            |m: &mut DeploymentSpec| { &mut m.rollbackTo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "progressDeadlineSeconds",
            |m: &DeploymentSpec| { &m.progressDeadlineSeconds },
            |m: &mut DeploymentSpec| { &mut m.progressDeadlineSeconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeploymentSpec>(
            "DeploymentSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeploymentSpec {
    const NAME: &'static str = "DeploymentSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.selector)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.template)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.strategy)?;
                },
                40 => {
                    self.minReadySeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.revisionHistoryLimit = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.paused = ::std::option::Option::Some(is.read_bool()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rollbackTo)?;
                },
                72 => {
                    self.progressDeadlineSeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.strategy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.minReadySeconds {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.revisionHistoryLimit {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.paused {
            my_size += 1 + 1;
        }
        if let Some(v) = self.rollbackTo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.progressDeadlineSeconds {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.replicas {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.selector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.template.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.strategy.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.minReadySeconds {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.revisionHistoryLimit {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.paused {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.rollbackTo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.progressDeadlineSeconds {
            os.write_int32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeploymentSpec {
        DeploymentSpec::new()
    }

    fn clear(&mut self) {
        self.replicas = ::std::option::Option::None;
        self.selector.clear();
        self.template.clear();
        self.strategy.clear();
        self.minReadySeconds = ::std::option::Option::None;
        self.revisionHistoryLimit = ::std::option::Option::None;
        self.paused = ::std::option::Option::None;
        self.rollbackTo.clear();
        self.progressDeadlineSeconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeploymentSpec {
        static instance: DeploymentSpec = DeploymentSpec {
            replicas: ::std::option::Option::None,
            selector: ::protobuf::MessageField::none(),
            template: ::protobuf::MessageField::none(),
            strategy: ::protobuf::MessageField::none(),
            minReadySeconds: ::std::option::Option::None,
            revisionHistoryLimit: ::std::option::Option::None,
            paused: ::std::option::Option::None,
            rollbackTo: ::protobuf::MessageField::none(),
            progressDeadlineSeconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeploymentSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeploymentSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeploymentSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeploymentSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.DeploymentStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeploymentStatus {
    // message fields
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentStatus.observedGeneration)
    pub observedGeneration: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentStatus.replicas)
    pub replicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentStatus.updatedReplicas)
    pub updatedReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentStatus.readyReplicas)
    pub readyReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentStatus.availableReplicas)
    pub availableReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentStatus.unavailableReplicas)
    pub unavailableReplicas: ::std::option::Option<i32>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentStatus.conditions)
    pub conditions: ::std::vec::Vec<DeploymentCondition>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentStatus.collisionCount)
    pub collisionCount: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.DeploymentStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeploymentStatus {
    fn default() -> &'a DeploymentStatus {
        <DeploymentStatus as ::protobuf::Message>::default_instance()
    }
}

impl DeploymentStatus {
    pub fn new() -> DeploymentStatus {
        ::std::default::Default::default()
    }

    // optional int64 observedGeneration = 1;

    pub fn observedGeneration(&self) -> i64 {
        self.observedGeneration.unwrap_or(0)
    }

    pub fn clear_observedGeneration(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
    }

    pub fn has_observedGeneration(&self) -> bool {
        self.observedGeneration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observedGeneration(&mut self, v: i64) {
        self.observedGeneration = ::std::option::Option::Some(v);
    }

    // optional int32 replicas = 2;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // optional int32 updatedReplicas = 3;

    pub fn updatedReplicas(&self) -> i32 {
        self.updatedReplicas.unwrap_or(0)
    }

    pub fn clear_updatedReplicas(&mut self) {
        self.updatedReplicas = ::std::option::Option::None;
    }

    pub fn has_updatedReplicas(&self) -> bool {
        self.updatedReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updatedReplicas(&mut self, v: i32) {
        self.updatedReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 readyReplicas = 7;

    pub fn readyReplicas(&self) -> i32 {
        self.readyReplicas.unwrap_or(0)
    }

    pub fn clear_readyReplicas(&mut self) {
        self.readyReplicas = ::std::option::Option::None;
    }

    pub fn has_readyReplicas(&self) -> bool {
        self.readyReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readyReplicas(&mut self, v: i32) {
        self.readyReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 availableReplicas = 4;

    pub fn availableReplicas(&self) -> i32 {
        self.availableReplicas.unwrap_or(0)
    }

    pub fn clear_availableReplicas(&mut self) {
        self.availableReplicas = ::std::option::Option::None;
    }

    pub fn has_availableReplicas(&self) -> bool {
        self.availableReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_availableReplicas(&mut self, v: i32) {
        self.availableReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 unavailableReplicas = 5;

    pub fn unavailableReplicas(&self) -> i32 {
        self.unavailableReplicas.unwrap_or(0)
    }

    pub fn clear_unavailableReplicas(&mut self) {
        self.unavailableReplicas = ::std::option::Option::None;
    }

    pub fn has_unavailableReplicas(&self) -> bool {
        self.unavailableReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unavailableReplicas(&mut self, v: i32) {
        self.unavailableReplicas = ::std::option::Option::Some(v);
    }

    // repeated .api.extensions.v1beta1.DeploymentCondition conditions = 6;

    pub fn conditions(&self) -> &[DeploymentCondition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<DeploymentCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<DeploymentCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<DeploymentCondition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    // optional int32 collisionCount = 8;

    pub fn collisionCount(&self) -> i32 {
        self.collisionCount.unwrap_or(0)
    }

    pub fn clear_collisionCount(&mut self) {
        self.collisionCount = ::std::option::Option::None;
    }

    pub fn has_collisionCount(&self) -> bool {
        self.collisionCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_collisionCount(&mut self, v: i32) {
        self.collisionCount = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "observedGeneration",
            |m: &DeploymentStatus| { &m.observedGeneration },
            |m: &mut DeploymentStatus| { &mut m.observedGeneration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &DeploymentStatus| { &m.replicas },
            |m: &mut DeploymentStatus| { &mut m.replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "updatedReplicas",
            |m: &DeploymentStatus| { &m.updatedReplicas },
            |m: &mut DeploymentStatus| { &mut m.updatedReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readyReplicas",
            |m: &DeploymentStatus| { &m.readyReplicas },
            |m: &mut DeploymentStatus| { &mut m.readyReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "availableReplicas",
            |m: &DeploymentStatus| { &m.availableReplicas },
            |m: &mut DeploymentStatus| { &mut m.availableReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unavailableReplicas",
            |m: &DeploymentStatus| { &m.unavailableReplicas },
            |m: &mut DeploymentStatus| { &mut m.unavailableReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &DeploymentStatus| { &m.conditions },
            |m: &mut DeploymentStatus| { &mut m.conditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "collisionCount",
            |m: &DeploymentStatus| { &m.collisionCount },
            |m: &mut DeploymentStatus| { &mut m.collisionCount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeploymentStatus>(
            "DeploymentStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeploymentStatus {
    const NAME: &'static str = "DeploymentStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.observedGeneration = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.updatedReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.readyReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.availableReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.unavailableReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    self.conditions.push(is.read_message()?);
                },
                64 => {
                    self.collisionCount = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.observedGeneration {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.updatedReplicas {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.readyReplicas {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.availableReplicas {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.unavailableReplicas {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.collisionCount {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.observedGeneration {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.replicas {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.updatedReplicas {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.readyReplicas {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.availableReplicas {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.unavailableReplicas {
            os.write_int32(5, v)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.collisionCount {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeploymentStatus {
        DeploymentStatus::new()
    }

    fn clear(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
        self.replicas = ::std::option::Option::None;
        self.updatedReplicas = ::std::option::Option::None;
        self.readyReplicas = ::std::option::Option::None;
        self.availableReplicas = ::std::option::Option::None;
        self.unavailableReplicas = ::std::option::Option::None;
        self.conditions.clear();
        self.collisionCount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeploymentStatus {
        static instance: DeploymentStatus = DeploymentStatus {
            observedGeneration: ::std::option::Option::None,
            replicas: ::std::option::Option::None,
            updatedReplicas: ::std::option::Option::None,
            readyReplicas: ::std::option::Option::None,
            availableReplicas: ::std::option::Option::None,
            unavailableReplicas: ::std::option::Option::None,
            conditions: ::std::vec::Vec::new(),
            collisionCount: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeploymentStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeploymentStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeploymentStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeploymentStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.DeploymentStrategy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeploymentStrategy {
    // message fields
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentStrategy.type)
    pub type_: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.DeploymentStrategy.rollingUpdate)
    pub rollingUpdate: ::protobuf::MessageField<RollingUpdateDeployment>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.DeploymentStrategy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeploymentStrategy {
    fn default() -> &'a DeploymentStrategy {
        <DeploymentStrategy as ::protobuf::Message>::default_instance()
    }
}

impl DeploymentStrategy {
    pub fn new() -> DeploymentStrategy {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.extensions.v1beta1.RollingUpdateDeployment rollingUpdate = 2;

    pub fn rollingUpdate(&self) -> &RollingUpdateDeployment {
        self.rollingUpdate.as_ref().unwrap_or_else(|| <RollingUpdateDeployment as ::protobuf::Message>::default_instance())
    }

    pub fn clear_rollingUpdate(&mut self) {
        self.rollingUpdate.clear();
    }

    pub fn has_rollingUpdate(&self) -> bool {
        self.rollingUpdate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollingUpdate(&mut self, v: RollingUpdateDeployment) {
        self.rollingUpdate = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollingUpdate(&mut self) -> &mut RollingUpdateDeployment {
        self.rollingUpdate.mut_or_insert_default()
    }

    // Take field
    pub fn take_rollingUpdate(&mut self) -> RollingUpdateDeployment {
        self.rollingUpdate.take().unwrap_or_else(|| RollingUpdateDeployment::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &DeploymentStrategy| { &m.type_ },
            |m: &mut DeploymentStrategy| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RollingUpdateDeployment>(
            "rollingUpdate",
            |m: &DeploymentStrategy| { &m.rollingUpdate },
            |m: &mut DeploymentStrategy| { &mut m.rollingUpdate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeploymentStrategy>(
            "DeploymentStrategy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeploymentStrategy {
    const NAME: &'static str = "DeploymentStrategy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rollingUpdate)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.rollingUpdate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.rollingUpdate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeploymentStrategy {
        DeploymentStrategy::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.rollingUpdate.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeploymentStrategy {
        static instance: DeploymentStrategy = DeploymentStrategy {
            type_: ::std::option::Option::None,
            rollingUpdate: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeploymentStrategy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeploymentStrategy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeploymentStrategy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeploymentStrategy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.HTTPIngressPath)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HTTPIngressPath {
    // message fields
    // @@protoc_insertion_point(field:api.extensions.v1beta1.HTTPIngressPath.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.HTTPIngressPath.pathType)
    pub pathType: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.HTTPIngressPath.backend)
    pub backend: ::protobuf::MessageField<IngressBackend>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.HTTPIngressPath.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HTTPIngressPath {
    fn default() -> &'a HTTPIngressPath {
        <HTTPIngressPath as ::protobuf::Message>::default_instance()
    }
}

impl HTTPIngressPath {
    pub fn new() -> HTTPIngressPath {
        ::std::default::Default::default()
    }

    // optional string path = 1;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pathType = 3;

    pub fn pathType(&self) -> &str {
        match self.pathType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pathType(&mut self) {
        self.pathType = ::std::option::Option::None;
    }

    pub fn has_pathType(&self) -> bool {
        self.pathType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pathType(&mut self, v: ::std::string::String) {
        self.pathType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pathType(&mut self) -> &mut ::std::string::String {
        if self.pathType.is_none() {
            self.pathType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pathType.as_mut().unwrap()
    }

    // Take field
    pub fn take_pathType(&mut self) -> ::std::string::String {
        self.pathType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.extensions.v1beta1.IngressBackend backend = 2;

    pub fn backend(&self) -> &IngressBackend {
        self.backend.as_ref().unwrap_or_else(|| <IngressBackend as ::protobuf::Message>::default_instance())
    }

    pub fn clear_backend(&mut self) {
        self.backend.clear();
    }

    pub fn has_backend(&self) -> bool {
        self.backend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backend(&mut self, v: IngressBackend) {
        self.backend = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backend(&mut self) -> &mut IngressBackend {
        self.backend.mut_or_insert_default()
    }

    // Take field
    pub fn take_backend(&mut self) -> IngressBackend {
        self.backend.take().unwrap_or_else(|| IngressBackend::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &HTTPIngressPath| { &m.path },
            |m: &mut HTTPIngressPath| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pathType",
            |m: &HTTPIngressPath| { &m.pathType },
            |m: &mut HTTPIngressPath| { &mut m.pathType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IngressBackend>(
            "backend",
            |m: &HTTPIngressPath| { &m.backend },
            |m: &mut HTTPIngressPath| { &mut m.backend },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HTTPIngressPath>(
            "HTTPIngressPath",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HTTPIngressPath {
    const NAME: &'static str = "HTTPIngressPath";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.pathType = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.backend)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.pathType.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.backend.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.path.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.pathType.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.backend.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HTTPIngressPath {
        HTTPIngressPath::new()
    }

    fn clear(&mut self) {
        self.path = ::std::option::Option::None;
        self.pathType = ::std::option::Option::None;
        self.backend.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HTTPIngressPath {
        static instance: HTTPIngressPath = HTTPIngressPath {
            path: ::std::option::Option::None,
            pathType: ::std::option::Option::None,
            backend: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HTTPIngressPath {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HTTPIngressPath").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HTTPIngressPath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPIngressPath {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.HTTPIngressRuleValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HTTPIngressRuleValue {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.HTTPIngressRuleValue.paths)
    pub paths: ::std::vec::Vec<HTTPIngressPath>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.HTTPIngressRuleValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HTTPIngressRuleValue {
    fn default() -> &'a HTTPIngressRuleValue {
        <HTTPIngressRuleValue as ::protobuf::Message>::default_instance()
    }
}

impl HTTPIngressRuleValue {
    pub fn new() -> HTTPIngressRuleValue {
        ::std::default::Default::default()
    }

    // repeated .api.extensions.v1beta1.HTTPIngressPath paths = 1;

    pub fn paths(&self) -> &[HTTPIngressPath] {
        &self.paths
    }

    pub fn clear_paths(&mut self) {
        self.paths.clear();
    }

    // Param is passed by value, moved
    pub fn set_paths(&mut self, v: ::std::vec::Vec<HTTPIngressPath>) {
        self.paths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_paths(&mut self) -> &mut ::std::vec::Vec<HTTPIngressPath> {
        &mut self.paths
    }

    // Take field
    pub fn take_paths(&mut self) -> ::std::vec::Vec<HTTPIngressPath> {
        ::std::mem::replace(&mut self.paths, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "paths",
            |m: &HTTPIngressRuleValue| { &m.paths },
            |m: &mut HTTPIngressRuleValue| { &mut m.paths },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HTTPIngressRuleValue>(
            "HTTPIngressRuleValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HTTPIngressRuleValue {
    const NAME: &'static str = "HTTPIngressRuleValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.paths.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.paths {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.paths {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HTTPIngressRuleValue {
        HTTPIngressRuleValue::new()
    }

    fn clear(&mut self) {
        self.paths.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HTTPIngressRuleValue {
        static instance: HTTPIngressRuleValue = HTTPIngressRuleValue {
            paths: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HTTPIngressRuleValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HTTPIngressRuleValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HTTPIngressRuleValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPIngressRuleValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.IPBlock)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IPBlock {
    // message fields
    // @@protoc_insertion_point(field:api.extensions.v1beta1.IPBlock.cidr)
    pub cidr: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.IPBlock.except)
    pub except: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.IPBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IPBlock {
    fn default() -> &'a IPBlock {
        <IPBlock as ::protobuf::Message>::default_instance()
    }
}

impl IPBlock {
    pub fn new() -> IPBlock {
        ::std::default::Default::default()
    }

    // optional string cidr = 1;

    pub fn cidr(&self) -> &str {
        match self.cidr.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cidr(&mut self) {
        self.cidr = ::std::option::Option::None;
    }

    pub fn has_cidr(&self) -> bool {
        self.cidr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cidr(&mut self, v: ::std::string::String) {
        self.cidr = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cidr(&mut self) -> &mut ::std::string::String {
        if self.cidr.is_none() {
            self.cidr = ::std::option::Option::Some(::std::string::String::new());
        }
        self.cidr.as_mut().unwrap()
    }

    // Take field
    pub fn take_cidr(&mut self) -> ::std::string::String {
        self.cidr.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string except = 2;

    pub fn except(&self) -> &[::std::string::String] {
        &self.except
    }

    pub fn clear_except(&mut self) {
        self.except.clear();
    }

    // Param is passed by value, moved
    pub fn set_except(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.except = v;
    }

    // Mutable pointer to the field.
    pub fn mut_except(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.except
    }

    // Take field
    pub fn take_except(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.except, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cidr",
            |m: &IPBlock| { &m.cidr },
            |m: &mut IPBlock| { &mut m.cidr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "except",
            |m: &IPBlock| { &m.except },
            |m: &mut IPBlock| { &mut m.except },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IPBlock>(
            "IPBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IPBlock {
    const NAME: &'static str = "IPBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cidr = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.except.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cidr.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.except {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cidr.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.except {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IPBlock {
        IPBlock::new()
    }

    fn clear(&mut self) {
        self.cidr = ::std::option::Option::None;
        self.except.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IPBlock {
        static instance: IPBlock = IPBlock {
            cidr: ::std::option::Option::None,
            except: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IPBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IPBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IPBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.Ingress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Ingress {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.Ingress.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.Ingress.spec)
    pub spec: ::protobuf::MessageField<IngressSpec>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.Ingress.status)
    pub status: ::protobuf::MessageField<IngressStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.Ingress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Ingress {
    fn default() -> &'a Ingress {
        <Ingress as ::protobuf::Message>::default_instance()
    }
}

impl Ingress {
    pub fn new() -> Ingress {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.extensions.v1beta1.IngressSpec spec = 2;

    pub fn spec(&self) -> &IngressSpec {
        self.spec.as_ref().unwrap_or_else(|| <IngressSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: IngressSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut IngressSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> IngressSpec {
        self.spec.take().unwrap_or_else(|| IngressSpec::new())
    }

    // optional .api.extensions.v1beta1.IngressStatus status = 3;

    pub fn status(&self) -> &IngressStatus {
        self.status.as_ref().unwrap_or_else(|| <IngressStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: IngressStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut IngressStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> IngressStatus {
        self.status.take().unwrap_or_else(|| IngressStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &Ingress| { &m.metadata },
            |m: &mut Ingress| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IngressSpec>(
            "spec",
            |m: &Ingress| { &m.spec },
            |m: &mut Ingress| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IngressStatus>(
            "status",
            |m: &Ingress| { &m.status },
            |m: &mut Ingress| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Ingress>(
            "Ingress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Ingress {
    const NAME: &'static str = "Ingress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Ingress {
        Ingress::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Ingress {
        static instance: Ingress = Ingress {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Ingress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Ingress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Ingress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ingress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.IngressBackend)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressBackend {
    // message fields
    // @@protoc_insertion_point(field:api.extensions.v1beta1.IngressBackend.serviceName)
    pub serviceName: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::intorstr")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.IngressBackend.servicePort)
    pub servicePort: ::protobuf::MessageField<crate::apimachinery::pkg::util::intstr::IntOrString>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.IngressBackend.resource)
    pub resource: ::protobuf::MessageField<crate::api::core::v1::TypedLocalObjectReference>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.IngressBackend.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressBackend {
    fn default() -> &'a IngressBackend {
        <IngressBackend as ::protobuf::Message>::default_instance()
    }
}

impl IngressBackend {
    pub fn new() -> IngressBackend {
        ::std::default::Default::default()
    }

    // optional string serviceName = 1;

    pub fn serviceName(&self) -> &str {
        match self.serviceName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_serviceName(&mut self) {
        self.serviceName = ::std::option::Option::None;
    }

    pub fn has_serviceName(&self) -> bool {
        self.serviceName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serviceName(&mut self, v: ::std::string::String) {
        self.serviceName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serviceName(&mut self) -> &mut ::std::string::String {
        if self.serviceName.is_none() {
            self.serviceName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.serviceName.as_mut().unwrap()
    }

    // Take field
    pub fn take_serviceName(&mut self) -> ::std::string::String {
        self.serviceName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.util.intstr.IntOrString servicePort = 2;

    pub fn servicePort(&self) -> &crate::apimachinery::pkg::util::intstr::IntOrString {
        self.servicePort.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::util::intstr::IntOrString as ::protobuf::Message>::default_instance())
    }

    pub fn clear_servicePort(&mut self) {
        self.servicePort.clear();
    }

    pub fn has_servicePort(&self) -> bool {
        self.servicePort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_servicePort(&mut self, v: crate::apimachinery::pkg::util::intstr::IntOrString) {
        self.servicePort = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_servicePort(&mut self) -> &mut crate::apimachinery::pkg::util::intstr::IntOrString {
        self.servicePort.mut_or_insert_default()
    }

    // Take field
    pub fn take_servicePort(&mut self) -> crate::apimachinery::pkg::util::intstr::IntOrString {
        self.servicePort.take().unwrap_or_else(|| crate::apimachinery::pkg::util::intstr::IntOrString::new())
    }

    // optional .api.core.v1.TypedLocalObjectReference resource = 3;

    pub fn resource(&self) -> &crate::api::core::v1::TypedLocalObjectReference {
        self.resource.as_ref().unwrap_or_else(|| <crate::api::core::v1::TypedLocalObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_resource(&mut self) {
        self.resource.clear();
    }

    pub fn has_resource(&self) -> bool {
        self.resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: crate::api::core::v1::TypedLocalObjectReference) {
        self.resource = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut crate::api::core::v1::TypedLocalObjectReference {
        self.resource.mut_or_insert_default()
    }

    // Take field
    pub fn take_resource(&mut self) -> crate::api::core::v1::TypedLocalObjectReference {
        self.resource.take().unwrap_or_else(|| crate::api::core::v1::TypedLocalObjectReference::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serviceName",
            |m: &IngressBackend| { &m.serviceName },
            |m: &mut IngressBackend| { &mut m.serviceName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::util::intstr::IntOrString>(
            "servicePort",
            |m: &IngressBackend| { &m.servicePort },
            |m: &mut IngressBackend| { &mut m.servicePort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::api::core::v1::TypedLocalObjectReference>(
            "resource",
            |m: &IngressBackend| { &m.resource },
            |m: &mut IngressBackend| { &mut m.resource },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressBackend>(
            "IngressBackend",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressBackend {
    const NAME: &'static str = "IngressBackend";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.serviceName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.servicePort)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resource)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.serviceName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.servicePort.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.resource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.serviceName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.servicePort.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.resource.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressBackend {
        IngressBackend::new()
    }

    fn clear(&mut self) {
        self.serviceName = ::std::option::Option::None;
        self.servicePort.clear();
        self.resource.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressBackend {
        static instance: IngressBackend = IngressBackend {
            serviceName: ::std::option::Option::None,
            servicePort: ::protobuf::MessageField::none(),
            resource: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressBackend {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressBackend").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressBackend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressBackend {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.IngressList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.IngressList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.IngressList.items)
    pub items: ::std::vec::Vec<Ingress>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.IngressList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressList {
    fn default() -> &'a IngressList {
        <IngressList as ::protobuf::Message>::default_instance()
    }
}

impl IngressList {
    pub fn new() -> IngressList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.extensions.v1beta1.Ingress items = 2;

    pub fn items(&self) -> &[Ingress] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<Ingress>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<Ingress> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<Ingress> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &IngressList| { &m.metadata },
            |m: &mut IngressList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &IngressList| { &m.items },
            |m: &mut IngressList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressList>(
            "IngressList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressList {
    const NAME: &'static str = "IngressList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressList {
        IngressList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressList {
        static instance: IngressList = IngressList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.IngressLoadBalancerIngress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressLoadBalancerIngress {
    // message fields
    // @@protoc_insertion_point(field:api.extensions.v1beta1.IngressLoadBalancerIngress.ip)
    pub ip: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.IngressLoadBalancerIngress.hostname)
    pub hostname: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.IngressLoadBalancerIngress.ports)
    pub ports: ::std::vec::Vec<IngressPortStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.IngressLoadBalancerIngress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressLoadBalancerIngress {
    fn default() -> &'a IngressLoadBalancerIngress {
        <IngressLoadBalancerIngress as ::protobuf::Message>::default_instance()
    }
}

impl IngressLoadBalancerIngress {
    pub fn new() -> IngressLoadBalancerIngress {
        ::std::default::Default::default()
    }

    // optional string ip = 1;

    pub fn ip(&self) -> &str {
        match self.ip.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        if self.ip.is_none() {
            self.ip = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        self.ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string hostname = 2;

    pub fn hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hostname(&mut self) {
        self.hostname = ::std::option::Option::None;
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.extensions.v1beta1.IngressPortStatus ports = 4;

    pub fn ports(&self) -> &[IngressPortStatus] {
        &self.ports
    }

    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::std::vec::Vec<IngressPortStatus>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::std::vec::Vec<IngressPortStatus> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::std::vec::Vec<IngressPortStatus> {
        ::std::mem::replace(&mut self.ports, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip",
            |m: &IngressLoadBalancerIngress| { &m.ip },
            |m: &mut IngressLoadBalancerIngress| { &mut m.ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hostname",
            |m: &IngressLoadBalancerIngress| { &m.hostname },
            |m: &mut IngressLoadBalancerIngress| { &mut m.hostname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ports",
            |m: &IngressLoadBalancerIngress| { &m.ports },
            |m: &mut IngressLoadBalancerIngress| { &mut m.ports },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressLoadBalancerIngress>(
            "IngressLoadBalancerIngress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressLoadBalancerIngress {
    const NAME: &'static str = "IngressLoadBalancerIngress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ip = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.hostname = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.ports.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ip.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ip.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.hostname.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.ports {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressLoadBalancerIngress {
        IngressLoadBalancerIngress::new()
    }

    fn clear(&mut self) {
        self.ip = ::std::option::Option::None;
        self.hostname = ::std::option::Option::None;
        self.ports.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressLoadBalancerIngress {
        static instance: IngressLoadBalancerIngress = IngressLoadBalancerIngress {
            ip: ::std::option::Option::None,
            hostname: ::std::option::Option::None,
            ports: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressLoadBalancerIngress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressLoadBalancerIngress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressLoadBalancerIngress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressLoadBalancerIngress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.IngressLoadBalancerStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressLoadBalancerStatus {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.IngressLoadBalancerStatus.ingress)
    pub ingress: ::std::vec::Vec<IngressLoadBalancerIngress>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.IngressLoadBalancerStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressLoadBalancerStatus {
    fn default() -> &'a IngressLoadBalancerStatus {
        <IngressLoadBalancerStatus as ::protobuf::Message>::default_instance()
    }
}

impl IngressLoadBalancerStatus {
    pub fn new() -> IngressLoadBalancerStatus {
        ::std::default::Default::default()
    }

    // repeated .api.extensions.v1beta1.IngressLoadBalancerIngress ingress = 1;

    pub fn ingress(&self) -> &[IngressLoadBalancerIngress] {
        &self.ingress
    }

    pub fn clear_ingress(&mut self) {
        self.ingress.clear();
    }

    // Param is passed by value, moved
    pub fn set_ingress(&mut self, v: ::std::vec::Vec<IngressLoadBalancerIngress>) {
        self.ingress = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ingress(&mut self) -> &mut ::std::vec::Vec<IngressLoadBalancerIngress> {
        &mut self.ingress
    }

    // Take field
    pub fn take_ingress(&mut self) -> ::std::vec::Vec<IngressLoadBalancerIngress> {
        ::std::mem::replace(&mut self.ingress, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ingress",
            |m: &IngressLoadBalancerStatus| { &m.ingress },
            |m: &mut IngressLoadBalancerStatus| { &mut m.ingress },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressLoadBalancerStatus>(
            "IngressLoadBalancerStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressLoadBalancerStatus {
    const NAME: &'static str = "IngressLoadBalancerStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ingress.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ingress {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ingress {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressLoadBalancerStatus {
        IngressLoadBalancerStatus::new()
    }

    fn clear(&mut self) {
        self.ingress.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressLoadBalancerStatus {
        static instance: IngressLoadBalancerStatus = IngressLoadBalancerStatus {
            ingress: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressLoadBalancerStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressLoadBalancerStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressLoadBalancerStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressLoadBalancerStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.IngressPortStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressPortStatus {
    // message fields
    // @@protoc_insertion_point(field:api.extensions.v1beta1.IngressPortStatus.port)
    pub port: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.IngressPortStatus.protocol)
    pub protocol: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.IngressPortStatus.error)
    pub error: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.IngressPortStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressPortStatus {
    fn default() -> &'a IngressPortStatus {
        <IngressPortStatus as ::protobuf::Message>::default_instance()
    }
}

impl IngressPortStatus {
    pub fn new() -> IngressPortStatus {
        ::std::default::Default::default()
    }

    // optional int32 port = 1;

    pub fn port(&self) -> i32 {
        self.port.unwrap_or(0)
    }

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Option::Some(v);
    }

    // optional string protocol = 2;

    pub fn protocol(&self) -> &str {
        match self.protocol.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_protocol(&mut self) {
        self.protocol = ::std::option::Option::None;
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol = ::std::option::Option::Some(::std::string::String::new());
        }
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string error = 3;

    pub fn error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "port",
            |m: &IngressPortStatus| { &m.port },
            |m: &mut IngressPortStatus| { &mut m.port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol",
            |m: &IngressPortStatus| { &m.protocol },
            |m: &mut IngressPortStatus| { &mut m.protocol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error",
            |m: &IngressPortStatus| { &m.error },
            |m: &mut IngressPortStatus| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressPortStatus>(
            "IngressPortStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressPortStatus {
    const NAME: &'static str = "IngressPortStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.port = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.protocol = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.error = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.protocol.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.port {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.protocol.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.error.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressPortStatus {
        IngressPortStatus::new()
    }

    fn clear(&mut self) {
        self.port = ::std::option::Option::None;
        self.protocol = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressPortStatus {
        static instance: IngressPortStatus = IngressPortStatus {
            port: ::std::option::Option::None,
            protocol: ::std::option::Option::None,
            error: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressPortStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressPortStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressPortStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressPortStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.IngressRule)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressRule {
    // message fields
    // @@protoc_insertion_point(field:api.extensions.v1beta1.IngressRule.host)
    pub host: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.IngressRule.ingressRuleValue)
    pub ingressRuleValue: ::protobuf::MessageField<IngressRuleValue>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.IngressRule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressRule {
    fn default() -> &'a IngressRule {
        <IngressRule as ::protobuf::Message>::default_instance()
    }
}

impl IngressRule {
    pub fn new() -> IngressRule {
        ::std::default::Default::default()
    }

    // optional string host = 1;

    pub fn host(&self) -> &str {
        match self.host.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_host(&mut self) {
        self.host = ::std::option::Option::None;
    }

    pub fn has_host(&self) -> bool {
        self.host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        if self.host.is_none() {
            self.host = ::std::option::Option::Some(::std::string::String::new());
        }
        self.host.as_mut().unwrap()
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        self.host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.extensions.v1beta1.IngressRuleValue ingressRuleValue = 2;

    pub fn ingressRuleValue(&self) -> &IngressRuleValue {
        self.ingressRuleValue.as_ref().unwrap_or_else(|| <IngressRuleValue as ::protobuf::Message>::default_instance())
    }

    pub fn clear_ingressRuleValue(&mut self) {
        self.ingressRuleValue.clear();
    }

    pub fn has_ingressRuleValue(&self) -> bool {
        self.ingressRuleValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ingressRuleValue(&mut self, v: IngressRuleValue) {
        self.ingressRuleValue = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ingressRuleValue(&mut self) -> &mut IngressRuleValue {
        self.ingressRuleValue.mut_or_insert_default()
    }

    // Take field
    pub fn take_ingressRuleValue(&mut self) -> IngressRuleValue {
        self.ingressRuleValue.take().unwrap_or_else(|| IngressRuleValue::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "host",
            |m: &IngressRule| { &m.host },
            |m: &mut IngressRule| { &mut m.host },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IngressRuleValue>(
            "ingressRuleValue",
            |m: &IngressRule| { &m.ingressRuleValue },
            |m: &mut IngressRule| { &mut m.ingressRuleValue },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressRule>(
            "IngressRule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressRule {
    const NAME: &'static str = "IngressRule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.host = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ingressRuleValue)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.host.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.ingressRuleValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.host.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.ingressRuleValue.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressRule {
        IngressRule::new()
    }

    fn clear(&mut self) {
        self.host = ::std::option::Option::None;
        self.ingressRuleValue.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressRule {
        static instance: IngressRule = IngressRule {
            host: ::std::option::Option::None,
            ingressRuleValue: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressRule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressRule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressRule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.IngressRuleValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressRuleValue {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.IngressRuleValue.http)
    pub http: ::protobuf::MessageField<HTTPIngressRuleValue>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.IngressRuleValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressRuleValue {
    fn default() -> &'a IngressRuleValue {
        <IngressRuleValue as ::protobuf::Message>::default_instance()
    }
}

impl IngressRuleValue {
    pub fn new() -> IngressRuleValue {
        ::std::default::Default::default()
    }

    // optional .api.extensions.v1beta1.HTTPIngressRuleValue http = 1;

    pub fn http(&self) -> &HTTPIngressRuleValue {
        self.http.as_ref().unwrap_or_else(|| <HTTPIngressRuleValue as ::protobuf::Message>::default_instance())
    }

    pub fn clear_http(&mut self) {
        self.http.clear();
    }

    pub fn has_http(&self) -> bool {
        self.http.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http(&mut self, v: HTTPIngressRuleValue) {
        self.http = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http(&mut self) -> &mut HTTPIngressRuleValue {
        self.http.mut_or_insert_default()
    }

    // Take field
    pub fn take_http(&mut self) -> HTTPIngressRuleValue {
        self.http.take().unwrap_or_else(|| HTTPIngressRuleValue::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HTTPIngressRuleValue>(
            "http",
            |m: &IngressRuleValue| { &m.http },
            |m: &mut IngressRuleValue| { &mut m.http },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressRuleValue>(
            "IngressRuleValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressRuleValue {
    const NAME: &'static str = "IngressRuleValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.http)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.http.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.http.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressRuleValue {
        IngressRuleValue::new()
    }

    fn clear(&mut self) {
        self.http.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressRuleValue {
        static instance: IngressRuleValue = IngressRuleValue {
            http: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressRuleValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressRuleValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressRuleValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressRuleValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.IngressSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressSpec {
    // message fields
    // @@protoc_insertion_point(field:api.extensions.v1beta1.IngressSpec.ingressClassName)
    pub ingressClassName: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.IngressSpec.backend)
    pub backend: ::protobuf::MessageField<IngressBackend>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.IngressSpec.tls)
    pub tls: ::std::vec::Vec<IngressTLS>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.IngressSpec.rules)
    pub rules: ::std::vec::Vec<IngressRule>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.IngressSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressSpec {
    fn default() -> &'a IngressSpec {
        <IngressSpec as ::protobuf::Message>::default_instance()
    }
}

impl IngressSpec {
    pub fn new() -> IngressSpec {
        ::std::default::Default::default()
    }

    // optional string ingressClassName = 4;

    pub fn ingressClassName(&self) -> &str {
        match self.ingressClassName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ingressClassName(&mut self) {
        self.ingressClassName = ::std::option::Option::None;
    }

    pub fn has_ingressClassName(&self) -> bool {
        self.ingressClassName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ingressClassName(&mut self, v: ::std::string::String) {
        self.ingressClassName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ingressClassName(&mut self) -> &mut ::std::string::String {
        if self.ingressClassName.is_none() {
            self.ingressClassName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ingressClassName.as_mut().unwrap()
    }

    // Take field
    pub fn take_ingressClassName(&mut self) -> ::std::string::String {
        self.ingressClassName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.extensions.v1beta1.IngressBackend backend = 1;

    pub fn backend(&self) -> &IngressBackend {
        self.backend.as_ref().unwrap_or_else(|| <IngressBackend as ::protobuf::Message>::default_instance())
    }

    pub fn clear_backend(&mut self) {
        self.backend.clear();
    }

    pub fn has_backend(&self) -> bool {
        self.backend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backend(&mut self, v: IngressBackend) {
        self.backend = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backend(&mut self) -> &mut IngressBackend {
        self.backend.mut_or_insert_default()
    }

    // Take field
    pub fn take_backend(&mut self) -> IngressBackend {
        self.backend.take().unwrap_or_else(|| IngressBackend::new())
    }

    // repeated .api.extensions.v1beta1.IngressTLS tls = 2;

    pub fn tls(&self) -> &[IngressTLS] {
        &self.tls
    }

    pub fn clear_tls(&mut self) {
        self.tls.clear();
    }

    // Param is passed by value, moved
    pub fn set_tls(&mut self, v: ::std::vec::Vec<IngressTLS>) {
        self.tls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tls(&mut self) -> &mut ::std::vec::Vec<IngressTLS> {
        &mut self.tls
    }

    // Take field
    pub fn take_tls(&mut self) -> ::std::vec::Vec<IngressTLS> {
        ::std::mem::replace(&mut self.tls, ::std::vec::Vec::new())
    }

    // repeated .api.extensions.v1beta1.IngressRule rules = 3;

    pub fn rules(&self) -> &[IngressRule] {
        &self.rules
    }

    pub fn clear_rules(&mut self) {
        self.rules.clear();
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: ::std::vec::Vec<IngressRule>) {
        self.rules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rules(&mut self) -> &mut ::std::vec::Vec<IngressRule> {
        &mut self.rules
    }

    // Take field
    pub fn take_rules(&mut self) -> ::std::vec::Vec<IngressRule> {
        ::std::mem::replace(&mut self.rules, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ingressClassName",
            |m: &IngressSpec| { &m.ingressClassName },
            |m: &mut IngressSpec| { &mut m.ingressClassName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IngressBackend>(
            "backend",
            |m: &IngressSpec| { &m.backend },
            |m: &mut IngressSpec| { &mut m.backend },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tls",
            |m: &IngressSpec| { &m.tls },
            |m: &mut IngressSpec| { &mut m.tls },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rules",
            |m: &IngressSpec| { &m.rules },
            |m: &mut IngressSpec| { &mut m.rules },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressSpec>(
            "IngressSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressSpec {
    const NAME: &'static str = "IngressSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                34 => {
                    self.ingressClassName = ::std::option::Option::Some(is.read_string()?);
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.backend)?;
                },
                18 => {
                    self.tls.push(is.read_message()?);
                },
                26 => {
                    self.rules.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ingressClassName.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.backend.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.tls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ingressClassName.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.backend.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.tls {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.rules {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressSpec {
        IngressSpec::new()
    }

    fn clear(&mut self) {
        self.ingressClassName = ::std::option::Option::None;
        self.backend.clear();
        self.tls.clear();
        self.rules.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressSpec {
        static instance: IngressSpec = IngressSpec {
            ingressClassName: ::std::option::Option::None,
            backend: ::protobuf::MessageField::none(),
            tls: ::std::vec::Vec::new(),
            rules: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.IngressStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressStatus {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.IngressStatus.loadBalancer)
    pub loadBalancer: ::protobuf::MessageField<IngressLoadBalancerStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.IngressStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressStatus {
    fn default() -> &'a IngressStatus {
        <IngressStatus as ::protobuf::Message>::default_instance()
    }
}

impl IngressStatus {
    pub fn new() -> IngressStatus {
        ::std::default::Default::default()
    }

    // optional .api.extensions.v1beta1.IngressLoadBalancerStatus loadBalancer = 1;

    pub fn loadBalancer(&self) -> &IngressLoadBalancerStatus {
        self.loadBalancer.as_ref().unwrap_or_else(|| <IngressLoadBalancerStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_loadBalancer(&mut self) {
        self.loadBalancer.clear();
    }

    pub fn has_loadBalancer(&self) -> bool {
        self.loadBalancer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loadBalancer(&mut self, v: IngressLoadBalancerStatus) {
        self.loadBalancer = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loadBalancer(&mut self) -> &mut IngressLoadBalancerStatus {
        self.loadBalancer.mut_or_insert_default()
    }

    // Take field
    pub fn take_loadBalancer(&mut self) -> IngressLoadBalancerStatus {
        self.loadBalancer.take().unwrap_or_else(|| IngressLoadBalancerStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IngressLoadBalancerStatus>(
            "loadBalancer",
            |m: &IngressStatus| { &m.loadBalancer },
            |m: &mut IngressStatus| { &mut m.loadBalancer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressStatus>(
            "IngressStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressStatus {
    const NAME: &'static str = "IngressStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.loadBalancer)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.loadBalancer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.loadBalancer.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressStatus {
        IngressStatus::new()
    }

    fn clear(&mut self) {
        self.loadBalancer.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressStatus {
        static instance: IngressStatus = IngressStatus {
            loadBalancer: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.IngressTLS)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressTLS {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.IngressTLS.hosts)
    pub hosts: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.IngressTLS.secretName)
    pub secretName: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.IngressTLS.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressTLS {
    fn default() -> &'a IngressTLS {
        <IngressTLS as ::protobuf::Message>::default_instance()
    }
}

impl IngressTLS {
    pub fn new() -> IngressTLS {
        ::std::default::Default::default()
    }

    // repeated string hosts = 1;

    pub fn hosts(&self) -> &[::std::string::String] {
        &self.hosts
    }

    pub fn clear_hosts(&mut self) {
        self.hosts.clear();
    }

    // Param is passed by value, moved
    pub fn set_hosts(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.hosts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hosts(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.hosts
    }

    // Take field
    pub fn take_hosts(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.hosts, ::std::vec::Vec::new())
    }

    // optional string secretName = 2;

    pub fn secretName(&self) -> &str {
        match self.secretName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_secretName(&mut self) {
        self.secretName = ::std::option::Option::None;
    }

    pub fn has_secretName(&self) -> bool {
        self.secretName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretName(&mut self, v: ::std::string::String) {
        self.secretName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretName(&mut self) -> &mut ::std::string::String {
        if self.secretName.is_none() {
            self.secretName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.secretName.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretName(&mut self) -> ::std::string::String {
        self.secretName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hosts",
            |m: &IngressTLS| { &m.hosts },
            |m: &mut IngressTLS| { &mut m.hosts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "secretName",
            |m: &IngressTLS| { &m.secretName },
            |m: &mut IngressTLS| { &mut m.secretName },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressTLS>(
            "IngressTLS",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressTLS {
    const NAME: &'static str = "IngressTLS";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hosts.push(is.read_string()?);
                },
                18 => {
                    self.secretName = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.hosts {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.secretName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.hosts {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.secretName.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressTLS {
        IngressTLS::new()
    }

    fn clear(&mut self) {
        self.hosts.clear();
        self.secretName = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressTLS {
        static instance: IngressTLS = IngressTLS {
            hosts: ::std::vec::Vec::new(),
            secretName: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressTLS {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressTLS").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressTLS {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressTLS {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.NetworkPolicy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NetworkPolicy {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.NetworkPolicy.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.NetworkPolicy.spec)
    pub spec: ::protobuf::MessageField<NetworkPolicySpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.NetworkPolicy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NetworkPolicy {
    fn default() -> &'a NetworkPolicy {
        <NetworkPolicy as ::protobuf::Message>::default_instance()
    }
}

impl NetworkPolicy {
    pub fn new() -> NetworkPolicy {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.extensions.v1beta1.NetworkPolicySpec spec = 2;

    pub fn spec(&self) -> &NetworkPolicySpec {
        self.spec.as_ref().unwrap_or_else(|| <NetworkPolicySpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: NetworkPolicySpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut NetworkPolicySpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> NetworkPolicySpec {
        self.spec.take().unwrap_or_else(|| NetworkPolicySpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &NetworkPolicy| { &m.metadata },
            |m: &mut NetworkPolicy| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NetworkPolicySpec>(
            "spec",
            |m: &NetworkPolicy| { &m.spec },
            |m: &mut NetworkPolicy| { &mut m.spec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NetworkPolicy>(
            "NetworkPolicy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NetworkPolicy {
    const NAME: &'static str = "NetworkPolicy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NetworkPolicy {
        NetworkPolicy::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NetworkPolicy {
        static instance: NetworkPolicy = NetworkPolicy {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NetworkPolicy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NetworkPolicy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NetworkPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkPolicy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.NetworkPolicyEgressRule)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NetworkPolicyEgressRule {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.NetworkPolicyEgressRule.ports)
    pub ports: ::std::vec::Vec<NetworkPolicyPort>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.NetworkPolicyEgressRule.to)
    pub to: ::std::vec::Vec<NetworkPolicyPeer>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.NetworkPolicyEgressRule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NetworkPolicyEgressRule {
    fn default() -> &'a NetworkPolicyEgressRule {
        <NetworkPolicyEgressRule as ::protobuf::Message>::default_instance()
    }
}

impl NetworkPolicyEgressRule {
    pub fn new() -> NetworkPolicyEgressRule {
        ::std::default::Default::default()
    }

    // repeated .api.extensions.v1beta1.NetworkPolicyPort ports = 1;

    pub fn ports(&self) -> &[NetworkPolicyPort] {
        &self.ports
    }

    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::std::vec::Vec<NetworkPolicyPort>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::std::vec::Vec<NetworkPolicyPort> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::std::vec::Vec<NetworkPolicyPort> {
        ::std::mem::replace(&mut self.ports, ::std::vec::Vec::new())
    }

    // repeated .api.extensions.v1beta1.NetworkPolicyPeer to = 2;

    pub fn to(&self) -> &[NetworkPolicyPeer] {
        &self.to
    }

    pub fn clear_to(&mut self) {
        self.to.clear();
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: ::std::vec::Vec<NetworkPolicyPeer>) {
        self.to = v;
    }

    // Mutable pointer to the field.
    pub fn mut_to(&mut self) -> &mut ::std::vec::Vec<NetworkPolicyPeer> {
        &mut self.to
    }

    // Take field
    pub fn take_to(&mut self) -> ::std::vec::Vec<NetworkPolicyPeer> {
        ::std::mem::replace(&mut self.to, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ports",
            |m: &NetworkPolicyEgressRule| { &m.ports },
            |m: &mut NetworkPolicyEgressRule| { &mut m.ports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "to",
            |m: &NetworkPolicyEgressRule| { &m.to },
            |m: &mut NetworkPolicyEgressRule| { &mut m.to },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NetworkPolicyEgressRule>(
            "NetworkPolicyEgressRule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NetworkPolicyEgressRule {
    const NAME: &'static str = "NetworkPolicyEgressRule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ports.push(is.read_message()?);
                },
                18 => {
                    self.to.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.to {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ports {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.to {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NetworkPolicyEgressRule {
        NetworkPolicyEgressRule::new()
    }

    fn clear(&mut self) {
        self.ports.clear();
        self.to.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NetworkPolicyEgressRule {
        static instance: NetworkPolicyEgressRule = NetworkPolicyEgressRule {
            ports: ::std::vec::Vec::new(),
            to: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NetworkPolicyEgressRule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NetworkPolicyEgressRule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NetworkPolicyEgressRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkPolicyEgressRule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.NetworkPolicyIngressRule)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NetworkPolicyIngressRule {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.NetworkPolicyIngressRule.ports)
    pub ports: ::std::vec::Vec<NetworkPolicyPort>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.NetworkPolicyIngressRule.from)
    pub from: ::std::vec::Vec<NetworkPolicyPeer>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.NetworkPolicyIngressRule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NetworkPolicyIngressRule {
    fn default() -> &'a NetworkPolicyIngressRule {
        <NetworkPolicyIngressRule as ::protobuf::Message>::default_instance()
    }
}

impl NetworkPolicyIngressRule {
    pub fn new() -> NetworkPolicyIngressRule {
        ::std::default::Default::default()
    }

    // repeated .api.extensions.v1beta1.NetworkPolicyPort ports = 1;

    pub fn ports(&self) -> &[NetworkPolicyPort] {
        &self.ports
    }

    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::std::vec::Vec<NetworkPolicyPort>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::std::vec::Vec<NetworkPolicyPort> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::std::vec::Vec<NetworkPolicyPort> {
        ::std::mem::replace(&mut self.ports, ::std::vec::Vec::new())
    }

    // repeated .api.extensions.v1beta1.NetworkPolicyPeer from = 2;

    pub fn from(&self) -> &[NetworkPolicyPeer] {
        &self.from
    }

    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::std::vec::Vec<NetworkPolicyPeer>) {
        self.from = v;
    }

    // Mutable pointer to the field.
    pub fn mut_from(&mut self) -> &mut ::std::vec::Vec<NetworkPolicyPeer> {
        &mut self.from
    }

    // Take field
    pub fn take_from(&mut self) -> ::std::vec::Vec<NetworkPolicyPeer> {
        ::std::mem::replace(&mut self.from, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ports",
            |m: &NetworkPolicyIngressRule| { &m.ports },
            |m: &mut NetworkPolicyIngressRule| { &mut m.ports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "from",
            |m: &NetworkPolicyIngressRule| { &m.from },
            |m: &mut NetworkPolicyIngressRule| { &mut m.from },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NetworkPolicyIngressRule>(
            "NetworkPolicyIngressRule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NetworkPolicyIngressRule {
    const NAME: &'static str = "NetworkPolicyIngressRule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ports.push(is.read_message()?);
                },
                18 => {
                    self.from.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.from {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ports {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.from {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NetworkPolicyIngressRule {
        NetworkPolicyIngressRule::new()
    }

    fn clear(&mut self) {
        self.ports.clear();
        self.from.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NetworkPolicyIngressRule {
        static instance: NetworkPolicyIngressRule = NetworkPolicyIngressRule {
            ports: ::std::vec::Vec::new(),
            from: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NetworkPolicyIngressRule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NetworkPolicyIngressRule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NetworkPolicyIngressRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkPolicyIngressRule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.NetworkPolicyList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NetworkPolicyList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.NetworkPolicyList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.NetworkPolicyList.items)
    pub items: ::std::vec::Vec<NetworkPolicy>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.NetworkPolicyList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NetworkPolicyList {
    fn default() -> &'a NetworkPolicyList {
        <NetworkPolicyList as ::protobuf::Message>::default_instance()
    }
}

impl NetworkPolicyList {
    pub fn new() -> NetworkPolicyList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.extensions.v1beta1.NetworkPolicy items = 2;

    pub fn items(&self) -> &[NetworkPolicy] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<NetworkPolicy>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<NetworkPolicy> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<NetworkPolicy> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &NetworkPolicyList| { &m.metadata },
            |m: &mut NetworkPolicyList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &NetworkPolicyList| { &m.items },
            |m: &mut NetworkPolicyList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NetworkPolicyList>(
            "NetworkPolicyList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NetworkPolicyList {
    const NAME: &'static str = "NetworkPolicyList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NetworkPolicyList {
        NetworkPolicyList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NetworkPolicyList {
        static instance: NetworkPolicyList = NetworkPolicyList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NetworkPolicyList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NetworkPolicyList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NetworkPolicyList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkPolicyList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.NetworkPolicyPeer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NetworkPolicyPeer {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.NetworkPolicyPeer.podSelector)
    pub podSelector: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.NetworkPolicyPeer.namespaceSelector)
    pub namespaceSelector: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.NetworkPolicyPeer.ipBlock)
    pub ipBlock: ::protobuf::MessageField<IPBlock>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.NetworkPolicyPeer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NetworkPolicyPeer {
    fn default() -> &'a NetworkPolicyPeer {
        <NetworkPolicyPeer as ::protobuf::Message>::default_instance()
    }
}

impl NetworkPolicyPeer {
    pub fn new() -> NetworkPolicyPeer {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;

    pub fn podSelector(&self) -> &crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.podSelector.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_podSelector(&mut self) {
        self.podSelector.clear();
    }

    pub fn has_podSelector(&self) -> bool {
        self.podSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podSelector(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.podSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podSelector(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.podSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_podSelector(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.podSelector.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 2;

    pub fn namespaceSelector(&self) -> &crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_namespaceSelector(&mut self) {
        self.namespaceSelector.clear();
    }

    pub fn has_namespaceSelector(&self) -> bool {
        self.namespaceSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespaceSelector(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.namespaceSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespaceSelector(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_namespaceSelector(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional .api.extensions.v1beta1.IPBlock ipBlock = 3;

    pub fn ipBlock(&self) -> &IPBlock {
        self.ipBlock.as_ref().unwrap_or_else(|| <IPBlock as ::protobuf::Message>::default_instance())
    }

    pub fn clear_ipBlock(&mut self) {
        self.ipBlock.clear();
    }

    pub fn has_ipBlock(&self) -> bool {
        self.ipBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipBlock(&mut self, v: IPBlock) {
        self.ipBlock = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipBlock(&mut self) -> &mut IPBlock {
        self.ipBlock.mut_or_insert_default()
    }

    // Take field
    pub fn take_ipBlock(&mut self) -> IPBlock {
        self.ipBlock.take().unwrap_or_else(|| IPBlock::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "podSelector",
            |m: &NetworkPolicyPeer| { &m.podSelector },
            |m: &mut NetworkPolicyPeer| { &mut m.podSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "namespaceSelector",
            |m: &NetworkPolicyPeer| { &m.namespaceSelector },
            |m: &mut NetworkPolicyPeer| { &mut m.namespaceSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IPBlock>(
            "ipBlock",
            |m: &NetworkPolicyPeer| { &m.ipBlock },
            |m: &mut NetworkPolicyPeer| { &mut m.ipBlock },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NetworkPolicyPeer>(
            "NetworkPolicyPeer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NetworkPolicyPeer {
    const NAME: &'static str = "NetworkPolicyPeer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.podSelector)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.namespaceSelector)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ipBlock)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.podSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.namespaceSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ipBlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.podSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.namespaceSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.ipBlock.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NetworkPolicyPeer {
        NetworkPolicyPeer::new()
    }

    fn clear(&mut self) {
        self.podSelector.clear();
        self.namespaceSelector.clear();
        self.ipBlock.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NetworkPolicyPeer {
        static instance: NetworkPolicyPeer = NetworkPolicyPeer {
            podSelector: ::protobuf::MessageField::none(),
            namespaceSelector: ::protobuf::MessageField::none(),
            ipBlock: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NetworkPolicyPeer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NetworkPolicyPeer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NetworkPolicyPeer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkPolicyPeer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.NetworkPolicyPort)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NetworkPolicyPort {
    // message fields
    // @@protoc_insertion_point(field:api.extensions.v1beta1.NetworkPolicyPort.protocol)
    pub protocol: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::intorstr")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.NetworkPolicyPort.port)
    pub port: ::protobuf::MessageField<crate::apimachinery::pkg::util::intstr::IntOrString>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.NetworkPolicyPort.endPort)
    pub endPort: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.NetworkPolicyPort.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NetworkPolicyPort {
    fn default() -> &'a NetworkPolicyPort {
        <NetworkPolicyPort as ::protobuf::Message>::default_instance()
    }
}

impl NetworkPolicyPort {
    pub fn new() -> NetworkPolicyPort {
        ::std::default::Default::default()
    }

    // optional string protocol = 1;

    pub fn protocol(&self) -> &str {
        match self.protocol.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_protocol(&mut self) {
        self.protocol = ::std::option::Option::None;
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol = ::std::option::Option::Some(::std::string::String::new());
        }
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.util.intstr.IntOrString port = 2;

    pub fn port(&self) -> &crate::apimachinery::pkg::util::intstr::IntOrString {
        self.port.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::util::intstr::IntOrString as ::protobuf::Message>::default_instance())
    }

    pub fn clear_port(&mut self) {
        self.port.clear();
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: crate::apimachinery::pkg::util::intstr::IntOrString) {
        self.port = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_port(&mut self) -> &mut crate::apimachinery::pkg::util::intstr::IntOrString {
        self.port.mut_or_insert_default()
    }

    // Take field
    pub fn take_port(&mut self) -> crate::apimachinery::pkg::util::intstr::IntOrString {
        self.port.take().unwrap_or_else(|| crate::apimachinery::pkg::util::intstr::IntOrString::new())
    }

    // optional int32 endPort = 3;

    pub fn endPort(&self) -> i32 {
        self.endPort.unwrap_or(0)
    }

    pub fn clear_endPort(&mut self) {
        self.endPort = ::std::option::Option::None;
    }

    pub fn has_endPort(&self) -> bool {
        self.endPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endPort(&mut self, v: i32) {
        self.endPort = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol",
            |m: &NetworkPolicyPort| { &m.protocol },
            |m: &mut NetworkPolicyPort| { &mut m.protocol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::util::intstr::IntOrString>(
            "port",
            |m: &NetworkPolicyPort| { &m.port },
            |m: &mut NetworkPolicyPort| { &mut m.port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "endPort",
            |m: &NetworkPolicyPort| { &m.endPort },
            |m: &mut NetworkPolicyPort| { &mut m.endPort },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NetworkPolicyPort>(
            "NetworkPolicyPort",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NetworkPolicyPort {
    const NAME: &'static str = "NetworkPolicyPort";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.protocol = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.port)?;
                },
                24 => {
                    self.endPort = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.protocol.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.port.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.endPort {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.protocol.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.port.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.endPort {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NetworkPolicyPort {
        NetworkPolicyPort::new()
    }

    fn clear(&mut self) {
        self.protocol = ::std::option::Option::None;
        self.port.clear();
        self.endPort = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NetworkPolicyPort {
        static instance: NetworkPolicyPort = NetworkPolicyPort {
            protocol: ::std::option::Option::None,
            port: ::protobuf::MessageField::none(),
            endPort: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NetworkPolicyPort {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NetworkPolicyPort").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NetworkPolicyPort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkPolicyPort {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.NetworkPolicySpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NetworkPolicySpec {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.NetworkPolicySpec.podSelector)
    pub podSelector: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.NetworkPolicySpec.ingress)
    pub ingress: ::std::vec::Vec<NetworkPolicyIngressRule>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.NetworkPolicySpec.egress)
    pub egress: ::std::vec::Vec<NetworkPolicyEgressRule>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.NetworkPolicySpec.policyTypes)
    pub policyTypes: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.NetworkPolicySpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NetworkPolicySpec {
    fn default() -> &'a NetworkPolicySpec {
        <NetworkPolicySpec as ::protobuf::Message>::default_instance()
    }
}

impl NetworkPolicySpec {
    pub fn new() -> NetworkPolicySpec {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;

    pub fn podSelector(&self) -> &crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.podSelector.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_podSelector(&mut self) {
        self.podSelector.clear();
    }

    pub fn has_podSelector(&self) -> bool {
        self.podSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podSelector(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.podSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podSelector(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.podSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_podSelector(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.podSelector.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // repeated .api.extensions.v1beta1.NetworkPolicyIngressRule ingress = 2;

    pub fn ingress(&self) -> &[NetworkPolicyIngressRule] {
        &self.ingress
    }

    pub fn clear_ingress(&mut self) {
        self.ingress.clear();
    }

    // Param is passed by value, moved
    pub fn set_ingress(&mut self, v: ::std::vec::Vec<NetworkPolicyIngressRule>) {
        self.ingress = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ingress(&mut self) -> &mut ::std::vec::Vec<NetworkPolicyIngressRule> {
        &mut self.ingress
    }

    // Take field
    pub fn take_ingress(&mut self) -> ::std::vec::Vec<NetworkPolicyIngressRule> {
        ::std::mem::replace(&mut self.ingress, ::std::vec::Vec::new())
    }

    // repeated .api.extensions.v1beta1.NetworkPolicyEgressRule egress = 3;

    pub fn egress(&self) -> &[NetworkPolicyEgressRule] {
        &self.egress
    }

    pub fn clear_egress(&mut self) {
        self.egress.clear();
    }

    // Param is passed by value, moved
    pub fn set_egress(&mut self, v: ::std::vec::Vec<NetworkPolicyEgressRule>) {
        self.egress = v;
    }

    // Mutable pointer to the field.
    pub fn mut_egress(&mut self) -> &mut ::std::vec::Vec<NetworkPolicyEgressRule> {
        &mut self.egress
    }

    // Take field
    pub fn take_egress(&mut self) -> ::std::vec::Vec<NetworkPolicyEgressRule> {
        ::std::mem::replace(&mut self.egress, ::std::vec::Vec::new())
    }

    // repeated string policyTypes = 4;

    pub fn policyTypes(&self) -> &[::std::string::String] {
        &self.policyTypes
    }

    pub fn clear_policyTypes(&mut self) {
        self.policyTypes.clear();
    }

    // Param is passed by value, moved
    pub fn set_policyTypes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.policyTypes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_policyTypes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.policyTypes
    }

    // Take field
    pub fn take_policyTypes(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.policyTypes, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "podSelector",
            |m: &NetworkPolicySpec| { &m.podSelector },
            |m: &mut NetworkPolicySpec| { &mut m.podSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ingress",
            |m: &NetworkPolicySpec| { &m.ingress },
            |m: &mut NetworkPolicySpec| { &mut m.ingress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "egress",
            |m: &NetworkPolicySpec| { &m.egress },
            |m: &mut NetworkPolicySpec| { &mut m.egress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "policyTypes",
            |m: &NetworkPolicySpec| { &m.policyTypes },
            |m: &mut NetworkPolicySpec| { &mut m.policyTypes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NetworkPolicySpec>(
            "NetworkPolicySpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NetworkPolicySpec {
    const NAME: &'static str = "NetworkPolicySpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.podSelector)?;
                },
                18 => {
                    self.ingress.push(is.read_message()?);
                },
                26 => {
                    self.egress.push(is.read_message()?);
                },
                34 => {
                    self.policyTypes.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.podSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ingress {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.egress {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.policyTypes {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.podSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ingress {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.egress {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.policyTypes {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NetworkPolicySpec {
        NetworkPolicySpec::new()
    }

    fn clear(&mut self) {
        self.podSelector.clear();
        self.ingress.clear();
        self.egress.clear();
        self.policyTypes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NetworkPolicySpec {
        static instance: NetworkPolicySpec = NetworkPolicySpec {
            podSelector: ::protobuf::MessageField::none(),
            ingress: ::std::vec::Vec::new(),
            egress: ::std::vec::Vec::new(),
            policyTypes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NetworkPolicySpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NetworkPolicySpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NetworkPolicySpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkPolicySpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.ReplicaSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReplicaSet {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.ReplicaSet.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.ReplicaSet.spec)
    pub spec: ::protobuf::MessageField<ReplicaSetSpec>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.ReplicaSet.status)
    pub status: ::protobuf::MessageField<ReplicaSetStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.ReplicaSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReplicaSet {
    fn default() -> &'a ReplicaSet {
        <ReplicaSet as ::protobuf::Message>::default_instance()
    }
}

impl ReplicaSet {
    pub fn new() -> ReplicaSet {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.extensions.v1beta1.ReplicaSetSpec spec = 2;

    pub fn spec(&self) -> &ReplicaSetSpec {
        self.spec.as_ref().unwrap_or_else(|| <ReplicaSetSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ReplicaSetSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ReplicaSetSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ReplicaSetSpec {
        self.spec.take().unwrap_or_else(|| ReplicaSetSpec::new())
    }

    // optional .api.extensions.v1beta1.ReplicaSetStatus status = 3;

    pub fn status(&self) -> &ReplicaSetStatus {
        self.status.as_ref().unwrap_or_else(|| <ReplicaSetStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ReplicaSetStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ReplicaSetStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> ReplicaSetStatus {
        self.status.take().unwrap_or_else(|| ReplicaSetStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ReplicaSet| { &m.metadata },
            |m: &mut ReplicaSet| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ReplicaSetSpec>(
            "spec",
            |m: &ReplicaSet| { &m.spec },
            |m: &mut ReplicaSet| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ReplicaSetStatus>(
            "status",
            |m: &ReplicaSet| { &m.status },
            |m: &mut ReplicaSet| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplicaSet>(
            "ReplicaSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReplicaSet {
    const NAME: &'static str = "ReplicaSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReplicaSet {
        ReplicaSet::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReplicaSet {
        static instance: ReplicaSet = ReplicaSet {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReplicaSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReplicaSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReplicaSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicaSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.ReplicaSetCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReplicaSetCondition {
    // message fields
    // @@protoc_insertion_point(field:api.extensions.v1beta1.ReplicaSetCondition.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.ReplicaSetCondition.status)
    pub status: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.ReplicaSetCondition.lastTransitionTime)
    pub lastTransitionTime: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.ReplicaSetCondition.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.ReplicaSetCondition.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.ReplicaSetCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReplicaSetCondition {
    fn default() -> &'a ReplicaSetCondition {
        <ReplicaSetCondition as ::protobuf::Message>::default_instance()
    }
}

impl ReplicaSetCondition {
    pub fn new() -> ReplicaSetCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

    pub fn lastTransitionTime(&self) -> &crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastTransitionTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional string reason = 4;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 5;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &ReplicaSetCondition| { &m.type_ },
            |m: &mut ReplicaSetCondition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &ReplicaSetCondition| { &m.status },
            |m: &mut ReplicaSetCondition| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::Time>(
            "lastTransitionTime",
            |m: &ReplicaSetCondition| { &m.lastTransitionTime },
            |m: &mut ReplicaSetCondition| { &mut m.lastTransitionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &ReplicaSetCondition| { &m.reason },
            |m: &mut ReplicaSetCondition| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &ReplicaSetCondition| { &m.message },
            |m: &mut ReplicaSetCondition| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplicaSetCondition>(
            "ReplicaSetCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReplicaSetCondition {
    const NAME: &'static str = "ReplicaSetCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTransitionTime)?;
                },
                34 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReplicaSetCondition {
        ReplicaSetCondition::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.lastTransitionTime.clear();
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReplicaSetCondition {
        static instance: ReplicaSetCondition = ReplicaSetCondition {
            type_: ::std::option::Option::None,
            status: ::std::option::Option::None,
            lastTransitionTime: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReplicaSetCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReplicaSetCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReplicaSetCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicaSetCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.ReplicaSetList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReplicaSetList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.ReplicaSetList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.ReplicaSetList.items)
    pub items: ::std::vec::Vec<ReplicaSet>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.ReplicaSetList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReplicaSetList {
    fn default() -> &'a ReplicaSetList {
        <ReplicaSetList as ::protobuf::Message>::default_instance()
    }
}

impl ReplicaSetList {
    pub fn new() -> ReplicaSetList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.extensions.v1beta1.ReplicaSet items = 2;

    pub fn items(&self) -> &[ReplicaSet] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ReplicaSet>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ReplicaSet> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ReplicaSet> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ReplicaSetList| { &m.metadata },
            |m: &mut ReplicaSetList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ReplicaSetList| { &m.items },
            |m: &mut ReplicaSetList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplicaSetList>(
            "ReplicaSetList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReplicaSetList {
    const NAME: &'static str = "ReplicaSetList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReplicaSetList {
        ReplicaSetList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReplicaSetList {
        static instance: ReplicaSetList = ReplicaSetList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReplicaSetList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReplicaSetList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReplicaSetList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicaSetList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.ReplicaSetSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReplicaSetSpec {
    // message fields
    // @@protoc_insertion_point(field:api.extensions.v1beta1.ReplicaSetSpec.replicas)
    pub replicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.ReplicaSetSpec.minReadySeconds)
    pub minReadySeconds: ::std::option::Option<i32>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.ReplicaSetSpec.selector)
    pub selector: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.ReplicaSetSpec.template)
    pub template: ::protobuf::MessageField<crate::api::core::v1::PodTemplateSpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.ReplicaSetSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReplicaSetSpec {
    fn default() -> &'a ReplicaSetSpec {
        <ReplicaSetSpec as ::protobuf::Message>::default_instance()
    }
}

impl ReplicaSetSpec {
    pub fn new() -> ReplicaSetSpec {
        ::std::default::Default::default()
    }

    // optional int32 replicas = 1;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // optional int32 minReadySeconds = 4;

    pub fn minReadySeconds(&self) -> i32 {
        self.minReadySeconds.unwrap_or(0)
    }

    pub fn clear_minReadySeconds(&mut self) {
        self.minReadySeconds = ::std::option::Option::None;
    }

    pub fn has_minReadySeconds(&self) -> bool {
        self.minReadySeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minReadySeconds(&mut self, v: i32) {
        self.minReadySeconds = ::std::option::Option::Some(v);
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;

    pub fn selector(&self) -> &crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    pub fn has_selector(&self) -> bool {
        self.selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.selector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selector(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.mut_or_insert_default()
    }

    // Take field
    pub fn take_selector(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional .api.core.v1.PodTemplateSpec template = 3;

    pub fn template(&self) -> &crate::api::core::v1::PodTemplateSpec {
        self.template.as_ref().unwrap_or_else(|| <crate::api::core::v1::PodTemplateSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_template(&mut self) {
        self.template.clear();
    }

    pub fn has_template(&self) -> bool {
        self.template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template(&mut self, v: crate::api::core::v1::PodTemplateSpec) {
        self.template = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template(&mut self) -> &mut crate::api::core::v1::PodTemplateSpec {
        self.template.mut_or_insert_default()
    }

    // Take field
    pub fn take_template(&mut self) -> crate::api::core::v1::PodTemplateSpec {
        self.template.take().unwrap_or_else(|| crate::api::core::v1::PodTemplateSpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &ReplicaSetSpec| { &m.replicas },
            |m: &mut ReplicaSetSpec| { &mut m.replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minReadySeconds",
            |m: &ReplicaSetSpec| { &m.minReadySeconds },
            |m: &mut ReplicaSetSpec| { &mut m.minReadySeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "selector",
            |m: &ReplicaSetSpec| { &m.selector },
            |m: &mut ReplicaSetSpec| { &mut m.selector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::api::core::v1::PodTemplateSpec>(
            "template",
            |m: &ReplicaSetSpec| { &m.template },
            |m: &mut ReplicaSetSpec| { &mut m.template },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplicaSetSpec>(
            "ReplicaSetSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReplicaSetSpec {
    const NAME: &'static str = "ReplicaSetSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.minReadySeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.selector)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.template)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.minReadySeconds {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.replicas {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.minReadySeconds {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.selector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.template.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReplicaSetSpec {
        ReplicaSetSpec::new()
    }

    fn clear(&mut self) {
        self.replicas = ::std::option::Option::None;
        self.minReadySeconds = ::std::option::Option::None;
        self.selector.clear();
        self.template.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReplicaSetSpec {
        static instance: ReplicaSetSpec = ReplicaSetSpec {
            replicas: ::std::option::Option::None,
            minReadySeconds: ::std::option::Option::None,
            selector: ::protobuf::MessageField::none(),
            template: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReplicaSetSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReplicaSetSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReplicaSetSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicaSetSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.ReplicaSetStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReplicaSetStatus {
    // message fields
    // @@protoc_insertion_point(field:api.extensions.v1beta1.ReplicaSetStatus.replicas)
    pub replicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.ReplicaSetStatus.fullyLabeledReplicas)
    pub fullyLabeledReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.ReplicaSetStatus.readyReplicas)
    pub readyReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.ReplicaSetStatus.availableReplicas)
    pub availableReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.ReplicaSetStatus.observedGeneration)
    pub observedGeneration: ::std::option::Option<i64>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.ReplicaSetStatus.conditions)
    pub conditions: ::std::vec::Vec<ReplicaSetCondition>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.ReplicaSetStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReplicaSetStatus {
    fn default() -> &'a ReplicaSetStatus {
        <ReplicaSetStatus as ::protobuf::Message>::default_instance()
    }
}

impl ReplicaSetStatus {
    pub fn new() -> ReplicaSetStatus {
        ::std::default::Default::default()
    }

    // optional int32 replicas = 1;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // optional int32 fullyLabeledReplicas = 2;

    pub fn fullyLabeledReplicas(&self) -> i32 {
        self.fullyLabeledReplicas.unwrap_or(0)
    }

    pub fn clear_fullyLabeledReplicas(&mut self) {
        self.fullyLabeledReplicas = ::std::option::Option::None;
    }

    pub fn has_fullyLabeledReplicas(&self) -> bool {
        self.fullyLabeledReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fullyLabeledReplicas(&mut self, v: i32) {
        self.fullyLabeledReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 readyReplicas = 4;

    pub fn readyReplicas(&self) -> i32 {
        self.readyReplicas.unwrap_or(0)
    }

    pub fn clear_readyReplicas(&mut self) {
        self.readyReplicas = ::std::option::Option::None;
    }

    pub fn has_readyReplicas(&self) -> bool {
        self.readyReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readyReplicas(&mut self, v: i32) {
        self.readyReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 availableReplicas = 5;

    pub fn availableReplicas(&self) -> i32 {
        self.availableReplicas.unwrap_or(0)
    }

    pub fn clear_availableReplicas(&mut self) {
        self.availableReplicas = ::std::option::Option::None;
    }

    pub fn has_availableReplicas(&self) -> bool {
        self.availableReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_availableReplicas(&mut self, v: i32) {
        self.availableReplicas = ::std::option::Option::Some(v);
    }

    // optional int64 observedGeneration = 3;

    pub fn observedGeneration(&self) -> i64 {
        self.observedGeneration.unwrap_or(0)
    }

    pub fn clear_observedGeneration(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
    }

    pub fn has_observedGeneration(&self) -> bool {
        self.observedGeneration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observedGeneration(&mut self, v: i64) {
        self.observedGeneration = ::std::option::Option::Some(v);
    }

    // repeated .api.extensions.v1beta1.ReplicaSetCondition conditions = 6;

    pub fn conditions(&self) -> &[ReplicaSetCondition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<ReplicaSetCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<ReplicaSetCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<ReplicaSetCondition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &ReplicaSetStatus| { &m.replicas },
            |m: &mut ReplicaSetStatus| { &mut m.replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fullyLabeledReplicas",
            |m: &ReplicaSetStatus| { &m.fullyLabeledReplicas },
            |m: &mut ReplicaSetStatus| { &mut m.fullyLabeledReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readyReplicas",
            |m: &ReplicaSetStatus| { &m.readyReplicas },
            |m: &mut ReplicaSetStatus| { &mut m.readyReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "availableReplicas",
            |m: &ReplicaSetStatus| { &m.availableReplicas },
            |m: &mut ReplicaSetStatus| { &mut m.availableReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "observedGeneration",
            |m: &ReplicaSetStatus| { &m.observedGeneration },
            |m: &mut ReplicaSetStatus| { &mut m.observedGeneration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &ReplicaSetStatus| { &m.conditions },
            |m: &mut ReplicaSetStatus| { &mut m.conditions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplicaSetStatus>(
            "ReplicaSetStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReplicaSetStatus {
    const NAME: &'static str = "ReplicaSetStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.fullyLabeledReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.readyReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.availableReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.observedGeneration = ::std::option::Option::Some(is.read_int64()?);
                },
                50 => {
                    self.conditions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.fullyLabeledReplicas {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.readyReplicas {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.availableReplicas {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.observedGeneration {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.replicas {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.fullyLabeledReplicas {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.readyReplicas {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.availableReplicas {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.observedGeneration {
            os.write_int64(3, v)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReplicaSetStatus {
        ReplicaSetStatus::new()
    }

    fn clear(&mut self) {
        self.replicas = ::std::option::Option::None;
        self.fullyLabeledReplicas = ::std::option::Option::None;
        self.readyReplicas = ::std::option::Option::None;
        self.availableReplicas = ::std::option::Option::None;
        self.observedGeneration = ::std::option::Option::None;
        self.conditions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReplicaSetStatus {
        static instance: ReplicaSetStatus = ReplicaSetStatus {
            replicas: ::std::option::Option::None,
            fullyLabeledReplicas: ::std::option::Option::None,
            readyReplicas: ::std::option::Option::None,
            availableReplicas: ::std::option::Option::None,
            observedGeneration: ::std::option::Option::None,
            conditions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReplicaSetStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReplicaSetStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReplicaSetStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicaSetStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.RollbackConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RollbackConfig {
    // message fields
    // @@protoc_insertion_point(field:api.extensions.v1beta1.RollbackConfig.revision)
    pub revision: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.RollbackConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RollbackConfig {
    fn default() -> &'a RollbackConfig {
        <RollbackConfig as ::protobuf::Message>::default_instance()
    }
}

impl RollbackConfig {
    pub fn new() -> RollbackConfig {
        ::std::default::Default::default()
    }

    // optional int64 revision = 1;

    pub fn revision(&self) -> i64 {
        self.revision.unwrap_or(0)
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: i64) {
        self.revision = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revision",
            |m: &RollbackConfig| { &m.revision },
            |m: &mut RollbackConfig| { &mut m.revision },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RollbackConfig>(
            "RollbackConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RollbackConfig {
    const NAME: &'static str = "RollbackConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.revision = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.revision {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.revision {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RollbackConfig {
        RollbackConfig::new()
    }

    fn clear(&mut self) {
        self.revision = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RollbackConfig {
        static instance: RollbackConfig = RollbackConfig {
            revision: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RollbackConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RollbackConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RollbackConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollbackConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.RollingUpdateDaemonSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RollingUpdateDaemonSet {
    // message fields
    #[serde(with = "crate::intorstr")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.RollingUpdateDaemonSet.maxUnavailable)
    pub maxUnavailable: ::protobuf::MessageField<crate::apimachinery::pkg::util::intstr::IntOrString>,
    #[serde(with = "crate::intorstr")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.RollingUpdateDaemonSet.maxSurge)
    pub maxSurge: ::protobuf::MessageField<crate::apimachinery::pkg::util::intstr::IntOrString>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.RollingUpdateDaemonSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RollingUpdateDaemonSet {
    fn default() -> &'a RollingUpdateDaemonSet {
        <RollingUpdateDaemonSet as ::protobuf::Message>::default_instance()
    }
}

impl RollingUpdateDaemonSet {
    pub fn new() -> RollingUpdateDaemonSet {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;

    pub fn maxUnavailable(&self) -> &crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::util::intstr::IntOrString as ::protobuf::Message>::default_instance())
    }

    pub fn clear_maxUnavailable(&mut self) {
        self.maxUnavailable.clear();
    }

    pub fn has_maxUnavailable(&self) -> bool {
        self.maxUnavailable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxUnavailable(&mut self, v: crate::apimachinery::pkg::util::intstr::IntOrString) {
        self.maxUnavailable = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maxUnavailable(&mut self) -> &mut crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.mut_or_insert_default()
    }

    // Take field
    pub fn take_maxUnavailable(&mut self) -> crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.take().unwrap_or_else(|| crate::apimachinery::pkg::util::intstr::IntOrString::new())
    }

    // optional .apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;

    pub fn maxSurge(&self) -> &crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxSurge.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::util::intstr::IntOrString as ::protobuf::Message>::default_instance())
    }

    pub fn clear_maxSurge(&mut self) {
        self.maxSurge.clear();
    }

    pub fn has_maxSurge(&self) -> bool {
        self.maxSurge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxSurge(&mut self, v: crate::apimachinery::pkg::util::intstr::IntOrString) {
        self.maxSurge = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maxSurge(&mut self) -> &mut crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxSurge.mut_or_insert_default()
    }

    // Take field
    pub fn take_maxSurge(&mut self) -> crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxSurge.take().unwrap_or_else(|| crate::apimachinery::pkg::util::intstr::IntOrString::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::util::intstr::IntOrString>(
            "maxUnavailable",
            |m: &RollingUpdateDaemonSet| { &m.maxUnavailable },
            |m: &mut RollingUpdateDaemonSet| { &mut m.maxUnavailable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::util::intstr::IntOrString>(
            "maxSurge",
            |m: &RollingUpdateDaemonSet| { &m.maxSurge },
            |m: &mut RollingUpdateDaemonSet| { &mut m.maxSurge },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RollingUpdateDaemonSet>(
            "RollingUpdateDaemonSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RollingUpdateDaemonSet {
    const NAME: &'static str = "RollingUpdateDaemonSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.maxUnavailable)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.maxSurge)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.maxUnavailable.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.maxSurge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.maxUnavailable.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.maxSurge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RollingUpdateDaemonSet {
        RollingUpdateDaemonSet::new()
    }

    fn clear(&mut self) {
        self.maxUnavailable.clear();
        self.maxSurge.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RollingUpdateDaemonSet {
        static instance: RollingUpdateDaemonSet = RollingUpdateDaemonSet {
            maxUnavailable: ::protobuf::MessageField::none(),
            maxSurge: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RollingUpdateDaemonSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RollingUpdateDaemonSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RollingUpdateDaemonSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpdateDaemonSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.RollingUpdateDeployment)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RollingUpdateDeployment {
    // message fields
    #[serde(with = "crate::intorstr")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.RollingUpdateDeployment.maxUnavailable)
    pub maxUnavailable: ::protobuf::MessageField<crate::apimachinery::pkg::util::intstr::IntOrString>,
    #[serde(with = "crate::intorstr")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.RollingUpdateDeployment.maxSurge)
    pub maxSurge: ::protobuf::MessageField<crate::apimachinery::pkg::util::intstr::IntOrString>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.RollingUpdateDeployment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RollingUpdateDeployment {
    fn default() -> &'a RollingUpdateDeployment {
        <RollingUpdateDeployment as ::protobuf::Message>::default_instance()
    }
}

impl RollingUpdateDeployment {
    pub fn new() -> RollingUpdateDeployment {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;

    pub fn maxUnavailable(&self) -> &crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::util::intstr::IntOrString as ::protobuf::Message>::default_instance())
    }

    pub fn clear_maxUnavailable(&mut self) {
        self.maxUnavailable.clear();
    }

    pub fn has_maxUnavailable(&self) -> bool {
        self.maxUnavailable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxUnavailable(&mut self, v: crate::apimachinery::pkg::util::intstr::IntOrString) {
        self.maxUnavailable = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maxUnavailable(&mut self) -> &mut crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.mut_or_insert_default()
    }

    // Take field
    pub fn take_maxUnavailable(&mut self) -> crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.take().unwrap_or_else(|| crate::apimachinery::pkg::util::intstr::IntOrString::new())
    }

    // optional .apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;

    pub fn maxSurge(&self) -> &crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxSurge.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::util::intstr::IntOrString as ::protobuf::Message>::default_instance())
    }

    pub fn clear_maxSurge(&mut self) {
        self.maxSurge.clear();
    }

    pub fn has_maxSurge(&self) -> bool {
        self.maxSurge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxSurge(&mut self, v: crate::apimachinery::pkg::util::intstr::IntOrString) {
        self.maxSurge = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maxSurge(&mut self) -> &mut crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxSurge.mut_or_insert_default()
    }

    // Take field
    pub fn take_maxSurge(&mut self) -> crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxSurge.take().unwrap_or_else(|| crate::apimachinery::pkg::util::intstr::IntOrString::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::util::intstr::IntOrString>(
            "maxUnavailable",
            |m: &RollingUpdateDeployment| { &m.maxUnavailable },
            |m: &mut RollingUpdateDeployment| { &mut m.maxUnavailable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::util::intstr::IntOrString>(
            "maxSurge",
            |m: &RollingUpdateDeployment| { &m.maxSurge },
            |m: &mut RollingUpdateDeployment| { &mut m.maxSurge },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RollingUpdateDeployment>(
            "RollingUpdateDeployment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RollingUpdateDeployment {
    const NAME: &'static str = "RollingUpdateDeployment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.maxUnavailable)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.maxSurge)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.maxUnavailable.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.maxSurge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.maxUnavailable.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.maxSurge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RollingUpdateDeployment {
        RollingUpdateDeployment::new()
    }

    fn clear(&mut self) {
        self.maxUnavailable.clear();
        self.maxSurge.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RollingUpdateDeployment {
        static instance: RollingUpdateDeployment = RollingUpdateDeployment {
            maxUnavailable: ::protobuf::MessageField::none(),
            maxSurge: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RollingUpdateDeployment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RollingUpdateDeployment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RollingUpdateDeployment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpdateDeployment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.Scale)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Scale {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.Scale.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.Scale.spec)
    pub spec: ::protobuf::MessageField<ScaleSpec>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.Scale.status)
    pub status: ::protobuf::MessageField<ScaleStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.Scale.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Scale {
    fn default() -> &'a Scale {
        <Scale as ::protobuf::Message>::default_instance()
    }
}

impl Scale {
    pub fn new() -> Scale {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.extensions.v1beta1.ScaleSpec spec = 2;

    pub fn spec(&self) -> &ScaleSpec {
        self.spec.as_ref().unwrap_or_else(|| <ScaleSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ScaleSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ScaleSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ScaleSpec {
        self.spec.take().unwrap_or_else(|| ScaleSpec::new())
    }

    // optional .api.extensions.v1beta1.ScaleStatus status = 3;

    pub fn status(&self) -> &ScaleStatus {
        self.status.as_ref().unwrap_or_else(|| <ScaleStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ScaleStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ScaleStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> ScaleStatus {
        self.status.take().unwrap_or_else(|| ScaleStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &Scale| { &m.metadata },
            |m: &mut Scale| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ScaleSpec>(
            "spec",
            |m: &Scale| { &m.spec },
            |m: &mut Scale| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ScaleStatus>(
            "status",
            |m: &Scale| { &m.status },
            |m: &mut Scale| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Scale>(
            "Scale",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Scale {
    const NAME: &'static str = "Scale";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Scale {
        Scale::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Scale {
        static instance: Scale = Scale {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Scale {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Scale").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Scale {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Scale {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.ScaleSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ScaleSpec {
    // message fields
    // @@protoc_insertion_point(field:api.extensions.v1beta1.ScaleSpec.replicas)
    pub replicas: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.ScaleSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScaleSpec {
    fn default() -> &'a ScaleSpec {
        <ScaleSpec as ::protobuf::Message>::default_instance()
    }
}

impl ScaleSpec {
    pub fn new() -> ScaleSpec {
        ::std::default::Default::default()
    }

    // optional int32 replicas = 1;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &ScaleSpec| { &m.replicas },
            |m: &mut ScaleSpec| { &mut m.replicas },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScaleSpec>(
            "ScaleSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScaleSpec {
    const NAME: &'static str = "ScaleSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.replicas {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScaleSpec {
        ScaleSpec::new()
    }

    fn clear(&mut self) {
        self.replicas = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScaleSpec {
        static instance: ScaleSpec = ScaleSpec {
            replicas: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScaleSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScaleSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScaleSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScaleSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.extensions.v1beta1.ScaleStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ScaleStatus {
    // message fields
    // @@protoc_insertion_point(field:api.extensions.v1beta1.ScaleStatus.replicas)
    pub replicas: ::std::option::Option<i32>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.extensions.v1beta1.ScaleStatus.selector)
    pub selector: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:api.extensions.v1beta1.ScaleStatus.targetSelector)
    pub targetSelector: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.extensions.v1beta1.ScaleStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScaleStatus {
    fn default() -> &'a ScaleStatus {
        <ScaleStatus as ::protobuf::Message>::default_instance()
    }
}

impl ScaleStatus {
    pub fn new() -> ScaleStatus {
        ::std::default::Default::default()
    }

    // optional int32 replicas = 1;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // repeated .api.extensions.v1beta1.ScaleStatus.SelectorEntry selector = 2;

    pub fn selector(&self) -> &::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &self.selector
    }

    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
        self.selector = v;
    }

    // Mutable pointer to the field.
    pub fn mut_selector(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &mut self.selector
    }

    // Take field
    pub fn take_selector(&mut self) -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.selector, ::std::collections::BTreeMap::new())
    }

    // optional string targetSelector = 3;

    pub fn targetSelector(&self) -> &str {
        match self.targetSelector.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_targetSelector(&mut self) {
        self.targetSelector = ::std::option::Option::None;
    }

    pub fn has_targetSelector(&self) -> bool {
        self.targetSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetSelector(&mut self, v: ::std::string::String) {
        self.targetSelector = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetSelector(&mut self) -> &mut ::std::string::String {
        if self.targetSelector.is_none() {
            self.targetSelector = ::std::option::Option::Some(::std::string::String::new());
        }
        self.targetSelector.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetSelector(&mut self) -> ::std::string::String {
        self.targetSelector.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &ScaleStatus| { &m.replicas },
            |m: &mut ScaleStatus| { &mut m.replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "selector",
            |m: &ScaleStatus| { &m.selector },
            |m: &mut ScaleStatus| { &mut m.selector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "targetSelector",
            |m: &ScaleStatus| { &m.targetSelector },
            |m: &mut ScaleStatus| { &mut m.targetSelector },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScaleStatus>(
            "ScaleStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScaleStatus {
    const NAME: &'static str = "ScaleStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.selector.insert(key, value);
                },
                26 => {
                    self.targetSelector = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for (k, v) in &self.selector {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.targetSelector.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.replicas {
            os.write_int32(1, v)?;
        }
        for (k, v) in &self.selector {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.targetSelector.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScaleStatus {
        ScaleStatus::new()
    }

    fn clear(&mut self) {
        self.replicas = ::std::option::Option::None;
        self.selector.clear();
        self.targetSelector = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScaleStatus {
        static instance: ::protobuf::rt::Lazy<ScaleStatus> = ::protobuf::rt::Lazy::new();
        instance.get(ScaleStatus::new)
    }
}

impl ::protobuf::MessageFull for ScaleStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScaleStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScaleStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScaleStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n&api/extensions/v1beta1/generated.proto\x12\x16api.extensions.v1beta1\
    \x1a\x1bapi/core/v1/generated.proto\x1a-apimachinery/pkg/apis/meta/v1/ge\
    nerated.proto\x1a(apimachinery/pkg/runtime/generated.proto\x1a/apimachin\
    ery/pkg/runtime/schema/generated.proto\x1a,apimachinery/pkg/util/intstr/\
    generated.proto\"\xce\x01\n\tDaemonSet\x12E\n\x08metadata\x18\x01\x20\
    \x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x129\n\
    \x04spec\x18\x02\x20\x01(\x0b2%.api.extensions.v1beta1.DaemonSetSpecR\
    \x04spec\x12?\n\x06status\x18\x03\x20\x01(\x0b2'.api.extensions.v1beta1.\
    DaemonSetStatusR\x06status\"\xc7\x01\n\x12DaemonSetCondition\x12\x12\n\
    \x04type\x18\x01\x20\x01(\tR\x04type\x12\x16\n\x06status\x18\x02\x20\x01\
    (\tR\x06status\x12S\n\x12lastTransitionTime\x18\x03\x20\x01(\x0b2#.apima\
    chinery.pkg.apis.meta.v1.TimeR\x12lastTransitionTime\x12\x16\n\x06reason\
    \x18\x04\x20\x01(\tR\x06reason\x12\x18\n\x07message\x18\x05\x20\x01(\tR\
    \x07message\"\x8d\x01\n\rDaemonSetList\x12C\n\x08metadata\x18\x01\x20\
    \x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x127\n\
    \x05items\x18\x02\x20\x03(\x0b2!.api.extensions.v1beta1.DaemonSetR\x05it\
    ems\"\xfa\x02\n\rDaemonSetSpec\x12H\n\x08selector\x18\x01\x20\x01(\x0b2,\
    .apimachinery.pkg.apis.meta.v1.LabelSelectorR\x08selector\x128\n\x08temp\
    late\x18\x02\x20\x01(\x0b2\x1c.api.core.v1.PodTemplateSpecR\x08template\
    \x12W\n\x0eupdateStrategy\x18\x03\x20\x01(\x0b2/.api.extensions.v1beta1.\
    DaemonSetUpdateStrategyR\x0eupdateStrategy\x12(\n\x0fminReadySeconds\x18\
    \x04\x20\x01(\x05R\x0fminReadySeconds\x12.\n\x12templateGeneration\x18\
    \x05\x20\x01(\x03R\x12templateGeneration\x122\n\x14revisionHistoryLimit\
    \x18\x06\x20\x01(\x05R\x14revisionHistoryLimit\"\x87\x04\n\x0fDaemonSetS\
    tatus\x126\n\x16currentNumberScheduled\x18\x01\x20\x01(\x05R\x16currentN\
    umberScheduled\x12.\n\x12numberMisscheduled\x18\x02\x20\x01(\x05R\x12num\
    berMisscheduled\x126\n\x16desiredNumberScheduled\x18\x03\x20\x01(\x05R\
    \x16desiredNumberScheduled\x12\x20\n\x0bnumberReady\x18\x04\x20\x01(\x05\
    R\x0bnumberReady\x12.\n\x12observedGeneration\x18\x05\x20\x01(\x03R\x12o\
    bservedGeneration\x126\n\x16updatedNumberScheduled\x18\x06\x20\x01(\x05R\
    \x16updatedNumberScheduled\x12(\n\x0fnumberAvailable\x18\x07\x20\x01(\
    \x05R\x0fnumberAvailable\x12,\n\x11numberUnavailable\x18\x08\x20\x01(\
    \x05R\x11numberUnavailable\x12&\n\x0ecollisionCount\x18\t\x20\x01(\x05R\
    \x0ecollisionCount\x12J\n\nconditions\x18\n\x20\x03(\x0b2*.api.extension\
    s.v1beta1.DaemonSetConditionR\nconditions\"\x83\x01\n\x17DaemonSetUpdate\
    Strategy\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12T\n\rrollingUp\
    date\x18\x02\x20\x01(\x0b2..api.extensions.v1beta1.RollingUpdateDaemonSe\
    tR\rrollingUpdate\"\xd1\x01\n\nDeployment\x12E\n\x08metadata\x18\x01\x20\
    \x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12:\n\
    \x04spec\x18\x02\x20\x01(\x0b2&.api.extensions.v1beta1.DeploymentSpecR\
    \x04spec\x12@\n\x06status\x18\x03\x20\x01(\x0b2(.api.extensions.v1beta1.\
    DeploymentStatusR\x06status\"\x95\x02\n\x13DeploymentCondition\x12\x12\n\
    \x04type\x18\x01\x20\x01(\tR\x04type\x12\x16\n\x06status\x18\x02\x20\x01\
    (\tR\x06status\x12K\n\x0elastUpdateTime\x18\x06\x20\x01(\x0b2#.apimachin\
    ery.pkg.apis.meta.v1.TimeR\x0elastUpdateTime\x12S\n\x12lastTransitionTim\
    e\x18\x07\x20\x01(\x0b2#.apimachinery.pkg.apis.meta.v1.TimeR\x12lastTran\
    sitionTime\x12\x16\n\x06reason\x18\x04\x20\x01(\tR\x06reason\x12\x18\n\
    \x07message\x18\x05\x20\x01(\tR\x07message\"\x8f\x01\n\x0eDeploymentList\
    \x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1\
    .ListMetaR\x08metadata\x128\n\x05items\x18\x02\x20\x03(\x0b2\".api.exten\
    sions.v1beta1.DeploymentR\x05items\"\xab\x02\n\x12DeploymentRollback\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12r\n\x12updatedAnnotations\
    \x18\x02\x20\x03(\x0b2B.api.extensions.v1beta1.DeploymentRollback.Update\
    dAnnotationsEntryR\x12updatedAnnotations\x12F\n\nrollbackTo\x18\x03\x20\
    \x01(\x0b2&.api.extensions.v1beta1.RollbackConfigR\nrollbackTo\x1aE\n\
    \x17UpdatedAnnotationsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xf0\x03\n\
    \x0eDeploymentSpec\x12\x1a\n\x08replicas\x18\x01\x20\x01(\x05R\x08replic\
    as\x12H\n\x08selector\x18\x02\x20\x01(\x0b2,.apimachinery.pkg.apis.meta.\
    v1.LabelSelectorR\x08selector\x128\n\x08template\x18\x03\x20\x01(\x0b2\
    \x1c.api.core.v1.PodTemplateSpecR\x08template\x12F\n\x08strategy\x18\x04\
    \x20\x01(\x0b2*.api.extensions.v1beta1.DeploymentStrategyR\x08strategy\
    \x12(\n\x0fminReadySeconds\x18\x05\x20\x01(\x05R\x0fminReadySeconds\x122\
    \n\x14revisionHistoryLimit\x18\x06\x20\x01(\x05R\x14revisionHistoryLimit\
    \x12\x16\n\x06paused\x18\x07\x20\x01(\x08R\x06paused\x12F\n\nrollbackTo\
    \x18\x08\x20\x01(\x0b2&.api.extensions.v1beta1.RollbackConfigR\nrollback\
    To\x128\n\x17progressDeadlineSeconds\x18\t\x20\x01(\x05R\x17progressDead\
    lineSeconds\"\x83\x03\n\x10DeploymentStatus\x12.\n\x12observedGeneration\
    \x18\x01\x20\x01(\x03R\x12observedGeneration\x12\x1a\n\x08replicas\x18\
    \x02\x20\x01(\x05R\x08replicas\x12(\n\x0fupdatedReplicas\x18\x03\x20\x01\
    (\x05R\x0fupdatedReplicas\x12$\n\rreadyReplicas\x18\x07\x20\x01(\x05R\rr\
    eadyReplicas\x12,\n\x11availableReplicas\x18\x04\x20\x01(\x05R\x11availa\
    bleReplicas\x120\n\x13unavailableReplicas\x18\x05\x20\x01(\x05R\x13unava\
    ilableReplicas\x12K\n\nconditions\x18\x06\x20\x03(\x0b2+.api.extensions.\
    v1beta1.DeploymentConditionR\nconditions\x12&\n\x0ecollisionCount\x18\
    \x08\x20\x01(\x05R\x0ecollisionCount\"\x7f\n\x12DeploymentStrategy\x12\
    \x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12U\n\rrollingUpdate\x18\x02\
    \x20\x01(\x0b2/.api.extensions.v1beta1.RollingUpdateDeploymentR\rrolling\
    Update\"\x83\x01\n\x0fHTTPIngressPath\x12\x12\n\x04path\x18\x01\x20\x01(\
    \tR\x04path\x12\x1a\n\x08pathType\x18\x03\x20\x01(\tR\x08pathType\x12@\n\
    \x07backend\x18\x02\x20\x01(\x0b2&.api.extensions.v1beta1.IngressBackend\
    R\x07backend\"U\n\x14HTTPIngressRuleValue\x12=\n\x05paths\x18\x01\x20\
    \x03(\x0b2'.api.extensions.v1beta1.HTTPIngressPathR\x05paths\"5\n\x07IPB\
    lock\x12\x12\n\x04cidr\x18\x01\x20\x01(\tR\x04cidr\x12\x16\n\x06except\
    \x18\x02\x20\x03(\tR\x06except\"\xc8\x01\n\x07Ingress\x12E\n\x08metadata\
    \x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08met\
    adata\x127\n\x04spec\x18\x02\x20\x01(\x0b2#.api.extensions.v1beta1.Ingre\
    ssSpecR\x04spec\x12=\n\x06status\x18\x03\x20\x01(\x0b2%.api.extensions.v\
    1beta1.IngressStatusR\x06status\"\xc3\x01\n\x0eIngressBackend\x12\x20\n\
    \x0bserviceName\x18\x01\x20\x01(\tR\x0bserviceName\x12K\n\x0bservicePort\
    \x18\x02\x20\x01(\x0b2).apimachinery.pkg.util.intstr.IntOrStringR\x0bser\
    vicePort\x12B\n\x08resource\x18\x03\x20\x01(\x0b2&.api.core.v1.TypedLoca\
    lObjectReferenceR\x08resource\"\x89\x01\n\x0bIngressList\x12C\n\x08metad\
    ata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMetaR\x08me\
    tadata\x125\n\x05items\x18\x02\x20\x03(\x0b2\x1f.api.extensions.v1beta1.\
    IngressR\x05items\"\x89\x01\n\x1aIngressLoadBalancerIngress\x12\x0e\n\
    \x02ip\x18\x01\x20\x01(\tR\x02ip\x12\x1a\n\x08hostname\x18\x02\x20\x01(\
    \tR\x08hostname\x12?\n\x05ports\x18\x04\x20\x03(\x0b2).api.extensions.v1\
    beta1.IngressPortStatusR\x05ports\"i\n\x19IngressLoadBalancerStatus\x12L\
    \n\x07ingress\x18\x01\x20\x03(\x0b22.api.extensions.v1beta1.IngressLoadB\
    alancerIngressR\x07ingress\"Y\n\x11IngressPortStatus\x12\x12\n\x04port\
    \x18\x01\x20\x01(\x05R\x04port\x12\x1a\n\x08protocol\x18\x02\x20\x01(\tR\
    \x08protocol\x12\x14\n\x05error\x18\x03\x20\x01(\tR\x05error\"w\n\x0bIng\
    ressRule\x12\x12\n\x04host\x18\x01\x20\x01(\tR\x04host\x12T\n\x10ingress\
    RuleValue\x18\x02\x20\x01(\x0b2(.api.extensions.v1beta1.IngressRuleValue\
    R\x10ingressRuleValue\"T\n\x10IngressRuleValue\x12@\n\x04http\x18\x01\
    \x20\x01(\x0b2,.api.extensions.v1beta1.HTTPIngressRuleValueR\x04http\"\
    \xec\x01\n\x0bIngressSpec\x12*\n\x10ingressClassName\x18\x04\x20\x01(\tR\
    \x10ingressClassName\x12@\n\x07backend\x18\x01\x20\x01(\x0b2&.api.extens\
    ions.v1beta1.IngressBackendR\x07backend\x124\n\x03tls\x18\x02\x20\x03(\
    \x0b2\".api.extensions.v1beta1.IngressTLSR\x03tls\x129\n\x05rules\x18\
    \x03\x20\x03(\x0b2#.api.extensions.v1beta1.IngressRuleR\x05rules\"f\n\rI\
    ngressStatus\x12U\n\x0cloadBalancer\x18\x01\x20\x01(\x0b21.api.extension\
    s.v1beta1.IngressLoadBalancerStatusR\x0cloadBalancer\"B\n\nIngressTLS\
    \x12\x14\n\x05hosts\x18\x01\x20\x03(\tR\x05hosts\x12\x1e\n\nsecretName\
    \x18\x02\x20\x01(\tR\nsecretName\"\x95\x01\n\rNetworkPolicy\x12E\n\x08me\
    tadata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\
    \x08metadata\x12=\n\x04spec\x18\x02\x20\x01(\x0b2).api.extensions.v1beta\
    1.NetworkPolicySpecR\x04spec\"\x95\x01\n\x17NetworkPolicyEgressRule\x12?\
    \n\x05ports\x18\x01\x20\x03(\x0b2).api.extensions.v1beta1.NetworkPolicyP\
    ortR\x05ports\x129\n\x02to\x18\x02\x20\x03(\x0b2).api.extensions.v1beta1\
    .NetworkPolicyPeerR\x02to\"\x9a\x01\n\x18NetworkPolicyIngressRule\x12?\n\
    \x05ports\x18\x01\x20\x03(\x0b2).api.extensions.v1beta1.NetworkPolicyPor\
    tR\x05ports\x12=\n\x04from\x18\x02\x20\x03(\x0b2).api.extensions.v1beta1\
    .NetworkPolicyPeerR\x04from\"\x95\x01\n\x11NetworkPolicyList\x12C\n\x08m\
    etadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMetaR\
    \x08metadata\x12;\n\x05items\x18\x02\x20\x03(\x0b2%.api.extensions.v1bet\
    a1.NetworkPolicyR\x05items\"\xfa\x01\n\x11NetworkPolicyPeer\x12N\n\x0bpo\
    dSelector\x18\x01\x20\x01(\x0b2,.apimachinery.pkg.apis.meta.v1.LabelSele\
    ctorR\x0bpodSelector\x12Z\n\x11namespaceSelector\x18\x02\x20\x01(\x0b2,.\
    apimachinery.pkg.apis.meta.v1.LabelSelectorR\x11namespaceSelector\x129\n\
    \x07ipBlock\x18\x03\x20\x01(\x0b2\x1f.api.extensions.v1beta1.IPBlockR\
    \x07ipBlock\"\x88\x01\n\x11NetworkPolicyPort\x12\x1a\n\x08protocol\x18\
    \x01\x20\x01(\tR\x08protocol\x12=\n\x04port\x18\x02\x20\x01(\x0b2).apima\
    chinery.pkg.util.intstr.IntOrStringR\x04port\x12\x18\n\x07endPort\x18\
    \x03\x20\x01(\x05R\x07endPort\"\x9a\x02\n\x11NetworkPolicySpec\x12N\n\
    \x0bpodSelector\x18\x01\x20\x01(\x0b2,.apimachinery.pkg.apis.meta.v1.Lab\
    elSelectorR\x0bpodSelector\x12J\n\x07ingress\x18\x02\x20\x03(\x0b20.api.\
    extensions.v1beta1.NetworkPolicyIngressRuleR\x07ingress\x12G\n\x06egress\
    \x18\x03\x20\x03(\x0b2/.api.extensions.v1beta1.NetworkPolicyEgressRuleR\
    \x06egress\x12\x20\n\x0bpolicyTypes\x18\x04\x20\x03(\tR\x0bpolicyTypes\"\
    \xd1\x01\n\nReplicaSet\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimach\
    inery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12:\n\x04spec\x18\x02\
    \x20\x01(\x0b2&.api.extensions.v1beta1.ReplicaSetSpecR\x04spec\x12@\n\
    \x06status\x18\x03\x20\x01(\x0b2(.api.extensions.v1beta1.ReplicaSetStatu\
    sR\x06status\"\xc8\x01\n\x13ReplicaSetCondition\x12\x12\n\x04type\x18\
    \x01\x20\x01(\tR\x04type\x12\x16\n\x06status\x18\x02\x20\x01(\tR\x06stat\
    us\x12S\n\x12lastTransitionTime\x18\x03\x20\x01(\x0b2#.apimachinery.pkg.\
    apis.meta.v1.TimeR\x12lastTransitionTime\x12\x16\n\x06reason\x18\x04\x20\
    \x01(\tR\x06reason\x12\x18\n\x07message\x18\x05\x20\x01(\tR\x07message\"\
    \x8f\x01\n\x0eReplicaSetList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.a\
    pimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x128\n\x05items\x18\
    \x02\x20\x03(\x0b2\".api.extensions.v1beta1.ReplicaSetR\x05items\"\xda\
    \x01\n\x0eReplicaSetSpec\x12\x1a\n\x08replicas\x18\x01\x20\x01(\x05R\x08\
    replicas\x12(\n\x0fminReadySeconds\x18\x04\x20\x01(\x05R\x0fminReadySeco\
    nds\x12H\n\x08selector\x18\x02\x20\x01(\x0b2,.apimachinery.pkg.apis.meta\
    .v1.LabelSelectorR\x08selector\x128\n\x08template\x18\x03\x20\x01(\x0b2\
    \x1c.api.core.v1.PodTemplateSpecR\x08template\"\xb3\x02\n\x10ReplicaSetS\
    tatus\x12\x1a\n\x08replicas\x18\x01\x20\x01(\x05R\x08replicas\x122\n\x14\
    fullyLabeledReplicas\x18\x02\x20\x01(\x05R\x14fullyLabeledReplicas\x12$\
    \n\rreadyReplicas\x18\x04\x20\x01(\x05R\rreadyReplicas\x12,\n\x11availab\
    leReplicas\x18\x05\x20\x01(\x05R\x11availableReplicas\x12.\n\x12observed\
    Generation\x18\x03\x20\x01(\x03R\x12observedGeneration\x12K\n\ncondition\
    s\x18\x06\x20\x03(\x0b2+.api.extensions.v1beta1.ReplicaSetConditionR\nco\
    nditions\",\n\x0eRollbackConfig\x12\x1a\n\x08revision\x18\x01\x20\x01(\
    \x03R\x08revision\"\xb2\x01\n\x16RollingUpdateDaemonSet\x12Q\n\x0emaxUna\
    vailable\x18\x01\x20\x01(\x0b2).apimachinery.pkg.util.intstr.IntOrString\
    R\x0emaxUnavailable\x12E\n\x08maxSurge\x18\x02\x20\x01(\x0b2).apimachine\
    ry.pkg.util.intstr.IntOrStringR\x08maxSurge\"\xb3\x01\n\x17RollingUpdate\
    Deployment\x12Q\n\x0emaxUnavailable\x18\x01\x20\x01(\x0b2).apimachinery.\
    pkg.util.intstr.IntOrStringR\x0emaxUnavailable\x12E\n\x08maxSurge\x18\
    \x02\x20\x01(\x0b2).apimachinery.pkg.util.intstr.IntOrStringR\x08maxSurg\
    e\"\xc2\x01\n\x05Scale\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimach\
    inery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x125\n\x04spec\x18\x02\
    \x20\x01(\x0b2!.api.extensions.v1beta1.ScaleSpecR\x04spec\x12;\n\x06stat\
    us\x18\x03\x20\x01(\x0b2#.api.extensions.v1beta1.ScaleStatusR\x06status\
    \"'\n\tScaleSpec\x12\x1a\n\x08replicas\x18\x01\x20\x01(\x05R\x08replicas\
    \"\xdd\x01\n\x0bScaleStatus\x12\x1a\n\x08replicas\x18\x01\x20\x01(\x05R\
    \x08replicas\x12M\n\x08selector\x18\x02\x20\x03(\x0b21.api.extensions.v1\
    beta1.ScaleStatus.SelectorEntryR\x08selector\x12&\n\x0etargetSelector\
    \x18\x03\x20\x01(\tR\x0etargetSelector\x1a;\n\rSelectorEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01B\x1fZ\x1dk8s.io/api/extensions/v1beta1\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(5);
            deps.push(super::v1beta1::file_descriptor().clone());
            deps.push(super::v1beta1::file_descriptor().clone());
            deps.push(super::v1beta1::file_descriptor().clone());
            deps.push(super::v1beta1::file_descriptor().clone());
            deps.push(super::v1beta1::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(45);
            messages.push(DaemonSet::generated_message_descriptor_data());
            messages.push(DaemonSetCondition::generated_message_descriptor_data());
            messages.push(DaemonSetList::generated_message_descriptor_data());
            messages.push(DaemonSetSpec::generated_message_descriptor_data());
            messages.push(DaemonSetStatus::generated_message_descriptor_data());
            messages.push(DaemonSetUpdateStrategy::generated_message_descriptor_data());
            messages.push(Deployment::generated_message_descriptor_data());
            messages.push(DeploymentCondition::generated_message_descriptor_data());
            messages.push(DeploymentList::generated_message_descriptor_data());
            messages.push(DeploymentRollback::generated_message_descriptor_data());
            messages.push(DeploymentSpec::generated_message_descriptor_data());
            messages.push(DeploymentStatus::generated_message_descriptor_data());
            messages.push(DeploymentStrategy::generated_message_descriptor_data());
            messages.push(HTTPIngressPath::generated_message_descriptor_data());
            messages.push(HTTPIngressRuleValue::generated_message_descriptor_data());
            messages.push(IPBlock::generated_message_descriptor_data());
            messages.push(Ingress::generated_message_descriptor_data());
            messages.push(IngressBackend::generated_message_descriptor_data());
            messages.push(IngressList::generated_message_descriptor_data());
            messages.push(IngressLoadBalancerIngress::generated_message_descriptor_data());
            messages.push(IngressLoadBalancerStatus::generated_message_descriptor_data());
            messages.push(IngressPortStatus::generated_message_descriptor_data());
            messages.push(IngressRule::generated_message_descriptor_data());
            messages.push(IngressRuleValue::generated_message_descriptor_data());
            messages.push(IngressSpec::generated_message_descriptor_data());
            messages.push(IngressStatus::generated_message_descriptor_data());
            messages.push(IngressTLS::generated_message_descriptor_data());
            messages.push(NetworkPolicy::generated_message_descriptor_data());
            messages.push(NetworkPolicyEgressRule::generated_message_descriptor_data());
            messages.push(NetworkPolicyIngressRule::generated_message_descriptor_data());
            messages.push(NetworkPolicyList::generated_message_descriptor_data());
            messages.push(NetworkPolicyPeer::generated_message_descriptor_data());
            messages.push(NetworkPolicyPort::generated_message_descriptor_data());
            messages.push(NetworkPolicySpec::generated_message_descriptor_data());
            messages.push(ReplicaSet::generated_message_descriptor_data());
            messages.push(ReplicaSetCondition::generated_message_descriptor_data());
            messages.push(ReplicaSetList::generated_message_descriptor_data());
            messages.push(ReplicaSetSpec::generated_message_descriptor_data());
            messages.push(ReplicaSetStatus::generated_message_descriptor_data());
            messages.push(RollbackConfig::generated_message_descriptor_data());
            messages.push(RollingUpdateDaemonSet::generated_message_descriptor_data());
            messages.push(RollingUpdateDeployment::generated_message_descriptor_data());
            messages.push(Scale::generated_message_descriptor_data());
            messages.push(ScaleSpec::generated_message_descriptor_data());
            messages.push(ScaleStatus::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
