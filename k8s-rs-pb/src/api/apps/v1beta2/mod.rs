// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc 3.21.12
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `api/apps/v1beta2/generated.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.ControllerRevision)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ControllerRevision {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.ControllerRevision.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.ControllerRevision.data)
    pub data: ::protobuf::MessageField<crate::apimachinery::pkg::runtime::RawExtension>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.ControllerRevision.revision)
    pub revision: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.ControllerRevision.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ControllerRevision {
    fn default() -> &'a ControllerRevision {
        <ControllerRevision as ::protobuf::Message>::default_instance()
    }
}

impl ControllerRevision {
    pub fn new() -> ControllerRevision {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .apimachinery.pkg.runtime.RawExtension data = 2;

    pub fn data(&self) -> &crate::apimachinery::pkg::runtime::RawExtension {
        self.data.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::runtime::RawExtension as ::protobuf::Message>::default_instance())
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: crate::apimachinery::pkg::runtime::RawExtension) {
        self.data = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut crate::apimachinery::pkg::runtime::RawExtension {
        self.data.mut_or_insert_default()
    }

    // Take field
    pub fn take_data(&mut self) -> crate::apimachinery::pkg::runtime::RawExtension {
        self.data.take().unwrap_or_else(|| crate::apimachinery::pkg::runtime::RawExtension::new())
    }

    // optional int64 revision = 3;

    pub fn revision(&self) -> i64 {
        self.revision.unwrap_or(0)
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: i64) {
        self.revision = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ControllerRevision| { &m.metadata },
            |m: &mut ControllerRevision| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::runtime::RawExtension>(
            "data",
            |m: &ControllerRevision| { &m.data },
            |m: &mut ControllerRevision| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revision",
            |m: &ControllerRevision| { &m.revision },
            |m: &mut ControllerRevision| { &mut m.revision },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ControllerRevision>(
            "ControllerRevision",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ControllerRevision {
    const NAME: &'static str = "ControllerRevision";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                24 => {
                    self.revision = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.revision {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.revision {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ControllerRevision {
        ControllerRevision::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.data.clear();
        self.revision = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ControllerRevision {
        static instance: ControllerRevision = ControllerRevision {
            metadata: ::protobuf::MessageField::none(),
            data: ::protobuf::MessageField::none(),
            revision: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ControllerRevision {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ControllerRevision").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ControllerRevision {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControllerRevision {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.ControllerRevisionList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ControllerRevisionList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.ControllerRevisionList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.ControllerRevisionList.items)
    pub items: ::std::vec::Vec<ControllerRevision>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.ControllerRevisionList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ControllerRevisionList {
    fn default() -> &'a ControllerRevisionList {
        <ControllerRevisionList as ::protobuf::Message>::default_instance()
    }
}

impl ControllerRevisionList {
    pub fn new() -> ControllerRevisionList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.apps.v1beta2.ControllerRevision items = 2;

    pub fn items(&self) -> &[ControllerRevision] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ControllerRevision>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ControllerRevision> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ControllerRevision> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ControllerRevisionList| { &m.metadata },
            |m: &mut ControllerRevisionList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ControllerRevisionList| { &m.items },
            |m: &mut ControllerRevisionList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ControllerRevisionList>(
            "ControllerRevisionList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ControllerRevisionList {
    const NAME: &'static str = "ControllerRevisionList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ControllerRevisionList {
        ControllerRevisionList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ControllerRevisionList {
        static instance: ControllerRevisionList = ControllerRevisionList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ControllerRevisionList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ControllerRevisionList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ControllerRevisionList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControllerRevisionList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.DaemonSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DaemonSet {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSet.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSet.spec)
    pub spec: ::protobuf::MessageField<DaemonSetSpec>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSet.status)
    pub status: ::protobuf::MessageField<DaemonSetStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.DaemonSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DaemonSet {
    fn default() -> &'a DaemonSet {
        <DaemonSet as ::protobuf::Message>::default_instance()
    }
}

impl DaemonSet {
    pub fn new() -> DaemonSet {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.apps.v1beta2.DaemonSetSpec spec = 2;

    pub fn spec(&self) -> &DaemonSetSpec {
        self.spec.as_ref().unwrap_or_else(|| <DaemonSetSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: DaemonSetSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut DaemonSetSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> DaemonSetSpec {
        self.spec.take().unwrap_or_else(|| DaemonSetSpec::new())
    }

    // optional .api.apps.v1beta2.DaemonSetStatus status = 3;

    pub fn status(&self) -> &DaemonSetStatus {
        self.status.as_ref().unwrap_or_else(|| <DaemonSetStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: DaemonSetStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut DaemonSetStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> DaemonSetStatus {
        self.status.take().unwrap_or_else(|| DaemonSetStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &DaemonSet| { &m.metadata },
            |m: &mut DaemonSet| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DaemonSetSpec>(
            "spec",
            |m: &DaemonSet| { &m.spec },
            |m: &mut DaemonSet| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DaemonSetStatus>(
            "status",
            |m: &DaemonSet| { &m.status },
            |m: &mut DaemonSet| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DaemonSet>(
            "DaemonSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DaemonSet {
    const NAME: &'static str = "DaemonSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DaemonSet {
        DaemonSet::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DaemonSet {
        static instance: DaemonSet = DaemonSet {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DaemonSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DaemonSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DaemonSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaemonSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.DaemonSetCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DaemonSetCondition {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSetCondition.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSetCondition.status)
    pub status: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSetCondition.lastTransitionTime)
    pub lastTransitionTime: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSetCondition.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSetCondition.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.DaemonSetCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DaemonSetCondition {
    fn default() -> &'a DaemonSetCondition {
        <DaemonSetCondition as ::protobuf::Message>::default_instance()
    }
}

impl DaemonSetCondition {
    pub fn new() -> DaemonSetCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

    pub fn lastTransitionTime(&self) -> &crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastTransitionTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional string reason = 4;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 5;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &DaemonSetCondition| { &m.type_ },
            |m: &mut DaemonSetCondition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &DaemonSetCondition| { &m.status },
            |m: &mut DaemonSetCondition| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::Time>(
            "lastTransitionTime",
            |m: &DaemonSetCondition| { &m.lastTransitionTime },
            |m: &mut DaemonSetCondition| { &mut m.lastTransitionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &DaemonSetCondition| { &m.reason },
            |m: &mut DaemonSetCondition| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &DaemonSetCondition| { &m.message },
            |m: &mut DaemonSetCondition| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DaemonSetCondition>(
            "DaemonSetCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DaemonSetCondition {
    const NAME: &'static str = "DaemonSetCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTransitionTime)?;
                },
                34 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DaemonSetCondition {
        DaemonSetCondition::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.lastTransitionTime.clear();
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DaemonSetCondition {
        static instance: DaemonSetCondition = DaemonSetCondition {
            type_: ::std::option::Option::None,
            status: ::std::option::Option::None,
            lastTransitionTime: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DaemonSetCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DaemonSetCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DaemonSetCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaemonSetCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.DaemonSetList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DaemonSetList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSetList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSetList.items)
    pub items: ::std::vec::Vec<DaemonSet>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.DaemonSetList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DaemonSetList {
    fn default() -> &'a DaemonSetList {
        <DaemonSetList as ::protobuf::Message>::default_instance()
    }
}

impl DaemonSetList {
    pub fn new() -> DaemonSetList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.apps.v1beta2.DaemonSet items = 2;

    pub fn items(&self) -> &[DaemonSet] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<DaemonSet>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<DaemonSet> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<DaemonSet> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &DaemonSetList| { &m.metadata },
            |m: &mut DaemonSetList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &DaemonSetList| { &m.items },
            |m: &mut DaemonSetList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DaemonSetList>(
            "DaemonSetList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DaemonSetList {
    const NAME: &'static str = "DaemonSetList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DaemonSetList {
        DaemonSetList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DaemonSetList {
        static instance: DaemonSetList = DaemonSetList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DaemonSetList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DaemonSetList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DaemonSetList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaemonSetList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.DaemonSetSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DaemonSetSpec {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSetSpec.selector)
    pub selector: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSetSpec.template)
    pub template: ::protobuf::MessageField<crate::api::core::v1::PodTemplateSpec>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSetSpec.updateStrategy)
    pub updateStrategy: ::protobuf::MessageField<DaemonSetUpdateStrategy>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSetSpec.minReadySeconds)
    pub minReadySeconds: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSetSpec.revisionHistoryLimit)
    pub revisionHistoryLimit: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.DaemonSetSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DaemonSetSpec {
    fn default() -> &'a DaemonSetSpec {
        <DaemonSetSpec as ::protobuf::Message>::default_instance()
    }
}

impl DaemonSetSpec {
    pub fn new() -> DaemonSetSpec {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;

    pub fn selector(&self) -> &crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    pub fn has_selector(&self) -> bool {
        self.selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.selector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selector(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.mut_or_insert_default()
    }

    // Take field
    pub fn take_selector(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional .api.core.v1.PodTemplateSpec template = 2;

    pub fn template(&self) -> &crate::api::core::v1::PodTemplateSpec {
        self.template.as_ref().unwrap_or_else(|| <crate::api::core::v1::PodTemplateSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_template(&mut self) {
        self.template.clear();
    }

    pub fn has_template(&self) -> bool {
        self.template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template(&mut self, v: crate::api::core::v1::PodTemplateSpec) {
        self.template = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template(&mut self) -> &mut crate::api::core::v1::PodTemplateSpec {
        self.template.mut_or_insert_default()
    }

    // Take field
    pub fn take_template(&mut self) -> crate::api::core::v1::PodTemplateSpec {
        self.template.take().unwrap_or_else(|| crate::api::core::v1::PodTemplateSpec::new())
    }

    // optional .api.apps.v1beta2.DaemonSetUpdateStrategy updateStrategy = 3;

    pub fn updateStrategy(&self) -> &DaemonSetUpdateStrategy {
        self.updateStrategy.as_ref().unwrap_or_else(|| <DaemonSetUpdateStrategy as ::protobuf::Message>::default_instance())
    }

    pub fn clear_updateStrategy(&mut self) {
        self.updateStrategy.clear();
    }

    pub fn has_updateStrategy(&self) -> bool {
        self.updateStrategy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updateStrategy(&mut self, v: DaemonSetUpdateStrategy) {
        self.updateStrategy = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updateStrategy(&mut self) -> &mut DaemonSetUpdateStrategy {
        self.updateStrategy.mut_or_insert_default()
    }

    // Take field
    pub fn take_updateStrategy(&mut self) -> DaemonSetUpdateStrategy {
        self.updateStrategy.take().unwrap_or_else(|| DaemonSetUpdateStrategy::new())
    }

    // optional int32 minReadySeconds = 4;

    pub fn minReadySeconds(&self) -> i32 {
        self.minReadySeconds.unwrap_or(0)
    }

    pub fn clear_minReadySeconds(&mut self) {
        self.minReadySeconds = ::std::option::Option::None;
    }

    pub fn has_minReadySeconds(&self) -> bool {
        self.minReadySeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minReadySeconds(&mut self, v: i32) {
        self.minReadySeconds = ::std::option::Option::Some(v);
    }

    // optional int32 revisionHistoryLimit = 6;

    pub fn revisionHistoryLimit(&self) -> i32 {
        self.revisionHistoryLimit.unwrap_or(0)
    }

    pub fn clear_revisionHistoryLimit(&mut self) {
        self.revisionHistoryLimit = ::std::option::Option::None;
    }

    pub fn has_revisionHistoryLimit(&self) -> bool {
        self.revisionHistoryLimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revisionHistoryLimit(&mut self, v: i32) {
        self.revisionHistoryLimit = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "selector",
            |m: &DaemonSetSpec| { &m.selector },
            |m: &mut DaemonSetSpec| { &mut m.selector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::api::core::v1::PodTemplateSpec>(
            "template",
            |m: &DaemonSetSpec| { &m.template },
            |m: &mut DaemonSetSpec| { &mut m.template },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DaemonSetUpdateStrategy>(
            "updateStrategy",
            |m: &DaemonSetSpec| { &m.updateStrategy },
            |m: &mut DaemonSetSpec| { &mut m.updateStrategy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minReadySeconds",
            |m: &DaemonSetSpec| { &m.minReadySeconds },
            |m: &mut DaemonSetSpec| { &mut m.minReadySeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revisionHistoryLimit",
            |m: &DaemonSetSpec| { &m.revisionHistoryLimit },
            |m: &mut DaemonSetSpec| { &mut m.revisionHistoryLimit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DaemonSetSpec>(
            "DaemonSetSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DaemonSetSpec {
    const NAME: &'static str = "DaemonSetSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.selector)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.template)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.updateStrategy)?;
                },
                32 => {
                    self.minReadySeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.revisionHistoryLimit = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.updateStrategy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.minReadySeconds {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.revisionHistoryLimit {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.selector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.template.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.updateStrategy.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.minReadySeconds {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.revisionHistoryLimit {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DaemonSetSpec {
        DaemonSetSpec::new()
    }

    fn clear(&mut self) {
        self.selector.clear();
        self.template.clear();
        self.updateStrategy.clear();
        self.minReadySeconds = ::std::option::Option::None;
        self.revisionHistoryLimit = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DaemonSetSpec {
        static instance: DaemonSetSpec = DaemonSetSpec {
            selector: ::protobuf::MessageField::none(),
            template: ::protobuf::MessageField::none(),
            updateStrategy: ::protobuf::MessageField::none(),
            minReadySeconds: ::std::option::Option::None,
            revisionHistoryLimit: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DaemonSetSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DaemonSetSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DaemonSetSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaemonSetSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.DaemonSetStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DaemonSetStatus {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSetStatus.currentNumberScheduled)
    pub currentNumberScheduled: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSetStatus.numberMisscheduled)
    pub numberMisscheduled: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSetStatus.desiredNumberScheduled)
    pub desiredNumberScheduled: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSetStatus.numberReady)
    pub numberReady: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSetStatus.observedGeneration)
    pub observedGeneration: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSetStatus.updatedNumberScheduled)
    pub updatedNumberScheduled: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSetStatus.numberAvailable)
    pub numberAvailable: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSetStatus.numberUnavailable)
    pub numberUnavailable: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSetStatus.collisionCount)
    pub collisionCount: ::std::option::Option<i32>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSetStatus.conditions)
    pub conditions: ::std::vec::Vec<DaemonSetCondition>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.DaemonSetStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DaemonSetStatus {
    fn default() -> &'a DaemonSetStatus {
        <DaemonSetStatus as ::protobuf::Message>::default_instance()
    }
}

impl DaemonSetStatus {
    pub fn new() -> DaemonSetStatus {
        ::std::default::Default::default()
    }

    // optional int32 currentNumberScheduled = 1;

    pub fn currentNumberScheduled(&self) -> i32 {
        self.currentNumberScheduled.unwrap_or(0)
    }

    pub fn clear_currentNumberScheduled(&mut self) {
        self.currentNumberScheduled = ::std::option::Option::None;
    }

    pub fn has_currentNumberScheduled(&self) -> bool {
        self.currentNumberScheduled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currentNumberScheduled(&mut self, v: i32) {
        self.currentNumberScheduled = ::std::option::Option::Some(v);
    }

    // optional int32 numberMisscheduled = 2;

    pub fn numberMisscheduled(&self) -> i32 {
        self.numberMisscheduled.unwrap_or(0)
    }

    pub fn clear_numberMisscheduled(&mut self) {
        self.numberMisscheduled = ::std::option::Option::None;
    }

    pub fn has_numberMisscheduled(&self) -> bool {
        self.numberMisscheduled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numberMisscheduled(&mut self, v: i32) {
        self.numberMisscheduled = ::std::option::Option::Some(v);
    }

    // optional int32 desiredNumberScheduled = 3;

    pub fn desiredNumberScheduled(&self) -> i32 {
        self.desiredNumberScheduled.unwrap_or(0)
    }

    pub fn clear_desiredNumberScheduled(&mut self) {
        self.desiredNumberScheduled = ::std::option::Option::None;
    }

    pub fn has_desiredNumberScheduled(&self) -> bool {
        self.desiredNumberScheduled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desiredNumberScheduled(&mut self, v: i32) {
        self.desiredNumberScheduled = ::std::option::Option::Some(v);
    }

    // optional int32 numberReady = 4;

    pub fn numberReady(&self) -> i32 {
        self.numberReady.unwrap_or(0)
    }

    pub fn clear_numberReady(&mut self) {
        self.numberReady = ::std::option::Option::None;
    }

    pub fn has_numberReady(&self) -> bool {
        self.numberReady.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numberReady(&mut self, v: i32) {
        self.numberReady = ::std::option::Option::Some(v);
    }

    // optional int64 observedGeneration = 5;

    pub fn observedGeneration(&self) -> i64 {
        self.observedGeneration.unwrap_or(0)
    }

    pub fn clear_observedGeneration(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
    }

    pub fn has_observedGeneration(&self) -> bool {
        self.observedGeneration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observedGeneration(&mut self, v: i64) {
        self.observedGeneration = ::std::option::Option::Some(v);
    }

    // optional int32 updatedNumberScheduled = 6;

    pub fn updatedNumberScheduled(&self) -> i32 {
        self.updatedNumberScheduled.unwrap_or(0)
    }

    pub fn clear_updatedNumberScheduled(&mut self) {
        self.updatedNumberScheduled = ::std::option::Option::None;
    }

    pub fn has_updatedNumberScheduled(&self) -> bool {
        self.updatedNumberScheduled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updatedNumberScheduled(&mut self, v: i32) {
        self.updatedNumberScheduled = ::std::option::Option::Some(v);
    }

    // optional int32 numberAvailable = 7;

    pub fn numberAvailable(&self) -> i32 {
        self.numberAvailable.unwrap_or(0)
    }

    pub fn clear_numberAvailable(&mut self) {
        self.numberAvailable = ::std::option::Option::None;
    }

    pub fn has_numberAvailable(&self) -> bool {
        self.numberAvailable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numberAvailable(&mut self, v: i32) {
        self.numberAvailable = ::std::option::Option::Some(v);
    }

    // optional int32 numberUnavailable = 8;

    pub fn numberUnavailable(&self) -> i32 {
        self.numberUnavailable.unwrap_or(0)
    }

    pub fn clear_numberUnavailable(&mut self) {
        self.numberUnavailable = ::std::option::Option::None;
    }

    pub fn has_numberUnavailable(&self) -> bool {
        self.numberUnavailable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numberUnavailable(&mut self, v: i32) {
        self.numberUnavailable = ::std::option::Option::Some(v);
    }

    // optional int32 collisionCount = 9;

    pub fn collisionCount(&self) -> i32 {
        self.collisionCount.unwrap_or(0)
    }

    pub fn clear_collisionCount(&mut self) {
        self.collisionCount = ::std::option::Option::None;
    }

    pub fn has_collisionCount(&self) -> bool {
        self.collisionCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_collisionCount(&mut self, v: i32) {
        self.collisionCount = ::std::option::Option::Some(v);
    }

    // repeated .api.apps.v1beta2.DaemonSetCondition conditions = 10;

    pub fn conditions(&self) -> &[DaemonSetCondition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<DaemonSetCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<DaemonSetCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<DaemonSetCondition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currentNumberScheduled",
            |m: &DaemonSetStatus| { &m.currentNumberScheduled },
            |m: &mut DaemonSetStatus| { &mut m.currentNumberScheduled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "numberMisscheduled",
            |m: &DaemonSetStatus| { &m.numberMisscheduled },
            |m: &mut DaemonSetStatus| { &mut m.numberMisscheduled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desiredNumberScheduled",
            |m: &DaemonSetStatus| { &m.desiredNumberScheduled },
            |m: &mut DaemonSetStatus| { &mut m.desiredNumberScheduled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "numberReady",
            |m: &DaemonSetStatus| { &m.numberReady },
            |m: &mut DaemonSetStatus| { &mut m.numberReady },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "observedGeneration",
            |m: &DaemonSetStatus| { &m.observedGeneration },
            |m: &mut DaemonSetStatus| { &mut m.observedGeneration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "updatedNumberScheduled",
            |m: &DaemonSetStatus| { &m.updatedNumberScheduled },
            |m: &mut DaemonSetStatus| { &mut m.updatedNumberScheduled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "numberAvailable",
            |m: &DaemonSetStatus| { &m.numberAvailable },
            |m: &mut DaemonSetStatus| { &mut m.numberAvailable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "numberUnavailable",
            |m: &DaemonSetStatus| { &m.numberUnavailable },
            |m: &mut DaemonSetStatus| { &mut m.numberUnavailable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "collisionCount",
            |m: &DaemonSetStatus| { &m.collisionCount },
            |m: &mut DaemonSetStatus| { &mut m.collisionCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &DaemonSetStatus| { &m.conditions },
            |m: &mut DaemonSetStatus| { &mut m.conditions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DaemonSetStatus>(
            "DaemonSetStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DaemonSetStatus {
    const NAME: &'static str = "DaemonSetStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.currentNumberScheduled = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.numberMisscheduled = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.desiredNumberScheduled = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.numberReady = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.observedGeneration = ::std::option::Option::Some(is.read_int64()?);
                },
                48 => {
                    self.updatedNumberScheduled = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.numberAvailable = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.numberUnavailable = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.collisionCount = ::std::option::Option::Some(is.read_int32()?);
                },
                82 => {
                    self.conditions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.currentNumberScheduled {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.numberMisscheduled {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.desiredNumberScheduled {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.numberReady {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.observedGeneration {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.updatedNumberScheduled {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.numberAvailable {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.numberUnavailable {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.collisionCount {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.currentNumberScheduled {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.numberMisscheduled {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.desiredNumberScheduled {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.numberReady {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.observedGeneration {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.updatedNumberScheduled {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.numberAvailable {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.numberUnavailable {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.collisionCount {
            os.write_int32(9, v)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DaemonSetStatus {
        DaemonSetStatus::new()
    }

    fn clear(&mut self) {
        self.currentNumberScheduled = ::std::option::Option::None;
        self.numberMisscheduled = ::std::option::Option::None;
        self.desiredNumberScheduled = ::std::option::Option::None;
        self.numberReady = ::std::option::Option::None;
        self.observedGeneration = ::std::option::Option::None;
        self.updatedNumberScheduled = ::std::option::Option::None;
        self.numberAvailable = ::std::option::Option::None;
        self.numberUnavailable = ::std::option::Option::None;
        self.collisionCount = ::std::option::Option::None;
        self.conditions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DaemonSetStatus {
        static instance: DaemonSetStatus = DaemonSetStatus {
            currentNumberScheduled: ::std::option::Option::None,
            numberMisscheduled: ::std::option::Option::None,
            desiredNumberScheduled: ::std::option::Option::None,
            numberReady: ::std::option::Option::None,
            observedGeneration: ::std::option::Option::None,
            updatedNumberScheduled: ::std::option::Option::None,
            numberAvailable: ::std::option::Option::None,
            numberUnavailable: ::std::option::Option::None,
            collisionCount: ::std::option::Option::None,
            conditions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DaemonSetStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DaemonSetStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DaemonSetStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaemonSetStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.DaemonSetUpdateStrategy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DaemonSetUpdateStrategy {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSetUpdateStrategy.type)
    pub type_: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.DaemonSetUpdateStrategy.rollingUpdate)
    pub rollingUpdate: ::protobuf::MessageField<RollingUpdateDaemonSet>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.DaemonSetUpdateStrategy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DaemonSetUpdateStrategy {
    fn default() -> &'a DaemonSetUpdateStrategy {
        <DaemonSetUpdateStrategy as ::protobuf::Message>::default_instance()
    }
}

impl DaemonSetUpdateStrategy {
    pub fn new() -> DaemonSetUpdateStrategy {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.apps.v1beta2.RollingUpdateDaemonSet rollingUpdate = 2;

    pub fn rollingUpdate(&self) -> &RollingUpdateDaemonSet {
        self.rollingUpdate.as_ref().unwrap_or_else(|| <RollingUpdateDaemonSet as ::protobuf::Message>::default_instance())
    }

    pub fn clear_rollingUpdate(&mut self) {
        self.rollingUpdate.clear();
    }

    pub fn has_rollingUpdate(&self) -> bool {
        self.rollingUpdate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollingUpdate(&mut self, v: RollingUpdateDaemonSet) {
        self.rollingUpdate = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollingUpdate(&mut self) -> &mut RollingUpdateDaemonSet {
        self.rollingUpdate.mut_or_insert_default()
    }

    // Take field
    pub fn take_rollingUpdate(&mut self) -> RollingUpdateDaemonSet {
        self.rollingUpdate.take().unwrap_or_else(|| RollingUpdateDaemonSet::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &DaemonSetUpdateStrategy| { &m.type_ },
            |m: &mut DaemonSetUpdateStrategy| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RollingUpdateDaemonSet>(
            "rollingUpdate",
            |m: &DaemonSetUpdateStrategy| { &m.rollingUpdate },
            |m: &mut DaemonSetUpdateStrategy| { &mut m.rollingUpdate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DaemonSetUpdateStrategy>(
            "DaemonSetUpdateStrategy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DaemonSetUpdateStrategy {
    const NAME: &'static str = "DaemonSetUpdateStrategy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rollingUpdate)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.rollingUpdate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.rollingUpdate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DaemonSetUpdateStrategy {
        DaemonSetUpdateStrategy::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.rollingUpdate.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DaemonSetUpdateStrategy {
        static instance: DaemonSetUpdateStrategy = DaemonSetUpdateStrategy {
            type_: ::std::option::Option::None,
            rollingUpdate: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DaemonSetUpdateStrategy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DaemonSetUpdateStrategy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DaemonSetUpdateStrategy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaemonSetUpdateStrategy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.Deployment)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Deployment {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.Deployment.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.Deployment.spec)
    pub spec: ::protobuf::MessageField<DeploymentSpec>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.Deployment.status)
    pub status: ::protobuf::MessageField<DeploymentStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.Deployment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Deployment {
    fn default() -> &'a Deployment {
        <Deployment as ::protobuf::Message>::default_instance()
    }
}

impl Deployment {
    pub fn new() -> Deployment {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.apps.v1beta2.DeploymentSpec spec = 2;

    pub fn spec(&self) -> &DeploymentSpec {
        self.spec.as_ref().unwrap_or_else(|| <DeploymentSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: DeploymentSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut DeploymentSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> DeploymentSpec {
        self.spec.take().unwrap_or_else(|| DeploymentSpec::new())
    }

    // optional .api.apps.v1beta2.DeploymentStatus status = 3;

    pub fn status(&self) -> &DeploymentStatus {
        self.status.as_ref().unwrap_or_else(|| <DeploymentStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: DeploymentStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut DeploymentStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> DeploymentStatus {
        self.status.take().unwrap_or_else(|| DeploymentStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &Deployment| { &m.metadata },
            |m: &mut Deployment| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeploymentSpec>(
            "spec",
            |m: &Deployment| { &m.spec },
            |m: &mut Deployment| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeploymentStatus>(
            "status",
            |m: &Deployment| { &m.status },
            |m: &mut Deployment| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Deployment>(
            "Deployment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Deployment {
    const NAME: &'static str = "Deployment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Deployment {
        Deployment::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Deployment {
        static instance: Deployment = Deployment {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Deployment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Deployment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Deployment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Deployment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.DeploymentCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeploymentCondition {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentCondition.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentCondition.status)
    pub status: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentCondition.lastUpdateTime)
    pub lastUpdateTime: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::Time>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentCondition.lastTransitionTime)
    pub lastTransitionTime: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentCondition.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentCondition.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.DeploymentCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeploymentCondition {
    fn default() -> &'a DeploymentCondition {
        <DeploymentCondition as ::protobuf::Message>::default_instance()
    }
}

impl DeploymentCondition {
    pub fn new() -> DeploymentCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;

    pub fn lastUpdateTime(&self) -> &crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastUpdateTime.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastUpdateTime(&mut self) {
        self.lastUpdateTime.clear();
    }

    pub fn has_lastUpdateTime(&self) -> bool {
        self.lastUpdateTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastUpdateTime(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastUpdateTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastUpdateTime(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastUpdateTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastUpdateTime(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastUpdateTime.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;

    pub fn lastTransitionTime(&self) -> &crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastTransitionTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional string reason = 4;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 5;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &DeploymentCondition| { &m.type_ },
            |m: &mut DeploymentCondition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &DeploymentCondition| { &m.status },
            |m: &mut DeploymentCondition| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::Time>(
            "lastUpdateTime",
            |m: &DeploymentCondition| { &m.lastUpdateTime },
            |m: &mut DeploymentCondition| { &mut m.lastUpdateTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::Time>(
            "lastTransitionTime",
            |m: &DeploymentCondition| { &m.lastTransitionTime },
            |m: &mut DeploymentCondition| { &mut m.lastTransitionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &DeploymentCondition| { &m.reason },
            |m: &mut DeploymentCondition| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &DeploymentCondition| { &m.message },
            |m: &mut DeploymentCondition| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeploymentCondition>(
            "DeploymentCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeploymentCondition {
    const NAME: &'static str = "DeploymentCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastUpdateTime)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTransitionTime)?;
                },
                34 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastUpdateTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lastUpdateTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeploymentCondition {
        DeploymentCondition::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.lastUpdateTime.clear();
        self.lastTransitionTime.clear();
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeploymentCondition {
        static instance: DeploymentCondition = DeploymentCondition {
            type_: ::std::option::Option::None,
            status: ::std::option::Option::None,
            lastUpdateTime: ::protobuf::MessageField::none(),
            lastTransitionTime: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeploymentCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeploymentCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeploymentCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeploymentCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.DeploymentList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeploymentList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentList.items)
    pub items: ::std::vec::Vec<Deployment>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.DeploymentList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeploymentList {
    fn default() -> &'a DeploymentList {
        <DeploymentList as ::protobuf::Message>::default_instance()
    }
}

impl DeploymentList {
    pub fn new() -> DeploymentList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.apps.v1beta2.Deployment items = 2;

    pub fn items(&self) -> &[Deployment] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<Deployment>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<Deployment> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<Deployment> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &DeploymentList| { &m.metadata },
            |m: &mut DeploymentList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &DeploymentList| { &m.items },
            |m: &mut DeploymentList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeploymentList>(
            "DeploymentList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeploymentList {
    const NAME: &'static str = "DeploymentList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeploymentList {
        DeploymentList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeploymentList {
        static instance: DeploymentList = DeploymentList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeploymentList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeploymentList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeploymentList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeploymentList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.DeploymentSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeploymentSpec {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentSpec.replicas)
    pub replicas: ::std::option::Option<i32>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentSpec.selector)
    pub selector: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentSpec.template)
    pub template: ::protobuf::MessageField<crate::api::core::v1::PodTemplateSpec>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentSpec.strategy)
    pub strategy: ::protobuf::MessageField<DeploymentStrategy>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentSpec.minReadySeconds)
    pub minReadySeconds: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentSpec.revisionHistoryLimit)
    pub revisionHistoryLimit: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentSpec.paused)
    pub paused: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentSpec.progressDeadlineSeconds)
    pub progressDeadlineSeconds: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.DeploymentSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeploymentSpec {
    fn default() -> &'a DeploymentSpec {
        <DeploymentSpec as ::protobuf::Message>::default_instance()
    }
}

impl DeploymentSpec {
    pub fn new() -> DeploymentSpec {
        ::std::default::Default::default()
    }

    // optional int32 replicas = 1;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;

    pub fn selector(&self) -> &crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    pub fn has_selector(&self) -> bool {
        self.selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.selector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selector(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.mut_or_insert_default()
    }

    // Take field
    pub fn take_selector(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional .api.core.v1.PodTemplateSpec template = 3;

    pub fn template(&self) -> &crate::api::core::v1::PodTemplateSpec {
        self.template.as_ref().unwrap_or_else(|| <crate::api::core::v1::PodTemplateSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_template(&mut self) {
        self.template.clear();
    }

    pub fn has_template(&self) -> bool {
        self.template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template(&mut self, v: crate::api::core::v1::PodTemplateSpec) {
        self.template = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template(&mut self) -> &mut crate::api::core::v1::PodTemplateSpec {
        self.template.mut_or_insert_default()
    }

    // Take field
    pub fn take_template(&mut self) -> crate::api::core::v1::PodTemplateSpec {
        self.template.take().unwrap_or_else(|| crate::api::core::v1::PodTemplateSpec::new())
    }

    // optional .api.apps.v1beta2.DeploymentStrategy strategy = 4;

    pub fn strategy(&self) -> &DeploymentStrategy {
        self.strategy.as_ref().unwrap_or_else(|| <DeploymentStrategy as ::protobuf::Message>::default_instance())
    }

    pub fn clear_strategy(&mut self) {
        self.strategy.clear();
    }

    pub fn has_strategy(&self) -> bool {
        self.strategy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strategy(&mut self, v: DeploymentStrategy) {
        self.strategy = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_strategy(&mut self) -> &mut DeploymentStrategy {
        self.strategy.mut_or_insert_default()
    }

    // Take field
    pub fn take_strategy(&mut self) -> DeploymentStrategy {
        self.strategy.take().unwrap_or_else(|| DeploymentStrategy::new())
    }

    // optional int32 minReadySeconds = 5;

    pub fn minReadySeconds(&self) -> i32 {
        self.minReadySeconds.unwrap_or(0)
    }

    pub fn clear_minReadySeconds(&mut self) {
        self.minReadySeconds = ::std::option::Option::None;
    }

    pub fn has_minReadySeconds(&self) -> bool {
        self.minReadySeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minReadySeconds(&mut self, v: i32) {
        self.minReadySeconds = ::std::option::Option::Some(v);
    }

    // optional int32 revisionHistoryLimit = 6;

    pub fn revisionHistoryLimit(&self) -> i32 {
        self.revisionHistoryLimit.unwrap_or(0)
    }

    pub fn clear_revisionHistoryLimit(&mut self) {
        self.revisionHistoryLimit = ::std::option::Option::None;
    }

    pub fn has_revisionHistoryLimit(&self) -> bool {
        self.revisionHistoryLimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revisionHistoryLimit(&mut self, v: i32) {
        self.revisionHistoryLimit = ::std::option::Option::Some(v);
    }

    // optional bool paused = 7;

    pub fn paused(&self) -> bool {
        self.paused.unwrap_or(false)
    }

    pub fn clear_paused(&mut self) {
        self.paused = ::std::option::Option::None;
    }

    pub fn has_paused(&self) -> bool {
        self.paused.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paused(&mut self, v: bool) {
        self.paused = ::std::option::Option::Some(v);
    }

    // optional int32 progressDeadlineSeconds = 9;

    pub fn progressDeadlineSeconds(&self) -> i32 {
        self.progressDeadlineSeconds.unwrap_or(0)
    }

    pub fn clear_progressDeadlineSeconds(&mut self) {
        self.progressDeadlineSeconds = ::std::option::Option::None;
    }

    pub fn has_progressDeadlineSeconds(&self) -> bool {
        self.progressDeadlineSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progressDeadlineSeconds(&mut self, v: i32) {
        self.progressDeadlineSeconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &DeploymentSpec| { &m.replicas },
            |m: &mut DeploymentSpec| { &mut m.replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "selector",
            |m: &DeploymentSpec| { &m.selector },
            |m: &mut DeploymentSpec| { &mut m.selector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::api::core::v1::PodTemplateSpec>(
            "template",
            |m: &DeploymentSpec| { &m.template },
            |m: &mut DeploymentSpec| { &mut m.template },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeploymentStrategy>(
            "strategy",
            |m: &DeploymentSpec| { &m.strategy },
            |m: &mut DeploymentSpec| { &mut m.strategy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minReadySeconds",
            |m: &DeploymentSpec| { &m.minReadySeconds },
            |m: &mut DeploymentSpec| { &mut m.minReadySeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revisionHistoryLimit",
            |m: &DeploymentSpec| { &m.revisionHistoryLimit },
            |m: &mut DeploymentSpec| { &mut m.revisionHistoryLimit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "paused",
            |m: &DeploymentSpec| { &m.paused },
            |m: &mut DeploymentSpec| { &mut m.paused },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "progressDeadlineSeconds",
            |m: &DeploymentSpec| { &m.progressDeadlineSeconds },
            |m: &mut DeploymentSpec| { &mut m.progressDeadlineSeconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeploymentSpec>(
            "DeploymentSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeploymentSpec {
    const NAME: &'static str = "DeploymentSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.selector)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.template)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.strategy)?;
                },
                40 => {
                    self.minReadySeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.revisionHistoryLimit = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.paused = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.progressDeadlineSeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.strategy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.minReadySeconds {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.revisionHistoryLimit {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.paused {
            my_size += 1 + 1;
        }
        if let Some(v) = self.progressDeadlineSeconds {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.replicas {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.selector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.template.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.strategy.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.minReadySeconds {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.revisionHistoryLimit {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.paused {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.progressDeadlineSeconds {
            os.write_int32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeploymentSpec {
        DeploymentSpec::new()
    }

    fn clear(&mut self) {
        self.replicas = ::std::option::Option::None;
        self.selector.clear();
        self.template.clear();
        self.strategy.clear();
        self.minReadySeconds = ::std::option::Option::None;
        self.revisionHistoryLimit = ::std::option::Option::None;
        self.paused = ::std::option::Option::None;
        self.progressDeadlineSeconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeploymentSpec {
        static instance: DeploymentSpec = DeploymentSpec {
            replicas: ::std::option::Option::None,
            selector: ::protobuf::MessageField::none(),
            template: ::protobuf::MessageField::none(),
            strategy: ::protobuf::MessageField::none(),
            minReadySeconds: ::std::option::Option::None,
            revisionHistoryLimit: ::std::option::Option::None,
            paused: ::std::option::Option::None,
            progressDeadlineSeconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeploymentSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeploymentSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeploymentSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeploymentSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.DeploymentStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeploymentStatus {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentStatus.observedGeneration)
    pub observedGeneration: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentStatus.replicas)
    pub replicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentStatus.updatedReplicas)
    pub updatedReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentStatus.readyReplicas)
    pub readyReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentStatus.availableReplicas)
    pub availableReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentStatus.unavailableReplicas)
    pub unavailableReplicas: ::std::option::Option<i32>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentStatus.conditions)
    pub conditions: ::std::vec::Vec<DeploymentCondition>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentStatus.collisionCount)
    pub collisionCount: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.DeploymentStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeploymentStatus {
    fn default() -> &'a DeploymentStatus {
        <DeploymentStatus as ::protobuf::Message>::default_instance()
    }
}

impl DeploymentStatus {
    pub fn new() -> DeploymentStatus {
        ::std::default::Default::default()
    }

    // optional int64 observedGeneration = 1;

    pub fn observedGeneration(&self) -> i64 {
        self.observedGeneration.unwrap_or(0)
    }

    pub fn clear_observedGeneration(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
    }

    pub fn has_observedGeneration(&self) -> bool {
        self.observedGeneration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observedGeneration(&mut self, v: i64) {
        self.observedGeneration = ::std::option::Option::Some(v);
    }

    // optional int32 replicas = 2;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // optional int32 updatedReplicas = 3;

    pub fn updatedReplicas(&self) -> i32 {
        self.updatedReplicas.unwrap_or(0)
    }

    pub fn clear_updatedReplicas(&mut self) {
        self.updatedReplicas = ::std::option::Option::None;
    }

    pub fn has_updatedReplicas(&self) -> bool {
        self.updatedReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updatedReplicas(&mut self, v: i32) {
        self.updatedReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 readyReplicas = 7;

    pub fn readyReplicas(&self) -> i32 {
        self.readyReplicas.unwrap_or(0)
    }

    pub fn clear_readyReplicas(&mut self) {
        self.readyReplicas = ::std::option::Option::None;
    }

    pub fn has_readyReplicas(&self) -> bool {
        self.readyReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readyReplicas(&mut self, v: i32) {
        self.readyReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 availableReplicas = 4;

    pub fn availableReplicas(&self) -> i32 {
        self.availableReplicas.unwrap_or(0)
    }

    pub fn clear_availableReplicas(&mut self) {
        self.availableReplicas = ::std::option::Option::None;
    }

    pub fn has_availableReplicas(&self) -> bool {
        self.availableReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_availableReplicas(&mut self, v: i32) {
        self.availableReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 unavailableReplicas = 5;

    pub fn unavailableReplicas(&self) -> i32 {
        self.unavailableReplicas.unwrap_or(0)
    }

    pub fn clear_unavailableReplicas(&mut self) {
        self.unavailableReplicas = ::std::option::Option::None;
    }

    pub fn has_unavailableReplicas(&self) -> bool {
        self.unavailableReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unavailableReplicas(&mut self, v: i32) {
        self.unavailableReplicas = ::std::option::Option::Some(v);
    }

    // repeated .api.apps.v1beta2.DeploymentCondition conditions = 6;

    pub fn conditions(&self) -> &[DeploymentCondition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<DeploymentCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<DeploymentCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<DeploymentCondition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    // optional int32 collisionCount = 8;

    pub fn collisionCount(&self) -> i32 {
        self.collisionCount.unwrap_or(0)
    }

    pub fn clear_collisionCount(&mut self) {
        self.collisionCount = ::std::option::Option::None;
    }

    pub fn has_collisionCount(&self) -> bool {
        self.collisionCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_collisionCount(&mut self, v: i32) {
        self.collisionCount = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "observedGeneration",
            |m: &DeploymentStatus| { &m.observedGeneration },
            |m: &mut DeploymentStatus| { &mut m.observedGeneration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &DeploymentStatus| { &m.replicas },
            |m: &mut DeploymentStatus| { &mut m.replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "updatedReplicas",
            |m: &DeploymentStatus| { &m.updatedReplicas },
            |m: &mut DeploymentStatus| { &mut m.updatedReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readyReplicas",
            |m: &DeploymentStatus| { &m.readyReplicas },
            |m: &mut DeploymentStatus| { &mut m.readyReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "availableReplicas",
            |m: &DeploymentStatus| { &m.availableReplicas },
            |m: &mut DeploymentStatus| { &mut m.availableReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unavailableReplicas",
            |m: &DeploymentStatus| { &m.unavailableReplicas },
            |m: &mut DeploymentStatus| { &mut m.unavailableReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &DeploymentStatus| { &m.conditions },
            |m: &mut DeploymentStatus| { &mut m.conditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "collisionCount",
            |m: &DeploymentStatus| { &m.collisionCount },
            |m: &mut DeploymentStatus| { &mut m.collisionCount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeploymentStatus>(
            "DeploymentStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeploymentStatus {
    const NAME: &'static str = "DeploymentStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.observedGeneration = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.updatedReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.readyReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.availableReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.unavailableReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    self.conditions.push(is.read_message()?);
                },
                64 => {
                    self.collisionCount = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.observedGeneration {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.updatedReplicas {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.readyReplicas {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.availableReplicas {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.unavailableReplicas {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.collisionCount {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.observedGeneration {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.replicas {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.updatedReplicas {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.readyReplicas {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.availableReplicas {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.unavailableReplicas {
            os.write_int32(5, v)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.collisionCount {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeploymentStatus {
        DeploymentStatus::new()
    }

    fn clear(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
        self.replicas = ::std::option::Option::None;
        self.updatedReplicas = ::std::option::Option::None;
        self.readyReplicas = ::std::option::Option::None;
        self.availableReplicas = ::std::option::Option::None;
        self.unavailableReplicas = ::std::option::Option::None;
        self.conditions.clear();
        self.collisionCount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeploymentStatus {
        static instance: DeploymentStatus = DeploymentStatus {
            observedGeneration: ::std::option::Option::None,
            replicas: ::std::option::Option::None,
            updatedReplicas: ::std::option::Option::None,
            readyReplicas: ::std::option::Option::None,
            availableReplicas: ::std::option::Option::None,
            unavailableReplicas: ::std::option::Option::None,
            conditions: ::std::vec::Vec::new(),
            collisionCount: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeploymentStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeploymentStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeploymentStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeploymentStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.DeploymentStrategy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeploymentStrategy {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentStrategy.type)
    pub type_: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.DeploymentStrategy.rollingUpdate)
    pub rollingUpdate: ::protobuf::MessageField<RollingUpdateDeployment>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.DeploymentStrategy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeploymentStrategy {
    fn default() -> &'a DeploymentStrategy {
        <DeploymentStrategy as ::protobuf::Message>::default_instance()
    }
}

impl DeploymentStrategy {
    pub fn new() -> DeploymentStrategy {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.apps.v1beta2.RollingUpdateDeployment rollingUpdate = 2;

    pub fn rollingUpdate(&self) -> &RollingUpdateDeployment {
        self.rollingUpdate.as_ref().unwrap_or_else(|| <RollingUpdateDeployment as ::protobuf::Message>::default_instance())
    }

    pub fn clear_rollingUpdate(&mut self) {
        self.rollingUpdate.clear();
    }

    pub fn has_rollingUpdate(&self) -> bool {
        self.rollingUpdate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollingUpdate(&mut self, v: RollingUpdateDeployment) {
        self.rollingUpdate = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollingUpdate(&mut self) -> &mut RollingUpdateDeployment {
        self.rollingUpdate.mut_or_insert_default()
    }

    // Take field
    pub fn take_rollingUpdate(&mut self) -> RollingUpdateDeployment {
        self.rollingUpdate.take().unwrap_or_else(|| RollingUpdateDeployment::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &DeploymentStrategy| { &m.type_ },
            |m: &mut DeploymentStrategy| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RollingUpdateDeployment>(
            "rollingUpdate",
            |m: &DeploymentStrategy| { &m.rollingUpdate },
            |m: &mut DeploymentStrategy| { &mut m.rollingUpdate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeploymentStrategy>(
            "DeploymentStrategy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeploymentStrategy {
    const NAME: &'static str = "DeploymentStrategy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rollingUpdate)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.rollingUpdate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.rollingUpdate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeploymentStrategy {
        DeploymentStrategy::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.rollingUpdate.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeploymentStrategy {
        static instance: DeploymentStrategy = DeploymentStrategy {
            type_: ::std::option::Option::None,
            rollingUpdate: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeploymentStrategy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeploymentStrategy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeploymentStrategy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeploymentStrategy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.ReplicaSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReplicaSet {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.ReplicaSet.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.ReplicaSet.spec)
    pub spec: ::protobuf::MessageField<ReplicaSetSpec>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.ReplicaSet.status)
    pub status: ::protobuf::MessageField<ReplicaSetStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.ReplicaSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReplicaSet {
    fn default() -> &'a ReplicaSet {
        <ReplicaSet as ::protobuf::Message>::default_instance()
    }
}

impl ReplicaSet {
    pub fn new() -> ReplicaSet {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.apps.v1beta2.ReplicaSetSpec spec = 2;

    pub fn spec(&self) -> &ReplicaSetSpec {
        self.spec.as_ref().unwrap_or_else(|| <ReplicaSetSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ReplicaSetSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ReplicaSetSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ReplicaSetSpec {
        self.spec.take().unwrap_or_else(|| ReplicaSetSpec::new())
    }

    // optional .api.apps.v1beta2.ReplicaSetStatus status = 3;

    pub fn status(&self) -> &ReplicaSetStatus {
        self.status.as_ref().unwrap_or_else(|| <ReplicaSetStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ReplicaSetStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ReplicaSetStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> ReplicaSetStatus {
        self.status.take().unwrap_or_else(|| ReplicaSetStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ReplicaSet| { &m.metadata },
            |m: &mut ReplicaSet| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ReplicaSetSpec>(
            "spec",
            |m: &ReplicaSet| { &m.spec },
            |m: &mut ReplicaSet| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ReplicaSetStatus>(
            "status",
            |m: &ReplicaSet| { &m.status },
            |m: &mut ReplicaSet| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplicaSet>(
            "ReplicaSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReplicaSet {
    const NAME: &'static str = "ReplicaSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReplicaSet {
        ReplicaSet::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReplicaSet {
        static instance: ReplicaSet = ReplicaSet {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReplicaSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReplicaSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReplicaSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicaSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.ReplicaSetCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReplicaSetCondition {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta2.ReplicaSetCondition.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.ReplicaSetCondition.status)
    pub status: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.ReplicaSetCondition.lastTransitionTime)
    pub lastTransitionTime: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.ReplicaSetCondition.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.ReplicaSetCondition.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.ReplicaSetCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReplicaSetCondition {
    fn default() -> &'a ReplicaSetCondition {
        <ReplicaSetCondition as ::protobuf::Message>::default_instance()
    }
}

impl ReplicaSetCondition {
    pub fn new() -> ReplicaSetCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

    pub fn lastTransitionTime(&self) -> &crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastTransitionTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional string reason = 4;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 5;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &ReplicaSetCondition| { &m.type_ },
            |m: &mut ReplicaSetCondition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &ReplicaSetCondition| { &m.status },
            |m: &mut ReplicaSetCondition| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::Time>(
            "lastTransitionTime",
            |m: &ReplicaSetCondition| { &m.lastTransitionTime },
            |m: &mut ReplicaSetCondition| { &mut m.lastTransitionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &ReplicaSetCondition| { &m.reason },
            |m: &mut ReplicaSetCondition| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &ReplicaSetCondition| { &m.message },
            |m: &mut ReplicaSetCondition| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplicaSetCondition>(
            "ReplicaSetCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReplicaSetCondition {
    const NAME: &'static str = "ReplicaSetCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTransitionTime)?;
                },
                34 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReplicaSetCondition {
        ReplicaSetCondition::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.lastTransitionTime.clear();
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReplicaSetCondition {
        static instance: ReplicaSetCondition = ReplicaSetCondition {
            type_: ::std::option::Option::None,
            status: ::std::option::Option::None,
            lastTransitionTime: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReplicaSetCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReplicaSetCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReplicaSetCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicaSetCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.ReplicaSetList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReplicaSetList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.ReplicaSetList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.ReplicaSetList.items)
    pub items: ::std::vec::Vec<ReplicaSet>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.ReplicaSetList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReplicaSetList {
    fn default() -> &'a ReplicaSetList {
        <ReplicaSetList as ::protobuf::Message>::default_instance()
    }
}

impl ReplicaSetList {
    pub fn new() -> ReplicaSetList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.apps.v1beta2.ReplicaSet items = 2;

    pub fn items(&self) -> &[ReplicaSet] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ReplicaSet>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ReplicaSet> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ReplicaSet> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ReplicaSetList| { &m.metadata },
            |m: &mut ReplicaSetList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ReplicaSetList| { &m.items },
            |m: &mut ReplicaSetList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplicaSetList>(
            "ReplicaSetList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReplicaSetList {
    const NAME: &'static str = "ReplicaSetList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReplicaSetList {
        ReplicaSetList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReplicaSetList {
        static instance: ReplicaSetList = ReplicaSetList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReplicaSetList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReplicaSetList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReplicaSetList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicaSetList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.ReplicaSetSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReplicaSetSpec {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta2.ReplicaSetSpec.replicas)
    pub replicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.ReplicaSetSpec.minReadySeconds)
    pub minReadySeconds: ::std::option::Option<i32>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.ReplicaSetSpec.selector)
    pub selector: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.ReplicaSetSpec.template)
    pub template: ::protobuf::MessageField<crate::api::core::v1::PodTemplateSpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.ReplicaSetSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReplicaSetSpec {
    fn default() -> &'a ReplicaSetSpec {
        <ReplicaSetSpec as ::protobuf::Message>::default_instance()
    }
}

impl ReplicaSetSpec {
    pub fn new() -> ReplicaSetSpec {
        ::std::default::Default::default()
    }

    // optional int32 replicas = 1;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // optional int32 minReadySeconds = 4;

    pub fn minReadySeconds(&self) -> i32 {
        self.minReadySeconds.unwrap_or(0)
    }

    pub fn clear_minReadySeconds(&mut self) {
        self.minReadySeconds = ::std::option::Option::None;
    }

    pub fn has_minReadySeconds(&self) -> bool {
        self.minReadySeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minReadySeconds(&mut self, v: i32) {
        self.minReadySeconds = ::std::option::Option::Some(v);
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;

    pub fn selector(&self) -> &crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    pub fn has_selector(&self) -> bool {
        self.selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.selector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selector(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.mut_or_insert_default()
    }

    // Take field
    pub fn take_selector(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional .api.core.v1.PodTemplateSpec template = 3;

    pub fn template(&self) -> &crate::api::core::v1::PodTemplateSpec {
        self.template.as_ref().unwrap_or_else(|| <crate::api::core::v1::PodTemplateSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_template(&mut self) {
        self.template.clear();
    }

    pub fn has_template(&self) -> bool {
        self.template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template(&mut self, v: crate::api::core::v1::PodTemplateSpec) {
        self.template = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template(&mut self) -> &mut crate::api::core::v1::PodTemplateSpec {
        self.template.mut_or_insert_default()
    }

    // Take field
    pub fn take_template(&mut self) -> crate::api::core::v1::PodTemplateSpec {
        self.template.take().unwrap_or_else(|| crate::api::core::v1::PodTemplateSpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &ReplicaSetSpec| { &m.replicas },
            |m: &mut ReplicaSetSpec| { &mut m.replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minReadySeconds",
            |m: &ReplicaSetSpec| { &m.minReadySeconds },
            |m: &mut ReplicaSetSpec| { &mut m.minReadySeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "selector",
            |m: &ReplicaSetSpec| { &m.selector },
            |m: &mut ReplicaSetSpec| { &mut m.selector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::api::core::v1::PodTemplateSpec>(
            "template",
            |m: &ReplicaSetSpec| { &m.template },
            |m: &mut ReplicaSetSpec| { &mut m.template },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplicaSetSpec>(
            "ReplicaSetSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReplicaSetSpec {
    const NAME: &'static str = "ReplicaSetSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.minReadySeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.selector)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.template)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.minReadySeconds {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.replicas {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.minReadySeconds {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.selector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.template.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReplicaSetSpec {
        ReplicaSetSpec::new()
    }

    fn clear(&mut self) {
        self.replicas = ::std::option::Option::None;
        self.minReadySeconds = ::std::option::Option::None;
        self.selector.clear();
        self.template.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReplicaSetSpec {
        static instance: ReplicaSetSpec = ReplicaSetSpec {
            replicas: ::std::option::Option::None,
            minReadySeconds: ::std::option::Option::None,
            selector: ::protobuf::MessageField::none(),
            template: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReplicaSetSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReplicaSetSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReplicaSetSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicaSetSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.ReplicaSetStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReplicaSetStatus {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta2.ReplicaSetStatus.replicas)
    pub replicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.ReplicaSetStatus.fullyLabeledReplicas)
    pub fullyLabeledReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.ReplicaSetStatus.readyReplicas)
    pub readyReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.ReplicaSetStatus.availableReplicas)
    pub availableReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.ReplicaSetStatus.observedGeneration)
    pub observedGeneration: ::std::option::Option<i64>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.ReplicaSetStatus.conditions)
    pub conditions: ::std::vec::Vec<ReplicaSetCondition>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.ReplicaSetStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReplicaSetStatus {
    fn default() -> &'a ReplicaSetStatus {
        <ReplicaSetStatus as ::protobuf::Message>::default_instance()
    }
}

impl ReplicaSetStatus {
    pub fn new() -> ReplicaSetStatus {
        ::std::default::Default::default()
    }

    // optional int32 replicas = 1;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // optional int32 fullyLabeledReplicas = 2;

    pub fn fullyLabeledReplicas(&self) -> i32 {
        self.fullyLabeledReplicas.unwrap_or(0)
    }

    pub fn clear_fullyLabeledReplicas(&mut self) {
        self.fullyLabeledReplicas = ::std::option::Option::None;
    }

    pub fn has_fullyLabeledReplicas(&self) -> bool {
        self.fullyLabeledReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fullyLabeledReplicas(&mut self, v: i32) {
        self.fullyLabeledReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 readyReplicas = 4;

    pub fn readyReplicas(&self) -> i32 {
        self.readyReplicas.unwrap_or(0)
    }

    pub fn clear_readyReplicas(&mut self) {
        self.readyReplicas = ::std::option::Option::None;
    }

    pub fn has_readyReplicas(&self) -> bool {
        self.readyReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readyReplicas(&mut self, v: i32) {
        self.readyReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 availableReplicas = 5;

    pub fn availableReplicas(&self) -> i32 {
        self.availableReplicas.unwrap_or(0)
    }

    pub fn clear_availableReplicas(&mut self) {
        self.availableReplicas = ::std::option::Option::None;
    }

    pub fn has_availableReplicas(&self) -> bool {
        self.availableReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_availableReplicas(&mut self, v: i32) {
        self.availableReplicas = ::std::option::Option::Some(v);
    }

    // optional int64 observedGeneration = 3;

    pub fn observedGeneration(&self) -> i64 {
        self.observedGeneration.unwrap_or(0)
    }

    pub fn clear_observedGeneration(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
    }

    pub fn has_observedGeneration(&self) -> bool {
        self.observedGeneration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observedGeneration(&mut self, v: i64) {
        self.observedGeneration = ::std::option::Option::Some(v);
    }

    // repeated .api.apps.v1beta2.ReplicaSetCondition conditions = 6;

    pub fn conditions(&self) -> &[ReplicaSetCondition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<ReplicaSetCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<ReplicaSetCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<ReplicaSetCondition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &ReplicaSetStatus| { &m.replicas },
            |m: &mut ReplicaSetStatus| { &mut m.replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fullyLabeledReplicas",
            |m: &ReplicaSetStatus| { &m.fullyLabeledReplicas },
            |m: &mut ReplicaSetStatus| { &mut m.fullyLabeledReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readyReplicas",
            |m: &ReplicaSetStatus| { &m.readyReplicas },
            |m: &mut ReplicaSetStatus| { &mut m.readyReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "availableReplicas",
            |m: &ReplicaSetStatus| { &m.availableReplicas },
            |m: &mut ReplicaSetStatus| { &mut m.availableReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "observedGeneration",
            |m: &ReplicaSetStatus| { &m.observedGeneration },
            |m: &mut ReplicaSetStatus| { &mut m.observedGeneration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &ReplicaSetStatus| { &m.conditions },
            |m: &mut ReplicaSetStatus| { &mut m.conditions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReplicaSetStatus>(
            "ReplicaSetStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReplicaSetStatus {
    const NAME: &'static str = "ReplicaSetStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.fullyLabeledReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.readyReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.availableReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.observedGeneration = ::std::option::Option::Some(is.read_int64()?);
                },
                50 => {
                    self.conditions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.fullyLabeledReplicas {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.readyReplicas {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.availableReplicas {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.observedGeneration {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.replicas {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.fullyLabeledReplicas {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.readyReplicas {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.availableReplicas {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.observedGeneration {
            os.write_int64(3, v)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReplicaSetStatus {
        ReplicaSetStatus::new()
    }

    fn clear(&mut self) {
        self.replicas = ::std::option::Option::None;
        self.fullyLabeledReplicas = ::std::option::Option::None;
        self.readyReplicas = ::std::option::Option::None;
        self.availableReplicas = ::std::option::Option::None;
        self.observedGeneration = ::std::option::Option::None;
        self.conditions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReplicaSetStatus {
        static instance: ReplicaSetStatus = ReplicaSetStatus {
            replicas: ::std::option::Option::None,
            fullyLabeledReplicas: ::std::option::Option::None,
            readyReplicas: ::std::option::Option::None,
            availableReplicas: ::std::option::Option::None,
            observedGeneration: ::std::option::Option::None,
            conditions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReplicaSetStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReplicaSetStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReplicaSetStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicaSetStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.RollingUpdateDaemonSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RollingUpdateDaemonSet {
    // message fields
    #[serde(with = "crate::intorstr")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.RollingUpdateDaemonSet.maxUnavailable)
    pub maxUnavailable: ::protobuf::MessageField<crate::apimachinery::pkg::util::intstr::IntOrString>,
    #[serde(with = "crate::intorstr")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.RollingUpdateDaemonSet.maxSurge)
    pub maxSurge: ::protobuf::MessageField<crate::apimachinery::pkg::util::intstr::IntOrString>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.RollingUpdateDaemonSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RollingUpdateDaemonSet {
    fn default() -> &'a RollingUpdateDaemonSet {
        <RollingUpdateDaemonSet as ::protobuf::Message>::default_instance()
    }
}

impl RollingUpdateDaemonSet {
    pub fn new() -> RollingUpdateDaemonSet {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;

    pub fn maxUnavailable(&self) -> &crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::util::intstr::IntOrString as ::protobuf::Message>::default_instance())
    }

    pub fn clear_maxUnavailable(&mut self) {
        self.maxUnavailable.clear();
    }

    pub fn has_maxUnavailable(&self) -> bool {
        self.maxUnavailable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxUnavailable(&mut self, v: crate::apimachinery::pkg::util::intstr::IntOrString) {
        self.maxUnavailable = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maxUnavailable(&mut self) -> &mut crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.mut_or_insert_default()
    }

    // Take field
    pub fn take_maxUnavailable(&mut self) -> crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.take().unwrap_or_else(|| crate::apimachinery::pkg::util::intstr::IntOrString::new())
    }

    // optional .apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;

    pub fn maxSurge(&self) -> &crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxSurge.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::util::intstr::IntOrString as ::protobuf::Message>::default_instance())
    }

    pub fn clear_maxSurge(&mut self) {
        self.maxSurge.clear();
    }

    pub fn has_maxSurge(&self) -> bool {
        self.maxSurge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxSurge(&mut self, v: crate::apimachinery::pkg::util::intstr::IntOrString) {
        self.maxSurge = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maxSurge(&mut self) -> &mut crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxSurge.mut_or_insert_default()
    }

    // Take field
    pub fn take_maxSurge(&mut self) -> crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxSurge.take().unwrap_or_else(|| crate::apimachinery::pkg::util::intstr::IntOrString::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::util::intstr::IntOrString>(
            "maxUnavailable",
            |m: &RollingUpdateDaemonSet| { &m.maxUnavailable },
            |m: &mut RollingUpdateDaemonSet| { &mut m.maxUnavailable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::util::intstr::IntOrString>(
            "maxSurge",
            |m: &RollingUpdateDaemonSet| { &m.maxSurge },
            |m: &mut RollingUpdateDaemonSet| { &mut m.maxSurge },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RollingUpdateDaemonSet>(
            "RollingUpdateDaemonSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RollingUpdateDaemonSet {
    const NAME: &'static str = "RollingUpdateDaemonSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.maxUnavailable)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.maxSurge)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.maxUnavailable.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.maxSurge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.maxUnavailable.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.maxSurge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RollingUpdateDaemonSet {
        RollingUpdateDaemonSet::new()
    }

    fn clear(&mut self) {
        self.maxUnavailable.clear();
        self.maxSurge.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RollingUpdateDaemonSet {
        static instance: RollingUpdateDaemonSet = RollingUpdateDaemonSet {
            maxUnavailable: ::protobuf::MessageField::none(),
            maxSurge: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RollingUpdateDaemonSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RollingUpdateDaemonSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RollingUpdateDaemonSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpdateDaemonSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.RollingUpdateDeployment)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RollingUpdateDeployment {
    // message fields
    #[serde(with = "crate::intorstr")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.RollingUpdateDeployment.maxUnavailable)
    pub maxUnavailable: ::protobuf::MessageField<crate::apimachinery::pkg::util::intstr::IntOrString>,
    #[serde(with = "crate::intorstr")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.RollingUpdateDeployment.maxSurge)
    pub maxSurge: ::protobuf::MessageField<crate::apimachinery::pkg::util::intstr::IntOrString>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.RollingUpdateDeployment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RollingUpdateDeployment {
    fn default() -> &'a RollingUpdateDeployment {
        <RollingUpdateDeployment as ::protobuf::Message>::default_instance()
    }
}

impl RollingUpdateDeployment {
    pub fn new() -> RollingUpdateDeployment {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;

    pub fn maxUnavailable(&self) -> &crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::util::intstr::IntOrString as ::protobuf::Message>::default_instance())
    }

    pub fn clear_maxUnavailable(&mut self) {
        self.maxUnavailable.clear();
    }

    pub fn has_maxUnavailable(&self) -> bool {
        self.maxUnavailable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxUnavailable(&mut self, v: crate::apimachinery::pkg::util::intstr::IntOrString) {
        self.maxUnavailable = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maxUnavailable(&mut self) -> &mut crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.mut_or_insert_default()
    }

    // Take field
    pub fn take_maxUnavailable(&mut self) -> crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.take().unwrap_or_else(|| crate::apimachinery::pkg::util::intstr::IntOrString::new())
    }

    // optional .apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;

    pub fn maxSurge(&self) -> &crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxSurge.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::util::intstr::IntOrString as ::protobuf::Message>::default_instance())
    }

    pub fn clear_maxSurge(&mut self) {
        self.maxSurge.clear();
    }

    pub fn has_maxSurge(&self) -> bool {
        self.maxSurge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxSurge(&mut self, v: crate::apimachinery::pkg::util::intstr::IntOrString) {
        self.maxSurge = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maxSurge(&mut self) -> &mut crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxSurge.mut_or_insert_default()
    }

    // Take field
    pub fn take_maxSurge(&mut self) -> crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxSurge.take().unwrap_or_else(|| crate::apimachinery::pkg::util::intstr::IntOrString::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::util::intstr::IntOrString>(
            "maxUnavailable",
            |m: &RollingUpdateDeployment| { &m.maxUnavailable },
            |m: &mut RollingUpdateDeployment| { &mut m.maxUnavailable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::util::intstr::IntOrString>(
            "maxSurge",
            |m: &RollingUpdateDeployment| { &m.maxSurge },
            |m: &mut RollingUpdateDeployment| { &mut m.maxSurge },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RollingUpdateDeployment>(
            "RollingUpdateDeployment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RollingUpdateDeployment {
    const NAME: &'static str = "RollingUpdateDeployment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.maxUnavailable)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.maxSurge)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.maxUnavailable.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.maxSurge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.maxUnavailable.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.maxSurge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RollingUpdateDeployment {
        RollingUpdateDeployment::new()
    }

    fn clear(&mut self) {
        self.maxUnavailable.clear();
        self.maxSurge.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RollingUpdateDeployment {
        static instance: RollingUpdateDeployment = RollingUpdateDeployment {
            maxUnavailable: ::protobuf::MessageField::none(),
            maxSurge: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RollingUpdateDeployment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RollingUpdateDeployment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RollingUpdateDeployment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpdateDeployment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.RollingUpdateStatefulSetStrategy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RollingUpdateStatefulSetStrategy {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta2.RollingUpdateStatefulSetStrategy.partition)
    pub partition: ::std::option::Option<i32>,
    #[serde(with = "crate::intorstr")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.RollingUpdateStatefulSetStrategy.maxUnavailable)
    pub maxUnavailable: ::protobuf::MessageField<crate::apimachinery::pkg::util::intstr::IntOrString>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.RollingUpdateStatefulSetStrategy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RollingUpdateStatefulSetStrategy {
    fn default() -> &'a RollingUpdateStatefulSetStrategy {
        <RollingUpdateStatefulSetStrategy as ::protobuf::Message>::default_instance()
    }
}

impl RollingUpdateStatefulSetStrategy {
    pub fn new() -> RollingUpdateStatefulSetStrategy {
        ::std::default::Default::default()
    }

    // optional int32 partition = 1;

    pub fn partition(&self) -> i32 {
        self.partition.unwrap_or(0)
    }

    pub fn clear_partition(&mut self) {
        self.partition = ::std::option::Option::None;
    }

    pub fn has_partition(&self) -> bool {
        self.partition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partition(&mut self, v: i32) {
        self.partition = ::std::option::Option::Some(v);
    }

    // optional .apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 2;

    pub fn maxUnavailable(&self) -> &crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::util::intstr::IntOrString as ::protobuf::Message>::default_instance())
    }

    pub fn clear_maxUnavailable(&mut self) {
        self.maxUnavailable.clear();
    }

    pub fn has_maxUnavailable(&self) -> bool {
        self.maxUnavailable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxUnavailable(&mut self, v: crate::apimachinery::pkg::util::intstr::IntOrString) {
        self.maxUnavailable = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maxUnavailable(&mut self) -> &mut crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.mut_or_insert_default()
    }

    // Take field
    pub fn take_maxUnavailable(&mut self) -> crate::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.take().unwrap_or_else(|| crate::apimachinery::pkg::util::intstr::IntOrString::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "partition",
            |m: &RollingUpdateStatefulSetStrategy| { &m.partition },
            |m: &mut RollingUpdateStatefulSetStrategy| { &mut m.partition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::util::intstr::IntOrString>(
            "maxUnavailable",
            |m: &RollingUpdateStatefulSetStrategy| { &m.maxUnavailable },
            |m: &mut RollingUpdateStatefulSetStrategy| { &mut m.maxUnavailable },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RollingUpdateStatefulSetStrategy>(
            "RollingUpdateStatefulSetStrategy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RollingUpdateStatefulSetStrategy {
    const NAME: &'static str = "RollingUpdateStatefulSetStrategy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.partition = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.maxUnavailable)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.partition {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.maxUnavailable.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.partition {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.maxUnavailable.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RollingUpdateStatefulSetStrategy {
        RollingUpdateStatefulSetStrategy::new()
    }

    fn clear(&mut self) {
        self.partition = ::std::option::Option::None;
        self.maxUnavailable.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RollingUpdateStatefulSetStrategy {
        static instance: RollingUpdateStatefulSetStrategy = RollingUpdateStatefulSetStrategy {
            partition: ::std::option::Option::None,
            maxUnavailable: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RollingUpdateStatefulSetStrategy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RollingUpdateStatefulSetStrategy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RollingUpdateStatefulSetStrategy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpdateStatefulSetStrategy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.Scale)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Scale {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.Scale.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.Scale.spec)
    pub spec: ::protobuf::MessageField<ScaleSpec>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.Scale.status)
    pub status: ::protobuf::MessageField<ScaleStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.Scale.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Scale {
    fn default() -> &'a Scale {
        <Scale as ::protobuf::Message>::default_instance()
    }
}

impl Scale {
    pub fn new() -> Scale {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.apps.v1beta2.ScaleSpec spec = 2;

    pub fn spec(&self) -> &ScaleSpec {
        self.spec.as_ref().unwrap_or_else(|| <ScaleSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ScaleSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ScaleSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ScaleSpec {
        self.spec.take().unwrap_or_else(|| ScaleSpec::new())
    }

    // optional .api.apps.v1beta2.ScaleStatus status = 3;

    pub fn status(&self) -> &ScaleStatus {
        self.status.as_ref().unwrap_or_else(|| <ScaleStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ScaleStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ScaleStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> ScaleStatus {
        self.status.take().unwrap_or_else(|| ScaleStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &Scale| { &m.metadata },
            |m: &mut Scale| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ScaleSpec>(
            "spec",
            |m: &Scale| { &m.spec },
            |m: &mut Scale| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ScaleStatus>(
            "status",
            |m: &Scale| { &m.status },
            |m: &mut Scale| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Scale>(
            "Scale",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Scale {
    const NAME: &'static str = "Scale";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Scale {
        Scale::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Scale {
        static instance: Scale = Scale {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Scale {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Scale").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Scale {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Scale {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.ScaleSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ScaleSpec {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta2.ScaleSpec.replicas)
    pub replicas: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.ScaleSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScaleSpec {
    fn default() -> &'a ScaleSpec {
        <ScaleSpec as ::protobuf::Message>::default_instance()
    }
}

impl ScaleSpec {
    pub fn new() -> ScaleSpec {
        ::std::default::Default::default()
    }

    // optional int32 replicas = 1;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &ScaleSpec| { &m.replicas },
            |m: &mut ScaleSpec| { &mut m.replicas },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScaleSpec>(
            "ScaleSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScaleSpec {
    const NAME: &'static str = "ScaleSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.replicas {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScaleSpec {
        ScaleSpec::new()
    }

    fn clear(&mut self) {
        self.replicas = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScaleSpec {
        static instance: ScaleSpec = ScaleSpec {
            replicas: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScaleSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScaleSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScaleSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScaleSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.ScaleStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ScaleStatus {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta2.ScaleStatus.replicas)
    pub replicas: ::std::option::Option<i32>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.ScaleStatus.selector)
    pub selector: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.ScaleStatus.targetSelector)
    pub targetSelector: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.ScaleStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScaleStatus {
    fn default() -> &'a ScaleStatus {
        <ScaleStatus as ::protobuf::Message>::default_instance()
    }
}

impl ScaleStatus {
    pub fn new() -> ScaleStatus {
        ::std::default::Default::default()
    }

    // optional int32 replicas = 1;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // repeated .api.apps.v1beta2.ScaleStatus.SelectorEntry selector = 2;

    pub fn selector(&self) -> &::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &self.selector
    }

    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
        self.selector = v;
    }

    // Mutable pointer to the field.
    pub fn mut_selector(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &mut self.selector
    }

    // Take field
    pub fn take_selector(&mut self) -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.selector, ::std::collections::BTreeMap::new())
    }

    // optional string targetSelector = 3;

    pub fn targetSelector(&self) -> &str {
        match self.targetSelector.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_targetSelector(&mut self) {
        self.targetSelector = ::std::option::Option::None;
    }

    pub fn has_targetSelector(&self) -> bool {
        self.targetSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetSelector(&mut self, v: ::std::string::String) {
        self.targetSelector = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetSelector(&mut self) -> &mut ::std::string::String {
        if self.targetSelector.is_none() {
            self.targetSelector = ::std::option::Option::Some(::std::string::String::new());
        }
        self.targetSelector.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetSelector(&mut self) -> ::std::string::String {
        self.targetSelector.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &ScaleStatus| { &m.replicas },
            |m: &mut ScaleStatus| { &mut m.replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "selector",
            |m: &ScaleStatus| { &m.selector },
            |m: &mut ScaleStatus| { &mut m.selector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "targetSelector",
            |m: &ScaleStatus| { &m.targetSelector },
            |m: &mut ScaleStatus| { &mut m.targetSelector },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScaleStatus>(
            "ScaleStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScaleStatus {
    const NAME: &'static str = "ScaleStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.selector.insert(key, value);
                },
                26 => {
                    self.targetSelector = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for (k, v) in &self.selector {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.targetSelector.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.replicas {
            os.write_int32(1, v)?;
        }
        for (k, v) in &self.selector {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.targetSelector.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScaleStatus {
        ScaleStatus::new()
    }

    fn clear(&mut self) {
        self.replicas = ::std::option::Option::None;
        self.selector.clear();
        self.targetSelector = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScaleStatus {
        static instance: ::protobuf::rt::Lazy<ScaleStatus> = ::protobuf::rt::Lazy::new();
        instance.get(ScaleStatus::new)
    }
}

impl ::protobuf::MessageFull for ScaleStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScaleStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScaleStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScaleStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.StatefulSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatefulSet {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSet.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSet.spec)
    pub spec: ::protobuf::MessageField<StatefulSetSpec>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSet.status)
    pub status: ::protobuf::MessageField<StatefulSetStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.StatefulSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatefulSet {
    fn default() -> &'a StatefulSet {
        <StatefulSet as ::protobuf::Message>::default_instance()
    }
}

impl StatefulSet {
    pub fn new() -> StatefulSet {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.apps.v1beta2.StatefulSetSpec spec = 2;

    pub fn spec(&self) -> &StatefulSetSpec {
        self.spec.as_ref().unwrap_or_else(|| <StatefulSetSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: StatefulSetSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut StatefulSetSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> StatefulSetSpec {
        self.spec.take().unwrap_or_else(|| StatefulSetSpec::new())
    }

    // optional .api.apps.v1beta2.StatefulSetStatus status = 3;

    pub fn status(&self) -> &StatefulSetStatus {
        self.status.as_ref().unwrap_or_else(|| <StatefulSetStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: StatefulSetStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut StatefulSetStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> StatefulSetStatus {
        self.status.take().unwrap_or_else(|| StatefulSetStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &StatefulSet| { &m.metadata },
            |m: &mut StatefulSet| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StatefulSetSpec>(
            "spec",
            |m: &StatefulSet| { &m.spec },
            |m: &mut StatefulSet| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StatefulSetStatus>(
            "status",
            |m: &StatefulSet| { &m.status },
            |m: &mut StatefulSet| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatefulSet>(
            "StatefulSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatefulSet {
    const NAME: &'static str = "StatefulSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatefulSet {
        StatefulSet::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatefulSet {
        static instance: StatefulSet = StatefulSet {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatefulSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatefulSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatefulSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatefulSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.StatefulSetCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatefulSetCondition {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetCondition.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetCondition.status)
    pub status: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetCondition.lastTransitionTime)
    pub lastTransitionTime: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetCondition.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetCondition.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.StatefulSetCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatefulSetCondition {
    fn default() -> &'a StatefulSetCondition {
        <StatefulSetCondition as ::protobuf::Message>::default_instance()
    }
}

impl StatefulSetCondition {
    pub fn new() -> StatefulSetCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

    pub fn lastTransitionTime(&self) -> &crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastTransitionTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional string reason = 4;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 5;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &StatefulSetCondition| { &m.type_ },
            |m: &mut StatefulSetCondition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &StatefulSetCondition| { &m.status },
            |m: &mut StatefulSetCondition| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::Time>(
            "lastTransitionTime",
            |m: &StatefulSetCondition| { &m.lastTransitionTime },
            |m: &mut StatefulSetCondition| { &mut m.lastTransitionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &StatefulSetCondition| { &m.reason },
            |m: &mut StatefulSetCondition| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &StatefulSetCondition| { &m.message },
            |m: &mut StatefulSetCondition| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatefulSetCondition>(
            "StatefulSetCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatefulSetCondition {
    const NAME: &'static str = "StatefulSetCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTransitionTime)?;
                },
                34 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatefulSetCondition {
        StatefulSetCondition::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.lastTransitionTime.clear();
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatefulSetCondition {
        static instance: StatefulSetCondition = StatefulSetCondition {
            type_: ::std::option::Option::None,
            status: ::std::option::Option::None,
            lastTransitionTime: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatefulSetCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatefulSetCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatefulSetCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatefulSetCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.StatefulSetList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatefulSetList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetList.items)
    pub items: ::std::vec::Vec<StatefulSet>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.StatefulSetList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatefulSetList {
    fn default() -> &'a StatefulSetList {
        <StatefulSetList as ::protobuf::Message>::default_instance()
    }
}

impl StatefulSetList {
    pub fn new() -> StatefulSetList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.apps.v1beta2.StatefulSet items = 2;

    pub fn items(&self) -> &[StatefulSet] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<StatefulSet>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<StatefulSet> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<StatefulSet> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &StatefulSetList| { &m.metadata },
            |m: &mut StatefulSetList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &StatefulSetList| { &m.items },
            |m: &mut StatefulSetList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatefulSetList>(
            "StatefulSetList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatefulSetList {
    const NAME: &'static str = "StatefulSetList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatefulSetList {
        StatefulSetList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatefulSetList {
        static instance: StatefulSetList = StatefulSetList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatefulSetList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatefulSetList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatefulSetList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatefulSetList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.StatefulSetOrdinals)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatefulSetOrdinals {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetOrdinals.start)
    pub start: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.StatefulSetOrdinals.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatefulSetOrdinals {
    fn default() -> &'a StatefulSetOrdinals {
        <StatefulSetOrdinals as ::protobuf::Message>::default_instance()
    }
}

impl StatefulSetOrdinals {
    pub fn new() -> StatefulSetOrdinals {
        ::std::default::Default::default()
    }

    // optional int32 start = 1;

    pub fn start(&self) -> i32 {
        self.start.unwrap_or(0)
    }

    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: i32) {
        self.start = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start",
            |m: &StatefulSetOrdinals| { &m.start },
            |m: &mut StatefulSetOrdinals| { &mut m.start },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatefulSetOrdinals>(
            "StatefulSetOrdinals",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatefulSetOrdinals {
    const NAME: &'static str = "StatefulSetOrdinals";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.start = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatefulSetOrdinals {
        StatefulSetOrdinals::new()
    }

    fn clear(&mut self) {
        self.start = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatefulSetOrdinals {
        static instance: StatefulSetOrdinals = StatefulSetOrdinals {
            start: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatefulSetOrdinals {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatefulSetOrdinals").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatefulSetOrdinals {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatefulSetOrdinals {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.StatefulSetPersistentVolumeClaimRetentionPolicy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatefulSetPersistentVolumeClaimRetentionPolicy {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetPersistentVolumeClaimRetentionPolicy.whenDeleted)
    pub whenDeleted: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetPersistentVolumeClaimRetentionPolicy.whenScaled)
    pub whenScaled: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.StatefulSetPersistentVolumeClaimRetentionPolicy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatefulSetPersistentVolumeClaimRetentionPolicy {
    fn default() -> &'a StatefulSetPersistentVolumeClaimRetentionPolicy {
        <StatefulSetPersistentVolumeClaimRetentionPolicy as ::protobuf::Message>::default_instance()
    }
}

impl StatefulSetPersistentVolumeClaimRetentionPolicy {
    pub fn new() -> StatefulSetPersistentVolumeClaimRetentionPolicy {
        ::std::default::Default::default()
    }

    // optional string whenDeleted = 1;

    pub fn whenDeleted(&self) -> &str {
        match self.whenDeleted.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_whenDeleted(&mut self) {
        self.whenDeleted = ::std::option::Option::None;
    }

    pub fn has_whenDeleted(&self) -> bool {
        self.whenDeleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_whenDeleted(&mut self, v: ::std::string::String) {
        self.whenDeleted = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_whenDeleted(&mut self) -> &mut ::std::string::String {
        if self.whenDeleted.is_none() {
            self.whenDeleted = ::std::option::Option::Some(::std::string::String::new());
        }
        self.whenDeleted.as_mut().unwrap()
    }

    // Take field
    pub fn take_whenDeleted(&mut self) -> ::std::string::String {
        self.whenDeleted.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string whenScaled = 2;

    pub fn whenScaled(&self) -> &str {
        match self.whenScaled.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_whenScaled(&mut self) {
        self.whenScaled = ::std::option::Option::None;
    }

    pub fn has_whenScaled(&self) -> bool {
        self.whenScaled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_whenScaled(&mut self, v: ::std::string::String) {
        self.whenScaled = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_whenScaled(&mut self) -> &mut ::std::string::String {
        if self.whenScaled.is_none() {
            self.whenScaled = ::std::option::Option::Some(::std::string::String::new());
        }
        self.whenScaled.as_mut().unwrap()
    }

    // Take field
    pub fn take_whenScaled(&mut self) -> ::std::string::String {
        self.whenScaled.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "whenDeleted",
            |m: &StatefulSetPersistentVolumeClaimRetentionPolicy| { &m.whenDeleted },
            |m: &mut StatefulSetPersistentVolumeClaimRetentionPolicy| { &mut m.whenDeleted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "whenScaled",
            |m: &StatefulSetPersistentVolumeClaimRetentionPolicy| { &m.whenScaled },
            |m: &mut StatefulSetPersistentVolumeClaimRetentionPolicy| { &mut m.whenScaled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatefulSetPersistentVolumeClaimRetentionPolicy>(
            "StatefulSetPersistentVolumeClaimRetentionPolicy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatefulSetPersistentVolumeClaimRetentionPolicy {
    const NAME: &'static str = "StatefulSetPersistentVolumeClaimRetentionPolicy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.whenDeleted = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.whenScaled = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.whenDeleted.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.whenScaled.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.whenDeleted.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.whenScaled.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatefulSetPersistentVolumeClaimRetentionPolicy {
        StatefulSetPersistentVolumeClaimRetentionPolicy::new()
    }

    fn clear(&mut self) {
        self.whenDeleted = ::std::option::Option::None;
        self.whenScaled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatefulSetPersistentVolumeClaimRetentionPolicy {
        static instance: StatefulSetPersistentVolumeClaimRetentionPolicy = StatefulSetPersistentVolumeClaimRetentionPolicy {
            whenDeleted: ::std::option::Option::None,
            whenScaled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatefulSetPersistentVolumeClaimRetentionPolicy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatefulSetPersistentVolumeClaimRetentionPolicy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatefulSetPersistentVolumeClaimRetentionPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatefulSetPersistentVolumeClaimRetentionPolicy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.StatefulSetSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatefulSetSpec {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetSpec.replicas)
    pub replicas: ::std::option::Option<i32>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetSpec.selector)
    pub selector: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetSpec.template)
    pub template: ::protobuf::MessageField<crate::api::core::v1::PodTemplateSpec>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetSpec.volumeClaimTemplates)
    pub volumeClaimTemplates: ::std::vec::Vec<crate::api::core::v1::PersistentVolumeClaim>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetSpec.serviceName)
    pub serviceName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetSpec.podManagementPolicy)
    pub podManagementPolicy: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetSpec.updateStrategy)
    pub updateStrategy: ::protobuf::MessageField<StatefulSetUpdateStrategy>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetSpec.revisionHistoryLimit)
    pub revisionHistoryLimit: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetSpec.minReadySeconds)
    pub minReadySeconds: ::std::option::Option<i32>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetSpec.persistentVolumeClaimRetentionPolicy)
    pub persistentVolumeClaimRetentionPolicy: ::protobuf::MessageField<StatefulSetPersistentVolumeClaimRetentionPolicy>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetSpec.ordinals)
    pub ordinals: ::protobuf::MessageField<StatefulSetOrdinals>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.StatefulSetSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatefulSetSpec {
    fn default() -> &'a StatefulSetSpec {
        <StatefulSetSpec as ::protobuf::Message>::default_instance()
    }
}

impl StatefulSetSpec {
    pub fn new() -> StatefulSetSpec {
        ::std::default::Default::default()
    }

    // optional int32 replicas = 1;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;

    pub fn selector(&self) -> &crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    pub fn has_selector(&self) -> bool {
        self.selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.selector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selector(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.mut_or_insert_default()
    }

    // Take field
    pub fn take_selector(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional .api.core.v1.PodTemplateSpec template = 3;

    pub fn template(&self) -> &crate::api::core::v1::PodTemplateSpec {
        self.template.as_ref().unwrap_or_else(|| <crate::api::core::v1::PodTemplateSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_template(&mut self) {
        self.template.clear();
    }

    pub fn has_template(&self) -> bool {
        self.template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template(&mut self, v: crate::api::core::v1::PodTemplateSpec) {
        self.template = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template(&mut self) -> &mut crate::api::core::v1::PodTemplateSpec {
        self.template.mut_or_insert_default()
    }

    // Take field
    pub fn take_template(&mut self) -> crate::api::core::v1::PodTemplateSpec {
        self.template.take().unwrap_or_else(|| crate::api::core::v1::PodTemplateSpec::new())
    }

    // repeated .api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;

    pub fn volumeClaimTemplates(&self) -> &[crate::api::core::v1::PersistentVolumeClaim] {
        &self.volumeClaimTemplates
    }

    pub fn clear_volumeClaimTemplates(&mut self) {
        self.volumeClaimTemplates.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumeClaimTemplates(&mut self, v: ::std::vec::Vec<crate::api::core::v1::PersistentVolumeClaim>) {
        self.volumeClaimTemplates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumeClaimTemplates(&mut self) -> &mut ::std::vec::Vec<crate::api::core::v1::PersistentVolumeClaim> {
        &mut self.volumeClaimTemplates
    }

    // Take field
    pub fn take_volumeClaimTemplates(&mut self) -> ::std::vec::Vec<crate::api::core::v1::PersistentVolumeClaim> {
        ::std::mem::replace(&mut self.volumeClaimTemplates, ::std::vec::Vec::new())
    }

    // optional string serviceName = 5;

    pub fn serviceName(&self) -> &str {
        match self.serviceName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_serviceName(&mut self) {
        self.serviceName = ::std::option::Option::None;
    }

    pub fn has_serviceName(&self) -> bool {
        self.serviceName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serviceName(&mut self, v: ::std::string::String) {
        self.serviceName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serviceName(&mut self) -> &mut ::std::string::String {
        if self.serviceName.is_none() {
            self.serviceName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.serviceName.as_mut().unwrap()
    }

    // Take field
    pub fn take_serviceName(&mut self) -> ::std::string::String {
        self.serviceName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string podManagementPolicy = 6;

    pub fn podManagementPolicy(&self) -> &str {
        match self.podManagementPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_podManagementPolicy(&mut self) {
        self.podManagementPolicy = ::std::option::Option::None;
    }

    pub fn has_podManagementPolicy(&self) -> bool {
        self.podManagementPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podManagementPolicy(&mut self, v: ::std::string::String) {
        self.podManagementPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podManagementPolicy(&mut self) -> &mut ::std::string::String {
        if self.podManagementPolicy.is_none() {
            self.podManagementPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.podManagementPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_podManagementPolicy(&mut self) -> ::std::string::String {
        self.podManagementPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.apps.v1beta2.StatefulSetUpdateStrategy updateStrategy = 7;

    pub fn updateStrategy(&self) -> &StatefulSetUpdateStrategy {
        self.updateStrategy.as_ref().unwrap_or_else(|| <StatefulSetUpdateStrategy as ::protobuf::Message>::default_instance())
    }

    pub fn clear_updateStrategy(&mut self) {
        self.updateStrategy.clear();
    }

    pub fn has_updateStrategy(&self) -> bool {
        self.updateStrategy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updateStrategy(&mut self, v: StatefulSetUpdateStrategy) {
        self.updateStrategy = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updateStrategy(&mut self) -> &mut StatefulSetUpdateStrategy {
        self.updateStrategy.mut_or_insert_default()
    }

    // Take field
    pub fn take_updateStrategy(&mut self) -> StatefulSetUpdateStrategy {
        self.updateStrategy.take().unwrap_or_else(|| StatefulSetUpdateStrategy::new())
    }

    // optional int32 revisionHistoryLimit = 8;

    pub fn revisionHistoryLimit(&self) -> i32 {
        self.revisionHistoryLimit.unwrap_or(0)
    }

    pub fn clear_revisionHistoryLimit(&mut self) {
        self.revisionHistoryLimit = ::std::option::Option::None;
    }

    pub fn has_revisionHistoryLimit(&self) -> bool {
        self.revisionHistoryLimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revisionHistoryLimit(&mut self, v: i32) {
        self.revisionHistoryLimit = ::std::option::Option::Some(v);
    }

    // optional int32 minReadySeconds = 9;

    pub fn minReadySeconds(&self) -> i32 {
        self.minReadySeconds.unwrap_or(0)
    }

    pub fn clear_minReadySeconds(&mut self) {
        self.minReadySeconds = ::std::option::Option::None;
    }

    pub fn has_minReadySeconds(&self) -> bool {
        self.minReadySeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minReadySeconds(&mut self, v: i32) {
        self.minReadySeconds = ::std::option::Option::Some(v);
    }

    // optional .api.apps.v1beta2.StatefulSetPersistentVolumeClaimRetentionPolicy persistentVolumeClaimRetentionPolicy = 10;

    pub fn persistentVolumeClaimRetentionPolicy(&self) -> &StatefulSetPersistentVolumeClaimRetentionPolicy {
        self.persistentVolumeClaimRetentionPolicy.as_ref().unwrap_or_else(|| <StatefulSetPersistentVolumeClaimRetentionPolicy as ::protobuf::Message>::default_instance())
    }

    pub fn clear_persistentVolumeClaimRetentionPolicy(&mut self) {
        self.persistentVolumeClaimRetentionPolicy.clear();
    }

    pub fn has_persistentVolumeClaimRetentionPolicy(&self) -> bool {
        self.persistentVolumeClaimRetentionPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persistentVolumeClaimRetentionPolicy(&mut self, v: StatefulSetPersistentVolumeClaimRetentionPolicy) {
        self.persistentVolumeClaimRetentionPolicy = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persistentVolumeClaimRetentionPolicy(&mut self) -> &mut StatefulSetPersistentVolumeClaimRetentionPolicy {
        self.persistentVolumeClaimRetentionPolicy.mut_or_insert_default()
    }

    // Take field
    pub fn take_persistentVolumeClaimRetentionPolicy(&mut self) -> StatefulSetPersistentVolumeClaimRetentionPolicy {
        self.persistentVolumeClaimRetentionPolicy.take().unwrap_or_else(|| StatefulSetPersistentVolumeClaimRetentionPolicy::new())
    }

    // optional .api.apps.v1beta2.StatefulSetOrdinals ordinals = 11;

    pub fn ordinals(&self) -> &StatefulSetOrdinals {
        self.ordinals.as_ref().unwrap_or_else(|| <StatefulSetOrdinals as ::protobuf::Message>::default_instance())
    }

    pub fn clear_ordinals(&mut self) {
        self.ordinals.clear();
    }

    pub fn has_ordinals(&self) -> bool {
        self.ordinals.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinals(&mut self, v: StatefulSetOrdinals) {
        self.ordinals = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ordinals(&mut self) -> &mut StatefulSetOrdinals {
        self.ordinals.mut_or_insert_default()
    }

    // Take field
    pub fn take_ordinals(&mut self) -> StatefulSetOrdinals {
        self.ordinals.take().unwrap_or_else(|| StatefulSetOrdinals::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &StatefulSetSpec| { &m.replicas },
            |m: &mut StatefulSetSpec| { &mut m.replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "selector",
            |m: &StatefulSetSpec| { &m.selector },
            |m: &mut StatefulSetSpec| { &mut m.selector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::api::core::v1::PodTemplateSpec>(
            "template",
            |m: &StatefulSetSpec| { &m.template },
            |m: &mut StatefulSetSpec| { &mut m.template },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "volumeClaimTemplates",
            |m: &StatefulSetSpec| { &m.volumeClaimTemplates },
            |m: &mut StatefulSetSpec| { &mut m.volumeClaimTemplates },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serviceName",
            |m: &StatefulSetSpec| { &m.serviceName },
            |m: &mut StatefulSetSpec| { &mut m.serviceName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "podManagementPolicy",
            |m: &StatefulSetSpec| { &m.podManagementPolicy },
            |m: &mut StatefulSetSpec| { &mut m.podManagementPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StatefulSetUpdateStrategy>(
            "updateStrategy",
            |m: &StatefulSetSpec| { &m.updateStrategy },
            |m: &mut StatefulSetSpec| { &mut m.updateStrategy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revisionHistoryLimit",
            |m: &StatefulSetSpec| { &m.revisionHistoryLimit },
            |m: &mut StatefulSetSpec| { &mut m.revisionHistoryLimit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minReadySeconds",
            |m: &StatefulSetSpec| { &m.minReadySeconds },
            |m: &mut StatefulSetSpec| { &mut m.minReadySeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StatefulSetPersistentVolumeClaimRetentionPolicy>(
            "persistentVolumeClaimRetentionPolicy",
            |m: &StatefulSetSpec| { &m.persistentVolumeClaimRetentionPolicy },
            |m: &mut StatefulSetSpec| { &mut m.persistentVolumeClaimRetentionPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StatefulSetOrdinals>(
            "ordinals",
            |m: &StatefulSetSpec| { &m.ordinals },
            |m: &mut StatefulSetSpec| { &mut m.ordinals },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatefulSetSpec>(
            "StatefulSetSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatefulSetSpec {
    const NAME: &'static str = "StatefulSetSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.selector)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.template)?;
                },
                34 => {
                    self.volumeClaimTemplates.push(is.read_message()?);
                },
                42 => {
                    self.serviceName = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.podManagementPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.updateStrategy)?;
                },
                64 => {
                    self.revisionHistoryLimit = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.minReadySeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.persistentVolumeClaimRetentionPolicy)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ordinals)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.volumeClaimTemplates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.serviceName.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.podManagementPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.updateStrategy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.revisionHistoryLimit {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.minReadySeconds {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.persistentVolumeClaimRetentionPolicy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ordinals.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.replicas {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.selector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.template.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.volumeClaimTemplates {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.serviceName.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.podManagementPolicy.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.updateStrategy.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.revisionHistoryLimit {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.minReadySeconds {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.persistentVolumeClaimRetentionPolicy.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.ordinals.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatefulSetSpec {
        StatefulSetSpec::new()
    }

    fn clear(&mut self) {
        self.replicas = ::std::option::Option::None;
        self.selector.clear();
        self.template.clear();
        self.volumeClaimTemplates.clear();
        self.serviceName = ::std::option::Option::None;
        self.podManagementPolicy = ::std::option::Option::None;
        self.updateStrategy.clear();
        self.revisionHistoryLimit = ::std::option::Option::None;
        self.minReadySeconds = ::std::option::Option::None;
        self.persistentVolumeClaimRetentionPolicy.clear();
        self.ordinals.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatefulSetSpec {
        static instance: StatefulSetSpec = StatefulSetSpec {
            replicas: ::std::option::Option::None,
            selector: ::protobuf::MessageField::none(),
            template: ::protobuf::MessageField::none(),
            volumeClaimTemplates: ::std::vec::Vec::new(),
            serviceName: ::std::option::Option::None,
            podManagementPolicy: ::std::option::Option::None,
            updateStrategy: ::protobuf::MessageField::none(),
            revisionHistoryLimit: ::std::option::Option::None,
            minReadySeconds: ::std::option::Option::None,
            persistentVolumeClaimRetentionPolicy: ::protobuf::MessageField::none(),
            ordinals: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatefulSetSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatefulSetSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatefulSetSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatefulSetSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.StatefulSetStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatefulSetStatus {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetStatus.observedGeneration)
    pub observedGeneration: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetStatus.replicas)
    pub replicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetStatus.readyReplicas)
    pub readyReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetStatus.currentReplicas)
    pub currentReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetStatus.updatedReplicas)
    pub updatedReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetStatus.currentRevision)
    pub currentRevision: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetStatus.updateRevision)
    pub updateRevision: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetStatus.collisionCount)
    pub collisionCount: ::std::option::Option<i32>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetStatus.conditions)
    pub conditions: ::std::vec::Vec<StatefulSetCondition>,
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetStatus.availableReplicas)
    pub availableReplicas: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.StatefulSetStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatefulSetStatus {
    fn default() -> &'a StatefulSetStatus {
        <StatefulSetStatus as ::protobuf::Message>::default_instance()
    }
}

impl StatefulSetStatus {
    pub fn new() -> StatefulSetStatus {
        ::std::default::Default::default()
    }

    // optional int64 observedGeneration = 1;

    pub fn observedGeneration(&self) -> i64 {
        self.observedGeneration.unwrap_or(0)
    }

    pub fn clear_observedGeneration(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
    }

    pub fn has_observedGeneration(&self) -> bool {
        self.observedGeneration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observedGeneration(&mut self, v: i64) {
        self.observedGeneration = ::std::option::Option::Some(v);
    }

    // optional int32 replicas = 2;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // optional int32 readyReplicas = 3;

    pub fn readyReplicas(&self) -> i32 {
        self.readyReplicas.unwrap_or(0)
    }

    pub fn clear_readyReplicas(&mut self) {
        self.readyReplicas = ::std::option::Option::None;
    }

    pub fn has_readyReplicas(&self) -> bool {
        self.readyReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readyReplicas(&mut self, v: i32) {
        self.readyReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 currentReplicas = 4;

    pub fn currentReplicas(&self) -> i32 {
        self.currentReplicas.unwrap_or(0)
    }

    pub fn clear_currentReplicas(&mut self) {
        self.currentReplicas = ::std::option::Option::None;
    }

    pub fn has_currentReplicas(&self) -> bool {
        self.currentReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currentReplicas(&mut self, v: i32) {
        self.currentReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 updatedReplicas = 5;

    pub fn updatedReplicas(&self) -> i32 {
        self.updatedReplicas.unwrap_or(0)
    }

    pub fn clear_updatedReplicas(&mut self) {
        self.updatedReplicas = ::std::option::Option::None;
    }

    pub fn has_updatedReplicas(&self) -> bool {
        self.updatedReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updatedReplicas(&mut self, v: i32) {
        self.updatedReplicas = ::std::option::Option::Some(v);
    }

    // optional string currentRevision = 6;

    pub fn currentRevision(&self) -> &str {
        match self.currentRevision.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_currentRevision(&mut self) {
        self.currentRevision = ::std::option::Option::None;
    }

    pub fn has_currentRevision(&self) -> bool {
        self.currentRevision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currentRevision(&mut self, v: ::std::string::String) {
        self.currentRevision = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_currentRevision(&mut self) -> &mut ::std::string::String {
        if self.currentRevision.is_none() {
            self.currentRevision = ::std::option::Option::Some(::std::string::String::new());
        }
        self.currentRevision.as_mut().unwrap()
    }

    // Take field
    pub fn take_currentRevision(&mut self) -> ::std::string::String {
        self.currentRevision.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string updateRevision = 7;

    pub fn updateRevision(&self) -> &str {
        match self.updateRevision.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_updateRevision(&mut self) {
        self.updateRevision = ::std::option::Option::None;
    }

    pub fn has_updateRevision(&self) -> bool {
        self.updateRevision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updateRevision(&mut self, v: ::std::string::String) {
        self.updateRevision = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updateRevision(&mut self) -> &mut ::std::string::String {
        if self.updateRevision.is_none() {
            self.updateRevision = ::std::option::Option::Some(::std::string::String::new());
        }
        self.updateRevision.as_mut().unwrap()
    }

    // Take field
    pub fn take_updateRevision(&mut self) -> ::std::string::String {
        self.updateRevision.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 collisionCount = 9;

    pub fn collisionCount(&self) -> i32 {
        self.collisionCount.unwrap_or(0)
    }

    pub fn clear_collisionCount(&mut self) {
        self.collisionCount = ::std::option::Option::None;
    }

    pub fn has_collisionCount(&self) -> bool {
        self.collisionCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_collisionCount(&mut self, v: i32) {
        self.collisionCount = ::std::option::Option::Some(v);
    }

    // repeated .api.apps.v1beta2.StatefulSetCondition conditions = 10;

    pub fn conditions(&self) -> &[StatefulSetCondition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<StatefulSetCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<StatefulSetCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<StatefulSetCondition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    // optional int32 availableReplicas = 11;

    pub fn availableReplicas(&self) -> i32 {
        self.availableReplicas.unwrap_or(0)
    }

    pub fn clear_availableReplicas(&mut self) {
        self.availableReplicas = ::std::option::Option::None;
    }

    pub fn has_availableReplicas(&self) -> bool {
        self.availableReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_availableReplicas(&mut self, v: i32) {
        self.availableReplicas = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "observedGeneration",
            |m: &StatefulSetStatus| { &m.observedGeneration },
            |m: &mut StatefulSetStatus| { &mut m.observedGeneration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &StatefulSetStatus| { &m.replicas },
            |m: &mut StatefulSetStatus| { &mut m.replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readyReplicas",
            |m: &StatefulSetStatus| { &m.readyReplicas },
            |m: &mut StatefulSetStatus| { &mut m.readyReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currentReplicas",
            |m: &StatefulSetStatus| { &m.currentReplicas },
            |m: &mut StatefulSetStatus| { &mut m.currentReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "updatedReplicas",
            |m: &StatefulSetStatus| { &m.updatedReplicas },
            |m: &mut StatefulSetStatus| { &mut m.updatedReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currentRevision",
            |m: &StatefulSetStatus| { &m.currentRevision },
            |m: &mut StatefulSetStatus| { &mut m.currentRevision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "updateRevision",
            |m: &StatefulSetStatus| { &m.updateRevision },
            |m: &mut StatefulSetStatus| { &mut m.updateRevision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "collisionCount",
            |m: &StatefulSetStatus| { &m.collisionCount },
            |m: &mut StatefulSetStatus| { &mut m.collisionCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &StatefulSetStatus| { &m.conditions },
            |m: &mut StatefulSetStatus| { &mut m.conditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "availableReplicas",
            |m: &StatefulSetStatus| { &m.availableReplicas },
            |m: &mut StatefulSetStatus| { &mut m.availableReplicas },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatefulSetStatus>(
            "StatefulSetStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatefulSetStatus {
    const NAME: &'static str = "StatefulSetStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.observedGeneration = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.readyReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.currentReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.updatedReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    self.currentRevision = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.updateRevision = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.collisionCount = ::std::option::Option::Some(is.read_int32()?);
                },
                82 => {
                    self.conditions.push(is.read_message()?);
                },
                88 => {
                    self.availableReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.observedGeneration {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.readyReplicas {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.currentReplicas {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.updatedReplicas {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.currentRevision.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.updateRevision.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.collisionCount {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.availableReplicas {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.observedGeneration {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.replicas {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.readyReplicas {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.currentReplicas {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.updatedReplicas {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.currentRevision.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.updateRevision.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.collisionCount {
            os.write_int32(9, v)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        if let Some(v) = self.availableReplicas {
            os.write_int32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatefulSetStatus {
        StatefulSetStatus::new()
    }

    fn clear(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
        self.replicas = ::std::option::Option::None;
        self.readyReplicas = ::std::option::Option::None;
        self.currentReplicas = ::std::option::Option::None;
        self.updatedReplicas = ::std::option::Option::None;
        self.currentRevision = ::std::option::Option::None;
        self.updateRevision = ::std::option::Option::None;
        self.collisionCount = ::std::option::Option::None;
        self.conditions.clear();
        self.availableReplicas = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatefulSetStatus {
        static instance: StatefulSetStatus = StatefulSetStatus {
            observedGeneration: ::std::option::Option::None,
            replicas: ::std::option::Option::None,
            readyReplicas: ::std::option::Option::None,
            currentReplicas: ::std::option::Option::None,
            updatedReplicas: ::std::option::Option::None,
            currentRevision: ::std::option::Option::None,
            updateRevision: ::std::option::Option::None,
            collisionCount: ::std::option::Option::None,
            conditions: ::std::vec::Vec::new(),
            availableReplicas: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatefulSetStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatefulSetStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatefulSetStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatefulSetStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta2.StatefulSetUpdateStrategy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatefulSetUpdateStrategy {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetUpdateStrategy.type)
    pub type_: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta2.StatefulSetUpdateStrategy.rollingUpdate)
    pub rollingUpdate: ::protobuf::MessageField<RollingUpdateStatefulSetStrategy>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta2.StatefulSetUpdateStrategy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatefulSetUpdateStrategy {
    fn default() -> &'a StatefulSetUpdateStrategy {
        <StatefulSetUpdateStrategy as ::protobuf::Message>::default_instance()
    }
}

impl StatefulSetUpdateStrategy {
    pub fn new() -> StatefulSetUpdateStrategy {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.apps.v1beta2.RollingUpdateStatefulSetStrategy rollingUpdate = 2;

    pub fn rollingUpdate(&self) -> &RollingUpdateStatefulSetStrategy {
        self.rollingUpdate.as_ref().unwrap_or_else(|| <RollingUpdateStatefulSetStrategy as ::protobuf::Message>::default_instance())
    }

    pub fn clear_rollingUpdate(&mut self) {
        self.rollingUpdate.clear();
    }

    pub fn has_rollingUpdate(&self) -> bool {
        self.rollingUpdate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollingUpdate(&mut self, v: RollingUpdateStatefulSetStrategy) {
        self.rollingUpdate = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollingUpdate(&mut self) -> &mut RollingUpdateStatefulSetStrategy {
        self.rollingUpdate.mut_or_insert_default()
    }

    // Take field
    pub fn take_rollingUpdate(&mut self) -> RollingUpdateStatefulSetStrategy {
        self.rollingUpdate.take().unwrap_or_else(|| RollingUpdateStatefulSetStrategy::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &StatefulSetUpdateStrategy| { &m.type_ },
            |m: &mut StatefulSetUpdateStrategy| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RollingUpdateStatefulSetStrategy>(
            "rollingUpdate",
            |m: &StatefulSetUpdateStrategy| { &m.rollingUpdate },
            |m: &mut StatefulSetUpdateStrategy| { &mut m.rollingUpdate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatefulSetUpdateStrategy>(
            "StatefulSetUpdateStrategy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatefulSetUpdateStrategy {
    const NAME: &'static str = "StatefulSetUpdateStrategy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rollingUpdate)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.rollingUpdate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.rollingUpdate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatefulSetUpdateStrategy {
        StatefulSetUpdateStrategy::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.rollingUpdate.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatefulSetUpdateStrategy {
        static instance: StatefulSetUpdateStrategy = StatefulSetUpdateStrategy {
            type_: ::std::option::Option::None,
            rollingUpdate: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatefulSetUpdateStrategy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatefulSetUpdateStrategy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatefulSetUpdateStrategy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatefulSetUpdateStrategy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20api/apps/v1beta2/generated.proto\x12\x10api.apps.v1beta2\x1a\x1bap\
    i/core/v1/generated.proto\x1a-apimachinery/pkg/apis/meta/v1/generated.pr\
    oto\x1a(apimachinery/pkg/runtime/generated.proto\x1a/apimachinery/pkg/ru\
    ntime/schema/generated.proto\x1a,apimachinery/pkg/util/intstr/generated.\
    proto\"\xb3\x01\n\x12ControllerRevision\x12E\n\x08metadata\x18\x01\x20\
    \x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12:\n\
    \x04data\x18\x02\x20\x01(\x0b2&.apimachinery.pkg.runtime.RawExtensionR\
    \x04data\x12\x1a\n\x08revision\x18\x03\x20\x01(\x03R\x08revision\"\x99\
    \x01\n\x16ControllerRevisionList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b\
    2'.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12:\n\x05items\
    \x18\x02\x20\x03(\x0b2$.api.apps.v1beta2.ControllerRevisionR\x05items\"\
    \xc2\x01\n\tDaemonSet\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachi\
    nery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x123\n\x04spec\x18\x02\x20\
    \x01(\x0b2\x1f.api.apps.v1beta2.DaemonSetSpecR\x04spec\x129\n\x06status\
    \x18\x03\x20\x01(\x0b2!.api.apps.v1beta2.DaemonSetStatusR\x06status\"\
    \xc7\x01\n\x12DaemonSetCondition\x12\x12\n\x04type\x18\x01\x20\x01(\tR\
    \x04type\x12\x16\n\x06status\x18\x02\x20\x01(\tR\x06status\x12S\n\x12las\
    tTransitionTime\x18\x03\x20\x01(\x0b2#.apimachinery.pkg.apis.meta.v1.Tim\
    eR\x12lastTransitionTime\x12\x16\n\x06reason\x18\x04\x20\x01(\tR\x06reas\
    on\x12\x18\n\x07message\x18\x05\x20\x01(\tR\x07message\"\x87\x01\n\rDaem\
    onSetList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.api\
    s.meta.v1.ListMetaR\x08metadata\x121\n\x05items\x18\x02\x20\x03(\x0b2\
    \x1b.api.apps.v1beta2.DaemonSetR\x05items\"\xc4\x02\n\rDaemonSetSpec\x12\
    H\n\x08selector\x18\x01\x20\x01(\x0b2,.apimachinery.pkg.apis.meta.v1.Lab\
    elSelectorR\x08selector\x128\n\x08template\x18\x02\x20\x01(\x0b2\x1c.api\
    .core.v1.PodTemplateSpecR\x08template\x12Q\n\x0eupdateStrategy\x18\x03\
    \x20\x01(\x0b2).api.apps.v1beta2.DaemonSetUpdateStrategyR\x0eupdateStrat\
    egy\x12(\n\x0fminReadySeconds\x18\x04\x20\x01(\x05R\x0fminReadySeconds\
    \x122\n\x14revisionHistoryLimit\x18\x06\x20\x01(\x05R\x14revisionHistory\
    Limit\"\x81\x04\n\x0fDaemonSetStatus\x126\n\x16currentNumberScheduled\
    \x18\x01\x20\x01(\x05R\x16currentNumberScheduled\x12.\n\x12numberMissche\
    duled\x18\x02\x20\x01(\x05R\x12numberMisscheduled\x126\n\x16desiredNumbe\
    rScheduled\x18\x03\x20\x01(\x05R\x16desiredNumberScheduled\x12\x20\n\x0b\
    numberReady\x18\x04\x20\x01(\x05R\x0bnumberReady\x12.\n\x12observedGener\
    ation\x18\x05\x20\x01(\x03R\x12observedGeneration\x126\n\x16updatedNumbe\
    rScheduled\x18\x06\x20\x01(\x05R\x16updatedNumberScheduled\x12(\n\x0fnum\
    berAvailable\x18\x07\x20\x01(\x05R\x0fnumberAvailable\x12,\n\x11numberUn\
    available\x18\x08\x20\x01(\x05R\x11numberUnavailable\x12&\n\x0ecollision\
    Count\x18\t\x20\x01(\x05R\x0ecollisionCount\x12D\n\nconditions\x18\n\x20\
    \x03(\x0b2$.api.apps.v1beta2.DaemonSetConditionR\nconditions\"}\n\x17Dae\
    monSetUpdateStrategy\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12N\
    \n\rrollingUpdate\x18\x02\x20\x01(\x0b2(.api.apps.v1beta2.RollingUpdateD\
    aemonSetR\rrollingUpdate\"\xc5\x01\n\nDeployment\x12E\n\x08metadata\x18\
    \x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadat\
    a\x124\n\x04spec\x18\x02\x20\x01(\x0b2\x20.api.apps.v1beta2.DeploymentSp\
    ecR\x04spec\x12:\n\x06status\x18\x03\x20\x01(\x0b2\".api.apps.v1beta2.De\
    ploymentStatusR\x06status\"\x95\x02\n\x13DeploymentCondition\x12\x12\n\
    \x04type\x18\x01\x20\x01(\tR\x04type\x12\x16\n\x06status\x18\x02\x20\x01\
    (\tR\x06status\x12K\n\x0elastUpdateTime\x18\x06\x20\x01(\x0b2#.apimachin\
    ery.pkg.apis.meta.v1.TimeR\x0elastUpdateTime\x12S\n\x12lastTransitionTim\
    e\x18\x07\x20\x01(\x0b2#.apimachinery.pkg.apis.meta.v1.TimeR\x12lastTran\
    sitionTime\x12\x16\n\x06reason\x18\x04\x20\x01(\tR\x06reason\x12\x18\n\
    \x07message\x18\x05\x20\x01(\tR\x07message\"\x89\x01\n\x0eDeploymentList\
    \x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1\
    .ListMetaR\x08metadata\x122\n\x05items\x18\x02\x20\x03(\x0b2\x1c.api.app\
    s.v1beta2.DeploymentR\x05items\"\xa2\x03\n\x0eDeploymentSpec\x12\x1a\n\
    \x08replicas\x18\x01\x20\x01(\x05R\x08replicas\x12H\n\x08selector\x18\
    \x02\x20\x01(\x0b2,.apimachinery.pkg.apis.meta.v1.LabelSelectorR\x08sele\
    ctor\x128\n\x08template\x18\x03\x20\x01(\x0b2\x1c.api.core.v1.PodTemplat\
    eSpecR\x08template\x12@\n\x08strategy\x18\x04\x20\x01(\x0b2$.api.apps.v1\
    beta2.DeploymentStrategyR\x08strategy\x12(\n\x0fminReadySeconds\x18\x05\
    \x20\x01(\x05R\x0fminReadySeconds\x122\n\x14revisionHistoryLimit\x18\x06\
    \x20\x01(\x05R\x14revisionHistoryLimit\x12\x16\n\x06paused\x18\x07\x20\
    \x01(\x08R\x06paused\x128\n\x17progressDeadlineSeconds\x18\t\x20\x01(\
    \x05R\x17progressDeadlineSeconds\"\xfd\x02\n\x10DeploymentStatus\x12.\n\
    \x12observedGeneration\x18\x01\x20\x01(\x03R\x12observedGeneration\x12\
    \x1a\n\x08replicas\x18\x02\x20\x01(\x05R\x08replicas\x12(\n\x0fupdatedRe\
    plicas\x18\x03\x20\x01(\x05R\x0fupdatedReplicas\x12$\n\rreadyReplicas\
    \x18\x07\x20\x01(\x05R\rreadyReplicas\x12,\n\x11availableReplicas\x18\
    \x04\x20\x01(\x05R\x11availableReplicas\x120\n\x13unavailableReplicas\
    \x18\x05\x20\x01(\x05R\x13unavailableReplicas\x12E\n\nconditions\x18\x06\
    \x20\x03(\x0b2%.api.apps.v1beta2.DeploymentConditionR\nconditions\x12&\n\
    \x0ecollisionCount\x18\x08\x20\x01(\x05R\x0ecollisionCount\"y\n\x12Deplo\
    ymentStrategy\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12O\n\rroll\
    ingUpdate\x18\x02\x20\x01(\x0b2).api.apps.v1beta2.RollingUpdateDeploymen\
    tR\rrollingUpdate\"\xc5\x01\n\nReplicaSet\x12E\n\x08metadata\x18\x01\x20\
    \x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x124\n\
    \x04spec\x18\x02\x20\x01(\x0b2\x20.api.apps.v1beta2.ReplicaSetSpecR\x04s\
    pec\x12:\n\x06status\x18\x03\x20\x01(\x0b2\".api.apps.v1beta2.ReplicaSet\
    StatusR\x06status\"\xc8\x01\n\x13ReplicaSetCondition\x12\x12\n\x04type\
    \x18\x01\x20\x01(\tR\x04type\x12\x16\n\x06status\x18\x02\x20\x01(\tR\x06\
    status\x12S\n\x12lastTransitionTime\x18\x03\x20\x01(\x0b2#.apimachinery.\
    pkg.apis.meta.v1.TimeR\x12lastTransitionTime\x12\x16\n\x06reason\x18\x04\
    \x20\x01(\tR\x06reason\x12\x18\n\x07message\x18\x05\x20\x01(\tR\x07messa\
    ge\"\x89\x01\n\x0eReplicaSetList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b\
    2'.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x122\n\x05items\
    \x18\x02\x20\x03(\x0b2\x1c.api.apps.v1beta2.ReplicaSetR\x05items\"\xda\
    \x01\n\x0eReplicaSetSpec\x12\x1a\n\x08replicas\x18\x01\x20\x01(\x05R\x08\
    replicas\x12(\n\x0fminReadySeconds\x18\x04\x20\x01(\x05R\x0fminReadySeco\
    nds\x12H\n\x08selector\x18\x02\x20\x01(\x0b2,.apimachinery.pkg.apis.meta\
    .v1.LabelSelectorR\x08selector\x128\n\x08template\x18\x03\x20\x01(\x0b2\
    \x1c.api.core.v1.PodTemplateSpecR\x08template\"\xad\x02\n\x10ReplicaSetS\
    tatus\x12\x1a\n\x08replicas\x18\x01\x20\x01(\x05R\x08replicas\x122\n\x14\
    fullyLabeledReplicas\x18\x02\x20\x01(\x05R\x14fullyLabeledReplicas\x12$\
    \n\rreadyReplicas\x18\x04\x20\x01(\x05R\rreadyReplicas\x12,\n\x11availab\
    leReplicas\x18\x05\x20\x01(\x05R\x11availableReplicas\x12.\n\x12observed\
    Generation\x18\x03\x20\x01(\x03R\x12observedGeneration\x12E\n\ncondition\
    s\x18\x06\x20\x03(\x0b2%.api.apps.v1beta2.ReplicaSetConditionR\nconditio\
    ns\"\xb2\x01\n\x16RollingUpdateDaemonSet\x12Q\n\x0emaxUnavailable\x18\
    \x01\x20\x01(\x0b2).apimachinery.pkg.util.intstr.IntOrStringR\x0emaxUnav\
    ailable\x12E\n\x08maxSurge\x18\x02\x20\x01(\x0b2).apimachinery.pkg.util.\
    intstr.IntOrStringR\x08maxSurge\"\xb3\x01\n\x17RollingUpdateDeployment\
    \x12Q\n\x0emaxUnavailable\x18\x01\x20\x01(\x0b2).apimachinery.pkg.util.i\
    ntstr.IntOrStringR\x0emaxUnavailable\x12E\n\x08maxSurge\x18\x02\x20\x01(\
    \x0b2).apimachinery.pkg.util.intstr.IntOrStringR\x08maxSurge\"\x93\x01\n\
    \x20RollingUpdateStatefulSetStrategy\x12\x1c\n\tpartition\x18\x01\x20\
    \x01(\x05R\tpartition\x12Q\n\x0emaxUnavailable\x18\x02\x20\x01(\x0b2).ap\
    imachinery.pkg.util.intstr.IntOrStringR\x0emaxUnavailable\"\xb6\x01\n\
    \x05Scale\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.api\
    s.meta.v1.ObjectMetaR\x08metadata\x12/\n\x04spec\x18\x02\x20\x01(\x0b2\
    \x1b.api.apps.v1beta2.ScaleSpecR\x04spec\x125\n\x06status\x18\x03\x20\
    \x01(\x0b2\x1d.api.apps.v1beta2.ScaleStatusR\x06status\"'\n\tScaleSpec\
    \x12\x1a\n\x08replicas\x18\x01\x20\x01(\x05R\x08replicas\"\xd7\x01\n\x0b\
    ScaleStatus\x12\x1a\n\x08replicas\x18\x01\x20\x01(\x05R\x08replicas\x12G\
    \n\x08selector\x18\x02\x20\x03(\x0b2+.api.apps.v1beta2.ScaleStatus.Selec\
    torEntryR\x08selector\x12&\n\x0etargetSelector\x18\x03\x20\x01(\tR\x0eta\
    rgetSelector\x1a;\n\rSelectorEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xc8\
    \x01\n\x0bStatefulSet\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachi\
    nery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x125\n\x04spec\x18\x02\x20\
    \x01(\x0b2!.api.apps.v1beta2.StatefulSetSpecR\x04spec\x12;\n\x06status\
    \x18\x03\x20\x01(\x0b2#.api.apps.v1beta2.StatefulSetStatusR\x06status\"\
    \xc9\x01\n\x14StatefulSetCondition\x12\x12\n\x04type\x18\x01\x20\x01(\tR\
    \x04type\x12\x16\n\x06status\x18\x02\x20\x01(\tR\x06status\x12S\n\x12las\
    tTransitionTime\x18\x03\x20\x01(\x0b2#.apimachinery.pkg.apis.meta.v1.Tim\
    eR\x12lastTransitionTime\x12\x16\n\x06reason\x18\x04\x20\x01(\tR\x06reas\
    on\x12\x18\n\x07message\x18\x05\x20\x01(\tR\x07message\"\x8b\x01\n\x0fSt\
    atefulSetList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg\
    .apis.meta.v1.ListMetaR\x08metadata\x123\n\x05items\x18\x02\x20\x03(\x0b\
    2\x1d.api.apps.v1beta2.StatefulSetR\x05items\"+\n\x13StatefulSetOrdinals\
    \x12\x14\n\x05start\x18\x01\x20\x01(\x05R\x05start\"s\n/StatefulSetPersi\
    stentVolumeClaimRetentionPolicy\x12\x20\n\x0bwhenDeleted\x18\x01\x20\x01\
    (\tR\x0bwhenDeleted\x12\x1e\n\nwhenScaled\x18\x02\x20\x01(\tR\nwhenScale\
    d\"\xeb\x05\n\x0fStatefulSetSpec\x12\x1a\n\x08replicas\x18\x01\x20\x01(\
    \x05R\x08replicas\x12H\n\x08selector\x18\x02\x20\x01(\x0b2,.apimachinery\
    .pkg.apis.meta.v1.LabelSelectorR\x08selector\x128\n\x08template\x18\x03\
    \x20\x01(\x0b2\x1c.api.core.v1.PodTemplateSpecR\x08template\x12V\n\x14vo\
    lumeClaimTemplates\x18\x04\x20\x03(\x0b2\".api.core.v1.PersistentVolumeC\
    laimR\x14volumeClaimTemplates\x12\x20\n\x0bserviceName\x18\x05\x20\x01(\
    \tR\x0bserviceName\x120\n\x13podManagementPolicy\x18\x06\x20\x01(\tR\x13\
    podManagementPolicy\x12S\n\x0eupdateStrategy\x18\x07\x20\x01(\x0b2+.api.\
    apps.v1beta2.StatefulSetUpdateStrategyR\x0eupdateStrategy\x122\n\x14revi\
    sionHistoryLimit\x18\x08\x20\x01(\x05R\x14revisionHistoryLimit\x12(\n\
    \x0fminReadySeconds\x18\t\x20\x01(\x05R\x0fminReadySeconds\x12\x95\x01\n\
    $persistentVolumeClaimRetentionPolicy\x18\n\x20\x01(\x0b2A.api.apps.v1be\
    ta2.StatefulSetPersistentVolumeClaimRetentionPolicyR$persistentVolumeCla\
    imRetentionPolicy\x12A\n\x08ordinals\x18\x0b\x20\x01(\x0b2%.api.apps.v1b\
    eta2.StatefulSetOrdinalsR\x08ordinals\"\xc9\x03\n\x11StatefulSetStatus\
    \x12.\n\x12observedGeneration\x18\x01\x20\x01(\x03R\x12observedGeneratio\
    n\x12\x1a\n\x08replicas\x18\x02\x20\x01(\x05R\x08replicas\x12$\n\rreadyR\
    eplicas\x18\x03\x20\x01(\x05R\rreadyReplicas\x12(\n\x0fcurrentReplicas\
    \x18\x04\x20\x01(\x05R\x0fcurrentReplicas\x12(\n\x0fupdatedReplicas\x18\
    \x05\x20\x01(\x05R\x0fupdatedReplicas\x12(\n\x0fcurrentRevision\x18\x06\
    \x20\x01(\tR\x0fcurrentRevision\x12&\n\x0eupdateRevision\x18\x07\x20\x01\
    (\tR\x0eupdateRevision\x12&\n\x0ecollisionCount\x18\t\x20\x01(\x05R\x0ec\
    ollisionCount\x12F\n\nconditions\x18\n\x20\x03(\x0b2&.api.apps.v1beta2.S\
    tatefulSetConditionR\nconditions\x12,\n\x11availableReplicas\x18\x0b\x20\
    \x01(\x05R\x11availableReplicas\"\x89\x01\n\x19StatefulSetUpdateStrategy\
    \x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12X\n\rrollingUpdate\x18\
    \x02\x20\x01(\x0b22.api.apps.v1beta2.RollingUpdateStatefulSetStrategyR\r\
    rollingUpdateB\x19Z\x17k8s.io/api/apps/v1beta2\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(5);
            deps.push(super::v1beta2::file_descriptor().clone());
            deps.push(super::v1beta2::file_descriptor().clone());
            deps.push(super::v1beta2::file_descriptor().clone());
            deps.push(super::v1beta2::file_descriptor().clone());
            deps.push(super::v1beta2::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(33);
            messages.push(ControllerRevision::generated_message_descriptor_data());
            messages.push(ControllerRevisionList::generated_message_descriptor_data());
            messages.push(DaemonSet::generated_message_descriptor_data());
            messages.push(DaemonSetCondition::generated_message_descriptor_data());
            messages.push(DaemonSetList::generated_message_descriptor_data());
            messages.push(DaemonSetSpec::generated_message_descriptor_data());
            messages.push(DaemonSetStatus::generated_message_descriptor_data());
            messages.push(DaemonSetUpdateStrategy::generated_message_descriptor_data());
            messages.push(Deployment::generated_message_descriptor_data());
            messages.push(DeploymentCondition::generated_message_descriptor_data());
            messages.push(DeploymentList::generated_message_descriptor_data());
            messages.push(DeploymentSpec::generated_message_descriptor_data());
            messages.push(DeploymentStatus::generated_message_descriptor_data());
            messages.push(DeploymentStrategy::generated_message_descriptor_data());
            messages.push(ReplicaSet::generated_message_descriptor_data());
            messages.push(ReplicaSetCondition::generated_message_descriptor_data());
            messages.push(ReplicaSetList::generated_message_descriptor_data());
            messages.push(ReplicaSetSpec::generated_message_descriptor_data());
            messages.push(ReplicaSetStatus::generated_message_descriptor_data());
            messages.push(RollingUpdateDaemonSet::generated_message_descriptor_data());
            messages.push(RollingUpdateDeployment::generated_message_descriptor_data());
            messages.push(RollingUpdateStatefulSetStrategy::generated_message_descriptor_data());
            messages.push(Scale::generated_message_descriptor_data());
            messages.push(ScaleSpec::generated_message_descriptor_data());
            messages.push(ScaleStatus::generated_message_descriptor_data());
            messages.push(StatefulSet::generated_message_descriptor_data());
            messages.push(StatefulSetCondition::generated_message_descriptor_data());
            messages.push(StatefulSetList::generated_message_descriptor_data());
            messages.push(StatefulSetOrdinals::generated_message_descriptor_data());
            messages.push(StatefulSetPersistentVolumeClaimRetentionPolicy::generated_message_descriptor_data());
            messages.push(StatefulSetSpec::generated_message_descriptor_data());
            messages.push(StatefulSetStatus::generated_message_descriptor_data());
            messages.push(StatefulSetUpdateStrategy::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
