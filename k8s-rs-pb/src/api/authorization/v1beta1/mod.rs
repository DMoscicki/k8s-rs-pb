// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by protoc 28.3
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `api/authorization/v1beta1/generated.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.authorization.v1beta1.ExtraValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExtraValue {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.ExtraValue.items)
    pub items: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.authorization.v1beta1.ExtraValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExtraValue {
    fn default() -> &'a ExtraValue {
        <ExtraValue as ::protobuf::Message>::default_instance()
    }
}

impl ExtraValue {
    pub fn new() -> ExtraValue {
        ::std::default::Default::default()
    }

    // repeated string items = 1;

    pub fn items(&self) -> &[::std::string::String] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ExtraValue| { &m.items },
            |m: &mut ExtraValue| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExtraValue>(
            "ExtraValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExtraValue {
    const NAME: &'static str = "ExtraValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.items.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.items {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.items {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExtraValue {
        ExtraValue::new()
    }

    fn clear(&mut self) {
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExtraValue {
        static instance: ExtraValue = ExtraValue {
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExtraValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExtraValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExtraValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtraValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.authorization.v1beta1.LocalSubjectAccessReview)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LocalSubjectAccessReview {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.LocalSubjectAccessReview.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.LocalSubjectAccessReview.spec)
    pub spec: ::protobuf::MessageField<SubjectAccessReviewSpec>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.LocalSubjectAccessReview.status)
    pub status: ::protobuf::MessageField<SubjectAccessReviewStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.authorization.v1beta1.LocalSubjectAccessReview.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LocalSubjectAccessReview {
    fn default() -> &'a LocalSubjectAccessReview {
        <LocalSubjectAccessReview as ::protobuf::Message>::default_instance()
    }
}

impl LocalSubjectAccessReview {
    pub fn new() -> LocalSubjectAccessReview {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.authorization.v1beta1.SubjectAccessReviewSpec spec = 2;

    pub fn spec(&self) -> &SubjectAccessReviewSpec {
        self.spec.as_ref().unwrap_or_else(|| <SubjectAccessReviewSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: SubjectAccessReviewSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut SubjectAccessReviewSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> SubjectAccessReviewSpec {
        self.spec.take().unwrap_or_else(|| SubjectAccessReviewSpec::new())
    }

    // optional .api.authorization.v1beta1.SubjectAccessReviewStatus status = 3;

    pub fn status(&self) -> &SubjectAccessReviewStatus {
        self.status.as_ref().unwrap_or_else(|| <SubjectAccessReviewStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: SubjectAccessReviewStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut SubjectAccessReviewStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> SubjectAccessReviewStatus {
        self.status.take().unwrap_or_else(|| SubjectAccessReviewStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &LocalSubjectAccessReview| { &m.metadata },
            |m: &mut LocalSubjectAccessReview| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SubjectAccessReviewSpec>(
            "spec",
            |m: &LocalSubjectAccessReview| { &m.spec },
            |m: &mut LocalSubjectAccessReview| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SubjectAccessReviewStatus>(
            "status",
            |m: &LocalSubjectAccessReview| { &m.status },
            |m: &mut LocalSubjectAccessReview| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LocalSubjectAccessReview>(
            "LocalSubjectAccessReview",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LocalSubjectAccessReview {
    const NAME: &'static str = "LocalSubjectAccessReview";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LocalSubjectAccessReview {
        LocalSubjectAccessReview::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LocalSubjectAccessReview {
        static instance: LocalSubjectAccessReview = LocalSubjectAccessReview {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LocalSubjectAccessReview {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LocalSubjectAccessReview").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LocalSubjectAccessReview {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocalSubjectAccessReview {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.authorization.v1beta1.NonResourceAttributes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NonResourceAttributes {
    // message fields
    // @@protoc_insertion_point(field:api.authorization.v1beta1.NonResourceAttributes.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.authorization.v1beta1.NonResourceAttributes.verb)
    pub verb: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.authorization.v1beta1.NonResourceAttributes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NonResourceAttributes {
    fn default() -> &'a NonResourceAttributes {
        <NonResourceAttributes as ::protobuf::Message>::default_instance()
    }
}

impl NonResourceAttributes {
    pub fn new() -> NonResourceAttributes {
        ::std::default::Default::default()
    }

    // optional string path = 1;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string verb = 2;

    pub fn verb(&self) -> &str {
        match self.verb.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_verb(&mut self) {
        self.verb = ::std::option::Option::None;
    }

    pub fn has_verb(&self) -> bool {
        self.verb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_verb(&mut self, v: ::std::string::String) {
        self.verb = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_verb(&mut self) -> &mut ::std::string::String {
        if self.verb.is_none() {
            self.verb = ::std::option::Option::Some(::std::string::String::new());
        }
        self.verb.as_mut().unwrap()
    }

    // Take field
    pub fn take_verb(&mut self) -> ::std::string::String {
        self.verb.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &NonResourceAttributes| { &m.path },
            |m: &mut NonResourceAttributes| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "verb",
            |m: &NonResourceAttributes| { &m.verb },
            |m: &mut NonResourceAttributes| { &mut m.verb },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NonResourceAttributes>(
            "NonResourceAttributes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NonResourceAttributes {
    const NAME: &'static str = "NonResourceAttributes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.verb = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.verb.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.path.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.verb.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NonResourceAttributes {
        NonResourceAttributes::new()
    }

    fn clear(&mut self) {
        self.path = ::std::option::Option::None;
        self.verb = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NonResourceAttributes {
        static instance: NonResourceAttributes = NonResourceAttributes {
            path: ::std::option::Option::None,
            verb: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NonResourceAttributes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NonResourceAttributes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NonResourceAttributes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NonResourceAttributes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.authorization.v1beta1.NonResourceRule)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NonResourceRule {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.NonResourceRule.verbs)
    pub verbs: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.NonResourceRule.nonResourceURLs)
    pub nonResourceURLs: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.authorization.v1beta1.NonResourceRule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NonResourceRule {
    fn default() -> &'a NonResourceRule {
        <NonResourceRule as ::protobuf::Message>::default_instance()
    }
}

impl NonResourceRule {
    pub fn new() -> NonResourceRule {
        ::std::default::Default::default()
    }

    // repeated string verbs = 1;

    pub fn verbs(&self) -> &[::std::string::String] {
        &self.verbs
    }

    pub fn clear_verbs(&mut self) {
        self.verbs.clear();
    }

    // Param is passed by value, moved
    pub fn set_verbs(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.verbs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_verbs(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.verbs
    }

    // Take field
    pub fn take_verbs(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.verbs, ::std::vec::Vec::new())
    }

    // repeated string nonResourceURLs = 2;

    pub fn nonResourceURLs(&self) -> &[::std::string::String] {
        &self.nonResourceURLs
    }

    pub fn clear_nonResourceURLs(&mut self) {
        self.nonResourceURLs.clear();
    }

    // Param is passed by value, moved
    pub fn set_nonResourceURLs(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.nonResourceURLs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nonResourceURLs(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.nonResourceURLs
    }

    // Take field
    pub fn take_nonResourceURLs(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.nonResourceURLs, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "verbs",
            |m: &NonResourceRule| { &m.verbs },
            |m: &mut NonResourceRule| { &mut m.verbs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nonResourceURLs",
            |m: &NonResourceRule| { &m.nonResourceURLs },
            |m: &mut NonResourceRule| { &mut m.nonResourceURLs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NonResourceRule>(
            "NonResourceRule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NonResourceRule {
    const NAME: &'static str = "NonResourceRule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.verbs.push(is.read_string()?);
                },
                18 => {
                    self.nonResourceURLs.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.verbs {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.nonResourceURLs {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.verbs {
            os.write_string(1, &v)?;
        };
        for v in &self.nonResourceURLs {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NonResourceRule {
        NonResourceRule::new()
    }

    fn clear(&mut self) {
        self.verbs.clear();
        self.nonResourceURLs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NonResourceRule {
        static instance: NonResourceRule = NonResourceRule {
            verbs: ::std::vec::Vec::new(),
            nonResourceURLs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NonResourceRule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NonResourceRule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NonResourceRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NonResourceRule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.authorization.v1beta1.ResourceAttributes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceAttributes {
    // message fields
    // @@protoc_insertion_point(field:api.authorization.v1beta1.ResourceAttributes.namespace)
    pub namespace: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.authorization.v1beta1.ResourceAttributes.verb)
    pub verb: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.authorization.v1beta1.ResourceAttributes.group)
    pub group: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.authorization.v1beta1.ResourceAttributes.version)
    pub version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.authorization.v1beta1.ResourceAttributes.resource)
    pub resource: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.authorization.v1beta1.ResourceAttributes.subresource)
    pub subresource: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.authorization.v1beta1.ResourceAttributes.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.authorization.v1beta1.ResourceAttributes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceAttributes {
    fn default() -> &'a ResourceAttributes {
        <ResourceAttributes as ::protobuf::Message>::default_instance()
    }
}

impl ResourceAttributes {
    pub fn new() -> ResourceAttributes {
        ::std::default::Default::default()
    }

    // optional string namespace = 1;

    pub fn namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_namespace(&mut self) {
        self.namespace = ::std::option::Option::None;
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string verb = 2;

    pub fn verb(&self) -> &str {
        match self.verb.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_verb(&mut self) {
        self.verb = ::std::option::Option::None;
    }

    pub fn has_verb(&self) -> bool {
        self.verb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_verb(&mut self, v: ::std::string::String) {
        self.verb = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_verb(&mut self) -> &mut ::std::string::String {
        if self.verb.is_none() {
            self.verb = ::std::option::Option::Some(::std::string::String::new());
        }
        self.verb.as_mut().unwrap()
    }

    // Take field
    pub fn take_verb(&mut self) -> ::std::string::String {
        self.verb.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string group = 3;

    pub fn group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_group(&mut self) {
        self.group = ::std::option::Option::None;
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group = ::std::option::Option::Some(::std::string::String::new());
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 4;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resource = 5;

    pub fn resource(&self) -> &str {
        match self.resource.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resource(&mut self) {
        self.resource = ::std::option::Option::None;
    }

    pub fn has_resource(&self) -> bool {
        self.resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: ::std::string::String) {
        self.resource = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut ::std::string::String {
        if self.resource.is_none() {
            self.resource = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resource.as_mut().unwrap()
    }

    // Take field
    pub fn take_resource(&mut self) -> ::std::string::String {
        self.resource.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string subresource = 6;

    pub fn subresource(&self) -> &str {
        match self.subresource.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_subresource(&mut self) {
        self.subresource = ::std::option::Option::None;
    }

    pub fn has_subresource(&self) -> bool {
        self.subresource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subresource(&mut self, v: ::std::string::String) {
        self.subresource = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subresource(&mut self) -> &mut ::std::string::String {
        if self.subresource.is_none() {
            self.subresource = ::std::option::Option::Some(::std::string::String::new());
        }
        self.subresource.as_mut().unwrap()
    }

    // Take field
    pub fn take_subresource(&mut self) -> ::std::string::String {
        self.subresource.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 7;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "namespace",
            |m: &ResourceAttributes| { &m.namespace },
            |m: &mut ResourceAttributes| { &mut m.namespace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "verb",
            |m: &ResourceAttributes| { &m.verb },
            |m: &mut ResourceAttributes| { &mut m.verb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "group",
            |m: &ResourceAttributes| { &m.group },
            |m: &mut ResourceAttributes| { &mut m.group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &ResourceAttributes| { &m.version },
            |m: &mut ResourceAttributes| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resource",
            |m: &ResourceAttributes| { &m.resource },
            |m: &mut ResourceAttributes| { &mut m.resource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subresource",
            |m: &ResourceAttributes| { &m.subresource },
            |m: &mut ResourceAttributes| { &mut m.subresource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ResourceAttributes| { &m.name },
            |m: &mut ResourceAttributes| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceAttributes>(
            "ResourceAttributes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceAttributes {
    const NAME: &'static str = "ResourceAttributes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.namespace = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.verb = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.group = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.resource = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.subresource = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.verb.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.resource.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.subresource.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.namespace.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.verb.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.group.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.resource.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.subresource.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceAttributes {
        ResourceAttributes::new()
    }

    fn clear(&mut self) {
        self.namespace = ::std::option::Option::None;
        self.verb = ::std::option::Option::None;
        self.group = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.resource = ::std::option::Option::None;
        self.subresource = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceAttributes {
        static instance: ResourceAttributes = ResourceAttributes {
            namespace: ::std::option::Option::None,
            verb: ::std::option::Option::None,
            group: ::std::option::Option::None,
            version: ::std::option::Option::None,
            resource: ::std::option::Option::None,
            subresource: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceAttributes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceAttributes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceAttributes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceAttributes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.authorization.v1beta1.ResourceRule)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceRule {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.ResourceRule.verbs)
    pub verbs: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.ResourceRule.apiGroups)
    pub apiGroups: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.ResourceRule.resources)
    pub resources: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.ResourceRule.resourceNames)
    pub resourceNames: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.authorization.v1beta1.ResourceRule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceRule {
    fn default() -> &'a ResourceRule {
        <ResourceRule as ::protobuf::Message>::default_instance()
    }
}

impl ResourceRule {
    pub fn new() -> ResourceRule {
        ::std::default::Default::default()
    }

    // repeated string verbs = 1;

    pub fn verbs(&self) -> &[::std::string::String] {
        &self.verbs
    }

    pub fn clear_verbs(&mut self) {
        self.verbs.clear();
    }

    // Param is passed by value, moved
    pub fn set_verbs(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.verbs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_verbs(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.verbs
    }

    // Take field
    pub fn take_verbs(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.verbs, ::std::vec::Vec::new())
    }

    // repeated string apiGroups = 2;

    pub fn apiGroups(&self) -> &[::std::string::String] {
        &self.apiGroups
    }

    pub fn clear_apiGroups(&mut self) {
        self.apiGroups.clear();
    }

    // Param is passed by value, moved
    pub fn set_apiGroups(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.apiGroups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apiGroups(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.apiGroups
    }

    // Take field
    pub fn take_apiGroups(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.apiGroups, ::std::vec::Vec::new())
    }

    // repeated string resources = 3;

    pub fn resources(&self) -> &[::std::string::String] {
        &self.resources
    }

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.resources, ::std::vec::Vec::new())
    }

    // repeated string resourceNames = 4;

    pub fn resourceNames(&self) -> &[::std::string::String] {
        &self.resourceNames
    }

    pub fn clear_resourceNames(&mut self) {
        self.resourceNames.clear();
    }

    // Param is passed by value, moved
    pub fn set_resourceNames(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.resourceNames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resourceNames(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.resourceNames
    }

    // Take field
    pub fn take_resourceNames(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.resourceNames, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "verbs",
            |m: &ResourceRule| { &m.verbs },
            |m: &mut ResourceRule| { &mut m.verbs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apiGroups",
            |m: &ResourceRule| { &m.apiGroups },
            |m: &mut ResourceRule| { &mut m.apiGroups },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resources",
            |m: &ResourceRule| { &m.resources },
            |m: &mut ResourceRule| { &mut m.resources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resourceNames",
            |m: &ResourceRule| { &m.resourceNames },
            |m: &mut ResourceRule| { &mut m.resourceNames },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceRule>(
            "ResourceRule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceRule {
    const NAME: &'static str = "ResourceRule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.verbs.push(is.read_string()?);
                },
                18 => {
                    self.apiGroups.push(is.read_string()?);
                },
                26 => {
                    self.resources.push(is.read_string()?);
                },
                34 => {
                    self.resourceNames.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.verbs {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.apiGroups {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.resources {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.resourceNames {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.verbs {
            os.write_string(1, &v)?;
        };
        for v in &self.apiGroups {
            os.write_string(2, &v)?;
        };
        for v in &self.resources {
            os.write_string(3, &v)?;
        };
        for v in &self.resourceNames {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceRule {
        ResourceRule::new()
    }

    fn clear(&mut self) {
        self.verbs.clear();
        self.apiGroups.clear();
        self.resources.clear();
        self.resourceNames.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceRule {
        static instance: ResourceRule = ResourceRule {
            verbs: ::std::vec::Vec::new(),
            apiGroups: ::std::vec::Vec::new(),
            resources: ::std::vec::Vec::new(),
            resourceNames: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceRule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceRule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceRule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.authorization.v1beta1.SelfSubjectAccessReview)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SelfSubjectAccessReview {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SelfSubjectAccessReview.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SelfSubjectAccessReview.spec)
    pub spec: ::protobuf::MessageField<SelfSubjectAccessReviewSpec>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SelfSubjectAccessReview.status)
    pub status: ::protobuf::MessageField<SubjectAccessReviewStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.authorization.v1beta1.SelfSubjectAccessReview.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SelfSubjectAccessReview {
    fn default() -> &'a SelfSubjectAccessReview {
        <SelfSubjectAccessReview as ::protobuf::Message>::default_instance()
    }
}

impl SelfSubjectAccessReview {
    pub fn new() -> SelfSubjectAccessReview {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.authorization.v1beta1.SelfSubjectAccessReviewSpec spec = 2;

    pub fn spec(&self) -> &SelfSubjectAccessReviewSpec {
        self.spec.as_ref().unwrap_or_else(|| <SelfSubjectAccessReviewSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: SelfSubjectAccessReviewSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut SelfSubjectAccessReviewSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> SelfSubjectAccessReviewSpec {
        self.spec.take().unwrap_or_else(|| SelfSubjectAccessReviewSpec::new())
    }

    // optional .api.authorization.v1beta1.SubjectAccessReviewStatus status = 3;

    pub fn status(&self) -> &SubjectAccessReviewStatus {
        self.status.as_ref().unwrap_or_else(|| <SubjectAccessReviewStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: SubjectAccessReviewStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut SubjectAccessReviewStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> SubjectAccessReviewStatus {
        self.status.take().unwrap_or_else(|| SubjectAccessReviewStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &SelfSubjectAccessReview| { &m.metadata },
            |m: &mut SelfSubjectAccessReview| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SelfSubjectAccessReviewSpec>(
            "spec",
            |m: &SelfSubjectAccessReview| { &m.spec },
            |m: &mut SelfSubjectAccessReview| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SubjectAccessReviewStatus>(
            "status",
            |m: &SelfSubjectAccessReview| { &m.status },
            |m: &mut SelfSubjectAccessReview| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelfSubjectAccessReview>(
            "SelfSubjectAccessReview",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SelfSubjectAccessReview {
    const NAME: &'static str = "SelfSubjectAccessReview";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SelfSubjectAccessReview {
        SelfSubjectAccessReview::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SelfSubjectAccessReview {
        static instance: SelfSubjectAccessReview = SelfSubjectAccessReview {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SelfSubjectAccessReview {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SelfSubjectAccessReview").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SelfSubjectAccessReview {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelfSubjectAccessReview {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.authorization.v1beta1.SelfSubjectAccessReviewSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SelfSubjectAccessReviewSpec {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SelfSubjectAccessReviewSpec.resourceAttributes)
    pub resourceAttributes: ::protobuf::MessageField<ResourceAttributes>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SelfSubjectAccessReviewSpec.nonResourceAttributes)
    pub nonResourceAttributes: ::protobuf::MessageField<NonResourceAttributes>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.authorization.v1beta1.SelfSubjectAccessReviewSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SelfSubjectAccessReviewSpec {
    fn default() -> &'a SelfSubjectAccessReviewSpec {
        <SelfSubjectAccessReviewSpec as ::protobuf::Message>::default_instance()
    }
}

impl SelfSubjectAccessReviewSpec {
    pub fn new() -> SelfSubjectAccessReviewSpec {
        ::std::default::Default::default()
    }

    // optional .api.authorization.v1beta1.ResourceAttributes resourceAttributes = 1;

    pub fn resourceAttributes(&self) -> &ResourceAttributes {
        self.resourceAttributes.as_ref().unwrap_or_else(|| <ResourceAttributes as ::protobuf::Message>::default_instance())
    }

    pub fn clear_resourceAttributes(&mut self) {
        self.resourceAttributes.clear();
    }

    pub fn has_resourceAttributes(&self) -> bool {
        self.resourceAttributes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceAttributes(&mut self, v: ResourceAttributes) {
        self.resourceAttributes = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceAttributes(&mut self) -> &mut ResourceAttributes {
        self.resourceAttributes.mut_or_insert_default()
    }

    // Take field
    pub fn take_resourceAttributes(&mut self) -> ResourceAttributes {
        self.resourceAttributes.take().unwrap_or_else(|| ResourceAttributes::new())
    }

    // optional .api.authorization.v1beta1.NonResourceAttributes nonResourceAttributes = 2;

    pub fn nonResourceAttributes(&self) -> &NonResourceAttributes {
        self.nonResourceAttributes.as_ref().unwrap_or_else(|| <NonResourceAttributes as ::protobuf::Message>::default_instance())
    }

    pub fn clear_nonResourceAttributes(&mut self) {
        self.nonResourceAttributes.clear();
    }

    pub fn has_nonResourceAttributes(&self) -> bool {
        self.nonResourceAttributes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nonResourceAttributes(&mut self, v: NonResourceAttributes) {
        self.nonResourceAttributes = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonResourceAttributes(&mut self) -> &mut NonResourceAttributes {
        self.nonResourceAttributes.mut_or_insert_default()
    }

    // Take field
    pub fn take_nonResourceAttributes(&mut self) -> NonResourceAttributes {
        self.nonResourceAttributes.take().unwrap_or_else(|| NonResourceAttributes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceAttributes>(
            "resourceAttributes",
            |m: &SelfSubjectAccessReviewSpec| { &m.resourceAttributes },
            |m: &mut SelfSubjectAccessReviewSpec| { &mut m.resourceAttributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NonResourceAttributes>(
            "nonResourceAttributes",
            |m: &SelfSubjectAccessReviewSpec| { &m.nonResourceAttributes },
            |m: &mut SelfSubjectAccessReviewSpec| { &mut m.nonResourceAttributes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelfSubjectAccessReviewSpec>(
            "SelfSubjectAccessReviewSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SelfSubjectAccessReviewSpec {
    const NAME: &'static str = "SelfSubjectAccessReviewSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resourceAttributes)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.nonResourceAttributes)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.resourceAttributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.nonResourceAttributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.resourceAttributes.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.nonResourceAttributes.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SelfSubjectAccessReviewSpec {
        SelfSubjectAccessReviewSpec::new()
    }

    fn clear(&mut self) {
        self.resourceAttributes.clear();
        self.nonResourceAttributes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SelfSubjectAccessReviewSpec {
        static instance: SelfSubjectAccessReviewSpec = SelfSubjectAccessReviewSpec {
            resourceAttributes: ::protobuf::MessageField::none(),
            nonResourceAttributes: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SelfSubjectAccessReviewSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SelfSubjectAccessReviewSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SelfSubjectAccessReviewSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelfSubjectAccessReviewSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.authorization.v1beta1.SelfSubjectRulesReview)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SelfSubjectRulesReview {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SelfSubjectRulesReview.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SelfSubjectRulesReview.spec)
    pub spec: ::protobuf::MessageField<SelfSubjectRulesReviewSpec>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SelfSubjectRulesReview.status)
    pub status: ::protobuf::MessageField<SubjectRulesReviewStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.authorization.v1beta1.SelfSubjectRulesReview.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SelfSubjectRulesReview {
    fn default() -> &'a SelfSubjectRulesReview {
        <SelfSubjectRulesReview as ::protobuf::Message>::default_instance()
    }
}

impl SelfSubjectRulesReview {
    pub fn new() -> SelfSubjectRulesReview {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.authorization.v1beta1.SelfSubjectRulesReviewSpec spec = 2;

    pub fn spec(&self) -> &SelfSubjectRulesReviewSpec {
        self.spec.as_ref().unwrap_or_else(|| <SelfSubjectRulesReviewSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: SelfSubjectRulesReviewSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut SelfSubjectRulesReviewSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> SelfSubjectRulesReviewSpec {
        self.spec.take().unwrap_or_else(|| SelfSubjectRulesReviewSpec::new())
    }

    // optional .api.authorization.v1beta1.SubjectRulesReviewStatus status = 3;

    pub fn status(&self) -> &SubjectRulesReviewStatus {
        self.status.as_ref().unwrap_or_else(|| <SubjectRulesReviewStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: SubjectRulesReviewStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut SubjectRulesReviewStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> SubjectRulesReviewStatus {
        self.status.take().unwrap_or_else(|| SubjectRulesReviewStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &SelfSubjectRulesReview| { &m.metadata },
            |m: &mut SelfSubjectRulesReview| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SelfSubjectRulesReviewSpec>(
            "spec",
            |m: &SelfSubjectRulesReview| { &m.spec },
            |m: &mut SelfSubjectRulesReview| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SubjectRulesReviewStatus>(
            "status",
            |m: &SelfSubjectRulesReview| { &m.status },
            |m: &mut SelfSubjectRulesReview| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelfSubjectRulesReview>(
            "SelfSubjectRulesReview",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SelfSubjectRulesReview {
    const NAME: &'static str = "SelfSubjectRulesReview";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SelfSubjectRulesReview {
        SelfSubjectRulesReview::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SelfSubjectRulesReview {
        static instance: SelfSubjectRulesReview = SelfSubjectRulesReview {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SelfSubjectRulesReview {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SelfSubjectRulesReview").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SelfSubjectRulesReview {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelfSubjectRulesReview {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.authorization.v1beta1.SelfSubjectRulesReviewSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SelfSubjectRulesReviewSpec {
    // message fields
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SelfSubjectRulesReviewSpec.namespace)
    pub namespace: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.authorization.v1beta1.SelfSubjectRulesReviewSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SelfSubjectRulesReviewSpec {
    fn default() -> &'a SelfSubjectRulesReviewSpec {
        <SelfSubjectRulesReviewSpec as ::protobuf::Message>::default_instance()
    }
}

impl SelfSubjectRulesReviewSpec {
    pub fn new() -> SelfSubjectRulesReviewSpec {
        ::std::default::Default::default()
    }

    // optional string namespace = 1;

    pub fn namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_namespace(&mut self) {
        self.namespace = ::std::option::Option::None;
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "namespace",
            |m: &SelfSubjectRulesReviewSpec| { &m.namespace },
            |m: &mut SelfSubjectRulesReviewSpec| { &mut m.namespace },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelfSubjectRulesReviewSpec>(
            "SelfSubjectRulesReviewSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SelfSubjectRulesReviewSpec {
    const NAME: &'static str = "SelfSubjectRulesReviewSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.namespace = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.namespace.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SelfSubjectRulesReviewSpec {
        SelfSubjectRulesReviewSpec::new()
    }

    fn clear(&mut self) {
        self.namespace = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SelfSubjectRulesReviewSpec {
        static instance: SelfSubjectRulesReviewSpec = SelfSubjectRulesReviewSpec {
            namespace: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SelfSubjectRulesReviewSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SelfSubjectRulesReviewSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SelfSubjectRulesReviewSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelfSubjectRulesReviewSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.authorization.v1beta1.SubjectAccessReview)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubjectAccessReview {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SubjectAccessReview.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SubjectAccessReview.spec)
    pub spec: ::protobuf::MessageField<SubjectAccessReviewSpec>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SubjectAccessReview.status)
    pub status: ::protobuf::MessageField<SubjectAccessReviewStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.authorization.v1beta1.SubjectAccessReview.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubjectAccessReview {
    fn default() -> &'a SubjectAccessReview {
        <SubjectAccessReview as ::protobuf::Message>::default_instance()
    }
}

impl SubjectAccessReview {
    pub fn new() -> SubjectAccessReview {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.authorization.v1beta1.SubjectAccessReviewSpec spec = 2;

    pub fn spec(&self) -> &SubjectAccessReviewSpec {
        self.spec.as_ref().unwrap_or_else(|| <SubjectAccessReviewSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: SubjectAccessReviewSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut SubjectAccessReviewSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> SubjectAccessReviewSpec {
        self.spec.take().unwrap_or_else(|| SubjectAccessReviewSpec::new())
    }

    // optional .api.authorization.v1beta1.SubjectAccessReviewStatus status = 3;

    pub fn status(&self) -> &SubjectAccessReviewStatus {
        self.status.as_ref().unwrap_or_else(|| <SubjectAccessReviewStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: SubjectAccessReviewStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut SubjectAccessReviewStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> SubjectAccessReviewStatus {
        self.status.take().unwrap_or_else(|| SubjectAccessReviewStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &SubjectAccessReview| { &m.metadata },
            |m: &mut SubjectAccessReview| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SubjectAccessReviewSpec>(
            "spec",
            |m: &SubjectAccessReview| { &m.spec },
            |m: &mut SubjectAccessReview| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SubjectAccessReviewStatus>(
            "status",
            |m: &SubjectAccessReview| { &m.status },
            |m: &mut SubjectAccessReview| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubjectAccessReview>(
            "SubjectAccessReview",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubjectAccessReview {
    const NAME: &'static str = "SubjectAccessReview";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubjectAccessReview {
        SubjectAccessReview::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubjectAccessReview {
        static instance: SubjectAccessReview = SubjectAccessReview {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubjectAccessReview {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubjectAccessReview").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubjectAccessReview {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubjectAccessReview {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.authorization.v1beta1.SubjectAccessReviewSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubjectAccessReviewSpec {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SubjectAccessReviewSpec.resourceAttributes)
    pub resourceAttributes: ::protobuf::MessageField<ResourceAttributes>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SubjectAccessReviewSpec.nonResourceAttributes)
    pub nonResourceAttributes: ::protobuf::MessageField<NonResourceAttributes>,
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SubjectAccessReviewSpec.user)
    pub user: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SubjectAccessReviewSpec.group)
    pub group: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SubjectAccessReviewSpec.extra)
    pub extra: ::std::collections::BTreeMap<::std::string::String, ExtraValue>,
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SubjectAccessReviewSpec.uid)
    pub uid: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.authorization.v1beta1.SubjectAccessReviewSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubjectAccessReviewSpec {
    fn default() -> &'a SubjectAccessReviewSpec {
        <SubjectAccessReviewSpec as ::protobuf::Message>::default_instance()
    }
}

impl SubjectAccessReviewSpec {
    pub fn new() -> SubjectAccessReviewSpec {
        ::std::default::Default::default()
    }

    // optional .api.authorization.v1beta1.ResourceAttributes resourceAttributes = 1;

    pub fn resourceAttributes(&self) -> &ResourceAttributes {
        self.resourceAttributes.as_ref().unwrap_or_else(|| <ResourceAttributes as ::protobuf::Message>::default_instance())
    }

    pub fn clear_resourceAttributes(&mut self) {
        self.resourceAttributes.clear();
    }

    pub fn has_resourceAttributes(&self) -> bool {
        self.resourceAttributes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceAttributes(&mut self, v: ResourceAttributes) {
        self.resourceAttributes = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceAttributes(&mut self) -> &mut ResourceAttributes {
        self.resourceAttributes.mut_or_insert_default()
    }

    // Take field
    pub fn take_resourceAttributes(&mut self) -> ResourceAttributes {
        self.resourceAttributes.take().unwrap_or_else(|| ResourceAttributes::new())
    }

    // optional .api.authorization.v1beta1.NonResourceAttributes nonResourceAttributes = 2;

    pub fn nonResourceAttributes(&self) -> &NonResourceAttributes {
        self.nonResourceAttributes.as_ref().unwrap_or_else(|| <NonResourceAttributes as ::protobuf::Message>::default_instance())
    }

    pub fn clear_nonResourceAttributes(&mut self) {
        self.nonResourceAttributes.clear();
    }

    pub fn has_nonResourceAttributes(&self) -> bool {
        self.nonResourceAttributes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nonResourceAttributes(&mut self, v: NonResourceAttributes) {
        self.nonResourceAttributes = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonResourceAttributes(&mut self) -> &mut NonResourceAttributes {
        self.nonResourceAttributes.mut_or_insert_default()
    }

    // Take field
    pub fn take_nonResourceAttributes(&mut self) -> NonResourceAttributes {
        self.nonResourceAttributes.take().unwrap_or_else(|| NonResourceAttributes::new())
    }

    // optional string user = 3;

    pub fn user(&self) -> &str {
        match self.user.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_user(&mut self) {
        self.user = ::std::option::Option::None;
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        if self.user.is_none() {
            self.user = ::std::option::Option::Some(::std::string::String::new());
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string group = 4;

    pub fn group(&self) -> &[::std::string::String] {
        &self.group
    }

    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.group = v;
    }

    // Mutable pointer to the field.
    pub fn mut_group(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.group
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.group, ::std::vec::Vec::new())
    }

    // repeated .api.authorization.v1beta1.SubjectAccessReviewSpec.ExtraEntry extra = 5;

    pub fn extra(&self) -> &::std::collections::BTreeMap<::std::string::String, ExtraValue> {
        &self.extra
    }

    pub fn clear_extra(&mut self) {
        self.extra.clear();
    }

    // Param is passed by value, moved
    pub fn set_extra(&mut self, v: ::std::collections::BTreeMap<::std::string::String, ExtraValue>) {
        self.extra = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extra(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, ExtraValue> {
        &mut self.extra
    }

    // Take field
    pub fn take_extra(&mut self) -> ::std::collections::BTreeMap<::std::string::String, ExtraValue> {
        ::std::mem::replace(&mut self.extra, ::std::collections::BTreeMap::new())
    }

    // optional string uid = 6;

    pub fn uid(&self) -> &str {
        match self.uid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_uid(&mut self) {
        self.uid = ::std::option::Option::None;
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if self.uid.is_none() {
            self.uid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        self.uid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceAttributes>(
            "resourceAttributes",
            |m: &SubjectAccessReviewSpec| { &m.resourceAttributes },
            |m: &mut SubjectAccessReviewSpec| { &mut m.resourceAttributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NonResourceAttributes>(
            "nonResourceAttributes",
            |m: &SubjectAccessReviewSpec| { &m.nonResourceAttributes },
            |m: &mut SubjectAccessReviewSpec| { &mut m.nonResourceAttributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user",
            |m: &SubjectAccessReviewSpec| { &m.user },
            |m: &mut SubjectAccessReviewSpec| { &mut m.user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "group",
            |m: &SubjectAccessReviewSpec| { &m.group },
            |m: &mut SubjectAccessReviewSpec| { &mut m.group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "extra",
            |m: &SubjectAccessReviewSpec| { &m.extra },
            |m: &mut SubjectAccessReviewSpec| { &mut m.extra },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uid",
            |m: &SubjectAccessReviewSpec| { &m.uid },
            |m: &mut SubjectAccessReviewSpec| { &mut m.uid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubjectAccessReviewSpec>(
            "SubjectAccessReviewSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubjectAccessReviewSpec {
    const NAME: &'static str = "SubjectAccessReviewSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resourceAttributes)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.nonResourceAttributes)?;
                },
                26 => {
                    self.user = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.group.push(is.read_string()?);
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.extra.insert(key, value);
                },
                50 => {
                    self.uid = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.resourceAttributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.nonResourceAttributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.group {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for (k, v) in &self.extra {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.uid.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.resourceAttributes.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.nonResourceAttributes.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.user.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.group {
            os.write_string(4, &v)?;
        };
        for (k, v) in &self.extra {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.uid.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubjectAccessReviewSpec {
        SubjectAccessReviewSpec::new()
    }

    fn clear(&mut self) {
        self.resourceAttributes.clear();
        self.nonResourceAttributes.clear();
        self.user = ::std::option::Option::None;
        self.group.clear();
        self.extra.clear();
        self.uid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubjectAccessReviewSpec {
        static instance: ::protobuf::rt::Lazy<SubjectAccessReviewSpec> = ::protobuf::rt::Lazy::new();
        instance.get(SubjectAccessReviewSpec::new)
    }
}

impl ::protobuf::MessageFull for SubjectAccessReviewSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubjectAccessReviewSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubjectAccessReviewSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubjectAccessReviewSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.authorization.v1beta1.SubjectAccessReviewStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubjectAccessReviewStatus {
    // message fields
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SubjectAccessReviewStatus.allowed)
    pub allowed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SubjectAccessReviewStatus.denied)
    pub denied: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SubjectAccessReviewStatus.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SubjectAccessReviewStatus.evaluationError)
    pub evaluationError: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.authorization.v1beta1.SubjectAccessReviewStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubjectAccessReviewStatus {
    fn default() -> &'a SubjectAccessReviewStatus {
        <SubjectAccessReviewStatus as ::protobuf::Message>::default_instance()
    }
}

impl SubjectAccessReviewStatus {
    pub fn new() -> SubjectAccessReviewStatus {
        ::std::default::Default::default()
    }

    // optional bool allowed = 1;

    pub fn allowed(&self) -> bool {
        self.allowed.unwrap_or(false)
    }

    pub fn clear_allowed(&mut self) {
        self.allowed = ::std::option::Option::None;
    }

    pub fn has_allowed(&self) -> bool {
        self.allowed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allowed(&mut self, v: bool) {
        self.allowed = ::std::option::Option::Some(v);
    }

    // optional bool denied = 4;

    pub fn denied(&self) -> bool {
        self.denied.unwrap_or(false)
    }

    pub fn clear_denied(&mut self) {
        self.denied = ::std::option::Option::None;
    }

    pub fn has_denied(&self) -> bool {
        self.denied.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denied(&mut self, v: bool) {
        self.denied = ::std::option::Option::Some(v);
    }

    // optional string reason = 2;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string evaluationError = 3;

    pub fn evaluationError(&self) -> &str {
        match self.evaluationError.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_evaluationError(&mut self) {
        self.evaluationError = ::std::option::Option::None;
    }

    pub fn has_evaluationError(&self) -> bool {
        self.evaluationError.is_some()
    }

    // Param is passed by value, moved
    pub fn set_evaluationError(&mut self, v: ::std::string::String) {
        self.evaluationError = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_evaluationError(&mut self) -> &mut ::std::string::String {
        if self.evaluationError.is_none() {
            self.evaluationError = ::std::option::Option::Some(::std::string::String::new());
        }
        self.evaluationError.as_mut().unwrap()
    }

    // Take field
    pub fn take_evaluationError(&mut self) -> ::std::string::String {
        self.evaluationError.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allowed",
            |m: &SubjectAccessReviewStatus| { &m.allowed },
            |m: &mut SubjectAccessReviewStatus| { &mut m.allowed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "denied",
            |m: &SubjectAccessReviewStatus| { &m.denied },
            |m: &mut SubjectAccessReviewStatus| { &mut m.denied },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &SubjectAccessReviewStatus| { &m.reason },
            |m: &mut SubjectAccessReviewStatus| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "evaluationError",
            |m: &SubjectAccessReviewStatus| { &m.evaluationError },
            |m: &mut SubjectAccessReviewStatus| { &mut m.evaluationError },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubjectAccessReviewStatus>(
            "SubjectAccessReviewStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubjectAccessReviewStatus {
    const NAME: &'static str = "SubjectAccessReviewStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.allowed = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.denied = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.evaluationError = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.allowed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.denied {
            my_size += 1 + 1;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.evaluationError.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.allowed {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.denied {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.evaluationError.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubjectAccessReviewStatus {
        SubjectAccessReviewStatus::new()
    }

    fn clear(&mut self) {
        self.allowed = ::std::option::Option::None;
        self.denied = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.evaluationError = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubjectAccessReviewStatus {
        static instance: SubjectAccessReviewStatus = SubjectAccessReviewStatus {
            allowed: ::std::option::Option::None,
            denied: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            evaluationError: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubjectAccessReviewStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubjectAccessReviewStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubjectAccessReviewStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubjectAccessReviewStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.authorization.v1beta1.SubjectRulesReviewStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubjectRulesReviewStatus {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SubjectRulesReviewStatus.resourceRules)
    pub resourceRules: ::std::vec::Vec<ResourceRule>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SubjectRulesReviewStatus.nonResourceRules)
    pub nonResourceRules: ::std::vec::Vec<NonResourceRule>,
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SubjectRulesReviewStatus.incomplete)
    pub incomplete: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.authorization.v1beta1.SubjectRulesReviewStatus.evaluationError)
    pub evaluationError: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.authorization.v1beta1.SubjectRulesReviewStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubjectRulesReviewStatus {
    fn default() -> &'a SubjectRulesReviewStatus {
        <SubjectRulesReviewStatus as ::protobuf::Message>::default_instance()
    }
}

impl SubjectRulesReviewStatus {
    pub fn new() -> SubjectRulesReviewStatus {
        ::std::default::Default::default()
    }

    // repeated .api.authorization.v1beta1.ResourceRule resourceRules = 1;

    pub fn resourceRules(&self) -> &[ResourceRule] {
        &self.resourceRules
    }

    pub fn clear_resourceRules(&mut self) {
        self.resourceRules.clear();
    }

    // Param is passed by value, moved
    pub fn set_resourceRules(&mut self, v: ::std::vec::Vec<ResourceRule>) {
        self.resourceRules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resourceRules(&mut self) -> &mut ::std::vec::Vec<ResourceRule> {
        &mut self.resourceRules
    }

    // Take field
    pub fn take_resourceRules(&mut self) -> ::std::vec::Vec<ResourceRule> {
        ::std::mem::replace(&mut self.resourceRules, ::std::vec::Vec::new())
    }

    // repeated .api.authorization.v1beta1.NonResourceRule nonResourceRules = 2;

    pub fn nonResourceRules(&self) -> &[NonResourceRule] {
        &self.nonResourceRules
    }

    pub fn clear_nonResourceRules(&mut self) {
        self.nonResourceRules.clear();
    }

    // Param is passed by value, moved
    pub fn set_nonResourceRules(&mut self, v: ::std::vec::Vec<NonResourceRule>) {
        self.nonResourceRules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nonResourceRules(&mut self) -> &mut ::std::vec::Vec<NonResourceRule> {
        &mut self.nonResourceRules
    }

    // Take field
    pub fn take_nonResourceRules(&mut self) -> ::std::vec::Vec<NonResourceRule> {
        ::std::mem::replace(&mut self.nonResourceRules, ::std::vec::Vec::new())
    }

    // optional bool incomplete = 3;

    pub fn incomplete(&self) -> bool {
        self.incomplete.unwrap_or(false)
    }

    pub fn clear_incomplete(&mut self) {
        self.incomplete = ::std::option::Option::None;
    }

    pub fn has_incomplete(&self) -> bool {
        self.incomplete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_incomplete(&mut self, v: bool) {
        self.incomplete = ::std::option::Option::Some(v);
    }

    // optional string evaluationError = 4;

    pub fn evaluationError(&self) -> &str {
        match self.evaluationError.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_evaluationError(&mut self) {
        self.evaluationError = ::std::option::Option::None;
    }

    pub fn has_evaluationError(&self) -> bool {
        self.evaluationError.is_some()
    }

    // Param is passed by value, moved
    pub fn set_evaluationError(&mut self, v: ::std::string::String) {
        self.evaluationError = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_evaluationError(&mut self) -> &mut ::std::string::String {
        if self.evaluationError.is_none() {
            self.evaluationError = ::std::option::Option::Some(::std::string::String::new());
        }
        self.evaluationError.as_mut().unwrap()
    }

    // Take field
    pub fn take_evaluationError(&mut self) -> ::std::string::String {
        self.evaluationError.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resourceRules",
            |m: &SubjectRulesReviewStatus| { &m.resourceRules },
            |m: &mut SubjectRulesReviewStatus| { &mut m.resourceRules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nonResourceRules",
            |m: &SubjectRulesReviewStatus| { &m.nonResourceRules },
            |m: &mut SubjectRulesReviewStatus| { &mut m.nonResourceRules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "incomplete",
            |m: &SubjectRulesReviewStatus| { &m.incomplete },
            |m: &mut SubjectRulesReviewStatus| { &mut m.incomplete },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "evaluationError",
            |m: &SubjectRulesReviewStatus| { &m.evaluationError },
            |m: &mut SubjectRulesReviewStatus| { &mut m.evaluationError },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubjectRulesReviewStatus>(
            "SubjectRulesReviewStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubjectRulesReviewStatus {
    const NAME: &'static str = "SubjectRulesReviewStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.resourceRules.push(is.read_message()?);
                },
                18 => {
                    self.nonResourceRules.push(is.read_message()?);
                },
                24 => {
                    self.incomplete = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.evaluationError = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.resourceRules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.nonResourceRules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.incomplete {
            my_size += 1 + 1;
        }
        if let Some(v) = self.evaluationError.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.resourceRules {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.nonResourceRules {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.incomplete {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.evaluationError.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubjectRulesReviewStatus {
        SubjectRulesReviewStatus::new()
    }

    fn clear(&mut self) {
        self.resourceRules.clear();
        self.nonResourceRules.clear();
        self.incomplete = ::std::option::Option::None;
        self.evaluationError = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubjectRulesReviewStatus {
        static instance: SubjectRulesReviewStatus = SubjectRulesReviewStatus {
            resourceRules: ::std::vec::Vec::new(),
            nonResourceRules: ::std::vec::Vec::new(),
            incomplete: ::std::option::Option::None,
            evaluationError: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubjectRulesReviewStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubjectRulesReviewStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubjectRulesReviewStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubjectRulesReviewStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n)api/authorization/v1beta1/generated.proto\x12\x19api.authorization.v1\
    beta1\x1a-apimachinery/pkg/apis/meta/v1/generated.proto\x1a(apimachinery\
    /pkg/runtime/generated.proto\x1a/apimachinery/pkg/runtime/schema/generat\
    ed.proto\"\"\n\nExtraValue\x12\x14\n\x05items\x18\x01\x20\x03(\tR\x05ite\
    ms\"\xf7\x01\n\x18LocalSubjectAccessReview\x12E\n\x08metadata\x18\x01\
    \x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\
    \x12F\n\x04spec\x18\x02\x20\x01(\x0b22.api.authorization.v1beta1.Subject\
    AccessReviewSpecR\x04spec\x12L\n\x06status\x18\x03\x20\x01(\x0b24.api.au\
    thorization.v1beta1.SubjectAccessReviewStatusR\x06status\"?\n\x15NonReso\
    urceAttributes\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\x12\x12\n\
    \x04verb\x18\x02\x20\x01(\tR\x04verb\"Q\n\x0fNonResourceRule\x12\x14\n\
    \x05verbs\x18\x01\x20\x03(\tR\x05verbs\x12(\n\x0fnonResourceURLs\x18\x02\
    \x20\x03(\tR\x0fnonResourceURLs\"\xc8\x01\n\x12ResourceAttributes\x12\
    \x1c\n\tnamespace\x18\x01\x20\x01(\tR\tnamespace\x12\x12\n\x04verb\x18\
    \x02\x20\x01(\tR\x04verb\x12\x14\n\x05group\x18\x03\x20\x01(\tR\x05group\
    \x12\x18\n\x07version\x18\x04\x20\x01(\tR\x07version\x12\x1a\n\x08resour\
    ce\x18\x05\x20\x01(\tR\x08resource\x12\x20\n\x0bsubresource\x18\x06\x20\
    \x01(\tR\x0bsubresource\x12\x12\n\x04name\x18\x07\x20\x01(\tR\x04name\"\
    \x86\x01\n\x0cResourceRule\x12\x14\n\x05verbs\x18\x01\x20\x03(\tR\x05ver\
    bs\x12\x1c\n\tapiGroups\x18\x02\x20\x03(\tR\tapiGroups\x12\x1c\n\tresour\
    ces\x18\x03\x20\x03(\tR\tresources\x12$\n\rresourceNames\x18\x04\x20\x03\
    (\tR\rresourceNames\"\xfa\x01\n\x17SelfSubjectAccessReview\x12E\n\x08met\
    adata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\
    \x08metadata\x12J\n\x04spec\x18\x02\x20\x01(\x0b26.api.authorization.v1b\
    eta1.SelfSubjectAccessReviewSpecR\x04spec\x12L\n\x06status\x18\x03\x20\
    \x01(\x0b24.api.authorization.v1beta1.SubjectAccessReviewStatusR\x06stat\
    us\"\xe4\x01\n\x1bSelfSubjectAccessReviewSpec\x12]\n\x12resourceAttribut\
    es\x18\x01\x20\x01(\x0b2-.api.authorization.v1beta1.ResourceAttributesR\
    \x12resourceAttributes\x12f\n\x15nonResourceAttributes\x18\x02\x20\x01(\
    \x0b20.api.authorization.v1beta1.NonResourceAttributesR\x15nonResourceAt\
    tributes\"\xf7\x01\n\x16SelfSubjectRulesReview\x12E\n\x08metadata\x18\
    \x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadat\
    a\x12I\n\x04spec\x18\x02\x20\x01(\x0b25.api.authorization.v1beta1.SelfSu\
    bjectRulesReviewSpecR\x04spec\x12K\n\x06status\x18\x03\x20\x01(\x0b23.ap\
    i.authorization.v1beta1.SubjectRulesReviewStatusR\x06status\":\n\x1aSelf\
    SubjectRulesReviewSpec\x12\x1c\n\tnamespace\x18\x01\x20\x01(\tR\tnamespa\
    ce\"\xf2\x01\n\x13SubjectAccessReview\x12E\n\x08metadata\x18\x01\x20\x01\
    (\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12F\n\x04\
    spec\x18\x02\x20\x01(\x0b22.api.authorization.v1beta1.SubjectAccessRevie\
    wSpecR\x04spec\x12L\n\x06status\x18\x03\x20\x01(\x0b24.api.authorization\
    .v1beta1.SubjectAccessReviewStatusR\x06status\"\xd2\x03\n\x17SubjectAcce\
    ssReviewSpec\x12]\n\x12resourceAttributes\x18\x01\x20\x01(\x0b2-.api.aut\
    horization.v1beta1.ResourceAttributesR\x12resourceAttributes\x12f\n\x15n\
    onResourceAttributes\x18\x02\x20\x01(\x0b20.api.authorization.v1beta1.No\
    nResourceAttributesR\x15nonResourceAttributes\x12\x12\n\x04user\x18\x03\
    \x20\x01(\tR\x04user\x12\x14\n\x05group\x18\x04\x20\x03(\tR\x05group\x12\
    S\n\x05extra\x18\x05\x20\x03(\x0b2=.api.authorization.v1beta1.SubjectAcc\
    essReviewSpec.ExtraEntryR\x05extra\x12\x10\n\x03uid\x18\x06\x20\x01(\tR\
    \x03uid\x1a_\n\nExtraEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12;\n\x05value\x18\x02\x20\x01(\x0b2%.api.authorization.v1beta1.ExtraV\
    alueR\x05value:\x028\x01\"\x8f\x01\n\x19SubjectAccessReviewStatus\x12\
    \x18\n\x07allowed\x18\x01\x20\x01(\x08R\x07allowed\x12\x16\n\x06denied\
    \x18\x04\x20\x01(\x08R\x06denied\x12\x16\n\x06reason\x18\x02\x20\x01(\tR\
    \x06reason\x12(\n\x0fevaluationError\x18\x03\x20\x01(\tR\x0fevaluationEr\
    ror\"\x8b\x02\n\x18SubjectRulesReviewStatus\x12M\n\rresourceRules\x18\
    \x01\x20\x03(\x0b2'.api.authorization.v1beta1.ResourceRuleR\rresourceRul\
    es\x12V\n\x10nonResourceRules\x18\x02\x20\x03(\x0b2*.api.authorization.v\
    1beta1.NonResourceRuleR\x10nonResourceRules\x12\x1e\n\nincomplete\x18\
    \x03\x20\x01(\x08R\nincomplete\x12(\n\x0fevaluationError\x18\x04\x20\x01\
    (\tR\x0fevaluationErrorB\"Z\x20k8s.io/api/authorization/v1beta1\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::v1beta1::file_descriptor().clone());
            deps.push(super::v1beta1::file_descriptor().clone());
            deps.push(super::v1beta1::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(14);
            messages.push(ExtraValue::generated_message_descriptor_data());
            messages.push(LocalSubjectAccessReview::generated_message_descriptor_data());
            messages.push(NonResourceAttributes::generated_message_descriptor_data());
            messages.push(NonResourceRule::generated_message_descriptor_data());
            messages.push(ResourceAttributes::generated_message_descriptor_data());
            messages.push(ResourceRule::generated_message_descriptor_data());
            messages.push(SelfSubjectAccessReview::generated_message_descriptor_data());
            messages.push(SelfSubjectAccessReviewSpec::generated_message_descriptor_data());
            messages.push(SelfSubjectRulesReview::generated_message_descriptor_data());
            messages.push(SelfSubjectRulesReviewSpec::generated_message_descriptor_data());
            messages.push(SubjectAccessReview::generated_message_descriptor_data());
            messages.push(SubjectAccessReviewSpec::generated_message_descriptor_data());
            messages.push(SubjectAccessReviewStatus::generated_message_descriptor_data());
            messages.push(SubjectRulesReviewStatus::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
