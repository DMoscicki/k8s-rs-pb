// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by protoc 3.21.12
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `api/resource/v1alpha2/generated.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.AllocationResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AllocationResult {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.AllocationResult.resourceHandles)
    pub resourceHandles: ::std::vec::Vec<ResourceHandle>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.AllocationResult.availableOnNodes)
    pub availableOnNodes: ::protobuf::MessageField<crate::api::core::v1::NodeSelector>,
    // @@protoc_insertion_point(field:api.resource.v1alpha2.AllocationResult.shareable)
    pub shareable: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.AllocationResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AllocationResult {
    fn default() -> &'a AllocationResult {
        <AllocationResult as ::protobuf::Message>::default_instance()
    }
}

impl AllocationResult {
    pub fn new() -> AllocationResult {
        ::std::default::Default::default()
    }

    // repeated .api.resource.v1alpha2.ResourceHandle resourceHandles = 1;

    pub fn resourceHandles(&self) -> &[ResourceHandle] {
        &self.resourceHandles
    }

    pub fn clear_resourceHandles(&mut self) {
        self.resourceHandles.clear();
    }

    // Param is passed by value, moved
    pub fn set_resourceHandles(&mut self, v: ::std::vec::Vec<ResourceHandle>) {
        self.resourceHandles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resourceHandles(&mut self) -> &mut ::std::vec::Vec<ResourceHandle> {
        &mut self.resourceHandles
    }

    // Take field
    pub fn take_resourceHandles(&mut self) -> ::std::vec::Vec<ResourceHandle> {
        ::std::mem::replace(&mut self.resourceHandles, ::std::vec::Vec::new())
    }

    // optional .api.core.v1.NodeSelector availableOnNodes = 2;

    pub fn availableOnNodes(&self) -> &crate::api::core::v1::NodeSelector {
        self.availableOnNodes.as_ref().unwrap_or_else(|| <crate::api::core::v1::NodeSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_availableOnNodes(&mut self) {
        self.availableOnNodes.clear();
    }

    pub fn has_availableOnNodes(&self) -> bool {
        self.availableOnNodes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_availableOnNodes(&mut self, v: crate::api::core::v1::NodeSelector) {
        self.availableOnNodes = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_availableOnNodes(&mut self) -> &mut crate::api::core::v1::NodeSelector {
        self.availableOnNodes.mut_or_insert_default()
    }

    // Take field
    pub fn take_availableOnNodes(&mut self) -> crate::api::core::v1::NodeSelector {
        self.availableOnNodes.take().unwrap_or_else(|| crate::api::core::v1::NodeSelector::new())
    }

    // optional bool shareable = 3;

    pub fn shareable(&self) -> bool {
        self.shareable.unwrap_or(false)
    }

    pub fn clear_shareable(&mut self) {
        self.shareable = ::std::option::Option::None;
    }

    pub fn has_shareable(&self) -> bool {
        self.shareable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shareable(&mut self, v: bool) {
        self.shareable = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resourceHandles",
            |m: &AllocationResult| { &m.resourceHandles },
            |m: &mut AllocationResult| { &mut m.resourceHandles },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::api::core::v1::NodeSelector>(
            "availableOnNodes",
            |m: &AllocationResult| { &m.availableOnNodes },
            |m: &mut AllocationResult| { &mut m.availableOnNodes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shareable",
            |m: &AllocationResult| { &m.shareable },
            |m: &mut AllocationResult| { &mut m.shareable },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AllocationResult>(
            "AllocationResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AllocationResult {
    const NAME: &'static str = "AllocationResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.resourceHandles.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.availableOnNodes)?;
                },
                24 => {
                    self.shareable = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.resourceHandles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.availableOnNodes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.shareable {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.resourceHandles {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.availableOnNodes.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.shareable {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AllocationResult {
        AllocationResult::new()
    }

    fn clear(&mut self) {
        self.resourceHandles.clear();
        self.availableOnNodes.clear();
        self.shareable = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AllocationResult {
        static instance: AllocationResult = AllocationResult {
            resourceHandles: ::std::vec::Vec::new(),
            availableOnNodes: ::protobuf::MessageField::none(),
            shareable: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AllocationResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AllocationResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AllocationResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllocationResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.AllocationResultModel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AllocationResultModel {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.AllocationResultModel.namedResources)
    pub namedResources: ::protobuf::MessageField<NamedResourcesAllocationResult>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.AllocationResultModel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AllocationResultModel {
    fn default() -> &'a AllocationResultModel {
        <AllocationResultModel as ::protobuf::Message>::default_instance()
    }
}

impl AllocationResultModel {
    pub fn new() -> AllocationResultModel {
        ::std::default::Default::default()
    }

    // optional .api.resource.v1alpha2.NamedResourcesAllocationResult namedResources = 1;

    pub fn namedResources(&self) -> &NamedResourcesAllocationResult {
        self.namedResources.as_ref().unwrap_or_else(|| <NamedResourcesAllocationResult as ::protobuf::Message>::default_instance())
    }

    pub fn clear_namedResources(&mut self) {
        self.namedResources.clear();
    }

    pub fn has_namedResources(&self) -> bool {
        self.namedResources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namedResources(&mut self, v: NamedResourcesAllocationResult) {
        self.namedResources = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namedResources(&mut self) -> &mut NamedResourcesAllocationResult {
        self.namedResources.mut_or_insert_default()
    }

    // Take field
    pub fn take_namedResources(&mut self) -> NamedResourcesAllocationResult {
        self.namedResources.take().unwrap_or_else(|| NamedResourcesAllocationResult::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NamedResourcesAllocationResult>(
            "namedResources",
            |m: &AllocationResultModel| { &m.namedResources },
            |m: &mut AllocationResultModel| { &mut m.namedResources },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AllocationResultModel>(
            "AllocationResultModel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AllocationResultModel {
    const NAME: &'static str = "AllocationResultModel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.namedResources)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.namedResources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.namedResources.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AllocationResultModel {
        AllocationResultModel::new()
    }

    fn clear(&mut self) {
        self.namedResources.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AllocationResultModel {
        static instance: AllocationResultModel = AllocationResultModel {
            namedResources: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AllocationResultModel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AllocationResultModel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AllocationResultModel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllocationResultModel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.DriverAllocationResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DriverAllocationResult {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.DriverAllocationResult.vendorRequestParameters)
    pub vendorRequestParameters: ::protobuf::MessageField<crate::apimachinery::pkg::runtime::RawExtension>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.DriverAllocationResult.allocationResultModel)
    pub allocationResultModel: ::protobuf::MessageField<AllocationResultModel>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.DriverAllocationResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DriverAllocationResult {
    fn default() -> &'a DriverAllocationResult {
        <DriverAllocationResult as ::protobuf::Message>::default_instance()
    }
}

impl DriverAllocationResult {
    pub fn new() -> DriverAllocationResult {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.runtime.RawExtension vendorRequestParameters = 1;

    pub fn vendorRequestParameters(&self) -> &crate::apimachinery::pkg::runtime::RawExtension {
        self.vendorRequestParameters.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::runtime::RawExtension as ::protobuf::Message>::default_instance())
    }

    pub fn clear_vendorRequestParameters(&mut self) {
        self.vendorRequestParameters.clear();
    }

    pub fn has_vendorRequestParameters(&self) -> bool {
        self.vendorRequestParameters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vendorRequestParameters(&mut self, v: crate::apimachinery::pkg::runtime::RawExtension) {
        self.vendorRequestParameters = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vendorRequestParameters(&mut self) -> &mut crate::apimachinery::pkg::runtime::RawExtension {
        self.vendorRequestParameters.mut_or_insert_default()
    }

    // Take field
    pub fn take_vendorRequestParameters(&mut self) -> crate::apimachinery::pkg::runtime::RawExtension {
        self.vendorRequestParameters.take().unwrap_or_else(|| crate::apimachinery::pkg::runtime::RawExtension::new())
    }

    // optional .api.resource.v1alpha2.AllocationResultModel allocationResultModel = 2;

    pub fn allocationResultModel(&self) -> &AllocationResultModel {
        self.allocationResultModel.as_ref().unwrap_or_else(|| <AllocationResultModel as ::protobuf::Message>::default_instance())
    }

    pub fn clear_allocationResultModel(&mut self) {
        self.allocationResultModel.clear();
    }

    pub fn has_allocationResultModel(&self) -> bool {
        self.allocationResultModel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allocationResultModel(&mut self, v: AllocationResultModel) {
        self.allocationResultModel = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allocationResultModel(&mut self) -> &mut AllocationResultModel {
        self.allocationResultModel.mut_or_insert_default()
    }

    // Take field
    pub fn take_allocationResultModel(&mut self) -> AllocationResultModel {
        self.allocationResultModel.take().unwrap_or_else(|| AllocationResultModel::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::runtime::RawExtension>(
            "vendorRequestParameters",
            |m: &DriverAllocationResult| { &m.vendorRequestParameters },
            |m: &mut DriverAllocationResult| { &mut m.vendorRequestParameters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AllocationResultModel>(
            "allocationResultModel",
            |m: &DriverAllocationResult| { &m.allocationResultModel },
            |m: &mut DriverAllocationResult| { &mut m.allocationResultModel },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DriverAllocationResult>(
            "DriverAllocationResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DriverAllocationResult {
    const NAME: &'static str = "DriverAllocationResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vendorRequestParameters)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.allocationResultModel)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.vendorRequestParameters.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.allocationResultModel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.vendorRequestParameters.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.allocationResultModel.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DriverAllocationResult {
        DriverAllocationResult::new()
    }

    fn clear(&mut self) {
        self.vendorRequestParameters.clear();
        self.allocationResultModel.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DriverAllocationResult {
        static instance: DriverAllocationResult = DriverAllocationResult {
            vendorRequestParameters: ::protobuf::MessageField::none(),
            allocationResultModel: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DriverAllocationResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DriverAllocationResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DriverAllocationResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DriverAllocationResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.DriverRequests)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DriverRequests {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1alpha2.DriverRequests.driverName)
    pub driverName: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.DriverRequests.vendorParameters)
    pub vendorParameters: ::protobuf::MessageField<crate::apimachinery::pkg::runtime::RawExtension>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.DriverRequests.requests)
    pub requests: ::std::vec::Vec<ResourceRequest>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.DriverRequests.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DriverRequests {
    fn default() -> &'a DriverRequests {
        <DriverRequests as ::protobuf::Message>::default_instance()
    }
}

impl DriverRequests {
    pub fn new() -> DriverRequests {
        ::std::default::Default::default()
    }

    // optional string driverName = 1;

    pub fn driverName(&self) -> &str {
        match self.driverName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_driverName(&mut self) {
        self.driverName = ::std::option::Option::None;
    }

    pub fn has_driverName(&self) -> bool {
        self.driverName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driverName(&mut self, v: ::std::string::String) {
        self.driverName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driverName(&mut self) -> &mut ::std::string::String {
        if self.driverName.is_none() {
            self.driverName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.driverName.as_mut().unwrap()
    }

    // Take field
    pub fn take_driverName(&mut self) -> ::std::string::String {
        self.driverName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.runtime.RawExtension vendorParameters = 2;

    pub fn vendorParameters(&self) -> &crate::apimachinery::pkg::runtime::RawExtension {
        self.vendorParameters.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::runtime::RawExtension as ::protobuf::Message>::default_instance())
    }

    pub fn clear_vendorParameters(&mut self) {
        self.vendorParameters.clear();
    }

    pub fn has_vendorParameters(&self) -> bool {
        self.vendorParameters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vendorParameters(&mut self, v: crate::apimachinery::pkg::runtime::RawExtension) {
        self.vendorParameters = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vendorParameters(&mut self) -> &mut crate::apimachinery::pkg::runtime::RawExtension {
        self.vendorParameters.mut_or_insert_default()
    }

    // Take field
    pub fn take_vendorParameters(&mut self) -> crate::apimachinery::pkg::runtime::RawExtension {
        self.vendorParameters.take().unwrap_or_else(|| crate::apimachinery::pkg::runtime::RawExtension::new())
    }

    // repeated .api.resource.v1alpha2.ResourceRequest requests = 3;

    pub fn requests(&self) -> &[ResourceRequest] {
        &self.requests
    }

    pub fn clear_requests(&mut self) {
        self.requests.clear();
    }

    // Param is passed by value, moved
    pub fn set_requests(&mut self, v: ::std::vec::Vec<ResourceRequest>) {
        self.requests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requests(&mut self) -> &mut ::std::vec::Vec<ResourceRequest> {
        &mut self.requests
    }

    // Take field
    pub fn take_requests(&mut self) -> ::std::vec::Vec<ResourceRequest> {
        ::std::mem::replace(&mut self.requests, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "driverName",
            |m: &DriverRequests| { &m.driverName },
            |m: &mut DriverRequests| { &mut m.driverName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::runtime::RawExtension>(
            "vendorParameters",
            |m: &DriverRequests| { &m.vendorParameters },
            |m: &mut DriverRequests| { &mut m.vendorParameters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "requests",
            |m: &DriverRequests| { &m.requests },
            |m: &mut DriverRequests| { &mut m.requests },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DriverRequests>(
            "DriverRequests",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DriverRequests {
    const NAME: &'static str = "DriverRequests";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.driverName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vendorParameters)?;
                },
                26 => {
                    self.requests.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.driverName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.vendorParameters.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.requests {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.driverName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.vendorParameters.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.requests {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DriverRequests {
        DriverRequests::new()
    }

    fn clear(&mut self) {
        self.driverName = ::std::option::Option::None;
        self.vendorParameters.clear();
        self.requests.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DriverRequests {
        static instance: DriverRequests = DriverRequests {
            driverName: ::std::option::Option::None,
            vendorParameters: ::protobuf::MessageField::none(),
            requests: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DriverRequests {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DriverRequests").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DriverRequests {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DriverRequests {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.NamedResourcesAllocationResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NamedResourcesAllocationResult {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1alpha2.NamedResourcesAllocationResult.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.NamedResourcesAllocationResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NamedResourcesAllocationResult {
    fn default() -> &'a NamedResourcesAllocationResult {
        <NamedResourcesAllocationResult as ::protobuf::Message>::default_instance()
    }
}

impl NamedResourcesAllocationResult {
    pub fn new() -> NamedResourcesAllocationResult {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &NamedResourcesAllocationResult| { &m.name },
            |m: &mut NamedResourcesAllocationResult| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NamedResourcesAllocationResult>(
            "NamedResourcesAllocationResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NamedResourcesAllocationResult {
    const NAME: &'static str = "NamedResourcesAllocationResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NamedResourcesAllocationResult {
        NamedResourcesAllocationResult::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NamedResourcesAllocationResult {
        static instance: NamedResourcesAllocationResult = NamedResourcesAllocationResult {
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NamedResourcesAllocationResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NamedResourcesAllocationResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NamedResourcesAllocationResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamedResourcesAllocationResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.NamedResourcesAttribute)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NamedResourcesAttribute {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1alpha2.NamedResourcesAttribute.name)
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.NamedResourcesAttribute.attributeValue)
    pub attributeValue: ::protobuf::MessageField<NamedResourcesAttributeValue>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.NamedResourcesAttribute.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NamedResourcesAttribute {
    fn default() -> &'a NamedResourcesAttribute {
        <NamedResourcesAttribute as ::protobuf::Message>::default_instance()
    }
}

impl NamedResourcesAttribute {
    pub fn new() -> NamedResourcesAttribute {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.resource.v1alpha2.NamedResourcesAttributeValue attributeValue = 2;

    pub fn attributeValue(&self) -> &NamedResourcesAttributeValue {
        self.attributeValue.as_ref().unwrap_or_else(|| <NamedResourcesAttributeValue as ::protobuf::Message>::default_instance())
    }

    pub fn clear_attributeValue(&mut self) {
        self.attributeValue.clear();
    }

    pub fn has_attributeValue(&self) -> bool {
        self.attributeValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributeValue(&mut self, v: NamedResourcesAttributeValue) {
        self.attributeValue = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributeValue(&mut self) -> &mut NamedResourcesAttributeValue {
        self.attributeValue.mut_or_insert_default()
    }

    // Take field
    pub fn take_attributeValue(&mut self) -> NamedResourcesAttributeValue {
        self.attributeValue.take().unwrap_or_else(|| NamedResourcesAttributeValue::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &NamedResourcesAttribute| { &m.name },
            |m: &mut NamedResourcesAttribute| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NamedResourcesAttributeValue>(
            "attributeValue",
            |m: &NamedResourcesAttribute| { &m.attributeValue },
            |m: &mut NamedResourcesAttribute| { &mut m.attributeValue },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NamedResourcesAttribute>(
            "NamedResourcesAttribute",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NamedResourcesAttribute {
    const NAME: &'static str = "NamedResourcesAttribute";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.attributeValue)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.attributeValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.attributeValue.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NamedResourcesAttribute {
        NamedResourcesAttribute::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.attributeValue.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NamedResourcesAttribute {
        static instance: NamedResourcesAttribute = NamedResourcesAttribute {
            name: ::std::option::Option::None,
            attributeValue: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NamedResourcesAttribute {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NamedResourcesAttribute").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NamedResourcesAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamedResourcesAttribute {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.NamedResourcesAttributeValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NamedResourcesAttributeValue {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.NamedResourcesAttributeValue.quantity)
    pub quantity: ::protobuf::MessageField<crate::apimachinery::pkg::api::resource::Quantity>,
    // @@protoc_insertion_point(field:api.resource.v1alpha2.NamedResourcesAttributeValue.bool)
    pub bool: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.resource.v1alpha2.NamedResourcesAttributeValue.int)
    pub int: ::std::option::Option<i64>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.NamedResourcesAttributeValue.intSlice)
    pub intSlice: ::protobuf::MessageField<NamedResourcesIntSlice>,
    // @@protoc_insertion_point(field:api.resource.v1alpha2.NamedResourcesAttributeValue.string)
    pub string: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.NamedResourcesAttributeValue.stringSlice)
    pub stringSlice: ::protobuf::MessageField<NamedResourcesStringSlice>,
    // @@protoc_insertion_point(field:api.resource.v1alpha2.NamedResourcesAttributeValue.version)
    pub version: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.NamedResourcesAttributeValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NamedResourcesAttributeValue {
    fn default() -> &'a NamedResourcesAttributeValue {
        <NamedResourcesAttributeValue as ::protobuf::Message>::default_instance()
    }
}

impl NamedResourcesAttributeValue {
    pub fn new() -> NamedResourcesAttributeValue {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.api.resource.Quantity quantity = 6;

    pub fn quantity(&self) -> &crate::apimachinery::pkg::api::resource::Quantity {
        self.quantity.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::api::resource::Quantity as ::protobuf::Message>::default_instance())
    }

    pub fn clear_quantity(&mut self) {
        self.quantity.clear();
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: crate::apimachinery::pkg::api::resource::Quantity) {
        self.quantity = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity(&mut self) -> &mut crate::apimachinery::pkg::api::resource::Quantity {
        self.quantity.mut_or_insert_default()
    }

    // Take field
    pub fn take_quantity(&mut self) -> crate::apimachinery::pkg::api::resource::Quantity {
        self.quantity.take().unwrap_or_else(|| crate::apimachinery::pkg::api::resource::Quantity::new())
    }

    // optional bool bool = 2;

    pub fn bool(&self) -> bool {
        self.bool.unwrap_or(false)
    }

    pub fn clear_bool(&mut self) {
        self.bool = ::std::option::Option::None;
    }

    pub fn has_bool(&self) -> bool {
        self.bool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bool(&mut self, v: bool) {
        self.bool = ::std::option::Option::Some(v);
    }

    // optional int64 int = 7;

    pub fn int(&self) -> i64 {
        self.int.unwrap_or(0)
    }

    pub fn clear_int(&mut self) {
        self.int = ::std::option::Option::None;
    }

    pub fn has_int(&self) -> bool {
        self.int.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int(&mut self, v: i64) {
        self.int = ::std::option::Option::Some(v);
    }

    // optional .api.resource.v1alpha2.NamedResourcesIntSlice intSlice = 8;

    pub fn intSlice(&self) -> &NamedResourcesIntSlice {
        self.intSlice.as_ref().unwrap_or_else(|| <NamedResourcesIntSlice as ::protobuf::Message>::default_instance())
    }

    pub fn clear_intSlice(&mut self) {
        self.intSlice.clear();
    }

    pub fn has_intSlice(&self) -> bool {
        self.intSlice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_intSlice(&mut self, v: NamedResourcesIntSlice) {
        self.intSlice = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_intSlice(&mut self) -> &mut NamedResourcesIntSlice {
        self.intSlice.mut_or_insert_default()
    }

    // Take field
    pub fn take_intSlice(&mut self) -> NamedResourcesIntSlice {
        self.intSlice.take().unwrap_or_else(|| NamedResourcesIntSlice::new())
    }

    // optional string string = 5;

    pub fn string(&self) -> &str {
        match self.string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string(&mut self) {
        self.string = ::std::option::Option::None;
    }

    pub fn has_string(&self) -> bool {
        self.string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string(&mut self, v: ::std::string::String) {
        self.string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string(&mut self) -> &mut ::std::string::String {
        if self.string.is_none() {
            self.string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string.as_mut().unwrap()
    }

    // Take field
    pub fn take_string(&mut self) -> ::std::string::String {
        self.string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.resource.v1alpha2.NamedResourcesStringSlice stringSlice = 9;

    pub fn stringSlice(&self) -> &NamedResourcesStringSlice {
        self.stringSlice.as_ref().unwrap_or_else(|| <NamedResourcesStringSlice as ::protobuf::Message>::default_instance())
    }

    pub fn clear_stringSlice(&mut self) {
        self.stringSlice.clear();
    }

    pub fn has_stringSlice(&self) -> bool {
        self.stringSlice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stringSlice(&mut self, v: NamedResourcesStringSlice) {
        self.stringSlice = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stringSlice(&mut self) -> &mut NamedResourcesStringSlice {
        self.stringSlice.mut_or_insert_default()
    }

    // Take field
    pub fn take_stringSlice(&mut self) -> NamedResourcesStringSlice {
        self.stringSlice.take().unwrap_or_else(|| NamedResourcesStringSlice::new())
    }

    // optional string version = 10;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::api::resource::Quantity>(
            "quantity",
            |m: &NamedResourcesAttributeValue| { &m.quantity },
            |m: &mut NamedResourcesAttributeValue| { &mut m.quantity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bool",
            |m: &NamedResourcesAttributeValue| { &m.bool },
            |m: &mut NamedResourcesAttributeValue| { &mut m.bool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "int",
            |m: &NamedResourcesAttributeValue| { &m.int },
            |m: &mut NamedResourcesAttributeValue| { &mut m.int },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NamedResourcesIntSlice>(
            "intSlice",
            |m: &NamedResourcesAttributeValue| { &m.intSlice },
            |m: &mut NamedResourcesAttributeValue| { &mut m.intSlice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "string",
            |m: &NamedResourcesAttributeValue| { &m.string },
            |m: &mut NamedResourcesAttributeValue| { &mut m.string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NamedResourcesStringSlice>(
            "stringSlice",
            |m: &NamedResourcesAttributeValue| { &m.stringSlice },
            |m: &mut NamedResourcesAttributeValue| { &mut m.stringSlice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &NamedResourcesAttributeValue| { &m.version },
            |m: &mut NamedResourcesAttributeValue| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NamedResourcesAttributeValue>(
            "NamedResourcesAttributeValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NamedResourcesAttributeValue {
    const NAME: &'static str = "NamedResourcesAttributeValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quantity)?;
                },
                16 => {
                    self.bool = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.int = ::std::option::Option::Some(is.read_int64()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.intSlice)?;
                },
                42 => {
                    self.string = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stringSlice)?;
                },
                82 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quantity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bool {
            my_size += 1 + 1;
        }
        if let Some(v) = self.int {
            my_size += ::protobuf::rt::int64_size(7, v);
        }
        if let Some(v) = self.intSlice.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.string.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.stringSlice.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quantity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.bool {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.int {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.intSlice.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.string.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.stringSlice.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NamedResourcesAttributeValue {
        NamedResourcesAttributeValue::new()
    }

    fn clear(&mut self) {
        self.quantity.clear();
        self.bool = ::std::option::Option::None;
        self.int = ::std::option::Option::None;
        self.intSlice.clear();
        self.string = ::std::option::Option::None;
        self.stringSlice.clear();
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NamedResourcesAttributeValue {
        static instance: NamedResourcesAttributeValue = NamedResourcesAttributeValue {
            quantity: ::protobuf::MessageField::none(),
            bool: ::std::option::Option::None,
            int: ::std::option::Option::None,
            intSlice: ::protobuf::MessageField::none(),
            string: ::std::option::Option::None,
            stringSlice: ::protobuf::MessageField::none(),
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NamedResourcesAttributeValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NamedResourcesAttributeValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NamedResourcesAttributeValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamedResourcesAttributeValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.NamedResourcesFilter)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NamedResourcesFilter {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1alpha2.NamedResourcesFilter.selector)
    pub selector: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.NamedResourcesFilter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NamedResourcesFilter {
    fn default() -> &'a NamedResourcesFilter {
        <NamedResourcesFilter as ::protobuf::Message>::default_instance()
    }
}

impl NamedResourcesFilter {
    pub fn new() -> NamedResourcesFilter {
        ::std::default::Default::default()
    }

    // optional string selector = 1;

    pub fn selector(&self) -> &str {
        match self.selector.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_selector(&mut self) {
        self.selector = ::std::option::Option::None;
    }

    pub fn has_selector(&self) -> bool {
        self.selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: ::std::string::String) {
        self.selector = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selector(&mut self) -> &mut ::std::string::String {
        if self.selector.is_none() {
            self.selector = ::std::option::Option::Some(::std::string::String::new());
        }
        self.selector.as_mut().unwrap()
    }

    // Take field
    pub fn take_selector(&mut self) -> ::std::string::String {
        self.selector.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selector",
            |m: &NamedResourcesFilter| { &m.selector },
            |m: &mut NamedResourcesFilter| { &mut m.selector },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NamedResourcesFilter>(
            "NamedResourcesFilter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NamedResourcesFilter {
    const NAME: &'static str = "NamedResourcesFilter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.selector = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.selector.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.selector.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NamedResourcesFilter {
        NamedResourcesFilter::new()
    }

    fn clear(&mut self) {
        self.selector = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NamedResourcesFilter {
        static instance: NamedResourcesFilter = NamedResourcesFilter {
            selector: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NamedResourcesFilter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NamedResourcesFilter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NamedResourcesFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamedResourcesFilter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.NamedResourcesInstance)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NamedResourcesInstance {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1alpha2.NamedResourcesInstance.name)
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.NamedResourcesInstance.attributes)
    pub attributes: ::std::vec::Vec<NamedResourcesAttribute>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.NamedResourcesInstance.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NamedResourcesInstance {
    fn default() -> &'a NamedResourcesInstance {
        <NamedResourcesInstance as ::protobuf::Message>::default_instance()
    }
}

impl NamedResourcesInstance {
    pub fn new() -> NamedResourcesInstance {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.resource.v1alpha2.NamedResourcesAttribute attributes = 2;

    pub fn attributes(&self) -> &[NamedResourcesAttribute] {
        &self.attributes
    }

    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::std::vec::Vec<NamedResourcesAttribute>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes(&mut self) -> &mut ::std::vec::Vec<NamedResourcesAttribute> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::std::vec::Vec<NamedResourcesAttribute> {
        ::std::mem::replace(&mut self.attributes, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &NamedResourcesInstance| { &m.name },
            |m: &mut NamedResourcesInstance| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "attributes",
            |m: &NamedResourcesInstance| { &m.attributes },
            |m: &mut NamedResourcesInstance| { &mut m.attributes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NamedResourcesInstance>(
            "NamedResourcesInstance",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NamedResourcesInstance {
    const NAME: &'static str = "NamedResourcesInstance";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.attributes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.attributes {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NamedResourcesInstance {
        NamedResourcesInstance::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.attributes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NamedResourcesInstance {
        static instance: NamedResourcesInstance = NamedResourcesInstance {
            name: ::std::option::Option::None,
            attributes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NamedResourcesInstance {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NamedResourcesInstance").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NamedResourcesInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamedResourcesInstance {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.NamedResourcesIntSlice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NamedResourcesIntSlice {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.NamedResourcesIntSlice.ints)
    pub ints: ::std::vec::Vec<i64>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.NamedResourcesIntSlice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NamedResourcesIntSlice {
    fn default() -> &'a NamedResourcesIntSlice {
        <NamedResourcesIntSlice as ::protobuf::Message>::default_instance()
    }
}

impl NamedResourcesIntSlice {
    pub fn new() -> NamedResourcesIntSlice {
        ::std::default::Default::default()
    }

    // repeated int64 ints = 1;

    pub fn ints(&self) -> &[i64] {
        &self.ints
    }

    pub fn clear_ints(&mut self) {
        self.ints.clear();
    }

    // Param is passed by value, moved
    pub fn set_ints(&mut self, v: ::std::vec::Vec<i64>) {
        self.ints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ints(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.ints
    }

    // Take field
    pub fn take_ints(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.ints, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ints",
            |m: &NamedResourcesIntSlice| { &m.ints },
            |m: &mut NamedResourcesIntSlice| { &mut m.ints },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NamedResourcesIntSlice>(
            "NamedResourcesIntSlice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NamedResourcesIntSlice {
    const NAME: &'static str = "NamedResourcesIntSlice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int64_into(&mut self.ints)?;
                },
                8 => {
                    self.ints.push(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ints {
            my_size += ::protobuf::rt::int64_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ints {
            os.write_int64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NamedResourcesIntSlice {
        NamedResourcesIntSlice::new()
    }

    fn clear(&mut self) {
        self.ints.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NamedResourcesIntSlice {
        static instance: NamedResourcesIntSlice = NamedResourcesIntSlice {
            ints: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NamedResourcesIntSlice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NamedResourcesIntSlice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NamedResourcesIntSlice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamedResourcesIntSlice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.NamedResourcesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NamedResourcesRequest {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1alpha2.NamedResourcesRequest.selector)
    pub selector: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.NamedResourcesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NamedResourcesRequest {
    fn default() -> &'a NamedResourcesRequest {
        <NamedResourcesRequest as ::protobuf::Message>::default_instance()
    }
}

impl NamedResourcesRequest {
    pub fn new() -> NamedResourcesRequest {
        ::std::default::Default::default()
    }

    // optional string selector = 1;

    pub fn selector(&self) -> &str {
        match self.selector.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_selector(&mut self) {
        self.selector = ::std::option::Option::None;
    }

    pub fn has_selector(&self) -> bool {
        self.selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: ::std::string::String) {
        self.selector = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selector(&mut self) -> &mut ::std::string::String {
        if self.selector.is_none() {
            self.selector = ::std::option::Option::Some(::std::string::String::new());
        }
        self.selector.as_mut().unwrap()
    }

    // Take field
    pub fn take_selector(&mut self) -> ::std::string::String {
        self.selector.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selector",
            |m: &NamedResourcesRequest| { &m.selector },
            |m: &mut NamedResourcesRequest| { &mut m.selector },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NamedResourcesRequest>(
            "NamedResourcesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NamedResourcesRequest {
    const NAME: &'static str = "NamedResourcesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.selector = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.selector.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.selector.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NamedResourcesRequest {
        NamedResourcesRequest::new()
    }

    fn clear(&mut self) {
        self.selector = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NamedResourcesRequest {
        static instance: NamedResourcesRequest = NamedResourcesRequest {
            selector: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NamedResourcesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NamedResourcesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NamedResourcesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamedResourcesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.NamedResourcesResources)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NamedResourcesResources {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.NamedResourcesResources.instances)
    pub instances: ::std::vec::Vec<NamedResourcesInstance>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.NamedResourcesResources.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NamedResourcesResources {
    fn default() -> &'a NamedResourcesResources {
        <NamedResourcesResources as ::protobuf::Message>::default_instance()
    }
}

impl NamedResourcesResources {
    pub fn new() -> NamedResourcesResources {
        ::std::default::Default::default()
    }

    // repeated .api.resource.v1alpha2.NamedResourcesInstance instances = 1;

    pub fn instances(&self) -> &[NamedResourcesInstance] {
        &self.instances
    }

    pub fn clear_instances(&mut self) {
        self.instances.clear();
    }

    // Param is passed by value, moved
    pub fn set_instances(&mut self, v: ::std::vec::Vec<NamedResourcesInstance>) {
        self.instances = v;
    }

    // Mutable pointer to the field.
    pub fn mut_instances(&mut self) -> &mut ::std::vec::Vec<NamedResourcesInstance> {
        &mut self.instances
    }

    // Take field
    pub fn take_instances(&mut self) -> ::std::vec::Vec<NamedResourcesInstance> {
        ::std::mem::replace(&mut self.instances, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "instances",
            |m: &NamedResourcesResources| { &m.instances },
            |m: &mut NamedResourcesResources| { &mut m.instances },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NamedResourcesResources>(
            "NamedResourcesResources",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NamedResourcesResources {
    const NAME: &'static str = "NamedResourcesResources";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.instances.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.instances {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.instances {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NamedResourcesResources {
        NamedResourcesResources::new()
    }

    fn clear(&mut self) {
        self.instances.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NamedResourcesResources {
        static instance: NamedResourcesResources = NamedResourcesResources {
            instances: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NamedResourcesResources {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NamedResourcesResources").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NamedResourcesResources {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamedResourcesResources {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.NamedResourcesStringSlice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NamedResourcesStringSlice {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.NamedResourcesStringSlice.strings)
    pub strings: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.NamedResourcesStringSlice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NamedResourcesStringSlice {
    fn default() -> &'a NamedResourcesStringSlice {
        <NamedResourcesStringSlice as ::protobuf::Message>::default_instance()
    }
}

impl NamedResourcesStringSlice {
    pub fn new() -> NamedResourcesStringSlice {
        ::std::default::Default::default()
    }

    // repeated string strings = 1;

    pub fn strings(&self) -> &[::std::string::String] {
        &self.strings
    }

    pub fn clear_strings(&mut self) {
        self.strings.clear();
    }

    // Param is passed by value, moved
    pub fn set_strings(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.strings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_strings(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.strings
    }

    // Take field
    pub fn take_strings(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.strings, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "strings",
            |m: &NamedResourcesStringSlice| { &m.strings },
            |m: &mut NamedResourcesStringSlice| { &mut m.strings },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NamedResourcesStringSlice>(
            "NamedResourcesStringSlice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NamedResourcesStringSlice {
    const NAME: &'static str = "NamedResourcesStringSlice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.strings.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.strings {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.strings {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NamedResourcesStringSlice {
        NamedResourcesStringSlice::new()
    }

    fn clear(&mut self) {
        self.strings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NamedResourcesStringSlice {
        static instance: NamedResourcesStringSlice = NamedResourcesStringSlice {
            strings: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NamedResourcesStringSlice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NamedResourcesStringSlice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NamedResourcesStringSlice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamedResourcesStringSlice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.PodSchedulingContext)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodSchedulingContext {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.PodSchedulingContext.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.PodSchedulingContext.spec)
    pub spec: ::protobuf::MessageField<PodSchedulingContextSpec>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.PodSchedulingContext.status)
    pub status: ::protobuf::MessageField<PodSchedulingContextStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.PodSchedulingContext.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodSchedulingContext {
    fn default() -> &'a PodSchedulingContext {
        <PodSchedulingContext as ::protobuf::Message>::default_instance()
    }
}

impl PodSchedulingContext {
    pub fn new() -> PodSchedulingContext {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.resource.v1alpha2.PodSchedulingContextSpec spec = 2;

    pub fn spec(&self) -> &PodSchedulingContextSpec {
        self.spec.as_ref().unwrap_or_else(|| <PodSchedulingContextSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: PodSchedulingContextSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut PodSchedulingContextSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> PodSchedulingContextSpec {
        self.spec.take().unwrap_or_else(|| PodSchedulingContextSpec::new())
    }

    // optional .api.resource.v1alpha2.PodSchedulingContextStatus status = 3;

    pub fn status(&self) -> &PodSchedulingContextStatus {
        self.status.as_ref().unwrap_or_else(|| <PodSchedulingContextStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: PodSchedulingContextStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut PodSchedulingContextStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> PodSchedulingContextStatus {
        self.status.take().unwrap_or_else(|| PodSchedulingContextStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &PodSchedulingContext| { &m.metadata },
            |m: &mut PodSchedulingContext| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PodSchedulingContextSpec>(
            "spec",
            |m: &PodSchedulingContext| { &m.spec },
            |m: &mut PodSchedulingContext| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PodSchedulingContextStatus>(
            "status",
            |m: &PodSchedulingContext| { &m.status },
            |m: &mut PodSchedulingContext| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodSchedulingContext>(
            "PodSchedulingContext",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodSchedulingContext {
    const NAME: &'static str = "PodSchedulingContext";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodSchedulingContext {
        PodSchedulingContext::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodSchedulingContext {
        static instance: PodSchedulingContext = PodSchedulingContext {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodSchedulingContext {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodSchedulingContext").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodSchedulingContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodSchedulingContext {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.PodSchedulingContextList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodSchedulingContextList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.PodSchedulingContextList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.PodSchedulingContextList.items)
    pub items: ::std::vec::Vec<PodSchedulingContext>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.PodSchedulingContextList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodSchedulingContextList {
    fn default() -> &'a PodSchedulingContextList {
        <PodSchedulingContextList as ::protobuf::Message>::default_instance()
    }
}

impl PodSchedulingContextList {
    pub fn new() -> PodSchedulingContextList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.resource.v1alpha2.PodSchedulingContext items = 2;

    pub fn items(&self) -> &[PodSchedulingContext] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<PodSchedulingContext>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<PodSchedulingContext> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<PodSchedulingContext> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &PodSchedulingContextList| { &m.metadata },
            |m: &mut PodSchedulingContextList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &PodSchedulingContextList| { &m.items },
            |m: &mut PodSchedulingContextList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodSchedulingContextList>(
            "PodSchedulingContextList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodSchedulingContextList {
    const NAME: &'static str = "PodSchedulingContextList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodSchedulingContextList {
        PodSchedulingContextList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodSchedulingContextList {
        static instance: PodSchedulingContextList = PodSchedulingContextList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodSchedulingContextList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodSchedulingContextList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodSchedulingContextList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodSchedulingContextList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.PodSchedulingContextSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodSchedulingContextSpec {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1alpha2.PodSchedulingContextSpec.selectedNode)
    pub selectedNode: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.PodSchedulingContextSpec.potentialNodes)
    pub potentialNodes: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.PodSchedulingContextSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodSchedulingContextSpec {
    fn default() -> &'a PodSchedulingContextSpec {
        <PodSchedulingContextSpec as ::protobuf::Message>::default_instance()
    }
}

impl PodSchedulingContextSpec {
    pub fn new() -> PodSchedulingContextSpec {
        ::std::default::Default::default()
    }

    // optional string selectedNode = 1;

    pub fn selectedNode(&self) -> &str {
        match self.selectedNode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_selectedNode(&mut self) {
        self.selectedNode = ::std::option::Option::None;
    }

    pub fn has_selectedNode(&self) -> bool {
        self.selectedNode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selectedNode(&mut self, v: ::std::string::String) {
        self.selectedNode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selectedNode(&mut self) -> &mut ::std::string::String {
        if self.selectedNode.is_none() {
            self.selectedNode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.selectedNode.as_mut().unwrap()
    }

    // Take field
    pub fn take_selectedNode(&mut self) -> ::std::string::String {
        self.selectedNode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string potentialNodes = 2;

    pub fn potentialNodes(&self) -> &[::std::string::String] {
        &self.potentialNodes
    }

    pub fn clear_potentialNodes(&mut self) {
        self.potentialNodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_potentialNodes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.potentialNodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_potentialNodes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.potentialNodes
    }

    // Take field
    pub fn take_potentialNodes(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.potentialNodes, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selectedNode",
            |m: &PodSchedulingContextSpec| { &m.selectedNode },
            |m: &mut PodSchedulingContextSpec| { &mut m.selectedNode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "potentialNodes",
            |m: &PodSchedulingContextSpec| { &m.potentialNodes },
            |m: &mut PodSchedulingContextSpec| { &mut m.potentialNodes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodSchedulingContextSpec>(
            "PodSchedulingContextSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodSchedulingContextSpec {
    const NAME: &'static str = "PodSchedulingContextSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.selectedNode = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.potentialNodes.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.selectedNode.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.potentialNodes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.selectedNode.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.potentialNodes {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodSchedulingContextSpec {
        PodSchedulingContextSpec::new()
    }

    fn clear(&mut self) {
        self.selectedNode = ::std::option::Option::None;
        self.potentialNodes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodSchedulingContextSpec {
        static instance: PodSchedulingContextSpec = PodSchedulingContextSpec {
            selectedNode: ::std::option::Option::None,
            potentialNodes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodSchedulingContextSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodSchedulingContextSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodSchedulingContextSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodSchedulingContextSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.PodSchedulingContextStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PodSchedulingContextStatus {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.PodSchedulingContextStatus.resourceClaims)
    pub resourceClaims: ::std::vec::Vec<ResourceClaimSchedulingStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.PodSchedulingContextStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PodSchedulingContextStatus {
    fn default() -> &'a PodSchedulingContextStatus {
        <PodSchedulingContextStatus as ::protobuf::Message>::default_instance()
    }
}

impl PodSchedulingContextStatus {
    pub fn new() -> PodSchedulingContextStatus {
        ::std::default::Default::default()
    }

    // repeated .api.resource.v1alpha2.ResourceClaimSchedulingStatus resourceClaims = 1;

    pub fn resourceClaims(&self) -> &[ResourceClaimSchedulingStatus] {
        &self.resourceClaims
    }

    pub fn clear_resourceClaims(&mut self) {
        self.resourceClaims.clear();
    }

    // Param is passed by value, moved
    pub fn set_resourceClaims(&mut self, v: ::std::vec::Vec<ResourceClaimSchedulingStatus>) {
        self.resourceClaims = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resourceClaims(&mut self) -> &mut ::std::vec::Vec<ResourceClaimSchedulingStatus> {
        &mut self.resourceClaims
    }

    // Take field
    pub fn take_resourceClaims(&mut self) -> ::std::vec::Vec<ResourceClaimSchedulingStatus> {
        ::std::mem::replace(&mut self.resourceClaims, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resourceClaims",
            |m: &PodSchedulingContextStatus| { &m.resourceClaims },
            |m: &mut PodSchedulingContextStatus| { &mut m.resourceClaims },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PodSchedulingContextStatus>(
            "PodSchedulingContextStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PodSchedulingContextStatus {
    const NAME: &'static str = "PodSchedulingContextStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.resourceClaims.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.resourceClaims {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.resourceClaims {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PodSchedulingContextStatus {
        PodSchedulingContextStatus::new()
    }

    fn clear(&mut self) {
        self.resourceClaims.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PodSchedulingContextStatus {
        static instance: PodSchedulingContextStatus = PodSchedulingContextStatus {
            resourceClaims: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PodSchedulingContextStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PodSchedulingContextStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PodSchedulingContextStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodSchedulingContextStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.ResourceClaim)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaim {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaim.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaim.spec)
    pub spec: ::protobuf::MessageField<ResourceClaimSpec>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaim.status)
    pub status: ::protobuf::MessageField<ResourceClaimStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.ResourceClaim.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaim {
    fn default() -> &'a ResourceClaim {
        <ResourceClaim as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaim {
    pub fn new() -> ResourceClaim {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.resource.v1alpha2.ResourceClaimSpec spec = 2;

    pub fn spec(&self) -> &ResourceClaimSpec {
        self.spec.as_ref().unwrap_or_else(|| <ResourceClaimSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ResourceClaimSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ResourceClaimSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ResourceClaimSpec {
        self.spec.take().unwrap_or_else(|| ResourceClaimSpec::new())
    }

    // optional .api.resource.v1alpha2.ResourceClaimStatus status = 3;

    pub fn status(&self) -> &ResourceClaimStatus {
        self.status.as_ref().unwrap_or_else(|| <ResourceClaimStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ResourceClaimStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ResourceClaimStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> ResourceClaimStatus {
        self.status.take().unwrap_or_else(|| ResourceClaimStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ResourceClaim| { &m.metadata },
            |m: &mut ResourceClaim| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceClaimSpec>(
            "spec",
            |m: &ResourceClaim| { &m.spec },
            |m: &mut ResourceClaim| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceClaimStatus>(
            "status",
            |m: &ResourceClaim| { &m.status },
            |m: &mut ResourceClaim| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaim>(
            "ResourceClaim",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaim {
    const NAME: &'static str = "ResourceClaim";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaim {
        ResourceClaim::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaim {
        static instance: ResourceClaim = ResourceClaim {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaim {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaim").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaim {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaim {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.ResourceClaimConsumerReference)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaimConsumerReference {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimConsumerReference.apiGroup)
    pub apiGroup: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimConsumerReference.resource)
    pub resource: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimConsumerReference.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimConsumerReference.uid)
    pub uid: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.ResourceClaimConsumerReference.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaimConsumerReference {
    fn default() -> &'a ResourceClaimConsumerReference {
        <ResourceClaimConsumerReference as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaimConsumerReference {
    pub fn new() -> ResourceClaimConsumerReference {
        ::std::default::Default::default()
    }

    // optional string apiGroup = 1;

    pub fn apiGroup(&self) -> &str {
        match self.apiGroup.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_apiGroup(&mut self) {
        self.apiGroup = ::std::option::Option::None;
    }

    pub fn has_apiGroup(&self) -> bool {
        self.apiGroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiGroup(&mut self, v: ::std::string::String) {
        self.apiGroup = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiGroup(&mut self) -> &mut ::std::string::String {
        if self.apiGroup.is_none() {
            self.apiGroup = ::std::option::Option::Some(::std::string::String::new());
        }
        self.apiGroup.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiGroup(&mut self) -> ::std::string::String {
        self.apiGroup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resource = 3;

    pub fn resource(&self) -> &str {
        match self.resource.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resource(&mut self) {
        self.resource = ::std::option::Option::None;
    }

    pub fn has_resource(&self) -> bool {
        self.resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: ::std::string::String) {
        self.resource = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut ::std::string::String {
        if self.resource.is_none() {
            self.resource = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resource.as_mut().unwrap()
    }

    // Take field
    pub fn take_resource(&mut self) -> ::std::string::String {
        self.resource.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 4;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string uid = 5;

    pub fn uid(&self) -> &str {
        match self.uid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_uid(&mut self) {
        self.uid = ::std::option::Option::None;
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if self.uid.is_none() {
            self.uid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        self.uid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "apiGroup",
            |m: &ResourceClaimConsumerReference| { &m.apiGroup },
            |m: &mut ResourceClaimConsumerReference| { &mut m.apiGroup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resource",
            |m: &ResourceClaimConsumerReference| { &m.resource },
            |m: &mut ResourceClaimConsumerReference| { &mut m.resource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ResourceClaimConsumerReference| { &m.name },
            |m: &mut ResourceClaimConsumerReference| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uid",
            |m: &ResourceClaimConsumerReference| { &m.uid },
            |m: &mut ResourceClaimConsumerReference| { &mut m.uid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaimConsumerReference>(
            "ResourceClaimConsumerReference",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaimConsumerReference {
    const NAME: &'static str = "ResourceClaimConsumerReference";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.apiGroup = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.resource = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.uid = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.apiGroup.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.resource.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.uid.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.apiGroup.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.resource.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.uid.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaimConsumerReference {
        ResourceClaimConsumerReference::new()
    }

    fn clear(&mut self) {
        self.apiGroup = ::std::option::Option::None;
        self.resource = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.uid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaimConsumerReference {
        static instance: ResourceClaimConsumerReference = ResourceClaimConsumerReference {
            apiGroup: ::std::option::Option::None,
            resource: ::std::option::Option::None,
            name: ::std::option::Option::None,
            uid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaimConsumerReference {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaimConsumerReference").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaimConsumerReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaimConsumerReference {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.ResourceClaimList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaimList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimList.items)
    pub items: ::std::vec::Vec<ResourceClaim>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.ResourceClaimList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaimList {
    fn default() -> &'a ResourceClaimList {
        <ResourceClaimList as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaimList {
    pub fn new() -> ResourceClaimList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.resource.v1alpha2.ResourceClaim items = 2;

    pub fn items(&self) -> &[ResourceClaim] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ResourceClaim>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ResourceClaim> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ResourceClaim> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ResourceClaimList| { &m.metadata },
            |m: &mut ResourceClaimList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ResourceClaimList| { &m.items },
            |m: &mut ResourceClaimList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaimList>(
            "ResourceClaimList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaimList {
    const NAME: &'static str = "ResourceClaimList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaimList {
        ResourceClaimList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaimList {
        static instance: ResourceClaimList = ResourceClaimList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaimList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaimList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaimList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaimList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.ResourceClaimParameters)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaimParameters {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimParameters.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimParameters.generatedFrom)
    pub generatedFrom: ::protobuf::MessageField<ResourceClaimParametersReference>,
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimParameters.shareable)
    pub shareable: ::std::option::Option<bool>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimParameters.driverRequests)
    pub driverRequests: ::std::vec::Vec<DriverRequests>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.ResourceClaimParameters.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaimParameters {
    fn default() -> &'a ResourceClaimParameters {
        <ResourceClaimParameters as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaimParameters {
    pub fn new() -> ResourceClaimParameters {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.resource.v1alpha2.ResourceClaimParametersReference generatedFrom = 2;

    pub fn generatedFrom(&self) -> &ResourceClaimParametersReference {
        self.generatedFrom.as_ref().unwrap_or_else(|| <ResourceClaimParametersReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_generatedFrom(&mut self) {
        self.generatedFrom.clear();
    }

    pub fn has_generatedFrom(&self) -> bool {
        self.generatedFrom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generatedFrom(&mut self, v: ResourceClaimParametersReference) {
        self.generatedFrom = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_generatedFrom(&mut self) -> &mut ResourceClaimParametersReference {
        self.generatedFrom.mut_or_insert_default()
    }

    // Take field
    pub fn take_generatedFrom(&mut self) -> ResourceClaimParametersReference {
        self.generatedFrom.take().unwrap_or_else(|| ResourceClaimParametersReference::new())
    }

    // optional bool shareable = 3;

    pub fn shareable(&self) -> bool {
        self.shareable.unwrap_or(false)
    }

    pub fn clear_shareable(&mut self) {
        self.shareable = ::std::option::Option::None;
    }

    pub fn has_shareable(&self) -> bool {
        self.shareable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shareable(&mut self, v: bool) {
        self.shareable = ::std::option::Option::Some(v);
    }

    // repeated .api.resource.v1alpha2.DriverRequests driverRequests = 4;

    pub fn driverRequests(&self) -> &[DriverRequests] {
        &self.driverRequests
    }

    pub fn clear_driverRequests(&mut self) {
        self.driverRequests.clear();
    }

    // Param is passed by value, moved
    pub fn set_driverRequests(&mut self, v: ::std::vec::Vec<DriverRequests>) {
        self.driverRequests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_driverRequests(&mut self) -> &mut ::std::vec::Vec<DriverRequests> {
        &mut self.driverRequests
    }

    // Take field
    pub fn take_driverRequests(&mut self) -> ::std::vec::Vec<DriverRequests> {
        ::std::mem::replace(&mut self.driverRequests, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ResourceClaimParameters| { &m.metadata },
            |m: &mut ResourceClaimParameters| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceClaimParametersReference>(
            "generatedFrom",
            |m: &ResourceClaimParameters| { &m.generatedFrom },
            |m: &mut ResourceClaimParameters| { &mut m.generatedFrom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shareable",
            |m: &ResourceClaimParameters| { &m.shareable },
            |m: &mut ResourceClaimParameters| { &mut m.shareable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "driverRequests",
            |m: &ResourceClaimParameters| { &m.driverRequests },
            |m: &mut ResourceClaimParameters| { &mut m.driverRequests },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaimParameters>(
            "ResourceClaimParameters",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaimParameters {
    const NAME: &'static str = "ResourceClaimParameters";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.generatedFrom)?;
                },
                24 => {
                    self.shareable = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.driverRequests.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.generatedFrom.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.shareable {
            my_size += 1 + 1;
        }
        for value in &self.driverRequests {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.generatedFrom.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.shareable {
            os.write_bool(3, v)?;
        }
        for v in &self.driverRequests {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaimParameters {
        ResourceClaimParameters::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.generatedFrom.clear();
        self.shareable = ::std::option::Option::None;
        self.driverRequests.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaimParameters {
        static instance: ResourceClaimParameters = ResourceClaimParameters {
            metadata: ::protobuf::MessageField::none(),
            generatedFrom: ::protobuf::MessageField::none(),
            shareable: ::std::option::Option::None,
            driverRequests: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaimParameters {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaimParameters").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaimParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaimParameters {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.ResourceClaimParametersList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaimParametersList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimParametersList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimParametersList.items)
    pub items: ::std::vec::Vec<ResourceClaimParameters>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.ResourceClaimParametersList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaimParametersList {
    fn default() -> &'a ResourceClaimParametersList {
        <ResourceClaimParametersList as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaimParametersList {
    pub fn new() -> ResourceClaimParametersList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.resource.v1alpha2.ResourceClaimParameters items = 2;

    pub fn items(&self) -> &[ResourceClaimParameters] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ResourceClaimParameters>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ResourceClaimParameters> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ResourceClaimParameters> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ResourceClaimParametersList| { &m.metadata },
            |m: &mut ResourceClaimParametersList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ResourceClaimParametersList| { &m.items },
            |m: &mut ResourceClaimParametersList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaimParametersList>(
            "ResourceClaimParametersList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaimParametersList {
    const NAME: &'static str = "ResourceClaimParametersList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaimParametersList {
        ResourceClaimParametersList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaimParametersList {
        static instance: ResourceClaimParametersList = ResourceClaimParametersList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaimParametersList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaimParametersList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaimParametersList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaimParametersList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.ResourceClaimParametersReference)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaimParametersReference {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimParametersReference.apiGroup)
    pub apiGroup: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimParametersReference.kind)
    pub kind: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimParametersReference.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.ResourceClaimParametersReference.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaimParametersReference {
    fn default() -> &'a ResourceClaimParametersReference {
        <ResourceClaimParametersReference as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaimParametersReference {
    pub fn new() -> ResourceClaimParametersReference {
        ::std::default::Default::default()
    }

    // optional string apiGroup = 1;

    pub fn apiGroup(&self) -> &str {
        match self.apiGroup.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_apiGroup(&mut self) {
        self.apiGroup = ::std::option::Option::None;
    }

    pub fn has_apiGroup(&self) -> bool {
        self.apiGroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiGroup(&mut self, v: ::std::string::String) {
        self.apiGroup = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiGroup(&mut self) -> &mut ::std::string::String {
        if self.apiGroup.is_none() {
            self.apiGroup = ::std::option::Option::Some(::std::string::String::new());
        }
        self.apiGroup.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiGroup(&mut self) -> ::std::string::String {
        self.apiGroup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kind = 2;

    pub fn kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "apiGroup",
            |m: &ResourceClaimParametersReference| { &m.apiGroup },
            |m: &mut ResourceClaimParametersReference| { &mut m.apiGroup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &ResourceClaimParametersReference| { &m.kind },
            |m: &mut ResourceClaimParametersReference| { &mut m.kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ResourceClaimParametersReference| { &m.name },
            |m: &mut ResourceClaimParametersReference| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaimParametersReference>(
            "ResourceClaimParametersReference",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaimParametersReference {
    const NAME: &'static str = "ResourceClaimParametersReference";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.apiGroup = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.kind = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.apiGroup.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.apiGroup.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.kind.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaimParametersReference {
        ResourceClaimParametersReference::new()
    }

    fn clear(&mut self) {
        self.apiGroup = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaimParametersReference {
        static instance: ResourceClaimParametersReference = ResourceClaimParametersReference {
            apiGroup: ::std::option::Option::None,
            kind: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaimParametersReference {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaimParametersReference").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaimParametersReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaimParametersReference {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.ResourceClaimSchedulingStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaimSchedulingStatus {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimSchedulingStatus.name)
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimSchedulingStatus.unsuitableNodes)
    pub unsuitableNodes: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.ResourceClaimSchedulingStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaimSchedulingStatus {
    fn default() -> &'a ResourceClaimSchedulingStatus {
        <ResourceClaimSchedulingStatus as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaimSchedulingStatus {
    pub fn new() -> ResourceClaimSchedulingStatus {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string unsuitableNodes = 2;

    pub fn unsuitableNodes(&self) -> &[::std::string::String] {
        &self.unsuitableNodes
    }

    pub fn clear_unsuitableNodes(&mut self) {
        self.unsuitableNodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_unsuitableNodes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.unsuitableNodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unsuitableNodes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.unsuitableNodes
    }

    // Take field
    pub fn take_unsuitableNodes(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.unsuitableNodes, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ResourceClaimSchedulingStatus| { &m.name },
            |m: &mut ResourceClaimSchedulingStatus| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "unsuitableNodes",
            |m: &ResourceClaimSchedulingStatus| { &m.unsuitableNodes },
            |m: &mut ResourceClaimSchedulingStatus| { &mut m.unsuitableNodes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaimSchedulingStatus>(
            "ResourceClaimSchedulingStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaimSchedulingStatus {
    const NAME: &'static str = "ResourceClaimSchedulingStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.unsuitableNodes.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.unsuitableNodes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.unsuitableNodes {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaimSchedulingStatus {
        ResourceClaimSchedulingStatus::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.unsuitableNodes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaimSchedulingStatus {
        static instance: ResourceClaimSchedulingStatus = ResourceClaimSchedulingStatus {
            name: ::std::option::Option::None,
            unsuitableNodes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaimSchedulingStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaimSchedulingStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaimSchedulingStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaimSchedulingStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.ResourceClaimSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaimSpec {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimSpec.resourceClassName)
    pub resourceClassName: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimSpec.parametersRef)
    pub parametersRef: ::protobuf::MessageField<ResourceClaimParametersReference>,
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimSpec.allocationMode)
    pub allocationMode: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.ResourceClaimSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaimSpec {
    fn default() -> &'a ResourceClaimSpec {
        <ResourceClaimSpec as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaimSpec {
    pub fn new() -> ResourceClaimSpec {
        ::std::default::Default::default()
    }

    // optional string resourceClassName = 1;

    pub fn resourceClassName(&self) -> &str {
        match self.resourceClassName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resourceClassName(&mut self) {
        self.resourceClassName = ::std::option::Option::None;
    }

    pub fn has_resourceClassName(&self) -> bool {
        self.resourceClassName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceClassName(&mut self, v: ::std::string::String) {
        self.resourceClassName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceClassName(&mut self) -> &mut ::std::string::String {
        if self.resourceClassName.is_none() {
            self.resourceClassName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resourceClassName.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceClassName(&mut self) -> ::std::string::String {
        self.resourceClassName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.resource.v1alpha2.ResourceClaimParametersReference parametersRef = 2;

    pub fn parametersRef(&self) -> &ResourceClaimParametersReference {
        self.parametersRef.as_ref().unwrap_or_else(|| <ResourceClaimParametersReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_parametersRef(&mut self) {
        self.parametersRef.clear();
    }

    pub fn has_parametersRef(&self) -> bool {
        self.parametersRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parametersRef(&mut self, v: ResourceClaimParametersReference) {
        self.parametersRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parametersRef(&mut self) -> &mut ResourceClaimParametersReference {
        self.parametersRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_parametersRef(&mut self) -> ResourceClaimParametersReference {
        self.parametersRef.take().unwrap_or_else(|| ResourceClaimParametersReference::new())
    }

    // optional string allocationMode = 3;

    pub fn allocationMode(&self) -> &str {
        match self.allocationMode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_allocationMode(&mut self) {
        self.allocationMode = ::std::option::Option::None;
    }

    pub fn has_allocationMode(&self) -> bool {
        self.allocationMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allocationMode(&mut self, v: ::std::string::String) {
        self.allocationMode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allocationMode(&mut self) -> &mut ::std::string::String {
        if self.allocationMode.is_none() {
            self.allocationMode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.allocationMode.as_mut().unwrap()
    }

    // Take field
    pub fn take_allocationMode(&mut self) -> ::std::string::String {
        self.allocationMode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resourceClassName",
            |m: &ResourceClaimSpec| { &m.resourceClassName },
            |m: &mut ResourceClaimSpec| { &mut m.resourceClassName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceClaimParametersReference>(
            "parametersRef",
            |m: &ResourceClaimSpec| { &m.parametersRef },
            |m: &mut ResourceClaimSpec| { &mut m.parametersRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allocationMode",
            |m: &ResourceClaimSpec| { &m.allocationMode },
            |m: &mut ResourceClaimSpec| { &mut m.allocationMode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaimSpec>(
            "ResourceClaimSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaimSpec {
    const NAME: &'static str = "ResourceClaimSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.resourceClassName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.parametersRef)?;
                },
                26 => {
                    self.allocationMode = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.resourceClassName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.parametersRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.allocationMode.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.resourceClassName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.parametersRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.allocationMode.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaimSpec {
        ResourceClaimSpec::new()
    }

    fn clear(&mut self) {
        self.resourceClassName = ::std::option::Option::None;
        self.parametersRef.clear();
        self.allocationMode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaimSpec {
        static instance: ResourceClaimSpec = ResourceClaimSpec {
            resourceClassName: ::std::option::Option::None,
            parametersRef: ::protobuf::MessageField::none(),
            allocationMode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaimSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaimSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaimSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaimSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.ResourceClaimStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaimStatus {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimStatus.driverName)
    pub driverName: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimStatus.allocation)
    pub allocation: ::protobuf::MessageField<AllocationResult>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimStatus.reservedFor)
    pub reservedFor: ::std::vec::Vec<ResourceClaimConsumerReference>,
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimStatus.deallocationRequested)
    pub deallocationRequested: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.ResourceClaimStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaimStatus {
    fn default() -> &'a ResourceClaimStatus {
        <ResourceClaimStatus as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaimStatus {
    pub fn new() -> ResourceClaimStatus {
        ::std::default::Default::default()
    }

    // optional string driverName = 1;

    pub fn driverName(&self) -> &str {
        match self.driverName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_driverName(&mut self) {
        self.driverName = ::std::option::Option::None;
    }

    pub fn has_driverName(&self) -> bool {
        self.driverName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driverName(&mut self, v: ::std::string::String) {
        self.driverName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driverName(&mut self) -> &mut ::std::string::String {
        if self.driverName.is_none() {
            self.driverName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.driverName.as_mut().unwrap()
    }

    // Take field
    pub fn take_driverName(&mut self) -> ::std::string::String {
        self.driverName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.resource.v1alpha2.AllocationResult allocation = 2;

    pub fn allocation(&self) -> &AllocationResult {
        self.allocation.as_ref().unwrap_or_else(|| <AllocationResult as ::protobuf::Message>::default_instance())
    }

    pub fn clear_allocation(&mut self) {
        self.allocation.clear();
    }

    pub fn has_allocation(&self) -> bool {
        self.allocation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allocation(&mut self, v: AllocationResult) {
        self.allocation = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allocation(&mut self) -> &mut AllocationResult {
        self.allocation.mut_or_insert_default()
    }

    // Take field
    pub fn take_allocation(&mut self) -> AllocationResult {
        self.allocation.take().unwrap_or_else(|| AllocationResult::new())
    }

    // repeated .api.resource.v1alpha2.ResourceClaimConsumerReference reservedFor = 3;

    pub fn reservedFor(&self) -> &[ResourceClaimConsumerReference] {
        &self.reservedFor
    }

    pub fn clear_reservedFor(&mut self) {
        self.reservedFor.clear();
    }

    // Param is passed by value, moved
    pub fn set_reservedFor(&mut self, v: ::std::vec::Vec<ResourceClaimConsumerReference>) {
        self.reservedFor = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reservedFor(&mut self) -> &mut ::std::vec::Vec<ResourceClaimConsumerReference> {
        &mut self.reservedFor
    }

    // Take field
    pub fn take_reservedFor(&mut self) -> ::std::vec::Vec<ResourceClaimConsumerReference> {
        ::std::mem::replace(&mut self.reservedFor, ::std::vec::Vec::new())
    }

    // optional bool deallocationRequested = 4;

    pub fn deallocationRequested(&self) -> bool {
        self.deallocationRequested.unwrap_or(false)
    }

    pub fn clear_deallocationRequested(&mut self) {
        self.deallocationRequested = ::std::option::Option::None;
    }

    pub fn has_deallocationRequested(&self) -> bool {
        self.deallocationRequested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deallocationRequested(&mut self, v: bool) {
        self.deallocationRequested = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "driverName",
            |m: &ResourceClaimStatus| { &m.driverName },
            |m: &mut ResourceClaimStatus| { &mut m.driverName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AllocationResult>(
            "allocation",
            |m: &ResourceClaimStatus| { &m.allocation },
            |m: &mut ResourceClaimStatus| { &mut m.allocation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reservedFor",
            |m: &ResourceClaimStatus| { &m.reservedFor },
            |m: &mut ResourceClaimStatus| { &mut m.reservedFor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deallocationRequested",
            |m: &ResourceClaimStatus| { &m.deallocationRequested },
            |m: &mut ResourceClaimStatus| { &mut m.deallocationRequested },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaimStatus>(
            "ResourceClaimStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaimStatus {
    const NAME: &'static str = "ResourceClaimStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.driverName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.allocation)?;
                },
                26 => {
                    self.reservedFor.push(is.read_message()?);
                },
                32 => {
                    self.deallocationRequested = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.driverName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.allocation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.reservedFor {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.deallocationRequested {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.driverName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.allocation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.reservedFor {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.deallocationRequested {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaimStatus {
        ResourceClaimStatus::new()
    }

    fn clear(&mut self) {
        self.driverName = ::std::option::Option::None;
        self.allocation.clear();
        self.reservedFor.clear();
        self.deallocationRequested = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaimStatus {
        static instance: ResourceClaimStatus = ResourceClaimStatus {
            driverName: ::std::option::Option::None,
            allocation: ::protobuf::MessageField::none(),
            reservedFor: ::std::vec::Vec::new(),
            deallocationRequested: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaimStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaimStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaimStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaimStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.ResourceClaimTemplate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaimTemplate {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimTemplate.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimTemplate.spec)
    pub spec: ::protobuf::MessageField<ResourceClaimTemplateSpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.ResourceClaimTemplate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaimTemplate {
    fn default() -> &'a ResourceClaimTemplate {
        <ResourceClaimTemplate as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaimTemplate {
    pub fn new() -> ResourceClaimTemplate {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.resource.v1alpha2.ResourceClaimTemplateSpec spec = 2;

    pub fn spec(&self) -> &ResourceClaimTemplateSpec {
        self.spec.as_ref().unwrap_or_else(|| <ResourceClaimTemplateSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ResourceClaimTemplateSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ResourceClaimTemplateSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ResourceClaimTemplateSpec {
        self.spec.take().unwrap_or_else(|| ResourceClaimTemplateSpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ResourceClaimTemplate| { &m.metadata },
            |m: &mut ResourceClaimTemplate| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceClaimTemplateSpec>(
            "spec",
            |m: &ResourceClaimTemplate| { &m.spec },
            |m: &mut ResourceClaimTemplate| { &mut m.spec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaimTemplate>(
            "ResourceClaimTemplate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaimTemplate {
    const NAME: &'static str = "ResourceClaimTemplate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaimTemplate {
        ResourceClaimTemplate::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaimTemplate {
        static instance: ResourceClaimTemplate = ResourceClaimTemplate {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaimTemplate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaimTemplate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaimTemplate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaimTemplate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.ResourceClaimTemplateList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaimTemplateList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimTemplateList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimTemplateList.items)
    pub items: ::std::vec::Vec<ResourceClaimTemplate>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.ResourceClaimTemplateList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaimTemplateList {
    fn default() -> &'a ResourceClaimTemplateList {
        <ResourceClaimTemplateList as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaimTemplateList {
    pub fn new() -> ResourceClaimTemplateList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.resource.v1alpha2.ResourceClaimTemplate items = 2;

    pub fn items(&self) -> &[ResourceClaimTemplate] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ResourceClaimTemplate>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ResourceClaimTemplate> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ResourceClaimTemplate> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ResourceClaimTemplateList| { &m.metadata },
            |m: &mut ResourceClaimTemplateList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ResourceClaimTemplateList| { &m.items },
            |m: &mut ResourceClaimTemplateList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaimTemplateList>(
            "ResourceClaimTemplateList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaimTemplateList {
    const NAME: &'static str = "ResourceClaimTemplateList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaimTemplateList {
        ResourceClaimTemplateList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaimTemplateList {
        static instance: ResourceClaimTemplateList = ResourceClaimTemplateList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaimTemplateList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaimTemplateList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaimTemplateList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaimTemplateList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.ResourceClaimTemplateSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaimTemplateSpec {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimTemplateSpec.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClaimTemplateSpec.spec)
    pub spec: ::protobuf::MessageField<ResourceClaimSpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.ResourceClaimTemplateSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaimTemplateSpec {
    fn default() -> &'a ResourceClaimTemplateSpec {
        <ResourceClaimTemplateSpec as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaimTemplateSpec {
    pub fn new() -> ResourceClaimTemplateSpec {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.resource.v1alpha2.ResourceClaimSpec spec = 2;

    pub fn spec(&self) -> &ResourceClaimSpec {
        self.spec.as_ref().unwrap_or_else(|| <ResourceClaimSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ResourceClaimSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ResourceClaimSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ResourceClaimSpec {
        self.spec.take().unwrap_or_else(|| ResourceClaimSpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ResourceClaimTemplateSpec| { &m.metadata },
            |m: &mut ResourceClaimTemplateSpec| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceClaimSpec>(
            "spec",
            |m: &ResourceClaimTemplateSpec| { &m.spec },
            |m: &mut ResourceClaimTemplateSpec| { &mut m.spec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaimTemplateSpec>(
            "ResourceClaimTemplateSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaimTemplateSpec {
    const NAME: &'static str = "ResourceClaimTemplateSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaimTemplateSpec {
        ResourceClaimTemplateSpec::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaimTemplateSpec {
        static instance: ResourceClaimTemplateSpec = ResourceClaimTemplateSpec {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaimTemplateSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaimTemplateSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaimTemplateSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaimTemplateSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.ResourceClass)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClass {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClass.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClass.driverName)
    pub driverName: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClass.parametersRef)
    pub parametersRef: ::protobuf::MessageField<ResourceClassParametersReference>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClass.suitableNodes)
    pub suitableNodes: ::protobuf::MessageField<crate::api::core::v1::NodeSelector>,
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClass.structuredParameters)
    pub structuredParameters: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.ResourceClass.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClass {
    fn default() -> &'a ResourceClass {
        <ResourceClass as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClass {
    pub fn new() -> ResourceClass {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional string driverName = 2;

    pub fn driverName(&self) -> &str {
        match self.driverName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_driverName(&mut self) {
        self.driverName = ::std::option::Option::None;
    }

    pub fn has_driverName(&self) -> bool {
        self.driverName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driverName(&mut self, v: ::std::string::String) {
        self.driverName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driverName(&mut self) -> &mut ::std::string::String {
        if self.driverName.is_none() {
            self.driverName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.driverName.as_mut().unwrap()
    }

    // Take field
    pub fn take_driverName(&mut self) -> ::std::string::String {
        self.driverName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.resource.v1alpha2.ResourceClassParametersReference parametersRef = 3;

    pub fn parametersRef(&self) -> &ResourceClassParametersReference {
        self.parametersRef.as_ref().unwrap_or_else(|| <ResourceClassParametersReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_parametersRef(&mut self) {
        self.parametersRef.clear();
    }

    pub fn has_parametersRef(&self) -> bool {
        self.parametersRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parametersRef(&mut self, v: ResourceClassParametersReference) {
        self.parametersRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parametersRef(&mut self) -> &mut ResourceClassParametersReference {
        self.parametersRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_parametersRef(&mut self) -> ResourceClassParametersReference {
        self.parametersRef.take().unwrap_or_else(|| ResourceClassParametersReference::new())
    }

    // optional .api.core.v1.NodeSelector suitableNodes = 4;

    pub fn suitableNodes(&self) -> &crate::api::core::v1::NodeSelector {
        self.suitableNodes.as_ref().unwrap_or_else(|| <crate::api::core::v1::NodeSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_suitableNodes(&mut self) {
        self.suitableNodes.clear();
    }

    pub fn has_suitableNodes(&self) -> bool {
        self.suitableNodes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suitableNodes(&mut self, v: crate::api::core::v1::NodeSelector) {
        self.suitableNodes = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_suitableNodes(&mut self) -> &mut crate::api::core::v1::NodeSelector {
        self.suitableNodes.mut_or_insert_default()
    }

    // Take field
    pub fn take_suitableNodes(&mut self) -> crate::api::core::v1::NodeSelector {
        self.suitableNodes.take().unwrap_or_else(|| crate::api::core::v1::NodeSelector::new())
    }

    // optional bool structuredParameters = 5;

    pub fn structuredParameters(&self) -> bool {
        self.structuredParameters.unwrap_or(false)
    }

    pub fn clear_structuredParameters(&mut self) {
        self.structuredParameters = ::std::option::Option::None;
    }

    pub fn has_structuredParameters(&self) -> bool {
        self.structuredParameters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_structuredParameters(&mut self, v: bool) {
        self.structuredParameters = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ResourceClass| { &m.metadata },
            |m: &mut ResourceClass| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "driverName",
            |m: &ResourceClass| { &m.driverName },
            |m: &mut ResourceClass| { &mut m.driverName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceClassParametersReference>(
            "parametersRef",
            |m: &ResourceClass| { &m.parametersRef },
            |m: &mut ResourceClass| { &mut m.parametersRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::api::core::v1::NodeSelector>(
            "suitableNodes",
            |m: &ResourceClass| { &m.suitableNodes },
            |m: &mut ResourceClass| { &mut m.suitableNodes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "structuredParameters",
            |m: &ResourceClass| { &m.structuredParameters },
            |m: &mut ResourceClass| { &mut m.structuredParameters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClass>(
            "ResourceClass",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClass {
    const NAME: &'static str = "ResourceClass";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.driverName = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.parametersRef)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.suitableNodes)?;
                },
                40 => {
                    self.structuredParameters = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.driverName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.parametersRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.suitableNodes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.structuredParameters {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.driverName.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.parametersRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.suitableNodes.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.structuredParameters {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClass {
        ResourceClass::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.driverName = ::std::option::Option::None;
        self.parametersRef.clear();
        self.suitableNodes.clear();
        self.structuredParameters = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClass {
        static instance: ResourceClass = ResourceClass {
            metadata: ::protobuf::MessageField::none(),
            driverName: ::std::option::Option::None,
            parametersRef: ::protobuf::MessageField::none(),
            suitableNodes: ::protobuf::MessageField::none(),
            structuredParameters: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClass {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClass").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClass {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.ResourceClassList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClassList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClassList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClassList.items)
    pub items: ::std::vec::Vec<ResourceClass>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.ResourceClassList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClassList {
    fn default() -> &'a ResourceClassList {
        <ResourceClassList as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClassList {
    pub fn new() -> ResourceClassList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.resource.v1alpha2.ResourceClass items = 2;

    pub fn items(&self) -> &[ResourceClass] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ResourceClass>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ResourceClass> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ResourceClass> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ResourceClassList| { &m.metadata },
            |m: &mut ResourceClassList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ResourceClassList| { &m.items },
            |m: &mut ResourceClassList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClassList>(
            "ResourceClassList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClassList {
    const NAME: &'static str = "ResourceClassList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClassList {
        ResourceClassList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClassList {
        static instance: ResourceClassList = ResourceClassList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClassList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClassList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClassList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClassList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.ResourceClassParameters)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClassParameters {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClassParameters.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClassParameters.generatedFrom)
    pub generatedFrom: ::protobuf::MessageField<ResourceClassParametersReference>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClassParameters.vendorParameters)
    pub vendorParameters: ::std::vec::Vec<VendorParameters>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClassParameters.filters)
    pub filters: ::std::vec::Vec<ResourceFilter>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.ResourceClassParameters.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClassParameters {
    fn default() -> &'a ResourceClassParameters {
        <ResourceClassParameters as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClassParameters {
    pub fn new() -> ResourceClassParameters {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.resource.v1alpha2.ResourceClassParametersReference generatedFrom = 2;

    pub fn generatedFrom(&self) -> &ResourceClassParametersReference {
        self.generatedFrom.as_ref().unwrap_or_else(|| <ResourceClassParametersReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_generatedFrom(&mut self) {
        self.generatedFrom.clear();
    }

    pub fn has_generatedFrom(&self) -> bool {
        self.generatedFrom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generatedFrom(&mut self, v: ResourceClassParametersReference) {
        self.generatedFrom = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_generatedFrom(&mut self) -> &mut ResourceClassParametersReference {
        self.generatedFrom.mut_or_insert_default()
    }

    // Take field
    pub fn take_generatedFrom(&mut self) -> ResourceClassParametersReference {
        self.generatedFrom.take().unwrap_or_else(|| ResourceClassParametersReference::new())
    }

    // repeated .api.resource.v1alpha2.VendorParameters vendorParameters = 3;

    pub fn vendorParameters(&self) -> &[VendorParameters] {
        &self.vendorParameters
    }

    pub fn clear_vendorParameters(&mut self) {
        self.vendorParameters.clear();
    }

    // Param is passed by value, moved
    pub fn set_vendorParameters(&mut self, v: ::std::vec::Vec<VendorParameters>) {
        self.vendorParameters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vendorParameters(&mut self) -> &mut ::std::vec::Vec<VendorParameters> {
        &mut self.vendorParameters
    }

    // Take field
    pub fn take_vendorParameters(&mut self) -> ::std::vec::Vec<VendorParameters> {
        ::std::mem::replace(&mut self.vendorParameters, ::std::vec::Vec::new())
    }

    // repeated .api.resource.v1alpha2.ResourceFilter filters = 4;

    pub fn filters(&self) -> &[ResourceFilter] {
        &self.filters
    }

    pub fn clear_filters(&mut self) {
        self.filters.clear();
    }

    // Param is passed by value, moved
    pub fn set_filters(&mut self, v: ::std::vec::Vec<ResourceFilter>) {
        self.filters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_filters(&mut self) -> &mut ::std::vec::Vec<ResourceFilter> {
        &mut self.filters
    }

    // Take field
    pub fn take_filters(&mut self) -> ::std::vec::Vec<ResourceFilter> {
        ::std::mem::replace(&mut self.filters, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ResourceClassParameters| { &m.metadata },
            |m: &mut ResourceClassParameters| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceClassParametersReference>(
            "generatedFrom",
            |m: &ResourceClassParameters| { &m.generatedFrom },
            |m: &mut ResourceClassParameters| { &mut m.generatedFrom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vendorParameters",
            |m: &ResourceClassParameters| { &m.vendorParameters },
            |m: &mut ResourceClassParameters| { &mut m.vendorParameters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "filters",
            |m: &ResourceClassParameters| { &m.filters },
            |m: &mut ResourceClassParameters| { &mut m.filters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClassParameters>(
            "ResourceClassParameters",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClassParameters {
    const NAME: &'static str = "ResourceClassParameters";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.generatedFrom)?;
                },
                26 => {
                    self.vendorParameters.push(is.read_message()?);
                },
                34 => {
                    self.filters.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.generatedFrom.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.vendorParameters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.generatedFrom.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.vendorParameters {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.filters {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClassParameters {
        ResourceClassParameters::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.generatedFrom.clear();
        self.vendorParameters.clear();
        self.filters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClassParameters {
        static instance: ResourceClassParameters = ResourceClassParameters {
            metadata: ::protobuf::MessageField::none(),
            generatedFrom: ::protobuf::MessageField::none(),
            vendorParameters: ::std::vec::Vec::new(),
            filters: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClassParameters {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClassParameters").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClassParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClassParameters {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.ResourceClassParametersList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClassParametersList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClassParametersList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClassParametersList.items)
    pub items: ::std::vec::Vec<ResourceClassParameters>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.ResourceClassParametersList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClassParametersList {
    fn default() -> &'a ResourceClassParametersList {
        <ResourceClassParametersList as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClassParametersList {
    pub fn new() -> ResourceClassParametersList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.resource.v1alpha2.ResourceClassParameters items = 2;

    pub fn items(&self) -> &[ResourceClassParameters] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ResourceClassParameters>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ResourceClassParameters> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ResourceClassParameters> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ResourceClassParametersList| { &m.metadata },
            |m: &mut ResourceClassParametersList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ResourceClassParametersList| { &m.items },
            |m: &mut ResourceClassParametersList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClassParametersList>(
            "ResourceClassParametersList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClassParametersList {
    const NAME: &'static str = "ResourceClassParametersList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClassParametersList {
        ResourceClassParametersList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClassParametersList {
        static instance: ResourceClassParametersList = ResourceClassParametersList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClassParametersList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClassParametersList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClassParametersList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClassParametersList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.ResourceClassParametersReference)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClassParametersReference {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClassParametersReference.apiGroup)
    pub apiGroup: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClassParametersReference.kind)
    pub kind: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClassParametersReference.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceClassParametersReference.namespace)
    pub namespace: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.ResourceClassParametersReference.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClassParametersReference {
    fn default() -> &'a ResourceClassParametersReference {
        <ResourceClassParametersReference as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClassParametersReference {
    pub fn new() -> ResourceClassParametersReference {
        ::std::default::Default::default()
    }

    // optional string apiGroup = 1;

    pub fn apiGroup(&self) -> &str {
        match self.apiGroup.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_apiGroup(&mut self) {
        self.apiGroup = ::std::option::Option::None;
    }

    pub fn has_apiGroup(&self) -> bool {
        self.apiGroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiGroup(&mut self, v: ::std::string::String) {
        self.apiGroup = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiGroup(&mut self) -> &mut ::std::string::String {
        if self.apiGroup.is_none() {
            self.apiGroup = ::std::option::Option::Some(::std::string::String::new());
        }
        self.apiGroup.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiGroup(&mut self) -> ::std::string::String {
        self.apiGroup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kind = 2;

    pub fn kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string namespace = 4;

    pub fn namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_namespace(&mut self) {
        self.namespace = ::std::option::Option::None;
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "apiGroup",
            |m: &ResourceClassParametersReference| { &m.apiGroup },
            |m: &mut ResourceClassParametersReference| { &mut m.apiGroup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &ResourceClassParametersReference| { &m.kind },
            |m: &mut ResourceClassParametersReference| { &mut m.kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ResourceClassParametersReference| { &m.name },
            |m: &mut ResourceClassParametersReference| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "namespace",
            |m: &ResourceClassParametersReference| { &m.namespace },
            |m: &mut ResourceClassParametersReference| { &mut m.namespace },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClassParametersReference>(
            "ResourceClassParametersReference",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClassParametersReference {
    const NAME: &'static str = "ResourceClassParametersReference";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.apiGroup = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.kind = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.namespace = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.apiGroup.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.apiGroup.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.kind.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.namespace.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClassParametersReference {
        ResourceClassParametersReference::new()
    }

    fn clear(&mut self) {
        self.apiGroup = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.namespace = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClassParametersReference {
        static instance: ResourceClassParametersReference = ResourceClassParametersReference {
            apiGroup: ::std::option::Option::None,
            kind: ::std::option::Option::None,
            name: ::std::option::Option::None,
            namespace: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClassParametersReference {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClassParametersReference").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClassParametersReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClassParametersReference {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.ResourceFilter)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceFilter {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceFilter.driverName)
    pub driverName: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceFilter.resourceFilterModel)
    pub resourceFilterModel: ::protobuf::MessageField<ResourceFilterModel>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.ResourceFilter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceFilter {
    fn default() -> &'a ResourceFilter {
        <ResourceFilter as ::protobuf::Message>::default_instance()
    }
}

impl ResourceFilter {
    pub fn new() -> ResourceFilter {
        ::std::default::Default::default()
    }

    // optional string driverName = 1;

    pub fn driverName(&self) -> &str {
        match self.driverName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_driverName(&mut self) {
        self.driverName = ::std::option::Option::None;
    }

    pub fn has_driverName(&self) -> bool {
        self.driverName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driverName(&mut self, v: ::std::string::String) {
        self.driverName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driverName(&mut self) -> &mut ::std::string::String {
        if self.driverName.is_none() {
            self.driverName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.driverName.as_mut().unwrap()
    }

    // Take field
    pub fn take_driverName(&mut self) -> ::std::string::String {
        self.driverName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.resource.v1alpha2.ResourceFilterModel resourceFilterModel = 2;

    pub fn resourceFilterModel(&self) -> &ResourceFilterModel {
        self.resourceFilterModel.as_ref().unwrap_or_else(|| <ResourceFilterModel as ::protobuf::Message>::default_instance())
    }

    pub fn clear_resourceFilterModel(&mut self) {
        self.resourceFilterModel.clear();
    }

    pub fn has_resourceFilterModel(&self) -> bool {
        self.resourceFilterModel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceFilterModel(&mut self, v: ResourceFilterModel) {
        self.resourceFilterModel = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceFilterModel(&mut self) -> &mut ResourceFilterModel {
        self.resourceFilterModel.mut_or_insert_default()
    }

    // Take field
    pub fn take_resourceFilterModel(&mut self) -> ResourceFilterModel {
        self.resourceFilterModel.take().unwrap_or_else(|| ResourceFilterModel::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "driverName",
            |m: &ResourceFilter| { &m.driverName },
            |m: &mut ResourceFilter| { &mut m.driverName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceFilterModel>(
            "resourceFilterModel",
            |m: &ResourceFilter| { &m.resourceFilterModel },
            |m: &mut ResourceFilter| { &mut m.resourceFilterModel },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceFilter>(
            "ResourceFilter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceFilter {
    const NAME: &'static str = "ResourceFilter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.driverName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resourceFilterModel)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.driverName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.resourceFilterModel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.driverName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.resourceFilterModel.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceFilter {
        ResourceFilter::new()
    }

    fn clear(&mut self) {
        self.driverName = ::std::option::Option::None;
        self.resourceFilterModel.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceFilter {
        static instance: ResourceFilter = ResourceFilter {
            driverName: ::std::option::Option::None,
            resourceFilterModel: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceFilter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceFilter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceFilter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.ResourceFilterModel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceFilterModel {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceFilterModel.namedResources)
    pub namedResources: ::protobuf::MessageField<NamedResourcesFilter>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.ResourceFilterModel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceFilterModel {
    fn default() -> &'a ResourceFilterModel {
        <ResourceFilterModel as ::protobuf::Message>::default_instance()
    }
}

impl ResourceFilterModel {
    pub fn new() -> ResourceFilterModel {
        ::std::default::Default::default()
    }

    // optional .api.resource.v1alpha2.NamedResourcesFilter namedResources = 1;

    pub fn namedResources(&self) -> &NamedResourcesFilter {
        self.namedResources.as_ref().unwrap_or_else(|| <NamedResourcesFilter as ::protobuf::Message>::default_instance())
    }

    pub fn clear_namedResources(&mut self) {
        self.namedResources.clear();
    }

    pub fn has_namedResources(&self) -> bool {
        self.namedResources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namedResources(&mut self, v: NamedResourcesFilter) {
        self.namedResources = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namedResources(&mut self) -> &mut NamedResourcesFilter {
        self.namedResources.mut_or_insert_default()
    }

    // Take field
    pub fn take_namedResources(&mut self) -> NamedResourcesFilter {
        self.namedResources.take().unwrap_or_else(|| NamedResourcesFilter::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NamedResourcesFilter>(
            "namedResources",
            |m: &ResourceFilterModel| { &m.namedResources },
            |m: &mut ResourceFilterModel| { &mut m.namedResources },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceFilterModel>(
            "ResourceFilterModel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceFilterModel {
    const NAME: &'static str = "ResourceFilterModel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.namedResources)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.namedResources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.namedResources.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceFilterModel {
        ResourceFilterModel::new()
    }

    fn clear(&mut self) {
        self.namedResources.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceFilterModel {
        static instance: ResourceFilterModel = ResourceFilterModel {
            namedResources: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceFilterModel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceFilterModel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceFilterModel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceFilterModel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.ResourceHandle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceHandle {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceHandle.driverName)
    pub driverName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceHandle.data)
    pub data: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceHandle.structuredData)
    pub structuredData: ::protobuf::MessageField<StructuredResourceHandle>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.ResourceHandle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceHandle {
    fn default() -> &'a ResourceHandle {
        <ResourceHandle as ::protobuf::Message>::default_instance()
    }
}

impl ResourceHandle {
    pub fn new() -> ResourceHandle {
        ::std::default::Default::default()
    }

    // optional string driverName = 1;

    pub fn driverName(&self) -> &str {
        match self.driverName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_driverName(&mut self) {
        self.driverName = ::std::option::Option::None;
    }

    pub fn has_driverName(&self) -> bool {
        self.driverName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driverName(&mut self, v: ::std::string::String) {
        self.driverName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driverName(&mut self) -> &mut ::std::string::String {
        if self.driverName.is_none() {
            self.driverName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.driverName.as_mut().unwrap()
    }

    // Take field
    pub fn take_driverName(&mut self) -> ::std::string::String {
        self.driverName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string data = 2;

    pub fn data(&self) -> &str {
        match self.data.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::string::String) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::string::String {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::string::String::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::string::String {
        self.data.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.resource.v1alpha2.StructuredResourceHandle structuredData = 5;

    pub fn structuredData(&self) -> &StructuredResourceHandle {
        self.structuredData.as_ref().unwrap_or_else(|| <StructuredResourceHandle as ::protobuf::Message>::default_instance())
    }

    pub fn clear_structuredData(&mut self) {
        self.structuredData.clear();
    }

    pub fn has_structuredData(&self) -> bool {
        self.structuredData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_structuredData(&mut self, v: StructuredResourceHandle) {
        self.structuredData = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_structuredData(&mut self) -> &mut StructuredResourceHandle {
        self.structuredData.mut_or_insert_default()
    }

    // Take field
    pub fn take_structuredData(&mut self) -> StructuredResourceHandle {
        self.structuredData.take().unwrap_or_else(|| StructuredResourceHandle::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "driverName",
            |m: &ResourceHandle| { &m.driverName },
            |m: &mut ResourceHandle| { &mut m.driverName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &ResourceHandle| { &m.data },
            |m: &mut ResourceHandle| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StructuredResourceHandle>(
            "structuredData",
            |m: &ResourceHandle| { &m.structuredData },
            |m: &mut ResourceHandle| { &mut m.structuredData },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceHandle>(
            "ResourceHandle",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceHandle {
    const NAME: &'static str = "ResourceHandle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.driverName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.data = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.structuredData)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.driverName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.structuredData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.driverName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.structuredData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceHandle {
        ResourceHandle::new()
    }

    fn clear(&mut self) {
        self.driverName = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.structuredData.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceHandle {
        static instance: ResourceHandle = ResourceHandle {
            driverName: ::std::option::Option::None,
            data: ::std::option::Option::None,
            structuredData: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceHandle {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceHandle").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceHandle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceHandle {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.ResourceModel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceModel {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceModel.namedResources)
    pub namedResources: ::protobuf::MessageField<NamedResourcesResources>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.ResourceModel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceModel {
    fn default() -> &'a ResourceModel {
        <ResourceModel as ::protobuf::Message>::default_instance()
    }
}

impl ResourceModel {
    pub fn new() -> ResourceModel {
        ::std::default::Default::default()
    }

    // optional .api.resource.v1alpha2.NamedResourcesResources namedResources = 1;

    pub fn namedResources(&self) -> &NamedResourcesResources {
        self.namedResources.as_ref().unwrap_or_else(|| <NamedResourcesResources as ::protobuf::Message>::default_instance())
    }

    pub fn clear_namedResources(&mut self) {
        self.namedResources.clear();
    }

    pub fn has_namedResources(&self) -> bool {
        self.namedResources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namedResources(&mut self, v: NamedResourcesResources) {
        self.namedResources = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namedResources(&mut self) -> &mut NamedResourcesResources {
        self.namedResources.mut_or_insert_default()
    }

    // Take field
    pub fn take_namedResources(&mut self) -> NamedResourcesResources {
        self.namedResources.take().unwrap_or_else(|| NamedResourcesResources::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NamedResourcesResources>(
            "namedResources",
            |m: &ResourceModel| { &m.namedResources },
            |m: &mut ResourceModel| { &mut m.namedResources },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceModel>(
            "ResourceModel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceModel {
    const NAME: &'static str = "ResourceModel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.namedResources)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.namedResources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.namedResources.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceModel {
        ResourceModel::new()
    }

    fn clear(&mut self) {
        self.namedResources.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceModel {
        static instance: ResourceModel = ResourceModel {
            namedResources: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceModel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceModel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceModel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceModel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.ResourceRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceRequest {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceRequest.vendorParameters)
    pub vendorParameters: ::protobuf::MessageField<crate::apimachinery::pkg::runtime::RawExtension>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceRequest.resourceRequestModel)
    pub resourceRequestModel: ::protobuf::MessageField<ResourceRequestModel>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.ResourceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceRequest {
    fn default() -> &'a ResourceRequest {
        <ResourceRequest as ::protobuf::Message>::default_instance()
    }
}

impl ResourceRequest {
    pub fn new() -> ResourceRequest {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.runtime.RawExtension vendorParameters = 1;

    pub fn vendorParameters(&self) -> &crate::apimachinery::pkg::runtime::RawExtension {
        self.vendorParameters.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::runtime::RawExtension as ::protobuf::Message>::default_instance())
    }

    pub fn clear_vendorParameters(&mut self) {
        self.vendorParameters.clear();
    }

    pub fn has_vendorParameters(&self) -> bool {
        self.vendorParameters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vendorParameters(&mut self, v: crate::apimachinery::pkg::runtime::RawExtension) {
        self.vendorParameters = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vendorParameters(&mut self) -> &mut crate::apimachinery::pkg::runtime::RawExtension {
        self.vendorParameters.mut_or_insert_default()
    }

    // Take field
    pub fn take_vendorParameters(&mut self) -> crate::apimachinery::pkg::runtime::RawExtension {
        self.vendorParameters.take().unwrap_or_else(|| crate::apimachinery::pkg::runtime::RawExtension::new())
    }

    // optional .api.resource.v1alpha2.ResourceRequestModel resourceRequestModel = 2;

    pub fn resourceRequestModel(&self) -> &ResourceRequestModel {
        self.resourceRequestModel.as_ref().unwrap_or_else(|| <ResourceRequestModel as ::protobuf::Message>::default_instance())
    }

    pub fn clear_resourceRequestModel(&mut self) {
        self.resourceRequestModel.clear();
    }

    pub fn has_resourceRequestModel(&self) -> bool {
        self.resourceRequestModel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceRequestModel(&mut self, v: ResourceRequestModel) {
        self.resourceRequestModel = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceRequestModel(&mut self) -> &mut ResourceRequestModel {
        self.resourceRequestModel.mut_or_insert_default()
    }

    // Take field
    pub fn take_resourceRequestModel(&mut self) -> ResourceRequestModel {
        self.resourceRequestModel.take().unwrap_or_else(|| ResourceRequestModel::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::runtime::RawExtension>(
            "vendorParameters",
            |m: &ResourceRequest| { &m.vendorParameters },
            |m: &mut ResourceRequest| { &mut m.vendorParameters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceRequestModel>(
            "resourceRequestModel",
            |m: &ResourceRequest| { &m.resourceRequestModel },
            |m: &mut ResourceRequest| { &mut m.resourceRequestModel },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceRequest>(
            "ResourceRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceRequest {
    const NAME: &'static str = "ResourceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vendorParameters)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resourceRequestModel)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.vendorParameters.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.resourceRequestModel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.vendorParameters.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.resourceRequestModel.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceRequest {
        ResourceRequest::new()
    }

    fn clear(&mut self) {
        self.vendorParameters.clear();
        self.resourceRequestModel.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceRequest {
        static instance: ResourceRequest = ResourceRequest {
            vendorParameters: ::protobuf::MessageField::none(),
            resourceRequestModel: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.ResourceRequestModel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceRequestModel {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceRequestModel.namedResources)
    pub namedResources: ::protobuf::MessageField<NamedResourcesRequest>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.ResourceRequestModel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceRequestModel {
    fn default() -> &'a ResourceRequestModel {
        <ResourceRequestModel as ::protobuf::Message>::default_instance()
    }
}

impl ResourceRequestModel {
    pub fn new() -> ResourceRequestModel {
        ::std::default::Default::default()
    }

    // optional .api.resource.v1alpha2.NamedResourcesRequest namedResources = 1;

    pub fn namedResources(&self) -> &NamedResourcesRequest {
        self.namedResources.as_ref().unwrap_or_else(|| <NamedResourcesRequest as ::protobuf::Message>::default_instance())
    }

    pub fn clear_namedResources(&mut self) {
        self.namedResources.clear();
    }

    pub fn has_namedResources(&self) -> bool {
        self.namedResources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namedResources(&mut self, v: NamedResourcesRequest) {
        self.namedResources = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namedResources(&mut self) -> &mut NamedResourcesRequest {
        self.namedResources.mut_or_insert_default()
    }

    // Take field
    pub fn take_namedResources(&mut self) -> NamedResourcesRequest {
        self.namedResources.take().unwrap_or_else(|| NamedResourcesRequest::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NamedResourcesRequest>(
            "namedResources",
            |m: &ResourceRequestModel| { &m.namedResources },
            |m: &mut ResourceRequestModel| { &mut m.namedResources },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceRequestModel>(
            "ResourceRequestModel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceRequestModel {
    const NAME: &'static str = "ResourceRequestModel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.namedResources)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.namedResources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.namedResources.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceRequestModel {
        ResourceRequestModel::new()
    }

    fn clear(&mut self) {
        self.namedResources.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceRequestModel {
        static instance: ResourceRequestModel = ResourceRequestModel {
            namedResources: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceRequestModel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceRequestModel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceRequestModel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceRequestModel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.ResourceSlice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceSlice {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceSlice.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceSlice.nodeName)
    pub nodeName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceSlice.driverName)
    pub driverName: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceSlice.resourceModel)
    pub resourceModel: ::protobuf::MessageField<ResourceModel>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.ResourceSlice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceSlice {
    fn default() -> &'a ResourceSlice {
        <ResourceSlice as ::protobuf::Message>::default_instance()
    }
}

impl ResourceSlice {
    pub fn new() -> ResourceSlice {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional string nodeName = 2;

    pub fn nodeName(&self) -> &str {
        match self.nodeName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nodeName(&mut self) {
        self.nodeName = ::std::option::Option::None;
    }

    pub fn has_nodeName(&self) -> bool {
        self.nodeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeName(&mut self, v: ::std::string::String) {
        self.nodeName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeName(&mut self) -> &mut ::std::string::String {
        if self.nodeName.is_none() {
            self.nodeName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.nodeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodeName(&mut self) -> ::std::string::String {
        self.nodeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string driverName = 3;

    pub fn driverName(&self) -> &str {
        match self.driverName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_driverName(&mut self) {
        self.driverName = ::std::option::Option::None;
    }

    pub fn has_driverName(&self) -> bool {
        self.driverName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driverName(&mut self, v: ::std::string::String) {
        self.driverName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driverName(&mut self) -> &mut ::std::string::String {
        if self.driverName.is_none() {
            self.driverName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.driverName.as_mut().unwrap()
    }

    // Take field
    pub fn take_driverName(&mut self) -> ::std::string::String {
        self.driverName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.resource.v1alpha2.ResourceModel resourceModel = 4;

    pub fn resourceModel(&self) -> &ResourceModel {
        self.resourceModel.as_ref().unwrap_or_else(|| <ResourceModel as ::protobuf::Message>::default_instance())
    }

    pub fn clear_resourceModel(&mut self) {
        self.resourceModel.clear();
    }

    pub fn has_resourceModel(&self) -> bool {
        self.resourceModel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceModel(&mut self, v: ResourceModel) {
        self.resourceModel = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceModel(&mut self) -> &mut ResourceModel {
        self.resourceModel.mut_or_insert_default()
    }

    // Take field
    pub fn take_resourceModel(&mut self) -> ResourceModel {
        self.resourceModel.take().unwrap_or_else(|| ResourceModel::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ResourceSlice| { &m.metadata },
            |m: &mut ResourceSlice| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nodeName",
            |m: &ResourceSlice| { &m.nodeName },
            |m: &mut ResourceSlice| { &mut m.nodeName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "driverName",
            |m: &ResourceSlice| { &m.driverName },
            |m: &mut ResourceSlice| { &mut m.driverName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceModel>(
            "resourceModel",
            |m: &ResourceSlice| { &m.resourceModel },
            |m: &mut ResourceSlice| { &mut m.resourceModel },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceSlice>(
            "ResourceSlice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceSlice {
    const NAME: &'static str = "ResourceSlice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.nodeName = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.driverName = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resourceModel)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.nodeName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.driverName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.resourceModel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.nodeName.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.driverName.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.resourceModel.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceSlice {
        ResourceSlice::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.nodeName = ::std::option::Option::None;
        self.driverName = ::std::option::Option::None;
        self.resourceModel.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceSlice {
        static instance: ResourceSlice = ResourceSlice {
            metadata: ::protobuf::MessageField::none(),
            nodeName: ::std::option::Option::None,
            driverName: ::std::option::Option::None,
            resourceModel: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceSlice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceSlice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceSlice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceSlice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.ResourceSliceList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceSliceList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceSliceList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.ResourceSliceList.items)
    pub items: ::std::vec::Vec<ResourceSlice>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.ResourceSliceList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceSliceList {
    fn default() -> &'a ResourceSliceList {
        <ResourceSliceList as ::protobuf::Message>::default_instance()
    }
}

impl ResourceSliceList {
    pub fn new() -> ResourceSliceList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.resource.v1alpha2.ResourceSlice items = 2;

    pub fn items(&self) -> &[ResourceSlice] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ResourceSlice>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ResourceSlice> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ResourceSlice> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ResourceSliceList| { &m.metadata },
            |m: &mut ResourceSliceList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ResourceSliceList| { &m.items },
            |m: &mut ResourceSliceList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceSliceList>(
            "ResourceSliceList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceSliceList {
    const NAME: &'static str = "ResourceSliceList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceSliceList {
        ResourceSliceList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceSliceList {
        static instance: ResourceSliceList = ResourceSliceList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceSliceList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceSliceList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceSliceList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceSliceList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.StructuredResourceHandle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StructuredResourceHandle {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.StructuredResourceHandle.vendorClassParameters)
    pub vendorClassParameters: ::protobuf::MessageField<crate::apimachinery::pkg::runtime::RawExtension>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.StructuredResourceHandle.vendorClaimParameters)
    pub vendorClaimParameters: ::protobuf::MessageField<crate::apimachinery::pkg::runtime::RawExtension>,
    // @@protoc_insertion_point(field:api.resource.v1alpha2.StructuredResourceHandle.nodeName)
    pub nodeName: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.StructuredResourceHandle.results)
    pub results: ::std::vec::Vec<DriverAllocationResult>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.StructuredResourceHandle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StructuredResourceHandle {
    fn default() -> &'a StructuredResourceHandle {
        <StructuredResourceHandle as ::protobuf::Message>::default_instance()
    }
}

impl StructuredResourceHandle {
    pub fn new() -> StructuredResourceHandle {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.runtime.RawExtension vendorClassParameters = 1;

    pub fn vendorClassParameters(&self) -> &crate::apimachinery::pkg::runtime::RawExtension {
        self.vendorClassParameters.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::runtime::RawExtension as ::protobuf::Message>::default_instance())
    }

    pub fn clear_vendorClassParameters(&mut self) {
        self.vendorClassParameters.clear();
    }

    pub fn has_vendorClassParameters(&self) -> bool {
        self.vendorClassParameters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vendorClassParameters(&mut self, v: crate::apimachinery::pkg::runtime::RawExtension) {
        self.vendorClassParameters = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vendorClassParameters(&mut self) -> &mut crate::apimachinery::pkg::runtime::RawExtension {
        self.vendorClassParameters.mut_or_insert_default()
    }

    // Take field
    pub fn take_vendorClassParameters(&mut self) -> crate::apimachinery::pkg::runtime::RawExtension {
        self.vendorClassParameters.take().unwrap_or_else(|| crate::apimachinery::pkg::runtime::RawExtension::new())
    }

    // optional .apimachinery.pkg.runtime.RawExtension vendorClaimParameters = 2;

    pub fn vendorClaimParameters(&self) -> &crate::apimachinery::pkg::runtime::RawExtension {
        self.vendorClaimParameters.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::runtime::RawExtension as ::protobuf::Message>::default_instance())
    }

    pub fn clear_vendorClaimParameters(&mut self) {
        self.vendorClaimParameters.clear();
    }

    pub fn has_vendorClaimParameters(&self) -> bool {
        self.vendorClaimParameters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vendorClaimParameters(&mut self, v: crate::apimachinery::pkg::runtime::RawExtension) {
        self.vendorClaimParameters = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vendorClaimParameters(&mut self) -> &mut crate::apimachinery::pkg::runtime::RawExtension {
        self.vendorClaimParameters.mut_or_insert_default()
    }

    // Take field
    pub fn take_vendorClaimParameters(&mut self) -> crate::apimachinery::pkg::runtime::RawExtension {
        self.vendorClaimParameters.take().unwrap_or_else(|| crate::apimachinery::pkg::runtime::RawExtension::new())
    }

    // optional string nodeName = 4;

    pub fn nodeName(&self) -> &str {
        match self.nodeName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nodeName(&mut self) {
        self.nodeName = ::std::option::Option::None;
    }

    pub fn has_nodeName(&self) -> bool {
        self.nodeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeName(&mut self, v: ::std::string::String) {
        self.nodeName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeName(&mut self) -> &mut ::std::string::String {
        if self.nodeName.is_none() {
            self.nodeName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.nodeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodeName(&mut self) -> ::std::string::String {
        self.nodeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.resource.v1alpha2.DriverAllocationResult results = 5;

    pub fn results(&self) -> &[DriverAllocationResult] {
        &self.results
    }

    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::std::vec::Vec<DriverAllocationResult>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::std::vec::Vec<DriverAllocationResult> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::std::vec::Vec<DriverAllocationResult> {
        ::std::mem::replace(&mut self.results, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::runtime::RawExtension>(
            "vendorClassParameters",
            |m: &StructuredResourceHandle| { &m.vendorClassParameters },
            |m: &mut StructuredResourceHandle| { &mut m.vendorClassParameters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::runtime::RawExtension>(
            "vendorClaimParameters",
            |m: &StructuredResourceHandle| { &m.vendorClaimParameters },
            |m: &mut StructuredResourceHandle| { &mut m.vendorClaimParameters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nodeName",
            |m: &StructuredResourceHandle| { &m.nodeName },
            |m: &mut StructuredResourceHandle| { &mut m.nodeName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &StructuredResourceHandle| { &m.results },
            |m: &mut StructuredResourceHandle| { &mut m.results },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StructuredResourceHandle>(
            "StructuredResourceHandle",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StructuredResourceHandle {
    const NAME: &'static str = "StructuredResourceHandle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vendorClassParameters)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vendorClaimParameters)?;
                },
                34 => {
                    self.nodeName = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.vendorClassParameters.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.vendorClaimParameters.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.nodeName.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.vendorClassParameters.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.vendorClaimParameters.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.nodeName.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StructuredResourceHandle {
        StructuredResourceHandle::new()
    }

    fn clear(&mut self) {
        self.vendorClassParameters.clear();
        self.vendorClaimParameters.clear();
        self.nodeName = ::std::option::Option::None;
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StructuredResourceHandle {
        static instance: StructuredResourceHandle = StructuredResourceHandle {
            vendorClassParameters: ::protobuf::MessageField::none(),
            vendorClaimParameters: ::protobuf::MessageField::none(),
            nodeName: ::std::option::Option::None,
            results: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StructuredResourceHandle {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StructuredResourceHandle").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StructuredResourceHandle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StructuredResourceHandle {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1alpha2.VendorParameters)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VendorParameters {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1alpha2.VendorParameters.driverName)
    pub driverName: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1alpha2.VendorParameters.parameters)
    pub parameters: ::protobuf::MessageField<crate::apimachinery::pkg::runtime::RawExtension>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1alpha2.VendorParameters.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VendorParameters {
    fn default() -> &'a VendorParameters {
        <VendorParameters as ::protobuf::Message>::default_instance()
    }
}

impl VendorParameters {
    pub fn new() -> VendorParameters {
        ::std::default::Default::default()
    }

    // optional string driverName = 1;

    pub fn driverName(&self) -> &str {
        match self.driverName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_driverName(&mut self) {
        self.driverName = ::std::option::Option::None;
    }

    pub fn has_driverName(&self) -> bool {
        self.driverName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driverName(&mut self, v: ::std::string::String) {
        self.driverName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driverName(&mut self) -> &mut ::std::string::String {
        if self.driverName.is_none() {
            self.driverName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.driverName.as_mut().unwrap()
    }

    // Take field
    pub fn take_driverName(&mut self) -> ::std::string::String {
        self.driverName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.runtime.RawExtension parameters = 2;

    pub fn parameters(&self) -> &crate::apimachinery::pkg::runtime::RawExtension {
        self.parameters.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::runtime::RawExtension as ::protobuf::Message>::default_instance())
    }

    pub fn clear_parameters(&mut self) {
        self.parameters.clear();
    }

    pub fn has_parameters(&self) -> bool {
        self.parameters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameters(&mut self, v: crate::apimachinery::pkg::runtime::RawExtension) {
        self.parameters = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parameters(&mut self) -> &mut crate::apimachinery::pkg::runtime::RawExtension {
        self.parameters.mut_or_insert_default()
    }

    // Take field
    pub fn take_parameters(&mut self) -> crate::apimachinery::pkg::runtime::RawExtension {
        self.parameters.take().unwrap_or_else(|| crate::apimachinery::pkg::runtime::RawExtension::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "driverName",
            |m: &VendorParameters| { &m.driverName },
            |m: &mut VendorParameters| { &mut m.driverName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::runtime::RawExtension>(
            "parameters",
            |m: &VendorParameters| { &m.parameters },
            |m: &mut VendorParameters| { &mut m.parameters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VendorParameters>(
            "VendorParameters",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VendorParameters {
    const NAME: &'static str = "VendorParameters";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.driverName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.parameters)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.driverName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.parameters.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.driverName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.parameters.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VendorParameters {
        VendorParameters::new()
    }

    fn clear(&mut self) {
        self.driverName = ::std::option::Option::None;
        self.parameters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VendorParameters {
        static instance: VendorParameters = VendorParameters {
            driverName: ::std::option::Option::None,
            parameters: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VendorParameters {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VendorParameters").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VendorParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VendorParameters {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n%api/resource/v1alpha2/generated.proto\x12\x15api.resource.v1alpha2\
    \x1a\x1bapi/core/v1/generated.proto\x1a-apimachinery/pkg/api/resource/ge\
    nerated.proto\x1a-apimachinery/pkg/apis/meta/v1/generated.proto\x1a(apim\
    achinery/pkg/runtime/generated.proto\x1a/apimachinery/pkg/runtime/schema\
    /generated.proto\"\xc8\x01\n\x10AllocationResult\x12O\n\x0fresourceHandl\
    es\x18\x01\x20\x03(\x0b2%.api.resource.v1alpha2.ResourceHandleR\x0fresou\
    rceHandles\x12E\n\x10availableOnNodes\x18\x02\x20\x01(\x0b2\x19.api.core\
    .v1.NodeSelectorR\x10availableOnNodes\x12\x1c\n\tshareable\x18\x03\x20\
    \x01(\x08R\tshareable\"v\n\x15AllocationResultModel\x12]\n\x0enamedResou\
    rces\x18\x01\x20\x01(\x0b25.api.resource.v1alpha2.NamedResourcesAllocati\
    onResultR\x0enamedResources\"\xde\x01\n\x16DriverAllocationResult\x12`\n\
    \x17vendorRequestParameters\x18\x01\x20\x01(\x0b2&.apimachinery.pkg.runt\
    ime.RawExtensionR\x17vendorRequestParameters\x12b\n\x15allocationResultM\
    odel\x18\x02\x20\x01(\x0b2,.api.resource.v1alpha2.AllocationResultModelR\
    \x15allocationResultModel\"\xc8\x01\n\x0eDriverRequests\x12\x1e\n\ndrive\
    rName\x18\x01\x20\x01(\tR\ndriverName\x12R\n\x10vendorParameters\x18\x02\
    \x20\x01(\x0b2&.apimachinery.pkg.runtime.RawExtensionR\x10vendorParamete\
    rs\x12B\n\x08requests\x18\x03\x20\x03(\x0b2&.api.resource.v1alpha2.Resou\
    rceRequestR\x08requests\"4\n\x1eNamedResourcesAllocationResult\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\"\x8a\x01\n\x17NamedResourcesAttrib\
    ute\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12[\n\x0eattributeVal\
    ue\x18\x02\x20\x01(\x0b23.api.resource.v1alpha2.NamedResourcesAttributeV\
    alueR\x0eattributeValue\"\xda\x02\n\x1cNamedResourcesAttributeValue\x12C\
    \n\x08quantity\x18\x06\x20\x01(\x0b2'.apimachinery.pkg.api.resource.Quan\
    tityR\x08quantity\x12\x12\n\x04bool\x18\x02\x20\x01(\x08R\x04bool\x12\
    \x10\n\x03int\x18\x07\x20\x01(\x03R\x03int\x12I\n\x08intSlice\x18\x08\
    \x20\x01(\x0b2-.api.resource.v1alpha2.NamedResourcesIntSliceR\x08intSlic\
    e\x12\x16\n\x06string\x18\x05\x20\x01(\tR\x06string\x12R\n\x0bstringSlic\
    e\x18\t\x20\x01(\x0b20.api.resource.v1alpha2.NamedResourcesStringSliceR\
    \x0bstringSlice\x12\x18\n\x07version\x18\n\x20\x01(\tR\x07version\"2\n\
    \x14NamedResourcesFilter\x12\x1a\n\x08selector\x18\x01\x20\x01(\tR\x08se\
    lector\"|\n\x16NamedResourcesInstance\x12\x12\n\x04name\x18\x01\x20\x01(\
    \tR\x04name\x12N\n\nattributes\x18\x02\x20\x03(\x0b2..api.resource.v1alp\
    ha2.NamedResourcesAttributeR\nattributes\",\n\x16NamedResourcesIntSlice\
    \x12\x12\n\x04ints\x18\x01\x20\x03(\x03R\x04ints\"3\n\x15NamedResourcesR\
    equest\x12\x1a\n\x08selector\x18\x01\x20\x01(\tR\x08selector\"f\n\x17Nam\
    edResourcesResources\x12K\n\tinstances\x18\x01\x20\x03(\x0b2-.api.resour\
    ce.v1alpha2.NamedResourcesInstanceR\tinstances\"5\n\x19NamedResourcesStr\
    ingSlice\x12\x18\n\x07strings\x18\x01\x20\x03(\tR\x07strings\"\xed\x01\n\
    \x14PodSchedulingContext\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apima\
    chinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12C\n\x04spec\x18\x02\
    \x20\x01(\x0b2/.api.resource.v1alpha2.PodSchedulingContextSpecR\x04spec\
    \x12I\n\x06status\x18\x03\x20\x01(\x0b21.api.resource.v1alpha2.PodSchedu\
    lingContextStatusR\x06status\"\xa2\x01\n\x18PodSchedulingContextList\x12\
    C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.Lis\
    tMetaR\x08metadata\x12A\n\x05items\x18\x02\x20\x03(\x0b2+.api.resource.v\
    1alpha2.PodSchedulingContextR\x05items\"f\n\x18PodSchedulingContextSpec\
    \x12\"\n\x0cselectedNode\x18\x01\x20\x01(\tR\x0cselectedNode\x12&\n\x0ep\
    otentialNodes\x18\x02\x20\x03(\tR\x0epotentialNodes\"z\n\x1aPodSchedulin\
    gContextStatus\x12\\\n\x0eresourceClaims\x18\x01\x20\x03(\x0b24.api.reso\
    urce.v1alpha2.ResourceClaimSchedulingStatusR\x0eresourceClaims\"\xd8\x01\
    \n\rResourceClaim\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachinery\
    .pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12<\n\x04spec\x18\x02\x20\x01\
    (\x0b2(.api.resource.v1alpha2.ResourceClaimSpecR\x04spec\x12B\n\x06statu\
    s\x18\x03\x20\x01(\x0b2*.api.resource.v1alpha2.ResourceClaimStatusR\x06s\
    tatus\"~\n\x1eResourceClaimConsumerReference\x12\x1a\n\x08apiGroup\x18\
    \x01\x20\x01(\tR\x08apiGroup\x12\x1a\n\x08resource\x18\x03\x20\x01(\tR\
    \x08resource\x12\x12\n\x04name\x18\x04\x20\x01(\tR\x04name\x12\x10\n\x03\
    uid\x18\x05\x20\x01(\tR\x03uid\"\x94\x01\n\x11ResourceClaimList\x12C\n\
    \x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMe\
    taR\x08metadata\x12:\n\x05items\x18\x02\x20\x03(\x0b2$.api.resource.v1al\
    pha2.ResourceClaimR\x05items\"\xac\x02\n\x17ResourceClaimParameters\x12E\
    \n\x08metadata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.Obje\
    ctMetaR\x08metadata\x12]\n\rgeneratedFrom\x18\x02\x20\x01(\x0b27.api.res\
    ource.v1alpha2.ResourceClaimParametersReferenceR\rgeneratedFrom\x12\x1c\
    \n\tshareable\x18\x03\x20\x01(\x08R\tshareable\x12M\n\x0edriverRequests\
    \x18\x04\x20\x03(\x0b2%.api.resource.v1alpha2.DriverRequestsR\x0edriverR\
    equests\"\xa8\x01\n\x1bResourceClaimParametersList\x12C\n\x08metadata\
    \x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metad\
    ata\x12D\n\x05items\x18\x02\x20\x03(\x0b2..api.resource.v1alpha2.Resourc\
    eClaimParametersR\x05items\"f\n\x20ResourceClaimParametersReference\x12\
    \x1a\n\x08apiGroup\x18\x01\x20\x01(\tR\x08apiGroup\x12\x12\n\x04kind\x18\
    \x02\x20\x01(\tR\x04kind\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\"\
    ]\n\x1dResourceClaimSchedulingStatus\x12\x12\n\x04name\x18\x01\x20\x01(\
    \tR\x04name\x12(\n\x0funsuitableNodes\x18\x02\x20\x03(\tR\x0funsuitableN\
    odes\"\xc8\x01\n\x11ResourceClaimSpec\x12,\n\x11resourceClassName\x18\
    \x01\x20\x01(\tR\x11resourceClassName\x12]\n\rparametersRef\x18\x02\x20\
    \x01(\x0b27.api.resource.v1alpha2.ResourceClaimParametersReferenceR\rpar\
    ametersRef\x12&\n\x0eallocationMode\x18\x03\x20\x01(\tR\x0eallocationMod\
    e\"\x8d\x02\n\x13ResourceClaimStatus\x12\x1e\n\ndriverName\x18\x01\x20\
    \x01(\tR\ndriverName\x12G\n\nallocation\x18\x02\x20\x01(\x0b2'.api.resou\
    rce.v1alpha2.AllocationResultR\nallocation\x12W\n\x0breservedFor\x18\x03\
    \x20\x03(\x0b25.api.resource.v1alpha2.ResourceClaimConsumerReferenceR\
    \x0breservedFor\x124\n\x15deallocationRequested\x18\x04\x20\x01(\x08R\
    \x15deallocationRequested\"\xa4\x01\n\x15ResourceClaimTemplate\x12E\n\
    \x08metadata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.Object\
    MetaR\x08metadata\x12D\n\x04spec\x18\x02\x20\x01(\x0b20.api.resource.v1a\
    lpha2.ResourceClaimTemplateSpecR\x04spec\"\xa4\x01\n\x19ResourceClaimTem\
    plateList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.api\
    s.meta.v1.ListMetaR\x08metadata\x12B\n\x05items\x18\x02\x20\x03(\x0b2,.a\
    pi.resource.v1alpha2.ResourceClaimTemplateR\x05items\"\xa0\x01\n\x19Reso\
    urceClaimTemplateSpec\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachi\
    nery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12<\n\x04spec\x18\x02\x20\
    \x01(\x0b2(.api.resource.v1alpha2.ResourceClaimSpecR\x04spec\"\xca\x02\n\
    \rResourceClass\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachinery.p\
    kg.apis.meta.v1.ObjectMetaR\x08metadata\x12\x1e\n\ndriverName\x18\x02\
    \x20\x01(\tR\ndriverName\x12]\n\rparametersRef\x18\x03\x20\x01(\x0b27.ap\
    i.resource.v1alpha2.ResourceClassParametersReferenceR\rparametersRef\x12\
    ?\n\rsuitableNodes\x18\x04\x20\x01(\x0b2\x19.api.core.v1.NodeSelectorR\r\
    suitableNodes\x122\n\x14structuredParameters\x18\x05\x20\x01(\x08R\x14st\
    ructuredParameters\"\x94\x01\n\x11ResourceClassList\x12C\n\x08metadata\
    \x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metad\
    ata\x12:\n\x05items\x18\x02\x20\x03(\x0b2$.api.resource.v1alpha2.Resourc\
    eClassR\x05items\"\xd5\x02\n\x17ResourceClassParameters\x12E\n\x08metada\
    ta\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08m\
    etadata\x12]\n\rgeneratedFrom\x18\x02\x20\x01(\x0b27.api.resource.v1alph\
    a2.ResourceClassParametersReferenceR\rgeneratedFrom\x12S\n\x10vendorPara\
    meters\x18\x03\x20\x03(\x0b2'.api.resource.v1alpha2.VendorParametersR\
    \x10vendorParameters\x12?\n\x07filters\x18\x04\x20\x03(\x0b2%.api.resour\
    ce.v1alpha2.ResourceFilterR\x07filters\"\xa8\x01\n\x1bResourceClassParam\
    etersList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.api\
    s.meta.v1.ListMetaR\x08metadata\x12D\n\x05items\x18\x02\x20\x03(\x0b2..a\
    pi.resource.v1alpha2.ResourceClassParametersR\x05items\"\x84\x01\n\x20Re\
    sourceClassParametersReference\x12\x1a\n\x08apiGroup\x18\x01\x20\x01(\tR\
    \x08apiGroup\x12\x12\n\x04kind\x18\x02\x20\x01(\tR\x04kind\x12\x12\n\x04\
    name\x18\x03\x20\x01(\tR\x04name\x12\x1c\n\tnamespace\x18\x04\x20\x01(\t\
    R\tnamespace\"\x8e\x01\n\x0eResourceFilter\x12\x1e\n\ndriverName\x18\x01\
    \x20\x01(\tR\ndriverName\x12\\\n\x13resourceFilterModel\x18\x02\x20\x01(\
    \x0b2*.api.resource.v1alpha2.ResourceFilterModelR\x13resourceFilterModel\
    \"j\n\x13ResourceFilterModel\x12S\n\x0enamedResources\x18\x01\x20\x01(\
    \x0b2+.api.resource.v1alpha2.NamedResourcesFilterR\x0enamedResources\"\
    \x9d\x01\n\x0eResourceHandle\x12\x1e\n\ndriverName\x18\x01\x20\x01(\tR\n\
    driverName\x12\x12\n\x04data\x18\x02\x20\x01(\tR\x04data\x12W\n\x0estruc\
    turedData\x18\x05\x20\x01(\x0b2/.api.resource.v1alpha2.StructuredResourc\
    eHandleR\x0estructuredData\"g\n\rResourceModel\x12V\n\x0enamedResources\
    \x18\x01\x20\x01(\x0b2..api.resource.v1alpha2.NamedResourcesResourcesR\
    \x0enamedResources\"\xc6\x01\n\x0fResourceRequest\x12R\n\x10vendorParame\
    ters\x18\x01\x20\x01(\x0b2&.apimachinery.pkg.runtime.RawExtensionR\x10ve\
    ndorParameters\x12_\n\x14resourceRequestModel\x18\x02\x20\x01(\x0b2+.api\
    .resource.v1alpha2.ResourceRequestModelR\x14resourceRequestModel\"l\n\
    \x14ResourceRequestModel\x12T\n\x0enamedResources\x18\x01\x20\x01(\x0b2,\
    .api.resource.v1alpha2.NamedResourcesRequestR\x0enamedResources\"\xde\
    \x01\n\rResourceSlice\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachi\
    nery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12\x1a\n\x08nodeName\x18\
    \x02\x20\x01(\tR\x08nodeName\x12\x1e\n\ndriverName\x18\x03\x20\x01(\tR\n\
    driverName\x12J\n\rresourceModel\x18\x04\x20\x01(\x0b2$.api.resource.v1a\
    lpha2.ResourceModelR\rresourceModel\"\x94\x01\n\x11ResourceSliceList\x12\
    C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.Lis\
    tMetaR\x08metadata\x12:\n\x05items\x18\x02\x20\x03(\x0b2$.api.resource.v\
    1alpha2.ResourceSliceR\x05items\"\xbb\x02\n\x18StructuredResourceHandle\
    \x12\\\n\x15vendorClassParameters\x18\x01\x20\x01(\x0b2&.apimachinery.pk\
    g.runtime.RawExtensionR\x15vendorClassParameters\x12\\\n\x15vendorClaimP\
    arameters\x18\x02\x20\x01(\x0b2&.apimachinery.pkg.runtime.RawExtensionR\
    \x15vendorClaimParameters\x12\x1a\n\x08nodeName\x18\x04\x20\x01(\tR\x08n\
    odeName\x12G\n\x07results\x18\x05\x20\x03(\x0b2-.api.resource.v1alpha2.D\
    riverAllocationResultR\x07results\"z\n\x10VendorParameters\x12\x1e\n\ndr\
    iverName\x18\x01\x20\x01(\tR\ndriverName\x12F\n\nparameters\x18\x02\x20\
    \x01(\x0b2&.apimachinery.pkg.runtime.RawExtensionR\nparametersB\x1eZ\x1c\
    k8s.io/api/resource/v1alpha2\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(5);
            deps.push(super::v1alpha2::file_descriptor().clone());
            deps.push(super::v1alpha2::file_descriptor().clone());
            deps.push(super::v1alpha2::file_descriptor().clone());
            deps.push(super::v1alpha2::file_descriptor().clone());
            deps.push(super::v1alpha2::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(44);
            messages.push(AllocationResult::generated_message_descriptor_data());
            messages.push(AllocationResultModel::generated_message_descriptor_data());
            messages.push(DriverAllocationResult::generated_message_descriptor_data());
            messages.push(DriverRequests::generated_message_descriptor_data());
            messages.push(NamedResourcesAllocationResult::generated_message_descriptor_data());
            messages.push(NamedResourcesAttribute::generated_message_descriptor_data());
            messages.push(NamedResourcesAttributeValue::generated_message_descriptor_data());
            messages.push(NamedResourcesFilter::generated_message_descriptor_data());
            messages.push(NamedResourcesInstance::generated_message_descriptor_data());
            messages.push(NamedResourcesIntSlice::generated_message_descriptor_data());
            messages.push(NamedResourcesRequest::generated_message_descriptor_data());
            messages.push(NamedResourcesResources::generated_message_descriptor_data());
            messages.push(NamedResourcesStringSlice::generated_message_descriptor_data());
            messages.push(PodSchedulingContext::generated_message_descriptor_data());
            messages.push(PodSchedulingContextList::generated_message_descriptor_data());
            messages.push(PodSchedulingContextSpec::generated_message_descriptor_data());
            messages.push(PodSchedulingContextStatus::generated_message_descriptor_data());
            messages.push(ResourceClaim::generated_message_descriptor_data());
            messages.push(ResourceClaimConsumerReference::generated_message_descriptor_data());
            messages.push(ResourceClaimList::generated_message_descriptor_data());
            messages.push(ResourceClaimParameters::generated_message_descriptor_data());
            messages.push(ResourceClaimParametersList::generated_message_descriptor_data());
            messages.push(ResourceClaimParametersReference::generated_message_descriptor_data());
            messages.push(ResourceClaimSchedulingStatus::generated_message_descriptor_data());
            messages.push(ResourceClaimSpec::generated_message_descriptor_data());
            messages.push(ResourceClaimStatus::generated_message_descriptor_data());
            messages.push(ResourceClaimTemplate::generated_message_descriptor_data());
            messages.push(ResourceClaimTemplateList::generated_message_descriptor_data());
            messages.push(ResourceClaimTemplateSpec::generated_message_descriptor_data());
            messages.push(ResourceClass::generated_message_descriptor_data());
            messages.push(ResourceClassList::generated_message_descriptor_data());
            messages.push(ResourceClassParameters::generated_message_descriptor_data());
            messages.push(ResourceClassParametersList::generated_message_descriptor_data());
            messages.push(ResourceClassParametersReference::generated_message_descriptor_data());
            messages.push(ResourceFilter::generated_message_descriptor_data());
            messages.push(ResourceFilterModel::generated_message_descriptor_data());
            messages.push(ResourceHandle::generated_message_descriptor_data());
            messages.push(ResourceModel::generated_message_descriptor_data());
            messages.push(ResourceRequest::generated_message_descriptor_data());
            messages.push(ResourceRequestModel::generated_message_descriptor_data());
            messages.push(ResourceSlice::generated_message_descriptor_data());
            messages.push(ResourceSliceList::generated_message_descriptor_data());
            messages.push(StructuredResourceHandle::generated_message_descriptor_data());
            messages.push(VendorParameters::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
