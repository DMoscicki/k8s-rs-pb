// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by protoc 3.21.12
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `api/admissionregistration/v1/generated.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.AuditAnnotation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AuditAnnotation {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1.AuditAnnotation.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.AuditAnnotation.valueExpression)
    pub valueExpression: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.AuditAnnotation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuditAnnotation {
    fn default() -> &'a AuditAnnotation {
        <AuditAnnotation as ::protobuf::Message>::default_instance()
    }
}

impl AuditAnnotation {
    pub fn new() -> AuditAnnotation {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string valueExpression = 2;

    pub fn valueExpression(&self) -> &str {
        match self.valueExpression.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_valueExpression(&mut self) {
        self.valueExpression = ::std::option::Option::None;
    }

    pub fn has_valueExpression(&self) -> bool {
        self.valueExpression.is_some()
    }

    // Param is passed by value, moved
    pub fn set_valueExpression(&mut self, v: ::std::string::String) {
        self.valueExpression = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_valueExpression(&mut self) -> &mut ::std::string::String {
        if self.valueExpression.is_none() {
            self.valueExpression = ::std::option::Option::Some(::std::string::String::new());
        }
        self.valueExpression.as_mut().unwrap()
    }

    // Take field
    pub fn take_valueExpression(&mut self) -> ::std::string::String {
        self.valueExpression.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &AuditAnnotation| { &m.key },
            |m: &mut AuditAnnotation| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "valueExpression",
            |m: &AuditAnnotation| { &m.valueExpression },
            |m: &mut AuditAnnotation| { &mut m.valueExpression },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AuditAnnotation>(
            "AuditAnnotation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AuditAnnotation {
    const NAME: &'static str = "AuditAnnotation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.valueExpression = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.valueExpression.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.valueExpression.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuditAnnotation {
        AuditAnnotation::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.valueExpression = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuditAnnotation {
        static instance: AuditAnnotation = AuditAnnotation {
            key: ::std::option::Option::None,
            valueExpression: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AuditAnnotation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AuditAnnotation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AuditAnnotation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuditAnnotation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.ExpressionWarning)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExpressionWarning {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ExpressionWarning.fieldRef)
    pub fieldRef: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ExpressionWarning.warning)
    pub warning: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.ExpressionWarning.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExpressionWarning {
    fn default() -> &'a ExpressionWarning {
        <ExpressionWarning as ::protobuf::Message>::default_instance()
    }
}

impl ExpressionWarning {
    pub fn new() -> ExpressionWarning {
        ::std::default::Default::default()
    }

    // optional string fieldRef = 2;

    pub fn fieldRef(&self) -> &str {
        match self.fieldRef.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fieldRef(&mut self) {
        self.fieldRef = ::std::option::Option::None;
    }

    pub fn has_fieldRef(&self) -> bool {
        self.fieldRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldRef(&mut self, v: ::std::string::String) {
        self.fieldRef = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldRef(&mut self) -> &mut ::std::string::String {
        if self.fieldRef.is_none() {
            self.fieldRef = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fieldRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldRef(&mut self) -> ::std::string::String {
        self.fieldRef.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string warning = 3;

    pub fn warning(&self) -> &str {
        match self.warning.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_warning(&mut self) {
        self.warning = ::std::option::Option::None;
    }

    pub fn has_warning(&self) -> bool {
        self.warning.is_some()
    }

    // Param is passed by value, moved
    pub fn set_warning(&mut self, v: ::std::string::String) {
        self.warning = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_warning(&mut self) -> &mut ::std::string::String {
        if self.warning.is_none() {
            self.warning = ::std::option::Option::Some(::std::string::String::new());
        }
        self.warning.as_mut().unwrap()
    }

    // Take field
    pub fn take_warning(&mut self) -> ::std::string::String {
        self.warning.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fieldRef",
            |m: &ExpressionWarning| { &m.fieldRef },
            |m: &mut ExpressionWarning| { &mut m.fieldRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "warning",
            |m: &ExpressionWarning| { &m.warning },
            |m: &mut ExpressionWarning| { &mut m.warning },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExpressionWarning>(
            "ExpressionWarning",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExpressionWarning {
    const NAME: &'static str = "ExpressionWarning";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.fieldRef = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.warning = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.fieldRef.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.warning.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.fieldRef.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.warning.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExpressionWarning {
        ExpressionWarning::new()
    }

    fn clear(&mut self) {
        self.fieldRef = ::std::option::Option::None;
        self.warning = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExpressionWarning {
        static instance: ExpressionWarning = ExpressionWarning {
            fieldRef: ::std::option::Option::None,
            warning: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExpressionWarning {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExpressionWarning").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExpressionWarning {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExpressionWarning {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.MatchCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MatchCondition {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1.MatchCondition.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.MatchCondition.expression)
    pub expression: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.MatchCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MatchCondition {
    fn default() -> &'a MatchCondition {
        <MatchCondition as ::protobuf::Message>::default_instance()
    }
}

impl MatchCondition {
    pub fn new() -> MatchCondition {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string expression = 2;

    pub fn expression(&self) -> &str {
        match self.expression.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_expression(&mut self) {
        self.expression = ::std::option::Option::None;
    }

    pub fn has_expression(&self) -> bool {
        self.expression.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expression(&mut self, v: ::std::string::String) {
        self.expression = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expression(&mut self) -> &mut ::std::string::String {
        if self.expression.is_none() {
            self.expression = ::std::option::Option::Some(::std::string::String::new());
        }
        self.expression.as_mut().unwrap()
    }

    // Take field
    pub fn take_expression(&mut self) -> ::std::string::String {
        self.expression.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &MatchCondition| { &m.name },
            |m: &mut MatchCondition| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expression",
            |m: &MatchCondition| { &m.expression },
            |m: &mut MatchCondition| { &mut m.expression },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MatchCondition>(
            "MatchCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MatchCondition {
    const NAME: &'static str = "MatchCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.expression = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.expression.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.expression.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MatchCondition {
        MatchCondition::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.expression = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MatchCondition {
        static instance: MatchCondition = MatchCondition {
            name: ::std::option::Option::None,
            expression: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MatchCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MatchCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MatchCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.MatchResources)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MatchResources {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.MatchResources.namespaceSelector)
    pub namespaceSelector: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.MatchResources.objectSelector)
    pub objectSelector: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.MatchResources.resourceRules)
    pub resourceRules: ::std::vec::Vec<NamedRuleWithOperations>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.MatchResources.excludeResourceRules)
    pub excludeResourceRules: ::std::vec::Vec<NamedRuleWithOperations>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.MatchResources.matchPolicy)
    pub matchPolicy: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.MatchResources.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MatchResources {
    fn default() -> &'a MatchResources {
        <MatchResources as ::protobuf::Message>::default_instance()
    }
}

impl MatchResources {
    pub fn new() -> MatchResources {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;

    pub fn namespaceSelector(&self) -> &crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_namespaceSelector(&mut self) {
        self.namespaceSelector.clear();
    }

    pub fn has_namespaceSelector(&self) -> bool {
        self.namespaceSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespaceSelector(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.namespaceSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespaceSelector(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_namespaceSelector(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;

    pub fn objectSelector(&self) -> &crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.objectSelector.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_objectSelector(&mut self) {
        self.objectSelector.clear();
    }

    pub fn has_objectSelector(&self) -> bool {
        self.objectSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_objectSelector(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.objectSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_objectSelector(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.objectSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_objectSelector(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.objectSelector.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // repeated .api.admissionregistration.v1.NamedRuleWithOperations resourceRules = 3;

    pub fn resourceRules(&self) -> &[NamedRuleWithOperations] {
        &self.resourceRules
    }

    pub fn clear_resourceRules(&mut self) {
        self.resourceRules.clear();
    }

    // Param is passed by value, moved
    pub fn set_resourceRules(&mut self, v: ::std::vec::Vec<NamedRuleWithOperations>) {
        self.resourceRules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resourceRules(&mut self) -> &mut ::std::vec::Vec<NamedRuleWithOperations> {
        &mut self.resourceRules
    }

    // Take field
    pub fn take_resourceRules(&mut self) -> ::std::vec::Vec<NamedRuleWithOperations> {
        ::std::mem::replace(&mut self.resourceRules, ::std::vec::Vec::new())
    }

    // repeated .api.admissionregistration.v1.NamedRuleWithOperations excludeResourceRules = 4;

    pub fn excludeResourceRules(&self) -> &[NamedRuleWithOperations] {
        &self.excludeResourceRules
    }

    pub fn clear_excludeResourceRules(&mut self) {
        self.excludeResourceRules.clear();
    }

    // Param is passed by value, moved
    pub fn set_excludeResourceRules(&mut self, v: ::std::vec::Vec<NamedRuleWithOperations>) {
        self.excludeResourceRules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excludeResourceRules(&mut self) -> &mut ::std::vec::Vec<NamedRuleWithOperations> {
        &mut self.excludeResourceRules
    }

    // Take field
    pub fn take_excludeResourceRules(&mut self) -> ::std::vec::Vec<NamedRuleWithOperations> {
        ::std::mem::replace(&mut self.excludeResourceRules, ::std::vec::Vec::new())
    }

    // optional string matchPolicy = 7;

    pub fn matchPolicy(&self) -> &str {
        match self.matchPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_matchPolicy(&mut self) {
        self.matchPolicy = ::std::option::Option::None;
    }

    pub fn has_matchPolicy(&self) -> bool {
        self.matchPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchPolicy(&mut self, v: ::std::string::String) {
        self.matchPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_matchPolicy(&mut self) -> &mut ::std::string::String {
        if self.matchPolicy.is_none() {
            self.matchPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.matchPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_matchPolicy(&mut self) -> ::std::string::String {
        self.matchPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "namespaceSelector",
            |m: &MatchResources| { &m.namespaceSelector },
            |m: &mut MatchResources| { &mut m.namespaceSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "objectSelector",
            |m: &MatchResources| { &m.objectSelector },
            |m: &mut MatchResources| { &mut m.objectSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resourceRules",
            |m: &MatchResources| { &m.resourceRules },
            |m: &mut MatchResources| { &mut m.resourceRules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "excludeResourceRules",
            |m: &MatchResources| { &m.excludeResourceRules },
            |m: &mut MatchResources| { &mut m.excludeResourceRules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchPolicy",
            |m: &MatchResources| { &m.matchPolicy },
            |m: &mut MatchResources| { &mut m.matchPolicy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MatchResources>(
            "MatchResources",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MatchResources {
    const NAME: &'static str = "MatchResources";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.namespaceSelector)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.objectSelector)?;
                },
                26 => {
                    self.resourceRules.push(is.read_message()?);
                },
                34 => {
                    self.excludeResourceRules.push(is.read_message()?);
                },
                58 => {
                    self.matchPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.namespaceSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.objectSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.resourceRules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.excludeResourceRules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.matchPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.namespaceSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.objectSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.resourceRules {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.excludeResourceRules {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.matchPolicy.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MatchResources {
        MatchResources::new()
    }

    fn clear(&mut self) {
        self.namespaceSelector.clear();
        self.objectSelector.clear();
        self.resourceRules.clear();
        self.excludeResourceRules.clear();
        self.matchPolicy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MatchResources {
        static instance: MatchResources = MatchResources {
            namespaceSelector: ::protobuf::MessageField::none(),
            objectSelector: ::protobuf::MessageField::none(),
            resourceRules: ::std::vec::Vec::new(),
            excludeResourceRules: ::std::vec::Vec::new(),
            matchPolicy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MatchResources {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MatchResources").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MatchResources {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchResources {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.MutatingWebhook)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MutatingWebhook {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1.MutatingWebhook.name)
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.MutatingWebhook.clientConfig)
    pub clientConfig: ::protobuf::MessageField<WebhookClientConfig>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.MutatingWebhook.rules)
    pub rules: ::std::vec::Vec<RuleWithOperations>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.MutatingWebhook.failurePolicy)
    pub failurePolicy: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.MutatingWebhook.matchPolicy)
    pub matchPolicy: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.MutatingWebhook.namespaceSelector)
    pub namespaceSelector: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.MutatingWebhook.objectSelector)
    pub objectSelector: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.MutatingWebhook.sideEffects)
    pub sideEffects: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.MutatingWebhook.timeoutSeconds)
    pub timeoutSeconds: ::std::option::Option<i32>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.MutatingWebhook.admissionReviewVersions)
    pub admissionReviewVersions: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.MutatingWebhook.reinvocationPolicy)
    pub reinvocationPolicy: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.MutatingWebhook.matchConditions)
    pub matchConditions: ::std::vec::Vec<MatchCondition>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.MutatingWebhook.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MutatingWebhook {
    fn default() -> &'a MutatingWebhook {
        <MutatingWebhook as ::protobuf::Message>::default_instance()
    }
}

impl MutatingWebhook {
    pub fn new() -> MutatingWebhook {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;

    pub fn clientConfig(&self) -> &WebhookClientConfig {
        self.clientConfig.as_ref().unwrap_or_else(|| <WebhookClientConfig as ::protobuf::Message>::default_instance())
    }

    pub fn clear_clientConfig(&mut self) {
        self.clientConfig.clear();
    }

    pub fn has_clientConfig(&self) -> bool {
        self.clientConfig.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientConfig(&mut self, v: WebhookClientConfig) {
        self.clientConfig = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientConfig(&mut self) -> &mut WebhookClientConfig {
        self.clientConfig.mut_or_insert_default()
    }

    // Take field
    pub fn take_clientConfig(&mut self) -> WebhookClientConfig {
        self.clientConfig.take().unwrap_or_else(|| WebhookClientConfig::new())
    }

    // repeated .api.admissionregistration.v1.RuleWithOperations rules = 3;

    pub fn rules(&self) -> &[RuleWithOperations] {
        &self.rules
    }

    pub fn clear_rules(&mut self) {
        self.rules.clear();
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: ::std::vec::Vec<RuleWithOperations>) {
        self.rules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rules(&mut self) -> &mut ::std::vec::Vec<RuleWithOperations> {
        &mut self.rules
    }

    // Take field
    pub fn take_rules(&mut self) -> ::std::vec::Vec<RuleWithOperations> {
        ::std::mem::replace(&mut self.rules, ::std::vec::Vec::new())
    }

    // optional string failurePolicy = 4;

    pub fn failurePolicy(&self) -> &str {
        match self.failurePolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_failurePolicy(&mut self) {
        self.failurePolicy = ::std::option::Option::None;
    }

    pub fn has_failurePolicy(&self) -> bool {
        self.failurePolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failurePolicy(&mut self, v: ::std::string::String) {
        self.failurePolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_failurePolicy(&mut self) -> &mut ::std::string::String {
        if self.failurePolicy.is_none() {
            self.failurePolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.failurePolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_failurePolicy(&mut self) -> ::std::string::String {
        self.failurePolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string matchPolicy = 9;

    pub fn matchPolicy(&self) -> &str {
        match self.matchPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_matchPolicy(&mut self) {
        self.matchPolicy = ::std::option::Option::None;
    }

    pub fn has_matchPolicy(&self) -> bool {
        self.matchPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchPolicy(&mut self, v: ::std::string::String) {
        self.matchPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_matchPolicy(&mut self) -> &mut ::std::string::String {
        if self.matchPolicy.is_none() {
            self.matchPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.matchPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_matchPolicy(&mut self) -> ::std::string::String {
        self.matchPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;

    pub fn namespaceSelector(&self) -> &crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_namespaceSelector(&mut self) {
        self.namespaceSelector.clear();
    }

    pub fn has_namespaceSelector(&self) -> bool {
        self.namespaceSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespaceSelector(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.namespaceSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespaceSelector(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_namespaceSelector(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;

    pub fn objectSelector(&self) -> &crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.objectSelector.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_objectSelector(&mut self) {
        self.objectSelector.clear();
    }

    pub fn has_objectSelector(&self) -> bool {
        self.objectSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_objectSelector(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.objectSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_objectSelector(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.objectSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_objectSelector(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.objectSelector.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional string sideEffects = 6;

    pub fn sideEffects(&self) -> &str {
        match self.sideEffects.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sideEffects(&mut self) {
        self.sideEffects = ::std::option::Option::None;
    }

    pub fn has_sideEffects(&self) -> bool {
        self.sideEffects.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sideEffects(&mut self, v: ::std::string::String) {
        self.sideEffects = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sideEffects(&mut self) -> &mut ::std::string::String {
        if self.sideEffects.is_none() {
            self.sideEffects = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sideEffects.as_mut().unwrap()
    }

    // Take field
    pub fn take_sideEffects(&mut self) -> ::std::string::String {
        self.sideEffects.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 timeoutSeconds = 7;

    pub fn timeoutSeconds(&self) -> i32 {
        self.timeoutSeconds.unwrap_or(0)
    }

    pub fn clear_timeoutSeconds(&mut self) {
        self.timeoutSeconds = ::std::option::Option::None;
    }

    pub fn has_timeoutSeconds(&self) -> bool {
        self.timeoutSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeoutSeconds(&mut self, v: i32) {
        self.timeoutSeconds = ::std::option::Option::Some(v);
    }

    // repeated string admissionReviewVersions = 8;

    pub fn admissionReviewVersions(&self) -> &[::std::string::String] {
        &self.admissionReviewVersions
    }

    pub fn clear_admissionReviewVersions(&mut self) {
        self.admissionReviewVersions.clear();
    }

    // Param is passed by value, moved
    pub fn set_admissionReviewVersions(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.admissionReviewVersions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_admissionReviewVersions(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.admissionReviewVersions
    }

    // Take field
    pub fn take_admissionReviewVersions(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.admissionReviewVersions, ::std::vec::Vec::new())
    }

    // optional string reinvocationPolicy = 10;

    pub fn reinvocationPolicy(&self) -> &str {
        match self.reinvocationPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reinvocationPolicy(&mut self) {
        self.reinvocationPolicy = ::std::option::Option::None;
    }

    pub fn has_reinvocationPolicy(&self) -> bool {
        self.reinvocationPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reinvocationPolicy(&mut self, v: ::std::string::String) {
        self.reinvocationPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reinvocationPolicy(&mut self) -> &mut ::std::string::String {
        if self.reinvocationPolicy.is_none() {
            self.reinvocationPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reinvocationPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_reinvocationPolicy(&mut self) -> ::std::string::String {
        self.reinvocationPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.admissionregistration.v1.MatchCondition matchConditions = 12;

    pub fn matchConditions(&self) -> &[MatchCondition] {
        &self.matchConditions
    }

    pub fn clear_matchConditions(&mut self) {
        self.matchConditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchConditions(&mut self, v: ::std::vec::Vec<MatchCondition>) {
        self.matchConditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchConditions(&mut self) -> &mut ::std::vec::Vec<MatchCondition> {
        &mut self.matchConditions
    }

    // Take field
    pub fn take_matchConditions(&mut self) -> ::std::vec::Vec<MatchCondition> {
        ::std::mem::replace(&mut self.matchConditions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &MutatingWebhook| { &m.name },
            |m: &mut MutatingWebhook| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WebhookClientConfig>(
            "clientConfig",
            |m: &MutatingWebhook| { &m.clientConfig },
            |m: &mut MutatingWebhook| { &mut m.clientConfig },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rules",
            |m: &MutatingWebhook| { &m.rules },
            |m: &mut MutatingWebhook| { &mut m.rules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "failurePolicy",
            |m: &MutatingWebhook| { &m.failurePolicy },
            |m: &mut MutatingWebhook| { &mut m.failurePolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchPolicy",
            |m: &MutatingWebhook| { &m.matchPolicy },
            |m: &mut MutatingWebhook| { &mut m.matchPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "namespaceSelector",
            |m: &MutatingWebhook| { &m.namespaceSelector },
            |m: &mut MutatingWebhook| { &mut m.namespaceSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "objectSelector",
            |m: &MutatingWebhook| { &m.objectSelector },
            |m: &mut MutatingWebhook| { &mut m.objectSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sideEffects",
            |m: &MutatingWebhook| { &m.sideEffects },
            |m: &mut MutatingWebhook| { &mut m.sideEffects },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timeoutSeconds",
            |m: &MutatingWebhook| { &m.timeoutSeconds },
            |m: &mut MutatingWebhook| { &mut m.timeoutSeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "admissionReviewVersions",
            |m: &MutatingWebhook| { &m.admissionReviewVersions },
            |m: &mut MutatingWebhook| { &mut m.admissionReviewVersions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reinvocationPolicy",
            |m: &MutatingWebhook| { &m.reinvocationPolicy },
            |m: &mut MutatingWebhook| { &mut m.reinvocationPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matchConditions",
            |m: &MutatingWebhook| { &m.matchConditions },
            |m: &mut MutatingWebhook| { &mut m.matchConditions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MutatingWebhook>(
            "MutatingWebhook",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MutatingWebhook {
    const NAME: &'static str = "MutatingWebhook";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.clientConfig)?;
                },
                26 => {
                    self.rules.push(is.read_message()?);
                },
                34 => {
                    self.failurePolicy = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.matchPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.namespaceSelector)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.objectSelector)?;
                },
                50 => {
                    self.sideEffects = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.timeoutSeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                66 => {
                    self.admissionReviewVersions.push(is.read_string()?);
                },
                82 => {
                    self.reinvocationPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.matchConditions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.clientConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.failurePolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.matchPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.namespaceSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.objectSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sideEffects.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.timeoutSeconds {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        for value in &self.admissionReviewVersions {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if let Some(v) = self.reinvocationPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        for value in &self.matchConditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.clientConfig.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.rules {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.failurePolicy.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.matchPolicy.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.namespaceSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.objectSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.sideEffects.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.timeoutSeconds {
            os.write_int32(7, v)?;
        }
        for v in &self.admissionReviewVersions {
            os.write_string(8, &v)?;
        };
        if let Some(v) = self.reinvocationPolicy.as_ref() {
            os.write_string(10, v)?;
        }
        for v in &self.matchConditions {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MutatingWebhook {
        MutatingWebhook::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.clientConfig.clear();
        self.rules.clear();
        self.failurePolicy = ::std::option::Option::None;
        self.matchPolicy = ::std::option::Option::None;
        self.namespaceSelector.clear();
        self.objectSelector.clear();
        self.sideEffects = ::std::option::Option::None;
        self.timeoutSeconds = ::std::option::Option::None;
        self.admissionReviewVersions.clear();
        self.reinvocationPolicy = ::std::option::Option::None;
        self.matchConditions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MutatingWebhook {
        static instance: MutatingWebhook = MutatingWebhook {
            name: ::std::option::Option::None,
            clientConfig: ::protobuf::MessageField::none(),
            rules: ::std::vec::Vec::new(),
            failurePolicy: ::std::option::Option::None,
            matchPolicy: ::std::option::Option::None,
            namespaceSelector: ::protobuf::MessageField::none(),
            objectSelector: ::protobuf::MessageField::none(),
            sideEffects: ::std::option::Option::None,
            timeoutSeconds: ::std::option::Option::None,
            admissionReviewVersions: ::std::vec::Vec::new(),
            reinvocationPolicy: ::std::option::Option::None,
            matchConditions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MutatingWebhook {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MutatingWebhook").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MutatingWebhook {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MutatingWebhook {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.MutatingWebhookConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MutatingWebhookConfiguration {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.MutatingWebhookConfiguration.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.MutatingWebhookConfiguration.Webhooks)
    pub Webhooks: ::std::vec::Vec<MutatingWebhook>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.MutatingWebhookConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MutatingWebhookConfiguration {
    fn default() -> &'a MutatingWebhookConfiguration {
        <MutatingWebhookConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl MutatingWebhookConfiguration {
    pub fn new() -> MutatingWebhookConfiguration {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // repeated .api.admissionregistration.v1.MutatingWebhook Webhooks = 2;

    pub fn Webhooks(&self) -> &[MutatingWebhook] {
        &self.Webhooks
    }

    pub fn clear_Webhooks(&mut self) {
        self.Webhooks.clear();
    }

    // Param is passed by value, moved
    pub fn set_Webhooks(&mut self, v: ::std::vec::Vec<MutatingWebhook>) {
        self.Webhooks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Webhooks(&mut self) -> &mut ::std::vec::Vec<MutatingWebhook> {
        &mut self.Webhooks
    }

    // Take field
    pub fn take_Webhooks(&mut self) -> ::std::vec::Vec<MutatingWebhook> {
        ::std::mem::replace(&mut self.Webhooks, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &MutatingWebhookConfiguration| { &m.metadata },
            |m: &mut MutatingWebhookConfiguration| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Webhooks",
            |m: &MutatingWebhookConfiguration| { &m.Webhooks },
            |m: &mut MutatingWebhookConfiguration| { &mut m.Webhooks },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MutatingWebhookConfiguration>(
            "MutatingWebhookConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MutatingWebhookConfiguration {
    const NAME: &'static str = "MutatingWebhookConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.Webhooks.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.Webhooks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.Webhooks {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MutatingWebhookConfiguration {
        MutatingWebhookConfiguration::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.Webhooks.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MutatingWebhookConfiguration {
        static instance: MutatingWebhookConfiguration = MutatingWebhookConfiguration {
            metadata: ::protobuf::MessageField::none(),
            Webhooks: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MutatingWebhookConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MutatingWebhookConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MutatingWebhookConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MutatingWebhookConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.MutatingWebhookConfigurationList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MutatingWebhookConfigurationList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.MutatingWebhookConfigurationList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.MutatingWebhookConfigurationList.items)
    pub items: ::std::vec::Vec<MutatingWebhookConfiguration>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.MutatingWebhookConfigurationList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MutatingWebhookConfigurationList {
    fn default() -> &'a MutatingWebhookConfigurationList {
        <MutatingWebhookConfigurationList as ::protobuf::Message>::default_instance()
    }
}

impl MutatingWebhookConfigurationList {
    pub fn new() -> MutatingWebhookConfigurationList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.admissionregistration.v1.MutatingWebhookConfiguration items = 2;

    pub fn items(&self) -> &[MutatingWebhookConfiguration] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<MutatingWebhookConfiguration>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<MutatingWebhookConfiguration> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<MutatingWebhookConfiguration> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &MutatingWebhookConfigurationList| { &m.metadata },
            |m: &mut MutatingWebhookConfigurationList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &MutatingWebhookConfigurationList| { &m.items },
            |m: &mut MutatingWebhookConfigurationList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MutatingWebhookConfigurationList>(
            "MutatingWebhookConfigurationList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MutatingWebhookConfigurationList {
    const NAME: &'static str = "MutatingWebhookConfigurationList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MutatingWebhookConfigurationList {
        MutatingWebhookConfigurationList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MutatingWebhookConfigurationList {
        static instance: MutatingWebhookConfigurationList = MutatingWebhookConfigurationList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MutatingWebhookConfigurationList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MutatingWebhookConfigurationList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MutatingWebhookConfigurationList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MutatingWebhookConfigurationList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.NamedRuleWithOperations)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NamedRuleWithOperations {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.NamedRuleWithOperations.resourceNames)
    pub resourceNames: ::std::vec::Vec<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.NamedRuleWithOperations.ruleWithOperations)
    pub ruleWithOperations: ::protobuf::MessageField<RuleWithOperations>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.NamedRuleWithOperations.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NamedRuleWithOperations {
    fn default() -> &'a NamedRuleWithOperations {
        <NamedRuleWithOperations as ::protobuf::Message>::default_instance()
    }
}

impl NamedRuleWithOperations {
    pub fn new() -> NamedRuleWithOperations {
        ::std::default::Default::default()
    }

    // repeated string resourceNames = 1;

    pub fn resourceNames(&self) -> &[::std::string::String] {
        &self.resourceNames
    }

    pub fn clear_resourceNames(&mut self) {
        self.resourceNames.clear();
    }

    // Param is passed by value, moved
    pub fn set_resourceNames(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.resourceNames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resourceNames(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.resourceNames
    }

    // Take field
    pub fn take_resourceNames(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.resourceNames, ::std::vec::Vec::new())
    }

    // optional .api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;

    pub fn ruleWithOperations(&self) -> &RuleWithOperations {
        self.ruleWithOperations.as_ref().unwrap_or_else(|| <RuleWithOperations as ::protobuf::Message>::default_instance())
    }

    pub fn clear_ruleWithOperations(&mut self) {
        self.ruleWithOperations.clear();
    }

    pub fn has_ruleWithOperations(&self) -> bool {
        self.ruleWithOperations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ruleWithOperations(&mut self, v: RuleWithOperations) {
        self.ruleWithOperations = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ruleWithOperations(&mut self) -> &mut RuleWithOperations {
        self.ruleWithOperations.mut_or_insert_default()
    }

    // Take field
    pub fn take_ruleWithOperations(&mut self) -> RuleWithOperations {
        self.ruleWithOperations.take().unwrap_or_else(|| RuleWithOperations::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resourceNames",
            |m: &NamedRuleWithOperations| { &m.resourceNames },
            |m: &mut NamedRuleWithOperations| { &mut m.resourceNames },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RuleWithOperations>(
            "ruleWithOperations",
            |m: &NamedRuleWithOperations| { &m.ruleWithOperations },
            |m: &mut NamedRuleWithOperations| { &mut m.ruleWithOperations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NamedRuleWithOperations>(
            "NamedRuleWithOperations",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NamedRuleWithOperations {
    const NAME: &'static str = "NamedRuleWithOperations";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.resourceNames.push(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ruleWithOperations)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.resourceNames {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.ruleWithOperations.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.resourceNames {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.ruleWithOperations.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NamedRuleWithOperations {
        NamedRuleWithOperations::new()
    }

    fn clear(&mut self) {
        self.resourceNames.clear();
        self.ruleWithOperations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NamedRuleWithOperations {
        static instance: NamedRuleWithOperations = NamedRuleWithOperations {
            resourceNames: ::std::vec::Vec::new(),
            ruleWithOperations: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NamedRuleWithOperations {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NamedRuleWithOperations").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NamedRuleWithOperations {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamedRuleWithOperations {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.ParamKind)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ParamKind {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ParamKind.apiVersion)
    pub apiVersion: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ParamKind.kind)
    pub kind: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.ParamKind.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ParamKind {
    fn default() -> &'a ParamKind {
        <ParamKind as ::protobuf::Message>::default_instance()
    }
}

impl ParamKind {
    pub fn new() -> ParamKind {
        ::std::default::Default::default()
    }

    // optional string apiVersion = 1;

    pub fn apiVersion(&self) -> &str {
        match self.apiVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_apiVersion(&mut self) {
        self.apiVersion = ::std::option::Option::None;
    }

    pub fn has_apiVersion(&self) -> bool {
        self.apiVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiVersion(&mut self, v: ::std::string::String) {
        self.apiVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiVersion(&mut self) -> &mut ::std::string::String {
        if self.apiVersion.is_none() {
            self.apiVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.apiVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiVersion(&mut self) -> ::std::string::String {
        self.apiVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kind = 2;

    pub fn kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "apiVersion",
            |m: &ParamKind| { &m.apiVersion },
            |m: &mut ParamKind| { &mut m.apiVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &ParamKind| { &m.kind },
            |m: &mut ParamKind| { &mut m.kind },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ParamKind>(
            "ParamKind",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ParamKind {
    const NAME: &'static str = "ParamKind";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.apiVersion = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.kind = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.apiVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.apiVersion.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.kind.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ParamKind {
        ParamKind::new()
    }

    fn clear(&mut self) {
        self.apiVersion = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ParamKind {
        static instance: ParamKind = ParamKind {
            apiVersion: ::std::option::Option::None,
            kind: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ParamKind {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ParamKind").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ParamKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParamKind {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.ParamRef)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ParamRef {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ParamRef.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ParamRef.namespace)
    pub namespace: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ParamRef.selector)
    pub selector: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ParamRef.parameterNotFoundAction)
    pub parameterNotFoundAction: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.ParamRef.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ParamRef {
    fn default() -> &'a ParamRef {
        <ParamRef as ::protobuf::Message>::default_instance()
    }
}

impl ParamRef {
    pub fn new() -> ParamRef {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string namespace = 2;

    pub fn namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_namespace(&mut self) {
        self.namespace = ::std::option::Option::None;
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;

    pub fn selector(&self) -> &crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    pub fn has_selector(&self) -> bool {
        self.selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.selector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selector(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.mut_or_insert_default()
    }

    // Take field
    pub fn take_selector(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional string parameterNotFoundAction = 4;

    pub fn parameterNotFoundAction(&self) -> &str {
        match self.parameterNotFoundAction.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_parameterNotFoundAction(&mut self) {
        self.parameterNotFoundAction = ::std::option::Option::None;
    }

    pub fn has_parameterNotFoundAction(&self) -> bool {
        self.parameterNotFoundAction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameterNotFoundAction(&mut self, v: ::std::string::String) {
        self.parameterNotFoundAction = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parameterNotFoundAction(&mut self) -> &mut ::std::string::String {
        if self.parameterNotFoundAction.is_none() {
            self.parameterNotFoundAction = ::std::option::Option::Some(::std::string::String::new());
        }
        self.parameterNotFoundAction.as_mut().unwrap()
    }

    // Take field
    pub fn take_parameterNotFoundAction(&mut self) -> ::std::string::String {
        self.parameterNotFoundAction.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ParamRef| { &m.name },
            |m: &mut ParamRef| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "namespace",
            |m: &ParamRef| { &m.namespace },
            |m: &mut ParamRef| { &mut m.namespace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "selector",
            |m: &ParamRef| { &m.selector },
            |m: &mut ParamRef| { &mut m.selector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parameterNotFoundAction",
            |m: &ParamRef| { &m.parameterNotFoundAction },
            |m: &mut ParamRef| { &mut m.parameterNotFoundAction },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ParamRef>(
            "ParamRef",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ParamRef {
    const NAME: &'static str = "ParamRef";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.namespace = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.selector)?;
                },
                34 => {
                    self.parameterNotFoundAction = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.parameterNotFoundAction.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.namespace.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.selector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.parameterNotFoundAction.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ParamRef {
        ParamRef::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.namespace = ::std::option::Option::None;
        self.selector.clear();
        self.parameterNotFoundAction = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ParamRef {
        static instance: ParamRef = ParamRef {
            name: ::std::option::Option::None,
            namespace: ::std::option::Option::None,
            selector: ::protobuf::MessageField::none(),
            parameterNotFoundAction: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ParamRef {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ParamRef").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ParamRef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParamRef {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.Rule)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Rule {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.Rule.apiGroups)
    pub apiGroups: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.Rule.apiVersions)
    pub apiVersions: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.Rule.resources)
    pub resources: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.Rule.scope)
    pub scope: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.Rule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rule {
    fn default() -> &'a Rule {
        <Rule as ::protobuf::Message>::default_instance()
    }
}

impl Rule {
    pub fn new() -> Rule {
        ::std::default::Default::default()
    }

    // repeated string apiGroups = 1;

    pub fn apiGroups(&self) -> &[::std::string::String] {
        &self.apiGroups
    }

    pub fn clear_apiGroups(&mut self) {
        self.apiGroups.clear();
    }

    // Param is passed by value, moved
    pub fn set_apiGroups(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.apiGroups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apiGroups(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.apiGroups
    }

    // Take field
    pub fn take_apiGroups(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.apiGroups, ::std::vec::Vec::new())
    }

    // repeated string apiVersions = 2;

    pub fn apiVersions(&self) -> &[::std::string::String] {
        &self.apiVersions
    }

    pub fn clear_apiVersions(&mut self) {
        self.apiVersions.clear();
    }

    // Param is passed by value, moved
    pub fn set_apiVersions(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.apiVersions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apiVersions(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.apiVersions
    }

    // Take field
    pub fn take_apiVersions(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.apiVersions, ::std::vec::Vec::new())
    }

    // repeated string resources = 3;

    pub fn resources(&self) -> &[::std::string::String] {
        &self.resources
    }

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.resources, ::std::vec::Vec::new())
    }

    // optional string scope = 4;

    pub fn scope(&self) -> &str {
        match self.scope.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_scope(&mut self) {
        self.scope = ::std::option::Option::None;
    }

    pub fn has_scope(&self) -> bool {
        self.scope.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: ::std::string::String) {
        self.scope = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scope(&mut self) -> &mut ::std::string::String {
        if self.scope.is_none() {
            self.scope = ::std::option::Option::Some(::std::string::String::new());
        }
        self.scope.as_mut().unwrap()
    }

    // Take field
    pub fn take_scope(&mut self) -> ::std::string::String {
        self.scope.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apiGroups",
            |m: &Rule| { &m.apiGroups },
            |m: &mut Rule| { &mut m.apiGroups },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apiVersions",
            |m: &Rule| { &m.apiVersions },
            |m: &mut Rule| { &mut m.apiVersions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resources",
            |m: &Rule| { &m.resources },
            |m: &mut Rule| { &mut m.resources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scope",
            |m: &Rule| { &m.scope },
            |m: &mut Rule| { &mut m.scope },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rule>(
            "Rule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rule {
    const NAME: &'static str = "Rule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.apiGroups.push(is.read_string()?);
                },
                18 => {
                    self.apiVersions.push(is.read_string()?);
                },
                26 => {
                    self.resources.push(is.read_string()?);
                },
                34 => {
                    self.scope = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.apiGroups {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.apiVersions {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.resources {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(v) = self.scope.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.apiGroups {
            os.write_string(1, &v)?;
        };
        for v in &self.apiVersions {
            os.write_string(2, &v)?;
        };
        for v in &self.resources {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.scope.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rule {
        Rule::new()
    }

    fn clear(&mut self) {
        self.apiGroups.clear();
        self.apiVersions.clear();
        self.resources.clear();
        self.scope = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rule {
        static instance: Rule = Rule {
            apiGroups: ::std::vec::Vec::new(),
            apiVersions: ::std::vec::Vec::new(),
            resources: ::std::vec::Vec::new(),
            scope: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.RuleWithOperations)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RuleWithOperations {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.RuleWithOperations.operations)
    pub operations: ::std::vec::Vec<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.RuleWithOperations.rule)
    pub rule: ::protobuf::MessageField<Rule>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.RuleWithOperations.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RuleWithOperations {
    fn default() -> &'a RuleWithOperations {
        <RuleWithOperations as ::protobuf::Message>::default_instance()
    }
}

impl RuleWithOperations {
    pub fn new() -> RuleWithOperations {
        ::std::default::Default::default()
    }

    // repeated string operations = 1;

    pub fn operations(&self) -> &[::std::string::String] {
        &self.operations
    }

    pub fn clear_operations(&mut self) {
        self.operations.clear();
    }

    // Param is passed by value, moved
    pub fn set_operations(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.operations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_operations(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.operations
    }

    // Take field
    pub fn take_operations(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.operations, ::std::vec::Vec::new())
    }

    // optional .api.admissionregistration.v1.Rule rule = 2;

    pub fn rule(&self) -> &Rule {
        self.rule.as_ref().unwrap_or_else(|| <Rule as ::protobuf::Message>::default_instance())
    }

    pub fn clear_rule(&mut self) {
        self.rule.clear();
    }

    pub fn has_rule(&self) -> bool {
        self.rule.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rule(&mut self, v: Rule) {
        self.rule = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rule(&mut self) -> &mut Rule {
        self.rule.mut_or_insert_default()
    }

    // Take field
    pub fn take_rule(&mut self) -> Rule {
        self.rule.take().unwrap_or_else(|| Rule::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "operations",
            |m: &RuleWithOperations| { &m.operations },
            |m: &mut RuleWithOperations| { &mut m.operations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Rule>(
            "rule",
            |m: &RuleWithOperations| { &m.rule },
            |m: &mut RuleWithOperations| { &mut m.rule },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RuleWithOperations>(
            "RuleWithOperations",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RuleWithOperations {
    const NAME: &'static str = "RuleWithOperations";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.operations.push(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rule)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.operations {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.rule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.operations {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.rule.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RuleWithOperations {
        RuleWithOperations::new()
    }

    fn clear(&mut self) {
        self.operations.clear();
        self.rule.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RuleWithOperations {
        static instance: RuleWithOperations = RuleWithOperations {
            operations: ::std::vec::Vec::new(),
            rule: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RuleWithOperations {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RuleWithOperations").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RuleWithOperations {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuleWithOperations {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.ServiceReference)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServiceReference {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ServiceReference.namespace)
    pub namespace: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ServiceReference.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ServiceReference.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ServiceReference.port)
    pub port: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.ServiceReference.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceReference {
    fn default() -> &'a ServiceReference {
        <ServiceReference as ::protobuf::Message>::default_instance()
    }
}

impl ServiceReference {
    pub fn new() -> ServiceReference {
        ::std::default::Default::default()
    }

    // optional string namespace = 1;

    pub fn namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_namespace(&mut self) {
        self.namespace = ::std::option::Option::None;
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string path = 3;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 port = 4;

    pub fn port(&self) -> i32 {
        self.port.unwrap_or(0)
    }

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "namespace",
            |m: &ServiceReference| { &m.namespace },
            |m: &mut ServiceReference| { &mut m.namespace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ServiceReference| { &m.name },
            |m: &mut ServiceReference| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &ServiceReference| { &m.path },
            |m: &mut ServiceReference| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "port",
            |m: &ServiceReference| { &m.port },
            |m: &mut ServiceReference| { &mut m.port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServiceReference>(
            "ServiceReference",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServiceReference {
    const NAME: &'static str = "ServiceReference";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.namespace = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.port = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.namespace.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.port {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceReference {
        ServiceReference::new()
    }

    fn clear(&mut self) {
        self.namespace = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.path = ::std::option::Option::None;
        self.port = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceReference {
        static instance: ServiceReference = ServiceReference {
            namespace: ::std::option::Option::None,
            name: ::std::option::Option::None,
            path: ::std::option::Option::None,
            port: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServiceReference {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceReference").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceReference {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.TypeChecking)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TypeChecking {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.TypeChecking.expressionWarnings)
    pub expressionWarnings: ::std::vec::Vec<ExpressionWarning>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.TypeChecking.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TypeChecking {
    fn default() -> &'a TypeChecking {
        <TypeChecking as ::protobuf::Message>::default_instance()
    }
}

impl TypeChecking {
    pub fn new() -> TypeChecking {
        ::std::default::Default::default()
    }

    // repeated .api.admissionregistration.v1.ExpressionWarning expressionWarnings = 1;

    pub fn expressionWarnings(&self) -> &[ExpressionWarning] {
        &self.expressionWarnings
    }

    pub fn clear_expressionWarnings(&mut self) {
        self.expressionWarnings.clear();
    }

    // Param is passed by value, moved
    pub fn set_expressionWarnings(&mut self, v: ::std::vec::Vec<ExpressionWarning>) {
        self.expressionWarnings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_expressionWarnings(&mut self) -> &mut ::std::vec::Vec<ExpressionWarning> {
        &mut self.expressionWarnings
    }

    // Take field
    pub fn take_expressionWarnings(&mut self) -> ::std::vec::Vec<ExpressionWarning> {
        ::std::mem::replace(&mut self.expressionWarnings, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "expressionWarnings",
            |m: &TypeChecking| { &m.expressionWarnings },
            |m: &mut TypeChecking| { &mut m.expressionWarnings },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TypeChecking>(
            "TypeChecking",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TypeChecking {
    const NAME: &'static str = "TypeChecking";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.expressionWarnings.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.expressionWarnings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.expressionWarnings {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TypeChecking {
        TypeChecking::new()
    }

    fn clear(&mut self) {
        self.expressionWarnings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TypeChecking {
        static instance: TypeChecking = TypeChecking {
            expressionWarnings: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TypeChecking {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TypeChecking").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TypeChecking {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeChecking {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.ValidatingAdmissionPolicy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingAdmissionPolicy {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingAdmissionPolicy.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingAdmissionPolicy.spec)
    pub spec: ::protobuf::MessageField<ValidatingAdmissionPolicySpec>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingAdmissionPolicy.status)
    pub status: ::protobuf::MessageField<ValidatingAdmissionPolicyStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.ValidatingAdmissionPolicy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingAdmissionPolicy {
    fn default() -> &'a ValidatingAdmissionPolicy {
        <ValidatingAdmissionPolicy as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingAdmissionPolicy {
    pub fn new() -> ValidatingAdmissionPolicy {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.admissionregistration.v1.ValidatingAdmissionPolicySpec spec = 2;

    pub fn spec(&self) -> &ValidatingAdmissionPolicySpec {
        self.spec.as_ref().unwrap_or_else(|| <ValidatingAdmissionPolicySpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ValidatingAdmissionPolicySpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ValidatingAdmissionPolicySpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ValidatingAdmissionPolicySpec {
        self.spec.take().unwrap_or_else(|| ValidatingAdmissionPolicySpec::new())
    }

    // optional .api.admissionregistration.v1.ValidatingAdmissionPolicyStatus status = 3;

    pub fn status(&self) -> &ValidatingAdmissionPolicyStatus {
        self.status.as_ref().unwrap_or_else(|| <ValidatingAdmissionPolicyStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ValidatingAdmissionPolicyStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ValidatingAdmissionPolicyStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> ValidatingAdmissionPolicyStatus {
        self.status.take().unwrap_or_else(|| ValidatingAdmissionPolicyStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ValidatingAdmissionPolicy| { &m.metadata },
            |m: &mut ValidatingAdmissionPolicy| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ValidatingAdmissionPolicySpec>(
            "spec",
            |m: &ValidatingAdmissionPolicy| { &m.spec },
            |m: &mut ValidatingAdmissionPolicy| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ValidatingAdmissionPolicyStatus>(
            "status",
            |m: &ValidatingAdmissionPolicy| { &m.status },
            |m: &mut ValidatingAdmissionPolicy| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingAdmissionPolicy>(
            "ValidatingAdmissionPolicy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingAdmissionPolicy {
    const NAME: &'static str = "ValidatingAdmissionPolicy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingAdmissionPolicy {
        ValidatingAdmissionPolicy::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingAdmissionPolicy {
        static instance: ValidatingAdmissionPolicy = ValidatingAdmissionPolicy {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingAdmissionPolicy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingAdmissionPolicy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingAdmissionPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingAdmissionPolicy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.ValidatingAdmissionPolicyBinding)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingAdmissionPolicyBinding {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingAdmissionPolicyBinding.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingAdmissionPolicyBinding.spec)
    pub spec: ::protobuf::MessageField<ValidatingAdmissionPolicyBindingSpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.ValidatingAdmissionPolicyBinding.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingAdmissionPolicyBinding {
    fn default() -> &'a ValidatingAdmissionPolicyBinding {
        <ValidatingAdmissionPolicyBinding as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingAdmissionPolicyBinding {
    pub fn new() -> ValidatingAdmissionPolicyBinding {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec spec = 2;

    pub fn spec(&self) -> &ValidatingAdmissionPolicyBindingSpec {
        self.spec.as_ref().unwrap_or_else(|| <ValidatingAdmissionPolicyBindingSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ValidatingAdmissionPolicyBindingSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ValidatingAdmissionPolicyBindingSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ValidatingAdmissionPolicyBindingSpec {
        self.spec.take().unwrap_or_else(|| ValidatingAdmissionPolicyBindingSpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ValidatingAdmissionPolicyBinding| { &m.metadata },
            |m: &mut ValidatingAdmissionPolicyBinding| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ValidatingAdmissionPolicyBindingSpec>(
            "spec",
            |m: &ValidatingAdmissionPolicyBinding| { &m.spec },
            |m: &mut ValidatingAdmissionPolicyBinding| { &mut m.spec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingAdmissionPolicyBinding>(
            "ValidatingAdmissionPolicyBinding",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingAdmissionPolicyBinding {
    const NAME: &'static str = "ValidatingAdmissionPolicyBinding";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingAdmissionPolicyBinding {
        ValidatingAdmissionPolicyBinding::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingAdmissionPolicyBinding {
        static instance: ValidatingAdmissionPolicyBinding = ValidatingAdmissionPolicyBinding {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingAdmissionPolicyBinding {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingAdmissionPolicyBinding").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingAdmissionPolicyBinding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingAdmissionPolicyBinding {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.ValidatingAdmissionPolicyBindingList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingAdmissionPolicyBindingList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingAdmissionPolicyBindingList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingAdmissionPolicyBindingList.items)
    pub items: ::std::vec::Vec<ValidatingAdmissionPolicyBinding>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.ValidatingAdmissionPolicyBindingList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingAdmissionPolicyBindingList {
    fn default() -> &'a ValidatingAdmissionPolicyBindingList {
        <ValidatingAdmissionPolicyBindingList as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingAdmissionPolicyBindingList {
    pub fn new() -> ValidatingAdmissionPolicyBindingList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.admissionregistration.v1.ValidatingAdmissionPolicyBinding items = 2;

    pub fn items(&self) -> &[ValidatingAdmissionPolicyBinding] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ValidatingAdmissionPolicyBinding>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ValidatingAdmissionPolicyBinding> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ValidatingAdmissionPolicyBinding> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ValidatingAdmissionPolicyBindingList| { &m.metadata },
            |m: &mut ValidatingAdmissionPolicyBindingList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ValidatingAdmissionPolicyBindingList| { &m.items },
            |m: &mut ValidatingAdmissionPolicyBindingList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingAdmissionPolicyBindingList>(
            "ValidatingAdmissionPolicyBindingList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingAdmissionPolicyBindingList {
    const NAME: &'static str = "ValidatingAdmissionPolicyBindingList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingAdmissionPolicyBindingList {
        ValidatingAdmissionPolicyBindingList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingAdmissionPolicyBindingList {
        static instance: ValidatingAdmissionPolicyBindingList = ValidatingAdmissionPolicyBindingList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingAdmissionPolicyBindingList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingAdmissionPolicyBindingList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingAdmissionPolicyBindingList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingAdmissionPolicyBindingList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingAdmissionPolicyBindingSpec {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec.policyName)
    pub policyName: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec.paramRef)
    pub paramRef: ::protobuf::MessageField<ParamRef>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec.matchResources)
    pub matchResources: ::protobuf::MessageField<MatchResources>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec.validationActions)
    pub validationActions: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingAdmissionPolicyBindingSpec {
    fn default() -> &'a ValidatingAdmissionPolicyBindingSpec {
        <ValidatingAdmissionPolicyBindingSpec as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingAdmissionPolicyBindingSpec {
    pub fn new() -> ValidatingAdmissionPolicyBindingSpec {
        ::std::default::Default::default()
    }

    // optional string policyName = 1;

    pub fn policyName(&self) -> &str {
        match self.policyName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_policyName(&mut self) {
        self.policyName = ::std::option::Option::None;
    }

    pub fn has_policyName(&self) -> bool {
        self.policyName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_policyName(&mut self, v: ::std::string::String) {
        self.policyName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_policyName(&mut self) -> &mut ::std::string::String {
        if self.policyName.is_none() {
            self.policyName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.policyName.as_mut().unwrap()
    }

    // Take field
    pub fn take_policyName(&mut self) -> ::std::string::String {
        self.policyName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.admissionregistration.v1.ParamRef paramRef = 2;

    pub fn paramRef(&self) -> &ParamRef {
        self.paramRef.as_ref().unwrap_or_else(|| <ParamRef as ::protobuf::Message>::default_instance())
    }

    pub fn clear_paramRef(&mut self) {
        self.paramRef.clear();
    }

    pub fn has_paramRef(&self) -> bool {
        self.paramRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paramRef(&mut self, v: ParamRef) {
        self.paramRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paramRef(&mut self) -> &mut ParamRef {
        self.paramRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_paramRef(&mut self) -> ParamRef {
        self.paramRef.take().unwrap_or_else(|| ParamRef::new())
    }

    // optional .api.admissionregistration.v1.MatchResources matchResources = 3;

    pub fn matchResources(&self) -> &MatchResources {
        self.matchResources.as_ref().unwrap_or_else(|| <MatchResources as ::protobuf::Message>::default_instance())
    }

    pub fn clear_matchResources(&mut self) {
        self.matchResources.clear();
    }

    pub fn has_matchResources(&self) -> bool {
        self.matchResources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchResources(&mut self, v: MatchResources) {
        self.matchResources = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_matchResources(&mut self) -> &mut MatchResources {
        self.matchResources.mut_or_insert_default()
    }

    // Take field
    pub fn take_matchResources(&mut self) -> MatchResources {
        self.matchResources.take().unwrap_or_else(|| MatchResources::new())
    }

    // repeated string validationActions = 4;

    pub fn validationActions(&self) -> &[::std::string::String] {
        &self.validationActions
    }

    pub fn clear_validationActions(&mut self) {
        self.validationActions.clear();
    }

    // Param is passed by value, moved
    pub fn set_validationActions(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.validationActions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_validationActions(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.validationActions
    }

    // Take field
    pub fn take_validationActions(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.validationActions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "policyName",
            |m: &ValidatingAdmissionPolicyBindingSpec| { &m.policyName },
            |m: &mut ValidatingAdmissionPolicyBindingSpec| { &mut m.policyName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ParamRef>(
            "paramRef",
            |m: &ValidatingAdmissionPolicyBindingSpec| { &m.paramRef },
            |m: &mut ValidatingAdmissionPolicyBindingSpec| { &mut m.paramRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MatchResources>(
            "matchResources",
            |m: &ValidatingAdmissionPolicyBindingSpec| { &m.matchResources },
            |m: &mut ValidatingAdmissionPolicyBindingSpec| { &mut m.matchResources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "validationActions",
            |m: &ValidatingAdmissionPolicyBindingSpec| { &m.validationActions },
            |m: &mut ValidatingAdmissionPolicyBindingSpec| { &mut m.validationActions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingAdmissionPolicyBindingSpec>(
            "ValidatingAdmissionPolicyBindingSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingAdmissionPolicyBindingSpec {
    const NAME: &'static str = "ValidatingAdmissionPolicyBindingSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.policyName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.paramRef)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.matchResources)?;
                },
                34 => {
                    self.validationActions.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.policyName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.paramRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.matchResources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.validationActions {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.policyName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.paramRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.matchResources.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.validationActions {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingAdmissionPolicyBindingSpec {
        ValidatingAdmissionPolicyBindingSpec::new()
    }

    fn clear(&mut self) {
        self.policyName = ::std::option::Option::None;
        self.paramRef.clear();
        self.matchResources.clear();
        self.validationActions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingAdmissionPolicyBindingSpec {
        static instance: ValidatingAdmissionPolicyBindingSpec = ValidatingAdmissionPolicyBindingSpec {
            policyName: ::std::option::Option::None,
            paramRef: ::protobuf::MessageField::none(),
            matchResources: ::protobuf::MessageField::none(),
            validationActions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingAdmissionPolicyBindingSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingAdmissionPolicyBindingSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingAdmissionPolicyBindingSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingAdmissionPolicyBindingSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.ValidatingAdmissionPolicyList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingAdmissionPolicyList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingAdmissionPolicyList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingAdmissionPolicyList.items)
    pub items: ::std::vec::Vec<ValidatingAdmissionPolicy>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.ValidatingAdmissionPolicyList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingAdmissionPolicyList {
    fn default() -> &'a ValidatingAdmissionPolicyList {
        <ValidatingAdmissionPolicyList as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingAdmissionPolicyList {
    pub fn new() -> ValidatingAdmissionPolicyList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.admissionregistration.v1.ValidatingAdmissionPolicy items = 2;

    pub fn items(&self) -> &[ValidatingAdmissionPolicy] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ValidatingAdmissionPolicy>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ValidatingAdmissionPolicy> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ValidatingAdmissionPolicy> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ValidatingAdmissionPolicyList| { &m.metadata },
            |m: &mut ValidatingAdmissionPolicyList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ValidatingAdmissionPolicyList| { &m.items },
            |m: &mut ValidatingAdmissionPolicyList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingAdmissionPolicyList>(
            "ValidatingAdmissionPolicyList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingAdmissionPolicyList {
    const NAME: &'static str = "ValidatingAdmissionPolicyList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingAdmissionPolicyList {
        ValidatingAdmissionPolicyList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingAdmissionPolicyList {
        static instance: ValidatingAdmissionPolicyList = ValidatingAdmissionPolicyList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingAdmissionPolicyList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingAdmissionPolicyList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingAdmissionPolicyList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingAdmissionPolicyList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.ValidatingAdmissionPolicySpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingAdmissionPolicySpec {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingAdmissionPolicySpec.paramKind)
    pub paramKind: ::protobuf::MessageField<ParamKind>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingAdmissionPolicySpec.matchConstraints)
    pub matchConstraints: ::protobuf::MessageField<MatchResources>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingAdmissionPolicySpec.validations)
    pub validations: ::std::vec::Vec<Validation>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingAdmissionPolicySpec.failurePolicy)
    pub failurePolicy: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingAdmissionPolicySpec.auditAnnotations)
    pub auditAnnotations: ::std::vec::Vec<AuditAnnotation>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingAdmissionPolicySpec.matchConditions)
    pub matchConditions: ::std::vec::Vec<MatchCondition>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingAdmissionPolicySpec.variables)
    pub variables: ::std::vec::Vec<Variable>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.ValidatingAdmissionPolicySpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingAdmissionPolicySpec {
    fn default() -> &'a ValidatingAdmissionPolicySpec {
        <ValidatingAdmissionPolicySpec as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingAdmissionPolicySpec {
    pub fn new() -> ValidatingAdmissionPolicySpec {
        ::std::default::Default::default()
    }

    // optional .api.admissionregistration.v1.ParamKind paramKind = 1;

    pub fn paramKind(&self) -> &ParamKind {
        self.paramKind.as_ref().unwrap_or_else(|| <ParamKind as ::protobuf::Message>::default_instance())
    }

    pub fn clear_paramKind(&mut self) {
        self.paramKind.clear();
    }

    pub fn has_paramKind(&self) -> bool {
        self.paramKind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paramKind(&mut self, v: ParamKind) {
        self.paramKind = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paramKind(&mut self) -> &mut ParamKind {
        self.paramKind.mut_or_insert_default()
    }

    // Take field
    pub fn take_paramKind(&mut self) -> ParamKind {
        self.paramKind.take().unwrap_or_else(|| ParamKind::new())
    }

    // optional .api.admissionregistration.v1.MatchResources matchConstraints = 2;

    pub fn matchConstraints(&self) -> &MatchResources {
        self.matchConstraints.as_ref().unwrap_or_else(|| <MatchResources as ::protobuf::Message>::default_instance())
    }

    pub fn clear_matchConstraints(&mut self) {
        self.matchConstraints.clear();
    }

    pub fn has_matchConstraints(&self) -> bool {
        self.matchConstraints.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchConstraints(&mut self, v: MatchResources) {
        self.matchConstraints = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_matchConstraints(&mut self) -> &mut MatchResources {
        self.matchConstraints.mut_or_insert_default()
    }

    // Take field
    pub fn take_matchConstraints(&mut self) -> MatchResources {
        self.matchConstraints.take().unwrap_or_else(|| MatchResources::new())
    }

    // repeated .api.admissionregistration.v1.Validation validations = 3;

    pub fn validations(&self) -> &[Validation] {
        &self.validations
    }

    pub fn clear_validations(&mut self) {
        self.validations.clear();
    }

    // Param is passed by value, moved
    pub fn set_validations(&mut self, v: ::std::vec::Vec<Validation>) {
        self.validations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_validations(&mut self) -> &mut ::std::vec::Vec<Validation> {
        &mut self.validations
    }

    // Take field
    pub fn take_validations(&mut self) -> ::std::vec::Vec<Validation> {
        ::std::mem::replace(&mut self.validations, ::std::vec::Vec::new())
    }

    // optional string failurePolicy = 4;

    pub fn failurePolicy(&self) -> &str {
        match self.failurePolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_failurePolicy(&mut self) {
        self.failurePolicy = ::std::option::Option::None;
    }

    pub fn has_failurePolicy(&self) -> bool {
        self.failurePolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failurePolicy(&mut self, v: ::std::string::String) {
        self.failurePolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_failurePolicy(&mut self) -> &mut ::std::string::String {
        if self.failurePolicy.is_none() {
            self.failurePolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.failurePolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_failurePolicy(&mut self) -> ::std::string::String {
        self.failurePolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.admissionregistration.v1.AuditAnnotation auditAnnotations = 5;

    pub fn auditAnnotations(&self) -> &[AuditAnnotation] {
        &self.auditAnnotations
    }

    pub fn clear_auditAnnotations(&mut self) {
        self.auditAnnotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_auditAnnotations(&mut self, v: ::std::vec::Vec<AuditAnnotation>) {
        self.auditAnnotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_auditAnnotations(&mut self) -> &mut ::std::vec::Vec<AuditAnnotation> {
        &mut self.auditAnnotations
    }

    // Take field
    pub fn take_auditAnnotations(&mut self) -> ::std::vec::Vec<AuditAnnotation> {
        ::std::mem::replace(&mut self.auditAnnotations, ::std::vec::Vec::new())
    }

    // repeated .api.admissionregistration.v1.MatchCondition matchConditions = 6;

    pub fn matchConditions(&self) -> &[MatchCondition] {
        &self.matchConditions
    }

    pub fn clear_matchConditions(&mut self) {
        self.matchConditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchConditions(&mut self, v: ::std::vec::Vec<MatchCondition>) {
        self.matchConditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchConditions(&mut self) -> &mut ::std::vec::Vec<MatchCondition> {
        &mut self.matchConditions
    }

    // Take field
    pub fn take_matchConditions(&mut self) -> ::std::vec::Vec<MatchCondition> {
        ::std::mem::replace(&mut self.matchConditions, ::std::vec::Vec::new())
    }

    // repeated .api.admissionregistration.v1.Variable variables = 7;

    pub fn variables(&self) -> &[Variable] {
        &self.variables
    }

    pub fn clear_variables(&mut self) {
        self.variables.clear();
    }

    // Param is passed by value, moved
    pub fn set_variables(&mut self, v: ::std::vec::Vec<Variable>) {
        self.variables = v;
    }

    // Mutable pointer to the field.
    pub fn mut_variables(&mut self) -> &mut ::std::vec::Vec<Variable> {
        &mut self.variables
    }

    // Take field
    pub fn take_variables(&mut self) -> ::std::vec::Vec<Variable> {
        ::std::mem::replace(&mut self.variables, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ParamKind>(
            "paramKind",
            |m: &ValidatingAdmissionPolicySpec| { &m.paramKind },
            |m: &mut ValidatingAdmissionPolicySpec| { &mut m.paramKind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MatchResources>(
            "matchConstraints",
            |m: &ValidatingAdmissionPolicySpec| { &m.matchConstraints },
            |m: &mut ValidatingAdmissionPolicySpec| { &mut m.matchConstraints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "validations",
            |m: &ValidatingAdmissionPolicySpec| { &m.validations },
            |m: &mut ValidatingAdmissionPolicySpec| { &mut m.validations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "failurePolicy",
            |m: &ValidatingAdmissionPolicySpec| { &m.failurePolicy },
            |m: &mut ValidatingAdmissionPolicySpec| { &mut m.failurePolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "auditAnnotations",
            |m: &ValidatingAdmissionPolicySpec| { &m.auditAnnotations },
            |m: &mut ValidatingAdmissionPolicySpec| { &mut m.auditAnnotations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matchConditions",
            |m: &ValidatingAdmissionPolicySpec| { &m.matchConditions },
            |m: &mut ValidatingAdmissionPolicySpec| { &mut m.matchConditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "variables",
            |m: &ValidatingAdmissionPolicySpec| { &m.variables },
            |m: &mut ValidatingAdmissionPolicySpec| { &mut m.variables },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingAdmissionPolicySpec>(
            "ValidatingAdmissionPolicySpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingAdmissionPolicySpec {
    const NAME: &'static str = "ValidatingAdmissionPolicySpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.paramKind)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.matchConstraints)?;
                },
                26 => {
                    self.validations.push(is.read_message()?);
                },
                34 => {
                    self.failurePolicy = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.auditAnnotations.push(is.read_message()?);
                },
                50 => {
                    self.matchConditions.push(is.read_message()?);
                },
                58 => {
                    self.variables.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.paramKind.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.matchConstraints.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.validations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.failurePolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.auditAnnotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.matchConditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.variables {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.paramKind.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.matchConstraints.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.validations {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.failurePolicy.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.auditAnnotations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.matchConditions {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.variables {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingAdmissionPolicySpec {
        ValidatingAdmissionPolicySpec::new()
    }

    fn clear(&mut self) {
        self.paramKind.clear();
        self.matchConstraints.clear();
        self.validations.clear();
        self.failurePolicy = ::std::option::Option::None;
        self.auditAnnotations.clear();
        self.matchConditions.clear();
        self.variables.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingAdmissionPolicySpec {
        static instance: ValidatingAdmissionPolicySpec = ValidatingAdmissionPolicySpec {
            paramKind: ::protobuf::MessageField::none(),
            matchConstraints: ::protobuf::MessageField::none(),
            validations: ::std::vec::Vec::new(),
            failurePolicy: ::std::option::Option::None,
            auditAnnotations: ::std::vec::Vec::new(),
            matchConditions: ::std::vec::Vec::new(),
            variables: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingAdmissionPolicySpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingAdmissionPolicySpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingAdmissionPolicySpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingAdmissionPolicySpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.ValidatingAdmissionPolicyStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingAdmissionPolicyStatus {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingAdmissionPolicyStatus.observedGeneration)
    pub observedGeneration: ::std::option::Option<i64>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingAdmissionPolicyStatus.typeChecking)
    pub typeChecking: ::protobuf::MessageField<TypeChecking>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingAdmissionPolicyStatus.conditions)
    pub conditions: ::std::vec::Vec<crate::apimachinery::pkg::apis::meta::v1::Condition>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.ValidatingAdmissionPolicyStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingAdmissionPolicyStatus {
    fn default() -> &'a ValidatingAdmissionPolicyStatus {
        <ValidatingAdmissionPolicyStatus as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingAdmissionPolicyStatus {
    pub fn new() -> ValidatingAdmissionPolicyStatus {
        ::std::default::Default::default()
    }

    // optional int64 observedGeneration = 1;

    pub fn observedGeneration(&self) -> i64 {
        self.observedGeneration.unwrap_or(0)
    }

    pub fn clear_observedGeneration(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
    }

    pub fn has_observedGeneration(&self) -> bool {
        self.observedGeneration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observedGeneration(&mut self, v: i64) {
        self.observedGeneration = ::std::option::Option::Some(v);
    }

    // optional .api.admissionregistration.v1.TypeChecking typeChecking = 2;

    pub fn typeChecking(&self) -> &TypeChecking {
        self.typeChecking.as_ref().unwrap_or_else(|| <TypeChecking as ::protobuf::Message>::default_instance())
    }

    pub fn clear_typeChecking(&mut self) {
        self.typeChecking.clear();
    }

    pub fn has_typeChecking(&self) -> bool {
        self.typeChecking.is_some()
    }

    // Param is passed by value, moved
    pub fn set_typeChecking(&mut self, v: TypeChecking) {
        self.typeChecking = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_typeChecking(&mut self) -> &mut TypeChecking {
        self.typeChecking.mut_or_insert_default()
    }

    // Take field
    pub fn take_typeChecking(&mut self) -> TypeChecking {
        self.typeChecking.take().unwrap_or_else(|| TypeChecking::new())
    }

    // repeated .apimachinery.pkg.apis.meta.v1.Condition conditions = 3;

    pub fn conditions(&self) -> &[crate::apimachinery::pkg::apis::meta::v1::Condition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<crate::apimachinery::pkg::apis::meta::v1::Condition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<crate::apimachinery::pkg::apis::meta::v1::Condition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<crate::apimachinery::pkg::apis::meta::v1::Condition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "observedGeneration",
            |m: &ValidatingAdmissionPolicyStatus| { &m.observedGeneration },
            |m: &mut ValidatingAdmissionPolicyStatus| { &mut m.observedGeneration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TypeChecking>(
            "typeChecking",
            |m: &ValidatingAdmissionPolicyStatus| { &m.typeChecking },
            |m: &mut ValidatingAdmissionPolicyStatus| { &mut m.typeChecking },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &ValidatingAdmissionPolicyStatus| { &m.conditions },
            |m: &mut ValidatingAdmissionPolicyStatus| { &mut m.conditions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingAdmissionPolicyStatus>(
            "ValidatingAdmissionPolicyStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingAdmissionPolicyStatus {
    const NAME: &'static str = "ValidatingAdmissionPolicyStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.observedGeneration = ::std::option::Option::Some(is.read_int64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.typeChecking)?;
                },
                26 => {
                    self.conditions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.observedGeneration {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.typeChecking.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.observedGeneration {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.typeChecking.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingAdmissionPolicyStatus {
        ValidatingAdmissionPolicyStatus::new()
    }

    fn clear(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
        self.typeChecking.clear();
        self.conditions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingAdmissionPolicyStatus {
        static instance: ValidatingAdmissionPolicyStatus = ValidatingAdmissionPolicyStatus {
            observedGeneration: ::std::option::Option::None,
            typeChecking: ::protobuf::MessageField::none(),
            conditions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingAdmissionPolicyStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingAdmissionPolicyStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingAdmissionPolicyStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingAdmissionPolicyStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.ValidatingWebhook)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingWebhook {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingWebhook.name)
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingWebhook.clientConfig)
    pub clientConfig: ::protobuf::MessageField<WebhookClientConfig>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingWebhook.rules)
    pub rules: ::std::vec::Vec<RuleWithOperations>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingWebhook.failurePolicy)
    pub failurePolicy: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingWebhook.matchPolicy)
    pub matchPolicy: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingWebhook.namespaceSelector)
    pub namespaceSelector: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingWebhook.objectSelector)
    pub objectSelector: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingWebhook.sideEffects)
    pub sideEffects: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingWebhook.timeoutSeconds)
    pub timeoutSeconds: ::std::option::Option<i32>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingWebhook.admissionReviewVersions)
    pub admissionReviewVersions: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingWebhook.matchConditions)
    pub matchConditions: ::std::vec::Vec<MatchCondition>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.ValidatingWebhook.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingWebhook {
    fn default() -> &'a ValidatingWebhook {
        <ValidatingWebhook as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingWebhook {
    pub fn new() -> ValidatingWebhook {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.admissionregistration.v1.WebhookClientConfig clientConfig = 2;

    pub fn clientConfig(&self) -> &WebhookClientConfig {
        self.clientConfig.as_ref().unwrap_or_else(|| <WebhookClientConfig as ::protobuf::Message>::default_instance())
    }

    pub fn clear_clientConfig(&mut self) {
        self.clientConfig.clear();
    }

    pub fn has_clientConfig(&self) -> bool {
        self.clientConfig.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientConfig(&mut self, v: WebhookClientConfig) {
        self.clientConfig = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientConfig(&mut self) -> &mut WebhookClientConfig {
        self.clientConfig.mut_or_insert_default()
    }

    // Take field
    pub fn take_clientConfig(&mut self) -> WebhookClientConfig {
        self.clientConfig.take().unwrap_or_else(|| WebhookClientConfig::new())
    }

    // repeated .api.admissionregistration.v1.RuleWithOperations rules = 3;

    pub fn rules(&self) -> &[RuleWithOperations] {
        &self.rules
    }

    pub fn clear_rules(&mut self) {
        self.rules.clear();
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: ::std::vec::Vec<RuleWithOperations>) {
        self.rules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rules(&mut self) -> &mut ::std::vec::Vec<RuleWithOperations> {
        &mut self.rules
    }

    // Take field
    pub fn take_rules(&mut self) -> ::std::vec::Vec<RuleWithOperations> {
        ::std::mem::replace(&mut self.rules, ::std::vec::Vec::new())
    }

    // optional string failurePolicy = 4;

    pub fn failurePolicy(&self) -> &str {
        match self.failurePolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_failurePolicy(&mut self) {
        self.failurePolicy = ::std::option::Option::None;
    }

    pub fn has_failurePolicy(&self) -> bool {
        self.failurePolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failurePolicy(&mut self, v: ::std::string::String) {
        self.failurePolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_failurePolicy(&mut self) -> &mut ::std::string::String {
        if self.failurePolicy.is_none() {
            self.failurePolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.failurePolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_failurePolicy(&mut self) -> ::std::string::String {
        self.failurePolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string matchPolicy = 9;

    pub fn matchPolicy(&self) -> &str {
        match self.matchPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_matchPolicy(&mut self) {
        self.matchPolicy = ::std::option::Option::None;
    }

    pub fn has_matchPolicy(&self) -> bool {
        self.matchPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchPolicy(&mut self, v: ::std::string::String) {
        self.matchPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_matchPolicy(&mut self) -> &mut ::std::string::String {
        if self.matchPolicy.is_none() {
            self.matchPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.matchPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_matchPolicy(&mut self) -> ::std::string::String {
        self.matchPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;

    pub fn namespaceSelector(&self) -> &crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_namespaceSelector(&mut self) {
        self.namespaceSelector.clear();
    }

    pub fn has_namespaceSelector(&self) -> bool {
        self.namespaceSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespaceSelector(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.namespaceSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespaceSelector(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_namespaceSelector(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;

    pub fn objectSelector(&self) -> &crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.objectSelector.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_objectSelector(&mut self) {
        self.objectSelector.clear();
    }

    pub fn has_objectSelector(&self) -> bool {
        self.objectSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_objectSelector(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.objectSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_objectSelector(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.objectSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_objectSelector(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.objectSelector.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional string sideEffects = 6;

    pub fn sideEffects(&self) -> &str {
        match self.sideEffects.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sideEffects(&mut self) {
        self.sideEffects = ::std::option::Option::None;
    }

    pub fn has_sideEffects(&self) -> bool {
        self.sideEffects.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sideEffects(&mut self, v: ::std::string::String) {
        self.sideEffects = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sideEffects(&mut self) -> &mut ::std::string::String {
        if self.sideEffects.is_none() {
            self.sideEffects = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sideEffects.as_mut().unwrap()
    }

    // Take field
    pub fn take_sideEffects(&mut self) -> ::std::string::String {
        self.sideEffects.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 timeoutSeconds = 7;

    pub fn timeoutSeconds(&self) -> i32 {
        self.timeoutSeconds.unwrap_or(0)
    }

    pub fn clear_timeoutSeconds(&mut self) {
        self.timeoutSeconds = ::std::option::Option::None;
    }

    pub fn has_timeoutSeconds(&self) -> bool {
        self.timeoutSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeoutSeconds(&mut self, v: i32) {
        self.timeoutSeconds = ::std::option::Option::Some(v);
    }

    // repeated string admissionReviewVersions = 8;

    pub fn admissionReviewVersions(&self) -> &[::std::string::String] {
        &self.admissionReviewVersions
    }

    pub fn clear_admissionReviewVersions(&mut self) {
        self.admissionReviewVersions.clear();
    }

    // Param is passed by value, moved
    pub fn set_admissionReviewVersions(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.admissionReviewVersions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_admissionReviewVersions(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.admissionReviewVersions
    }

    // Take field
    pub fn take_admissionReviewVersions(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.admissionReviewVersions, ::std::vec::Vec::new())
    }

    // repeated .api.admissionregistration.v1.MatchCondition matchConditions = 11;

    pub fn matchConditions(&self) -> &[MatchCondition] {
        &self.matchConditions
    }

    pub fn clear_matchConditions(&mut self) {
        self.matchConditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchConditions(&mut self, v: ::std::vec::Vec<MatchCondition>) {
        self.matchConditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchConditions(&mut self) -> &mut ::std::vec::Vec<MatchCondition> {
        &mut self.matchConditions
    }

    // Take field
    pub fn take_matchConditions(&mut self) -> ::std::vec::Vec<MatchCondition> {
        ::std::mem::replace(&mut self.matchConditions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ValidatingWebhook| { &m.name },
            |m: &mut ValidatingWebhook| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WebhookClientConfig>(
            "clientConfig",
            |m: &ValidatingWebhook| { &m.clientConfig },
            |m: &mut ValidatingWebhook| { &mut m.clientConfig },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rules",
            |m: &ValidatingWebhook| { &m.rules },
            |m: &mut ValidatingWebhook| { &mut m.rules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "failurePolicy",
            |m: &ValidatingWebhook| { &m.failurePolicy },
            |m: &mut ValidatingWebhook| { &mut m.failurePolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchPolicy",
            |m: &ValidatingWebhook| { &m.matchPolicy },
            |m: &mut ValidatingWebhook| { &mut m.matchPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "namespaceSelector",
            |m: &ValidatingWebhook| { &m.namespaceSelector },
            |m: &mut ValidatingWebhook| { &mut m.namespaceSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "objectSelector",
            |m: &ValidatingWebhook| { &m.objectSelector },
            |m: &mut ValidatingWebhook| { &mut m.objectSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sideEffects",
            |m: &ValidatingWebhook| { &m.sideEffects },
            |m: &mut ValidatingWebhook| { &mut m.sideEffects },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timeoutSeconds",
            |m: &ValidatingWebhook| { &m.timeoutSeconds },
            |m: &mut ValidatingWebhook| { &mut m.timeoutSeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "admissionReviewVersions",
            |m: &ValidatingWebhook| { &m.admissionReviewVersions },
            |m: &mut ValidatingWebhook| { &mut m.admissionReviewVersions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matchConditions",
            |m: &ValidatingWebhook| { &m.matchConditions },
            |m: &mut ValidatingWebhook| { &mut m.matchConditions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingWebhook>(
            "ValidatingWebhook",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingWebhook {
    const NAME: &'static str = "ValidatingWebhook";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.clientConfig)?;
                },
                26 => {
                    self.rules.push(is.read_message()?);
                },
                34 => {
                    self.failurePolicy = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.matchPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.namespaceSelector)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.objectSelector)?;
                },
                50 => {
                    self.sideEffects = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.timeoutSeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                66 => {
                    self.admissionReviewVersions.push(is.read_string()?);
                },
                90 => {
                    self.matchConditions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.clientConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.failurePolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.matchPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.namespaceSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.objectSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sideEffects.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.timeoutSeconds {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        for value in &self.admissionReviewVersions {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in &self.matchConditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.clientConfig.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.rules {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.failurePolicy.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.matchPolicy.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.namespaceSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.objectSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.sideEffects.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.timeoutSeconds {
            os.write_int32(7, v)?;
        }
        for v in &self.admissionReviewVersions {
            os.write_string(8, &v)?;
        };
        for v in &self.matchConditions {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingWebhook {
        ValidatingWebhook::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.clientConfig.clear();
        self.rules.clear();
        self.failurePolicy = ::std::option::Option::None;
        self.matchPolicy = ::std::option::Option::None;
        self.namespaceSelector.clear();
        self.objectSelector.clear();
        self.sideEffects = ::std::option::Option::None;
        self.timeoutSeconds = ::std::option::Option::None;
        self.admissionReviewVersions.clear();
        self.matchConditions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingWebhook {
        static instance: ValidatingWebhook = ValidatingWebhook {
            name: ::std::option::Option::None,
            clientConfig: ::protobuf::MessageField::none(),
            rules: ::std::vec::Vec::new(),
            failurePolicy: ::std::option::Option::None,
            matchPolicy: ::std::option::Option::None,
            namespaceSelector: ::protobuf::MessageField::none(),
            objectSelector: ::protobuf::MessageField::none(),
            sideEffects: ::std::option::Option::None,
            timeoutSeconds: ::std::option::Option::None,
            admissionReviewVersions: ::std::vec::Vec::new(),
            matchConditions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingWebhook {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingWebhook").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingWebhook {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingWebhook {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.ValidatingWebhookConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingWebhookConfiguration {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingWebhookConfiguration.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingWebhookConfiguration.Webhooks)
    pub Webhooks: ::std::vec::Vec<ValidatingWebhook>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.ValidatingWebhookConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingWebhookConfiguration {
    fn default() -> &'a ValidatingWebhookConfiguration {
        <ValidatingWebhookConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingWebhookConfiguration {
    pub fn new() -> ValidatingWebhookConfiguration {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // repeated .api.admissionregistration.v1.ValidatingWebhook Webhooks = 2;

    pub fn Webhooks(&self) -> &[ValidatingWebhook] {
        &self.Webhooks
    }

    pub fn clear_Webhooks(&mut self) {
        self.Webhooks.clear();
    }

    // Param is passed by value, moved
    pub fn set_Webhooks(&mut self, v: ::std::vec::Vec<ValidatingWebhook>) {
        self.Webhooks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Webhooks(&mut self) -> &mut ::std::vec::Vec<ValidatingWebhook> {
        &mut self.Webhooks
    }

    // Take field
    pub fn take_Webhooks(&mut self) -> ::std::vec::Vec<ValidatingWebhook> {
        ::std::mem::replace(&mut self.Webhooks, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ValidatingWebhookConfiguration| { &m.metadata },
            |m: &mut ValidatingWebhookConfiguration| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Webhooks",
            |m: &ValidatingWebhookConfiguration| { &m.Webhooks },
            |m: &mut ValidatingWebhookConfiguration| { &mut m.Webhooks },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingWebhookConfiguration>(
            "ValidatingWebhookConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingWebhookConfiguration {
    const NAME: &'static str = "ValidatingWebhookConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.Webhooks.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.Webhooks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.Webhooks {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingWebhookConfiguration {
        ValidatingWebhookConfiguration::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.Webhooks.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingWebhookConfiguration {
        static instance: ValidatingWebhookConfiguration = ValidatingWebhookConfiguration {
            metadata: ::protobuf::MessageField::none(),
            Webhooks: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingWebhookConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingWebhookConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingWebhookConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingWebhookConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.ValidatingWebhookConfigurationList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingWebhookConfigurationList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingWebhookConfigurationList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.ValidatingWebhookConfigurationList.items)
    pub items: ::std::vec::Vec<ValidatingWebhookConfiguration>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.ValidatingWebhookConfigurationList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingWebhookConfigurationList {
    fn default() -> &'a ValidatingWebhookConfigurationList {
        <ValidatingWebhookConfigurationList as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingWebhookConfigurationList {
    pub fn new() -> ValidatingWebhookConfigurationList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.admissionregistration.v1.ValidatingWebhookConfiguration items = 2;

    pub fn items(&self) -> &[ValidatingWebhookConfiguration] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ValidatingWebhookConfiguration>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ValidatingWebhookConfiguration> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ValidatingWebhookConfiguration> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ValidatingWebhookConfigurationList| { &m.metadata },
            |m: &mut ValidatingWebhookConfigurationList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ValidatingWebhookConfigurationList| { &m.items },
            |m: &mut ValidatingWebhookConfigurationList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingWebhookConfigurationList>(
            "ValidatingWebhookConfigurationList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingWebhookConfigurationList {
    const NAME: &'static str = "ValidatingWebhookConfigurationList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingWebhookConfigurationList {
        ValidatingWebhookConfigurationList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingWebhookConfigurationList {
        static instance: ValidatingWebhookConfigurationList = ValidatingWebhookConfigurationList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingWebhookConfigurationList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingWebhookConfigurationList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingWebhookConfigurationList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingWebhookConfigurationList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.Validation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Validation {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1.Validation.Expression)
    pub Expression: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.Validation.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.Validation.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.Validation.messageExpression)
    pub messageExpression: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.Validation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Validation {
    fn default() -> &'a Validation {
        <Validation as ::protobuf::Message>::default_instance()
    }
}

impl Validation {
    pub fn new() -> Validation {
        ::std::default::Default::default()
    }

    // optional string Expression = 1;

    pub fn Expression(&self) -> &str {
        match self.Expression.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_Expression(&mut self) {
        self.Expression = ::std::option::Option::None;
    }

    pub fn has_Expression(&self) -> bool {
        self.Expression.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Expression(&mut self, v: ::std::string::String) {
        self.Expression = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Expression(&mut self) -> &mut ::std::string::String {
        if self.Expression.is_none() {
            self.Expression = ::std::option::Option::Some(::std::string::String::new());
        }
        self.Expression.as_mut().unwrap()
    }

    // Take field
    pub fn take_Expression(&mut self) -> ::std::string::String {
        self.Expression.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reason = 3;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string messageExpression = 4;

    pub fn messageExpression(&self) -> &str {
        match self.messageExpression.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_messageExpression(&mut self) {
        self.messageExpression = ::std::option::Option::None;
    }

    pub fn has_messageExpression(&self) -> bool {
        self.messageExpression.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageExpression(&mut self, v: ::std::string::String) {
        self.messageExpression = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messageExpression(&mut self) -> &mut ::std::string::String {
        if self.messageExpression.is_none() {
            self.messageExpression = ::std::option::Option::Some(::std::string::String::new());
        }
        self.messageExpression.as_mut().unwrap()
    }

    // Take field
    pub fn take_messageExpression(&mut self) -> ::std::string::String {
        self.messageExpression.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "Expression",
            |m: &Validation| { &m.Expression },
            |m: &mut Validation| { &mut m.Expression },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &Validation| { &m.message },
            |m: &mut Validation| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &Validation| { &m.reason },
            |m: &mut Validation| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "messageExpression",
            |m: &Validation| { &m.messageExpression },
            |m: &mut Validation| { &mut m.messageExpression },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Validation>(
            "Validation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Validation {
    const NAME: &'static str = "Validation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Expression = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.messageExpression = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.Expression.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.messageExpression.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.Expression.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.messageExpression.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Validation {
        Validation::new()
    }

    fn clear(&mut self) {
        self.Expression = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.messageExpression = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Validation {
        static instance: Validation = Validation {
            Expression: ::std::option::Option::None,
            message: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            messageExpression: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Validation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Validation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Validation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Validation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.Variable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Variable {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1.Variable.Name)
    pub Name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.Variable.Expression)
    pub Expression: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.Variable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Variable {
    fn default() -> &'a Variable {
        <Variable as ::protobuf::Message>::default_instance()
    }
}

impl Variable {
    pub fn new() -> Variable {
        ::std::default::Default::default()
    }

    // optional string Name = 1;

    pub fn Name(&self) -> &str {
        match self.Name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_Name(&mut self) {
        self.Name = ::std::option::Option::None;
    }

    pub fn has_Name(&self) -> bool {
        self.Name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Name(&mut self, v: ::std::string::String) {
        self.Name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Name(&mut self) -> &mut ::std::string::String {
        if self.Name.is_none() {
            self.Name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.Name.as_mut().unwrap()
    }

    // Take field
    pub fn take_Name(&mut self) -> ::std::string::String {
        self.Name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string Expression = 2;

    pub fn Expression(&self) -> &str {
        match self.Expression.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_Expression(&mut self) {
        self.Expression = ::std::option::Option::None;
    }

    pub fn has_Expression(&self) -> bool {
        self.Expression.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Expression(&mut self, v: ::std::string::String) {
        self.Expression = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Expression(&mut self) -> &mut ::std::string::String {
        if self.Expression.is_none() {
            self.Expression = ::std::option::Option::Some(::std::string::String::new());
        }
        self.Expression.as_mut().unwrap()
    }

    // Take field
    pub fn take_Expression(&mut self) -> ::std::string::String {
        self.Expression.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "Name",
            |m: &Variable| { &m.Name },
            |m: &mut Variable| { &mut m.Name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "Expression",
            |m: &Variable| { &m.Expression },
            |m: &mut Variable| { &mut m.Expression },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Variable>(
            "Variable",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Variable {
    const NAME: &'static str = "Variable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.Expression = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.Name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.Expression.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.Name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.Expression.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Variable {
        Variable::new()
    }

    fn clear(&mut self) {
        self.Name = ::std::option::Option::None;
        self.Expression = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Variable {
        static instance: Variable = Variable {
            Name: ::std::option::Option::None,
            Expression: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Variable {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Variable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Variable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Variable {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1.WebhookClientConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebhookClientConfig {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1.WebhookClientConfig.url)
    pub url: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1.WebhookClientConfig.service)
    pub service: ::protobuf::MessageField<ServiceReference>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1.WebhookClientConfig.caBundle)
    pub caBundle: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1.WebhookClientConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebhookClientConfig {
    fn default() -> &'a WebhookClientConfig {
        <WebhookClientConfig as ::protobuf::Message>::default_instance()
    }
}

impl WebhookClientConfig {
    pub fn new() -> WebhookClientConfig {
        ::std::default::Default::default()
    }

    // optional string url = 3;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.admissionregistration.v1.ServiceReference service = 1;

    pub fn service(&self) -> &ServiceReference {
        self.service.as_ref().unwrap_or_else(|| <ServiceReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    pub fn has_service(&self) -> bool {
        self.service.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ServiceReference) {
        self.service = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ServiceReference {
        self.service.mut_or_insert_default()
    }

    // Take field
    pub fn take_service(&mut self) -> ServiceReference {
        self.service.take().unwrap_or_else(|| ServiceReference::new())
    }

    // optional bytes caBundle = 2;

    pub fn caBundle(&self) -> &[u8] {
        match self.caBundle.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_caBundle(&mut self) {
        self.caBundle = ::std::option::Option::None;
    }

    pub fn has_caBundle(&self) -> bool {
        self.caBundle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caBundle(&mut self, v: ::std::vec::Vec<u8>) {
        self.caBundle = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caBundle(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.caBundle.is_none() {
            self.caBundle = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.caBundle.as_mut().unwrap()
    }

    // Take field
    pub fn take_caBundle(&mut self) -> ::std::vec::Vec<u8> {
        self.caBundle.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &WebhookClientConfig| { &m.url },
            |m: &mut WebhookClientConfig| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ServiceReference>(
            "service",
            |m: &WebhookClientConfig| { &m.service },
            |m: &mut WebhookClientConfig| { &mut m.service },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caBundle",
            |m: &WebhookClientConfig| { &m.caBundle },
            |m: &mut WebhookClientConfig| { &mut m.caBundle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebhookClientConfig>(
            "WebhookClientConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebhookClientConfig {
    const NAME: &'static str = "WebhookClientConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.service)?;
                },
                18 => {
                    self.caBundle = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.caBundle.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.service.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.caBundle.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebhookClientConfig {
        WebhookClientConfig::new()
    }

    fn clear(&mut self) {
        self.url = ::std::option::Option::None;
        self.service.clear();
        self.caBundle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebhookClientConfig {
        static instance: WebhookClientConfig = WebhookClientConfig {
            url: ::std::option::Option::None,
            service: ::protobuf::MessageField::none(),
            caBundle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebhookClientConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebhookClientConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebhookClientConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebhookClientConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n,api/admissionregistration/v1/generated.proto\x12\x1capi.admissionregi\
    stration.v1\x1a-apimachinery/pkg/apis/meta/v1/generated.proto\x1a(apimac\
    hinery/pkg/runtime/generated.proto\x1a/apimachinery/pkg/runtime/schema/g\
    enerated.proto\"M\n\x0fAuditAnnotation\x12\x10\n\x03key\x18\x01\x20\x01(\
    \tR\x03key\x12(\n\x0fvalueExpression\x18\x02\x20\x01(\tR\x0fvalueExpress\
    ion\"I\n\x11ExpressionWarning\x12\x1a\n\x08fieldRef\x18\x02\x20\x01(\tR\
    \x08fieldRef\x12\x18\n\x07warning\x18\x03\x20\x01(\tR\x07warning\"D\n\
    \x0eMatchCondition\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1e\
    \n\nexpression\x18\x02\x20\x01(\tR\nexpression\"\xac\x03\n\x0eMatchResou\
    rces\x12Z\n\x11namespaceSelector\x18\x01\x20\x01(\x0b2,.apimachinery.pkg\
    .apis.meta.v1.LabelSelectorR\x11namespaceSelector\x12T\n\x0eobjectSelect\
    or\x18\x02\x20\x01(\x0b2,.apimachinery.pkg.apis.meta.v1.LabelSelectorR\
    \x0eobjectSelector\x12[\n\rresourceRules\x18\x03\x20\x03(\x0b25.api.admi\
    ssionregistration.v1.NamedRuleWithOperationsR\rresourceRules\x12i\n\x14e\
    xcludeResourceRules\x18\x04\x20\x03(\x0b25.api.admissionregistration.v1.\
    NamedRuleWithOperationsR\x14excludeResourceRules\x12\x20\n\x0bmatchPolic\
    y\x18\x07\x20\x01(\tR\x0bmatchPolicy\"\xca\x05\n\x0fMutatingWebhook\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12U\n\x0cclientConfig\x18\
    \x02\x20\x01(\x0b21.api.admissionregistration.v1.WebhookClientConfigR\
    \x0cclientConfig\x12F\n\x05rules\x18\x03\x20\x03(\x0b20.api.admissionreg\
    istration.v1.RuleWithOperationsR\x05rules\x12$\n\rfailurePolicy\x18\x04\
    \x20\x01(\tR\rfailurePolicy\x12\x20\n\x0bmatchPolicy\x18\t\x20\x01(\tR\
    \x0bmatchPolicy\x12Z\n\x11namespaceSelector\x18\x05\x20\x01(\x0b2,.apima\
    chinery.pkg.apis.meta.v1.LabelSelectorR\x11namespaceSelector\x12T\n\x0eo\
    bjectSelector\x18\x0b\x20\x01(\x0b2,.apimachinery.pkg.apis.meta.v1.Label\
    SelectorR\x0eobjectSelector\x12\x20\n\x0bsideEffects\x18\x06\x20\x01(\tR\
    \x0bsideEffects\x12&\n\x0etimeoutSeconds\x18\x07\x20\x01(\x05R\x0etimeou\
    tSeconds\x128\n\x17admissionReviewVersions\x18\x08\x20\x03(\tR\x17admiss\
    ionReviewVersions\x12.\n\x12reinvocationPolicy\x18\n\x20\x01(\tR\x12rein\
    vocationPolicy\x12V\n\x0fmatchConditions\x18\x0c\x20\x03(\x0b2,.api.admi\
    ssionregistration.v1.MatchConditionR\x0fmatchConditions\"\xb0\x01\n\x1cM\
    utatingWebhookConfiguration\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).ap\
    imachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12I\n\x08Webhooks\
    \x18\x02\x20\x03(\x0b2-.api.admissionregistration.v1.MutatingWebhookR\
    \x08Webhooks\"\xb9\x01\n\x20MutatingWebhookConfigurationList\x12C\n\x08m\
    etadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMetaR\
    \x08metadata\x12P\n\x05items\x18\x02\x20\x03(\x0b2:.api.admissionregistr\
    ation.v1.MutatingWebhookConfigurationR\x05items\"\xa1\x01\n\x17NamedRule\
    WithOperations\x12$\n\rresourceNames\x18\x01\x20\x03(\tR\rresourceNames\
    \x12`\n\x12ruleWithOperations\x18\x02\x20\x01(\x0b20.api.admissionregist\
    ration.v1.RuleWithOperationsR\x12ruleWithOperations\"?\n\tParamKind\x12\
    \x1e\n\napiVersion\x18\x01\x20\x01(\tR\napiVersion\x12\x12\n\x04kind\x18\
    \x02\x20\x01(\tR\x04kind\"\xc0\x01\n\x08ParamRef\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12\x1c\n\tnamespace\x18\x02\x20\x01(\tR\tnames\
    pace\x12H\n\x08selector\x18\x03\x20\x01(\x0b2,.apimachinery.pkg.apis.met\
    a.v1.LabelSelectorR\x08selector\x128\n\x17parameterNotFoundAction\x18\
    \x04\x20\x01(\tR\x17parameterNotFoundAction\"z\n\x04Rule\x12\x1c\n\tapiG\
    roups\x18\x01\x20\x03(\tR\tapiGroups\x12\x20\n\x0bapiVersions\x18\x02\
    \x20\x03(\tR\x0bapiVersions\x12\x1c\n\tresources\x18\x03\x20\x03(\tR\tre\
    sources\x12\x14\n\x05scope\x18\x04\x20\x01(\tR\x05scope\"l\n\x12RuleWith\
    Operations\x12\x1e\n\noperations\x18\x01\x20\x03(\tR\noperations\x126\n\
    \x04rule\x18\x02\x20\x01(\x0b2\".api.admissionregistration.v1.RuleR\x04r\
    ule\"l\n\x10ServiceReference\x12\x1c\n\tnamespace\x18\x01\x20\x01(\tR\tn\
    amespace\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x12\n\x04path\
    \x18\x03\x20\x01(\tR\x04path\x12\x12\n\x04port\x18\x04\x20\x01(\x05R\x04\
    port\"o\n\x0cTypeChecking\x12_\n\x12expressionWarnings\x18\x01\x20\x03(\
    \x0b2/.api.admissionregistration.v1.ExpressionWarningR\x12expressionWarn\
    ings\"\x8a\x02\n\x19ValidatingAdmissionPolicy\x12E\n\x08metadata\x18\x01\
    \x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\
    \x12O\n\x04spec\x18\x02\x20\x01(\x0b2;.api.admissionregistration.v1.Vali\
    datingAdmissionPolicySpecR\x04spec\x12U\n\x06status\x18\x03\x20\x01(\x0b\
    2=.api.admissionregistration.v1.ValidatingAdmissionPolicyStatusR\x06stat\
    us\"\xc1\x01\n\x20ValidatingAdmissionPolicyBinding\x12E\n\x08metadata\
    \x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08met\
    adata\x12V\n\x04spec\x18\x02\x20\x01(\x0b2B.api.admissionregistration.v1\
    .ValidatingAdmissionPolicyBindingSpecR\x04spec\"\xc1\x01\n$ValidatingAdm\
    issionPolicyBindingList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimac\
    hinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12T\n\x05items\x18\x02\
    \x20\x03(\x0b2>.api.admissionregistration.v1.ValidatingAdmissionPolicyBi\
    ndingR\x05items\"\x8e\x02\n$ValidatingAdmissionPolicyBindingSpec\x12\x1e\
    \n\npolicyName\x18\x01\x20\x01(\tR\npolicyName\x12B\n\x08paramRef\x18\
    \x02\x20\x01(\x0b2&.api.admissionregistration.v1.ParamRefR\x08paramRef\
    \x12T\n\x0ematchResources\x18\x03\x20\x01(\x0b2,.api.admissionregistrati\
    on.v1.MatchResourcesR\x0ematchResources\x12,\n\x11validationActions\x18\
    \x04\x20\x03(\tR\x11validationActions\"\xb3\x01\n\x1dValidatingAdmission\
    PolicyList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.ap\
    is.meta.v1.ListMetaR\x08metadata\x12M\n\x05items\x18\x02\x20\x03(\x0b27.\
    api.admissionregistration.v1.ValidatingAdmissionPolicyR\x05items\"\xab\
    \x04\n\x1dValidatingAdmissionPolicySpec\x12E\n\tparamKind\x18\x01\x20\
    \x01(\x0b2'.api.admissionregistration.v1.ParamKindR\tparamKind\x12X\n\
    \x10matchConstraints\x18\x02\x20\x01(\x0b2,.api.admissionregistration.v1\
    .MatchResourcesR\x10matchConstraints\x12J\n\x0bvalidations\x18\x03\x20\
    \x03(\x0b2(.api.admissionregistration.v1.ValidationR\x0bvalidations\x12$\
    \n\rfailurePolicy\x18\x04\x20\x01(\tR\rfailurePolicy\x12Y\n\x10auditAnno\
    tations\x18\x05\x20\x03(\x0b2-.api.admissionregistration.v1.AuditAnnotat\
    ionR\x10auditAnnotations\x12V\n\x0fmatchConditions\x18\x06\x20\x03(\x0b2\
    ,.api.admissionregistration.v1.MatchConditionR\x0fmatchConditions\x12D\n\
    \tvariables\x18\x07\x20\x03(\x0b2&.api.admissionregistration.v1.Variable\
    R\tvariables\"\xeb\x01\n\x1fValidatingAdmissionPolicyStatus\x12.\n\x12ob\
    servedGeneration\x18\x01\x20\x01(\x03R\x12observedGeneration\x12N\n\x0ct\
    ypeChecking\x18\x02\x20\x01(\x0b2*.api.admissionregistration.v1.TypeChec\
    kingR\x0ctypeChecking\x12H\n\nconditions\x18\x03\x20\x03(\x0b2(.apimachi\
    nery.pkg.apis.meta.v1.ConditionR\nconditions\"\x9c\x05\n\x11ValidatingWe\
    bhook\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12U\n\x0cclientConf\
    ig\x18\x02\x20\x01(\x0b21.api.admissionregistration.v1.WebhookClientConf\
    igR\x0cclientConfig\x12F\n\x05rules\x18\x03\x20\x03(\x0b20.api.admission\
    registration.v1.RuleWithOperationsR\x05rules\x12$\n\rfailurePolicy\x18\
    \x04\x20\x01(\tR\rfailurePolicy\x12\x20\n\x0bmatchPolicy\x18\t\x20\x01(\
    \tR\x0bmatchPolicy\x12Z\n\x11namespaceSelector\x18\x05\x20\x01(\x0b2,.ap\
    imachinery.pkg.apis.meta.v1.LabelSelectorR\x11namespaceSelector\x12T\n\
    \x0eobjectSelector\x18\n\x20\x01(\x0b2,.apimachinery.pkg.apis.meta.v1.La\
    belSelectorR\x0eobjectSelector\x12\x20\n\x0bsideEffects\x18\x06\x20\x01(\
    \tR\x0bsideEffects\x12&\n\x0etimeoutSeconds\x18\x07\x20\x01(\x05R\x0etim\
    eoutSeconds\x128\n\x17admissionReviewVersions\x18\x08\x20\x03(\tR\x17adm\
    issionReviewVersions\x12V\n\x0fmatchConditions\x18\x0b\x20\x03(\x0b2,.ap\
    i.admissionregistration.v1.MatchConditionR\x0fmatchConditions\"\xb4\x01\
    \n\x1eValidatingWebhookConfiguration\x12E\n\x08metadata\x18\x01\x20\x01(\
    \x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12K\n\x08W\
    ebhooks\x18\x02\x20\x03(\x0b2/.api.admissionregistration.v1.ValidatingWe\
    bhookR\x08Webhooks\"\xbd\x01\n\"ValidatingWebhookConfigurationList\x12C\
    \n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.List\
    MetaR\x08metadata\x12R\n\x05items\x18\x02\x20\x03(\x0b2<.api.admissionre\
    gistration.v1.ValidatingWebhookConfigurationR\x05items\"\x8c\x01\n\nVali\
    dation\x12\x1e\n\nExpression\x18\x01\x20\x01(\tR\nExpression\x12\x18\n\
    \x07message\x18\x02\x20\x01(\tR\x07message\x12\x16\n\x06reason\x18\x03\
    \x20\x01(\tR\x06reason\x12,\n\x11messageExpression\x18\x04\x20\x01(\tR\
    \x11messageExpression\">\n\x08Variable\x12\x12\n\x04Name\x18\x01\x20\x01\
    (\tR\x04Name\x12\x1e\n\nExpression\x18\x02\x20\x01(\tR\nExpression\"\x8d\
    \x01\n\x13WebhookClientConfig\x12\x10\n\x03url\x18\x03\x20\x01(\tR\x03ur\
    l\x12H\n\x07service\x18\x01\x20\x01(\x0b2..api.admissionregistration.v1.\
    ServiceReferenceR\x07service\x12\x1a\n\x08caBundle\x18\x02\x20\x01(\x0cR\
    \x08caBundleB%Z#k8s.io/api/admissionregistration/v1\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::v1::file_descriptor().clone());
            deps.push(super::v1::file_descriptor().clone());
            deps.push(super::v1::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(27);
            messages.push(AuditAnnotation::generated_message_descriptor_data());
            messages.push(ExpressionWarning::generated_message_descriptor_data());
            messages.push(MatchCondition::generated_message_descriptor_data());
            messages.push(MatchResources::generated_message_descriptor_data());
            messages.push(MutatingWebhook::generated_message_descriptor_data());
            messages.push(MutatingWebhookConfiguration::generated_message_descriptor_data());
            messages.push(MutatingWebhookConfigurationList::generated_message_descriptor_data());
            messages.push(NamedRuleWithOperations::generated_message_descriptor_data());
            messages.push(ParamKind::generated_message_descriptor_data());
            messages.push(ParamRef::generated_message_descriptor_data());
            messages.push(Rule::generated_message_descriptor_data());
            messages.push(RuleWithOperations::generated_message_descriptor_data());
            messages.push(ServiceReference::generated_message_descriptor_data());
            messages.push(TypeChecking::generated_message_descriptor_data());
            messages.push(ValidatingAdmissionPolicy::generated_message_descriptor_data());
            messages.push(ValidatingAdmissionPolicyBinding::generated_message_descriptor_data());
            messages.push(ValidatingAdmissionPolicyBindingList::generated_message_descriptor_data());
            messages.push(ValidatingAdmissionPolicyBindingSpec::generated_message_descriptor_data());
            messages.push(ValidatingAdmissionPolicyList::generated_message_descriptor_data());
            messages.push(ValidatingAdmissionPolicySpec::generated_message_descriptor_data());
            messages.push(ValidatingAdmissionPolicyStatus::generated_message_descriptor_data());
            messages.push(ValidatingWebhook::generated_message_descriptor_data());
            messages.push(ValidatingWebhookConfiguration::generated_message_descriptor_data());
            messages.push(ValidatingWebhookConfigurationList::generated_message_descriptor_data());
            messages.push(Validation::generated_message_descriptor_data());
            messages.push(Variable::generated_message_descriptor_data());
            messages.push(WebhookClientConfig::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
