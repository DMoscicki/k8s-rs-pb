// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc 3.21.12
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `api/admissionregistration/v1alpha1/generated.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1alpha1.AuditAnnotation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AuditAnnotation {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.AuditAnnotation.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.AuditAnnotation.valueExpression)
    pub valueExpression: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1alpha1.AuditAnnotation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuditAnnotation {
    fn default() -> &'a AuditAnnotation {
        <AuditAnnotation as ::protobuf::Message>::default_instance()
    }
}

impl AuditAnnotation {
    pub fn new() -> AuditAnnotation {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string valueExpression = 2;

    pub fn valueExpression(&self) -> &str {
        match self.valueExpression.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_valueExpression(&mut self) {
        self.valueExpression = ::std::option::Option::None;
    }

    pub fn has_valueExpression(&self) -> bool {
        self.valueExpression.is_some()
    }

    // Param is passed by value, moved
    pub fn set_valueExpression(&mut self, v: ::std::string::String) {
        self.valueExpression = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_valueExpression(&mut self) -> &mut ::std::string::String {
        if self.valueExpression.is_none() {
            self.valueExpression = ::std::option::Option::Some(::std::string::String::new());
        }
        self.valueExpression.as_mut().unwrap()
    }

    // Take field
    pub fn take_valueExpression(&mut self) -> ::std::string::String {
        self.valueExpression.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &AuditAnnotation| { &m.key },
            |m: &mut AuditAnnotation| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "valueExpression",
            |m: &AuditAnnotation| { &m.valueExpression },
            |m: &mut AuditAnnotation| { &mut m.valueExpression },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AuditAnnotation>(
            "AuditAnnotation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AuditAnnotation {
    const NAME: &'static str = "AuditAnnotation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.valueExpression = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.valueExpression.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.valueExpression.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuditAnnotation {
        AuditAnnotation::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.valueExpression = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuditAnnotation {
        static instance: AuditAnnotation = AuditAnnotation {
            key: ::std::option::Option::None,
            valueExpression: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AuditAnnotation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AuditAnnotation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AuditAnnotation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuditAnnotation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1alpha1.ExpressionWarning)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExpressionWarning {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ExpressionWarning.fieldRef)
    pub fieldRef: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ExpressionWarning.warning)
    pub warning: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1alpha1.ExpressionWarning.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExpressionWarning {
    fn default() -> &'a ExpressionWarning {
        <ExpressionWarning as ::protobuf::Message>::default_instance()
    }
}

impl ExpressionWarning {
    pub fn new() -> ExpressionWarning {
        ::std::default::Default::default()
    }

    // optional string fieldRef = 2;

    pub fn fieldRef(&self) -> &str {
        match self.fieldRef.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fieldRef(&mut self) {
        self.fieldRef = ::std::option::Option::None;
    }

    pub fn has_fieldRef(&self) -> bool {
        self.fieldRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldRef(&mut self, v: ::std::string::String) {
        self.fieldRef = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldRef(&mut self) -> &mut ::std::string::String {
        if self.fieldRef.is_none() {
            self.fieldRef = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fieldRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldRef(&mut self) -> ::std::string::String {
        self.fieldRef.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string warning = 3;

    pub fn warning(&self) -> &str {
        match self.warning.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_warning(&mut self) {
        self.warning = ::std::option::Option::None;
    }

    pub fn has_warning(&self) -> bool {
        self.warning.is_some()
    }

    // Param is passed by value, moved
    pub fn set_warning(&mut self, v: ::std::string::String) {
        self.warning = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_warning(&mut self) -> &mut ::std::string::String {
        if self.warning.is_none() {
            self.warning = ::std::option::Option::Some(::std::string::String::new());
        }
        self.warning.as_mut().unwrap()
    }

    // Take field
    pub fn take_warning(&mut self) -> ::std::string::String {
        self.warning.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fieldRef",
            |m: &ExpressionWarning| { &m.fieldRef },
            |m: &mut ExpressionWarning| { &mut m.fieldRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "warning",
            |m: &ExpressionWarning| { &m.warning },
            |m: &mut ExpressionWarning| { &mut m.warning },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExpressionWarning>(
            "ExpressionWarning",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExpressionWarning {
    const NAME: &'static str = "ExpressionWarning";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.fieldRef = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.warning = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.fieldRef.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.warning.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.fieldRef.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.warning.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExpressionWarning {
        ExpressionWarning::new()
    }

    fn clear(&mut self) {
        self.fieldRef = ::std::option::Option::None;
        self.warning = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExpressionWarning {
        static instance: ExpressionWarning = ExpressionWarning {
            fieldRef: ::std::option::Option::None,
            warning: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExpressionWarning {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExpressionWarning").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExpressionWarning {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExpressionWarning {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1alpha1.MatchCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MatchCondition {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.MatchCondition.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.MatchCondition.expression)
    pub expression: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1alpha1.MatchCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MatchCondition {
    fn default() -> &'a MatchCondition {
        <MatchCondition as ::protobuf::Message>::default_instance()
    }
}

impl MatchCondition {
    pub fn new() -> MatchCondition {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string expression = 2;

    pub fn expression(&self) -> &str {
        match self.expression.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_expression(&mut self) {
        self.expression = ::std::option::Option::None;
    }

    pub fn has_expression(&self) -> bool {
        self.expression.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expression(&mut self, v: ::std::string::String) {
        self.expression = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expression(&mut self) -> &mut ::std::string::String {
        if self.expression.is_none() {
            self.expression = ::std::option::Option::Some(::std::string::String::new());
        }
        self.expression.as_mut().unwrap()
    }

    // Take field
    pub fn take_expression(&mut self) -> ::std::string::String {
        self.expression.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &MatchCondition| { &m.name },
            |m: &mut MatchCondition| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expression",
            |m: &MatchCondition| { &m.expression },
            |m: &mut MatchCondition| { &mut m.expression },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MatchCondition>(
            "MatchCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MatchCondition {
    const NAME: &'static str = "MatchCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.expression = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.expression.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.expression.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MatchCondition {
        MatchCondition::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.expression = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MatchCondition {
        static instance: MatchCondition = MatchCondition {
            name: ::std::option::Option::None,
            expression: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MatchCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MatchCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MatchCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1alpha1.MatchResources)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MatchResources {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.MatchResources.namespaceSelector)
    pub namespaceSelector: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.MatchResources.objectSelector)
    pub objectSelector: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.MatchResources.resourceRules)
    pub resourceRules: ::std::vec::Vec<NamedRuleWithOperations>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.MatchResources.excludeResourceRules)
    pub excludeResourceRules: ::std::vec::Vec<NamedRuleWithOperations>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.MatchResources.matchPolicy)
    pub matchPolicy: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1alpha1.MatchResources.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MatchResources {
    fn default() -> &'a MatchResources {
        <MatchResources as ::protobuf::Message>::default_instance()
    }
}

impl MatchResources {
    pub fn new() -> MatchResources {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;

    pub fn namespaceSelector(&self) -> &crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_namespaceSelector(&mut self) {
        self.namespaceSelector.clear();
    }

    pub fn has_namespaceSelector(&self) -> bool {
        self.namespaceSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespaceSelector(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.namespaceSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespaceSelector(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_namespaceSelector(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;

    pub fn objectSelector(&self) -> &crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.objectSelector.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_objectSelector(&mut self) {
        self.objectSelector.clear();
    }

    pub fn has_objectSelector(&self) -> bool {
        self.objectSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_objectSelector(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.objectSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_objectSelector(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.objectSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_objectSelector(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.objectSelector.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // repeated .api.admissionregistration.v1alpha1.NamedRuleWithOperations resourceRules = 3;

    pub fn resourceRules(&self) -> &[NamedRuleWithOperations] {
        &self.resourceRules
    }

    pub fn clear_resourceRules(&mut self) {
        self.resourceRules.clear();
    }

    // Param is passed by value, moved
    pub fn set_resourceRules(&mut self, v: ::std::vec::Vec<NamedRuleWithOperations>) {
        self.resourceRules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resourceRules(&mut self) -> &mut ::std::vec::Vec<NamedRuleWithOperations> {
        &mut self.resourceRules
    }

    // Take field
    pub fn take_resourceRules(&mut self) -> ::std::vec::Vec<NamedRuleWithOperations> {
        ::std::mem::replace(&mut self.resourceRules, ::std::vec::Vec::new())
    }

    // repeated .api.admissionregistration.v1alpha1.NamedRuleWithOperations excludeResourceRules = 4;

    pub fn excludeResourceRules(&self) -> &[NamedRuleWithOperations] {
        &self.excludeResourceRules
    }

    pub fn clear_excludeResourceRules(&mut self) {
        self.excludeResourceRules.clear();
    }

    // Param is passed by value, moved
    pub fn set_excludeResourceRules(&mut self, v: ::std::vec::Vec<NamedRuleWithOperations>) {
        self.excludeResourceRules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excludeResourceRules(&mut self) -> &mut ::std::vec::Vec<NamedRuleWithOperations> {
        &mut self.excludeResourceRules
    }

    // Take field
    pub fn take_excludeResourceRules(&mut self) -> ::std::vec::Vec<NamedRuleWithOperations> {
        ::std::mem::replace(&mut self.excludeResourceRules, ::std::vec::Vec::new())
    }

    // optional string matchPolicy = 7;

    pub fn matchPolicy(&self) -> &str {
        match self.matchPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_matchPolicy(&mut self) {
        self.matchPolicy = ::std::option::Option::None;
    }

    pub fn has_matchPolicy(&self) -> bool {
        self.matchPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchPolicy(&mut self, v: ::std::string::String) {
        self.matchPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_matchPolicy(&mut self) -> &mut ::std::string::String {
        if self.matchPolicy.is_none() {
            self.matchPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.matchPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_matchPolicy(&mut self) -> ::std::string::String {
        self.matchPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "namespaceSelector",
            |m: &MatchResources| { &m.namespaceSelector },
            |m: &mut MatchResources| { &mut m.namespaceSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "objectSelector",
            |m: &MatchResources| { &m.objectSelector },
            |m: &mut MatchResources| { &mut m.objectSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resourceRules",
            |m: &MatchResources| { &m.resourceRules },
            |m: &mut MatchResources| { &mut m.resourceRules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "excludeResourceRules",
            |m: &MatchResources| { &m.excludeResourceRules },
            |m: &mut MatchResources| { &mut m.excludeResourceRules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchPolicy",
            |m: &MatchResources| { &m.matchPolicy },
            |m: &mut MatchResources| { &mut m.matchPolicy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MatchResources>(
            "MatchResources",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MatchResources {
    const NAME: &'static str = "MatchResources";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.namespaceSelector)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.objectSelector)?;
                },
                26 => {
                    self.resourceRules.push(is.read_message()?);
                },
                34 => {
                    self.excludeResourceRules.push(is.read_message()?);
                },
                58 => {
                    self.matchPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.namespaceSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.objectSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.resourceRules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.excludeResourceRules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.matchPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.namespaceSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.objectSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.resourceRules {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.excludeResourceRules {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.matchPolicy.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MatchResources {
        MatchResources::new()
    }

    fn clear(&mut self) {
        self.namespaceSelector.clear();
        self.objectSelector.clear();
        self.resourceRules.clear();
        self.excludeResourceRules.clear();
        self.matchPolicy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MatchResources {
        static instance: MatchResources = MatchResources {
            namespaceSelector: ::protobuf::MessageField::none(),
            objectSelector: ::protobuf::MessageField::none(),
            resourceRules: ::std::vec::Vec::new(),
            excludeResourceRules: ::std::vec::Vec::new(),
            matchPolicy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MatchResources {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MatchResources").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MatchResources {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchResources {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1alpha1.NamedRuleWithOperations)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NamedRuleWithOperations {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.NamedRuleWithOperations.resourceNames)
    pub resourceNames: ::std::vec::Vec<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.NamedRuleWithOperations.ruleWithOperations)
    pub ruleWithOperations: ::protobuf::MessageField<crate::api::admissionregistration::v1::RuleWithOperations>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1alpha1.NamedRuleWithOperations.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NamedRuleWithOperations {
    fn default() -> &'a NamedRuleWithOperations {
        <NamedRuleWithOperations as ::protobuf::Message>::default_instance()
    }
}

impl NamedRuleWithOperations {
    pub fn new() -> NamedRuleWithOperations {
        ::std::default::Default::default()
    }

    // repeated string resourceNames = 1;

    pub fn resourceNames(&self) -> &[::std::string::String] {
        &self.resourceNames
    }

    pub fn clear_resourceNames(&mut self) {
        self.resourceNames.clear();
    }

    // Param is passed by value, moved
    pub fn set_resourceNames(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.resourceNames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resourceNames(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.resourceNames
    }

    // Take field
    pub fn take_resourceNames(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.resourceNames, ::std::vec::Vec::new())
    }

    // optional .api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;

    pub fn ruleWithOperations(&self) -> &crate::api::admissionregistration::v1::RuleWithOperations {
        self.ruleWithOperations.as_ref().unwrap_or_else(|| <crate::api::admissionregistration::v1::RuleWithOperations as ::protobuf::Message>::default_instance())
    }

    pub fn clear_ruleWithOperations(&mut self) {
        self.ruleWithOperations.clear();
    }

    pub fn has_ruleWithOperations(&self) -> bool {
        self.ruleWithOperations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ruleWithOperations(&mut self, v: crate::api::admissionregistration::v1::RuleWithOperations) {
        self.ruleWithOperations = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ruleWithOperations(&mut self) -> &mut crate::api::admissionregistration::v1::RuleWithOperations {
        self.ruleWithOperations.mut_or_insert_default()
    }

    // Take field
    pub fn take_ruleWithOperations(&mut self) -> crate::api::admissionregistration::v1::RuleWithOperations {
        self.ruleWithOperations.take().unwrap_or_else(|| crate::api::admissionregistration::v1::RuleWithOperations::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resourceNames",
            |m: &NamedRuleWithOperations| { &m.resourceNames },
            |m: &mut NamedRuleWithOperations| { &mut m.resourceNames },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::api::admissionregistration::v1::RuleWithOperations>(
            "ruleWithOperations",
            |m: &NamedRuleWithOperations| { &m.ruleWithOperations },
            |m: &mut NamedRuleWithOperations| { &mut m.ruleWithOperations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NamedRuleWithOperations>(
            "NamedRuleWithOperations",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NamedRuleWithOperations {
    const NAME: &'static str = "NamedRuleWithOperations";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.resourceNames.push(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ruleWithOperations)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.resourceNames {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.ruleWithOperations.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.resourceNames {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.ruleWithOperations.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NamedRuleWithOperations {
        NamedRuleWithOperations::new()
    }

    fn clear(&mut self) {
        self.resourceNames.clear();
        self.ruleWithOperations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NamedRuleWithOperations {
        static instance: NamedRuleWithOperations = NamedRuleWithOperations {
            resourceNames: ::std::vec::Vec::new(),
            ruleWithOperations: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NamedRuleWithOperations {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NamedRuleWithOperations").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NamedRuleWithOperations {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamedRuleWithOperations {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1alpha1.ParamKind)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ParamKind {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ParamKind.apiVersion)
    pub apiVersion: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ParamKind.kind)
    pub kind: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1alpha1.ParamKind.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ParamKind {
    fn default() -> &'a ParamKind {
        <ParamKind as ::protobuf::Message>::default_instance()
    }
}

impl ParamKind {
    pub fn new() -> ParamKind {
        ::std::default::Default::default()
    }

    // optional string apiVersion = 1;

    pub fn apiVersion(&self) -> &str {
        match self.apiVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_apiVersion(&mut self) {
        self.apiVersion = ::std::option::Option::None;
    }

    pub fn has_apiVersion(&self) -> bool {
        self.apiVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiVersion(&mut self, v: ::std::string::String) {
        self.apiVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiVersion(&mut self) -> &mut ::std::string::String {
        if self.apiVersion.is_none() {
            self.apiVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.apiVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiVersion(&mut self) -> ::std::string::String {
        self.apiVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kind = 2;

    pub fn kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "apiVersion",
            |m: &ParamKind| { &m.apiVersion },
            |m: &mut ParamKind| { &mut m.apiVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &ParamKind| { &m.kind },
            |m: &mut ParamKind| { &mut m.kind },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ParamKind>(
            "ParamKind",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ParamKind {
    const NAME: &'static str = "ParamKind";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.apiVersion = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.kind = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.apiVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.apiVersion.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.kind.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ParamKind {
        ParamKind::new()
    }

    fn clear(&mut self) {
        self.apiVersion = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ParamKind {
        static instance: ParamKind = ParamKind {
            apiVersion: ::std::option::Option::None,
            kind: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ParamKind {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ParamKind").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ParamKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParamKind {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1alpha1.ParamRef)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ParamRef {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ParamRef.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ParamRef.namespace)
    pub namespace: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ParamRef.selector)
    pub selector: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ParamRef.parameterNotFoundAction)
    pub parameterNotFoundAction: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1alpha1.ParamRef.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ParamRef {
    fn default() -> &'a ParamRef {
        <ParamRef as ::protobuf::Message>::default_instance()
    }
}

impl ParamRef {
    pub fn new() -> ParamRef {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string namespace = 2;

    pub fn namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_namespace(&mut self) {
        self.namespace = ::std::option::Option::None;
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;

    pub fn selector(&self) -> &crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    pub fn has_selector(&self) -> bool {
        self.selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.selector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selector(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.mut_or_insert_default()
    }

    // Take field
    pub fn take_selector(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional string parameterNotFoundAction = 4;

    pub fn parameterNotFoundAction(&self) -> &str {
        match self.parameterNotFoundAction.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_parameterNotFoundAction(&mut self) {
        self.parameterNotFoundAction = ::std::option::Option::None;
    }

    pub fn has_parameterNotFoundAction(&self) -> bool {
        self.parameterNotFoundAction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameterNotFoundAction(&mut self, v: ::std::string::String) {
        self.parameterNotFoundAction = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parameterNotFoundAction(&mut self) -> &mut ::std::string::String {
        if self.parameterNotFoundAction.is_none() {
            self.parameterNotFoundAction = ::std::option::Option::Some(::std::string::String::new());
        }
        self.parameterNotFoundAction.as_mut().unwrap()
    }

    // Take field
    pub fn take_parameterNotFoundAction(&mut self) -> ::std::string::String {
        self.parameterNotFoundAction.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ParamRef| { &m.name },
            |m: &mut ParamRef| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "namespace",
            |m: &ParamRef| { &m.namespace },
            |m: &mut ParamRef| { &mut m.namespace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "selector",
            |m: &ParamRef| { &m.selector },
            |m: &mut ParamRef| { &mut m.selector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parameterNotFoundAction",
            |m: &ParamRef| { &m.parameterNotFoundAction },
            |m: &mut ParamRef| { &mut m.parameterNotFoundAction },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ParamRef>(
            "ParamRef",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ParamRef {
    const NAME: &'static str = "ParamRef";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.namespace = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.selector)?;
                },
                34 => {
                    self.parameterNotFoundAction = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.parameterNotFoundAction.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.namespace.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.selector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.parameterNotFoundAction.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ParamRef {
        ParamRef::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.namespace = ::std::option::Option::None;
        self.selector.clear();
        self.parameterNotFoundAction = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ParamRef {
        static instance: ParamRef = ParamRef {
            name: ::std::option::Option::None,
            namespace: ::std::option::Option::None,
            selector: ::protobuf::MessageField::none(),
            parameterNotFoundAction: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ParamRef {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ParamRef").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ParamRef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParamRef {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1alpha1.TypeChecking)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TypeChecking {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.TypeChecking.expressionWarnings)
    pub expressionWarnings: ::std::vec::Vec<ExpressionWarning>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1alpha1.TypeChecking.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TypeChecking {
    fn default() -> &'a TypeChecking {
        <TypeChecking as ::protobuf::Message>::default_instance()
    }
}

impl TypeChecking {
    pub fn new() -> TypeChecking {
        ::std::default::Default::default()
    }

    // repeated .api.admissionregistration.v1alpha1.ExpressionWarning expressionWarnings = 1;

    pub fn expressionWarnings(&self) -> &[ExpressionWarning] {
        &self.expressionWarnings
    }

    pub fn clear_expressionWarnings(&mut self) {
        self.expressionWarnings.clear();
    }

    // Param is passed by value, moved
    pub fn set_expressionWarnings(&mut self, v: ::std::vec::Vec<ExpressionWarning>) {
        self.expressionWarnings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_expressionWarnings(&mut self) -> &mut ::std::vec::Vec<ExpressionWarning> {
        &mut self.expressionWarnings
    }

    // Take field
    pub fn take_expressionWarnings(&mut self) -> ::std::vec::Vec<ExpressionWarning> {
        ::std::mem::replace(&mut self.expressionWarnings, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "expressionWarnings",
            |m: &TypeChecking| { &m.expressionWarnings },
            |m: &mut TypeChecking| { &mut m.expressionWarnings },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TypeChecking>(
            "TypeChecking",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TypeChecking {
    const NAME: &'static str = "TypeChecking";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.expressionWarnings.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.expressionWarnings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.expressionWarnings {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TypeChecking {
        TypeChecking::new()
    }

    fn clear(&mut self) {
        self.expressionWarnings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TypeChecking {
        static instance: TypeChecking = TypeChecking {
            expressionWarnings: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TypeChecking {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TypeChecking").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TypeChecking {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeChecking {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingAdmissionPolicy {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicy.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicy.spec)
    pub spec: ::protobuf::MessageField<ValidatingAdmissionPolicySpec>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicy.status)
    pub status: ::protobuf::MessageField<ValidatingAdmissionPolicyStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingAdmissionPolicy {
    fn default() -> &'a ValidatingAdmissionPolicy {
        <ValidatingAdmissionPolicy as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingAdmissionPolicy {
    pub fn new() -> ValidatingAdmissionPolicy {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.admissionregistration.v1alpha1.ValidatingAdmissionPolicySpec spec = 2;

    pub fn spec(&self) -> &ValidatingAdmissionPolicySpec {
        self.spec.as_ref().unwrap_or_else(|| <ValidatingAdmissionPolicySpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ValidatingAdmissionPolicySpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ValidatingAdmissionPolicySpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ValidatingAdmissionPolicySpec {
        self.spec.take().unwrap_or_else(|| ValidatingAdmissionPolicySpec::new())
    }

    // optional .api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyStatus status = 3;

    pub fn status(&self) -> &ValidatingAdmissionPolicyStatus {
        self.status.as_ref().unwrap_or_else(|| <ValidatingAdmissionPolicyStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ValidatingAdmissionPolicyStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ValidatingAdmissionPolicyStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> ValidatingAdmissionPolicyStatus {
        self.status.take().unwrap_or_else(|| ValidatingAdmissionPolicyStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ValidatingAdmissionPolicy| { &m.metadata },
            |m: &mut ValidatingAdmissionPolicy| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ValidatingAdmissionPolicySpec>(
            "spec",
            |m: &ValidatingAdmissionPolicy| { &m.spec },
            |m: &mut ValidatingAdmissionPolicy| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ValidatingAdmissionPolicyStatus>(
            "status",
            |m: &ValidatingAdmissionPolicy| { &m.status },
            |m: &mut ValidatingAdmissionPolicy| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingAdmissionPolicy>(
            "ValidatingAdmissionPolicy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingAdmissionPolicy {
    const NAME: &'static str = "ValidatingAdmissionPolicy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingAdmissionPolicy {
        ValidatingAdmissionPolicy::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingAdmissionPolicy {
        static instance: ValidatingAdmissionPolicy = ValidatingAdmissionPolicy {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingAdmissionPolicy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingAdmissionPolicy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingAdmissionPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingAdmissionPolicy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyBinding)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingAdmissionPolicyBinding {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyBinding.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyBinding.spec)
    pub spec: ::protobuf::MessageField<ValidatingAdmissionPolicyBindingSpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyBinding.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingAdmissionPolicyBinding {
    fn default() -> &'a ValidatingAdmissionPolicyBinding {
        <ValidatingAdmissionPolicyBinding as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingAdmissionPolicyBinding {
    pub fn new() -> ValidatingAdmissionPolicyBinding {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyBindingSpec spec = 2;

    pub fn spec(&self) -> &ValidatingAdmissionPolicyBindingSpec {
        self.spec.as_ref().unwrap_or_else(|| <ValidatingAdmissionPolicyBindingSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ValidatingAdmissionPolicyBindingSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ValidatingAdmissionPolicyBindingSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ValidatingAdmissionPolicyBindingSpec {
        self.spec.take().unwrap_or_else(|| ValidatingAdmissionPolicyBindingSpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ValidatingAdmissionPolicyBinding| { &m.metadata },
            |m: &mut ValidatingAdmissionPolicyBinding| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ValidatingAdmissionPolicyBindingSpec>(
            "spec",
            |m: &ValidatingAdmissionPolicyBinding| { &m.spec },
            |m: &mut ValidatingAdmissionPolicyBinding| { &mut m.spec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingAdmissionPolicyBinding>(
            "ValidatingAdmissionPolicyBinding",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingAdmissionPolicyBinding {
    const NAME: &'static str = "ValidatingAdmissionPolicyBinding";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingAdmissionPolicyBinding {
        ValidatingAdmissionPolicyBinding::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingAdmissionPolicyBinding {
        static instance: ValidatingAdmissionPolicyBinding = ValidatingAdmissionPolicyBinding {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingAdmissionPolicyBinding {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingAdmissionPolicyBinding").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingAdmissionPolicyBinding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingAdmissionPolicyBinding {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyBindingList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingAdmissionPolicyBindingList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyBindingList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyBindingList.items)
    pub items: ::std::vec::Vec<ValidatingAdmissionPolicyBinding>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyBindingList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingAdmissionPolicyBindingList {
    fn default() -> &'a ValidatingAdmissionPolicyBindingList {
        <ValidatingAdmissionPolicyBindingList as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingAdmissionPolicyBindingList {
    pub fn new() -> ValidatingAdmissionPolicyBindingList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyBinding items = 2;

    pub fn items(&self) -> &[ValidatingAdmissionPolicyBinding] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ValidatingAdmissionPolicyBinding>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ValidatingAdmissionPolicyBinding> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ValidatingAdmissionPolicyBinding> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ValidatingAdmissionPolicyBindingList| { &m.metadata },
            |m: &mut ValidatingAdmissionPolicyBindingList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ValidatingAdmissionPolicyBindingList| { &m.items },
            |m: &mut ValidatingAdmissionPolicyBindingList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingAdmissionPolicyBindingList>(
            "ValidatingAdmissionPolicyBindingList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingAdmissionPolicyBindingList {
    const NAME: &'static str = "ValidatingAdmissionPolicyBindingList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingAdmissionPolicyBindingList {
        ValidatingAdmissionPolicyBindingList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingAdmissionPolicyBindingList {
        static instance: ValidatingAdmissionPolicyBindingList = ValidatingAdmissionPolicyBindingList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingAdmissionPolicyBindingList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingAdmissionPolicyBindingList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingAdmissionPolicyBindingList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingAdmissionPolicyBindingList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyBindingSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingAdmissionPolicyBindingSpec {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyBindingSpec.policyName)
    pub policyName: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyBindingSpec.paramRef)
    pub paramRef: ::protobuf::MessageField<ParamRef>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyBindingSpec.matchResources)
    pub matchResources: ::protobuf::MessageField<MatchResources>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyBindingSpec.validationActions)
    pub validationActions: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyBindingSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingAdmissionPolicyBindingSpec {
    fn default() -> &'a ValidatingAdmissionPolicyBindingSpec {
        <ValidatingAdmissionPolicyBindingSpec as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingAdmissionPolicyBindingSpec {
    pub fn new() -> ValidatingAdmissionPolicyBindingSpec {
        ::std::default::Default::default()
    }

    // optional string policyName = 1;

    pub fn policyName(&self) -> &str {
        match self.policyName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_policyName(&mut self) {
        self.policyName = ::std::option::Option::None;
    }

    pub fn has_policyName(&self) -> bool {
        self.policyName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_policyName(&mut self, v: ::std::string::String) {
        self.policyName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_policyName(&mut self) -> &mut ::std::string::String {
        if self.policyName.is_none() {
            self.policyName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.policyName.as_mut().unwrap()
    }

    // Take field
    pub fn take_policyName(&mut self) -> ::std::string::String {
        self.policyName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.admissionregistration.v1alpha1.ParamRef paramRef = 2;

    pub fn paramRef(&self) -> &ParamRef {
        self.paramRef.as_ref().unwrap_or_else(|| <ParamRef as ::protobuf::Message>::default_instance())
    }

    pub fn clear_paramRef(&mut self) {
        self.paramRef.clear();
    }

    pub fn has_paramRef(&self) -> bool {
        self.paramRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paramRef(&mut self, v: ParamRef) {
        self.paramRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paramRef(&mut self) -> &mut ParamRef {
        self.paramRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_paramRef(&mut self) -> ParamRef {
        self.paramRef.take().unwrap_or_else(|| ParamRef::new())
    }

    // optional .api.admissionregistration.v1alpha1.MatchResources matchResources = 3;

    pub fn matchResources(&self) -> &MatchResources {
        self.matchResources.as_ref().unwrap_or_else(|| <MatchResources as ::protobuf::Message>::default_instance())
    }

    pub fn clear_matchResources(&mut self) {
        self.matchResources.clear();
    }

    pub fn has_matchResources(&self) -> bool {
        self.matchResources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchResources(&mut self, v: MatchResources) {
        self.matchResources = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_matchResources(&mut self) -> &mut MatchResources {
        self.matchResources.mut_or_insert_default()
    }

    // Take field
    pub fn take_matchResources(&mut self) -> MatchResources {
        self.matchResources.take().unwrap_or_else(|| MatchResources::new())
    }

    // repeated string validationActions = 4;

    pub fn validationActions(&self) -> &[::std::string::String] {
        &self.validationActions
    }

    pub fn clear_validationActions(&mut self) {
        self.validationActions.clear();
    }

    // Param is passed by value, moved
    pub fn set_validationActions(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.validationActions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_validationActions(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.validationActions
    }

    // Take field
    pub fn take_validationActions(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.validationActions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "policyName",
            |m: &ValidatingAdmissionPolicyBindingSpec| { &m.policyName },
            |m: &mut ValidatingAdmissionPolicyBindingSpec| { &mut m.policyName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ParamRef>(
            "paramRef",
            |m: &ValidatingAdmissionPolicyBindingSpec| { &m.paramRef },
            |m: &mut ValidatingAdmissionPolicyBindingSpec| { &mut m.paramRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MatchResources>(
            "matchResources",
            |m: &ValidatingAdmissionPolicyBindingSpec| { &m.matchResources },
            |m: &mut ValidatingAdmissionPolicyBindingSpec| { &mut m.matchResources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "validationActions",
            |m: &ValidatingAdmissionPolicyBindingSpec| { &m.validationActions },
            |m: &mut ValidatingAdmissionPolicyBindingSpec| { &mut m.validationActions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingAdmissionPolicyBindingSpec>(
            "ValidatingAdmissionPolicyBindingSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingAdmissionPolicyBindingSpec {
    const NAME: &'static str = "ValidatingAdmissionPolicyBindingSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.policyName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.paramRef)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.matchResources)?;
                },
                34 => {
                    self.validationActions.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.policyName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.paramRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.matchResources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.validationActions {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.policyName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.paramRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.matchResources.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.validationActions {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingAdmissionPolicyBindingSpec {
        ValidatingAdmissionPolicyBindingSpec::new()
    }

    fn clear(&mut self) {
        self.policyName = ::std::option::Option::None;
        self.paramRef.clear();
        self.matchResources.clear();
        self.validationActions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingAdmissionPolicyBindingSpec {
        static instance: ValidatingAdmissionPolicyBindingSpec = ValidatingAdmissionPolicyBindingSpec {
            policyName: ::std::option::Option::None,
            paramRef: ::protobuf::MessageField::none(),
            matchResources: ::protobuf::MessageField::none(),
            validationActions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingAdmissionPolicyBindingSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingAdmissionPolicyBindingSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingAdmissionPolicyBindingSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingAdmissionPolicyBindingSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingAdmissionPolicyList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyList.items)
    pub items: ::std::vec::Vec<ValidatingAdmissionPolicy>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingAdmissionPolicyList {
    fn default() -> &'a ValidatingAdmissionPolicyList {
        <ValidatingAdmissionPolicyList as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingAdmissionPolicyList {
    pub fn new() -> ValidatingAdmissionPolicyList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.admissionregistration.v1alpha1.ValidatingAdmissionPolicy items = 2;

    pub fn items(&self) -> &[ValidatingAdmissionPolicy] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ValidatingAdmissionPolicy>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ValidatingAdmissionPolicy> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ValidatingAdmissionPolicy> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ValidatingAdmissionPolicyList| { &m.metadata },
            |m: &mut ValidatingAdmissionPolicyList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ValidatingAdmissionPolicyList| { &m.items },
            |m: &mut ValidatingAdmissionPolicyList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingAdmissionPolicyList>(
            "ValidatingAdmissionPolicyList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingAdmissionPolicyList {
    const NAME: &'static str = "ValidatingAdmissionPolicyList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingAdmissionPolicyList {
        ValidatingAdmissionPolicyList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingAdmissionPolicyList {
        static instance: ValidatingAdmissionPolicyList = ValidatingAdmissionPolicyList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingAdmissionPolicyList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingAdmissionPolicyList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingAdmissionPolicyList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingAdmissionPolicyList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicySpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingAdmissionPolicySpec {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicySpec.paramKind)
    pub paramKind: ::protobuf::MessageField<ParamKind>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicySpec.matchConstraints)
    pub matchConstraints: ::protobuf::MessageField<MatchResources>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicySpec.validations)
    pub validations: ::std::vec::Vec<Validation>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicySpec.failurePolicy)
    pub failurePolicy: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicySpec.auditAnnotations)
    pub auditAnnotations: ::std::vec::Vec<AuditAnnotation>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicySpec.matchConditions)
    pub matchConditions: ::std::vec::Vec<MatchCondition>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicySpec.variables)
    pub variables: ::std::vec::Vec<Variable>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicySpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingAdmissionPolicySpec {
    fn default() -> &'a ValidatingAdmissionPolicySpec {
        <ValidatingAdmissionPolicySpec as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingAdmissionPolicySpec {
    pub fn new() -> ValidatingAdmissionPolicySpec {
        ::std::default::Default::default()
    }

    // optional .api.admissionregistration.v1alpha1.ParamKind paramKind = 1;

    pub fn paramKind(&self) -> &ParamKind {
        self.paramKind.as_ref().unwrap_or_else(|| <ParamKind as ::protobuf::Message>::default_instance())
    }

    pub fn clear_paramKind(&mut self) {
        self.paramKind.clear();
    }

    pub fn has_paramKind(&self) -> bool {
        self.paramKind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paramKind(&mut self, v: ParamKind) {
        self.paramKind = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paramKind(&mut self) -> &mut ParamKind {
        self.paramKind.mut_or_insert_default()
    }

    // Take field
    pub fn take_paramKind(&mut self) -> ParamKind {
        self.paramKind.take().unwrap_or_else(|| ParamKind::new())
    }

    // optional .api.admissionregistration.v1alpha1.MatchResources matchConstraints = 2;

    pub fn matchConstraints(&self) -> &MatchResources {
        self.matchConstraints.as_ref().unwrap_or_else(|| <MatchResources as ::protobuf::Message>::default_instance())
    }

    pub fn clear_matchConstraints(&mut self) {
        self.matchConstraints.clear();
    }

    pub fn has_matchConstraints(&self) -> bool {
        self.matchConstraints.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchConstraints(&mut self, v: MatchResources) {
        self.matchConstraints = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_matchConstraints(&mut self) -> &mut MatchResources {
        self.matchConstraints.mut_or_insert_default()
    }

    // Take field
    pub fn take_matchConstraints(&mut self) -> MatchResources {
        self.matchConstraints.take().unwrap_or_else(|| MatchResources::new())
    }

    // repeated .api.admissionregistration.v1alpha1.Validation validations = 3;

    pub fn validations(&self) -> &[Validation] {
        &self.validations
    }

    pub fn clear_validations(&mut self) {
        self.validations.clear();
    }

    // Param is passed by value, moved
    pub fn set_validations(&mut self, v: ::std::vec::Vec<Validation>) {
        self.validations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_validations(&mut self) -> &mut ::std::vec::Vec<Validation> {
        &mut self.validations
    }

    // Take field
    pub fn take_validations(&mut self) -> ::std::vec::Vec<Validation> {
        ::std::mem::replace(&mut self.validations, ::std::vec::Vec::new())
    }

    // optional string failurePolicy = 4;

    pub fn failurePolicy(&self) -> &str {
        match self.failurePolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_failurePolicy(&mut self) {
        self.failurePolicy = ::std::option::Option::None;
    }

    pub fn has_failurePolicy(&self) -> bool {
        self.failurePolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failurePolicy(&mut self, v: ::std::string::String) {
        self.failurePolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_failurePolicy(&mut self) -> &mut ::std::string::String {
        if self.failurePolicy.is_none() {
            self.failurePolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.failurePolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_failurePolicy(&mut self) -> ::std::string::String {
        self.failurePolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.admissionregistration.v1alpha1.AuditAnnotation auditAnnotations = 5;

    pub fn auditAnnotations(&self) -> &[AuditAnnotation] {
        &self.auditAnnotations
    }

    pub fn clear_auditAnnotations(&mut self) {
        self.auditAnnotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_auditAnnotations(&mut self, v: ::std::vec::Vec<AuditAnnotation>) {
        self.auditAnnotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_auditAnnotations(&mut self) -> &mut ::std::vec::Vec<AuditAnnotation> {
        &mut self.auditAnnotations
    }

    // Take field
    pub fn take_auditAnnotations(&mut self) -> ::std::vec::Vec<AuditAnnotation> {
        ::std::mem::replace(&mut self.auditAnnotations, ::std::vec::Vec::new())
    }

    // repeated .api.admissionregistration.v1alpha1.MatchCondition matchConditions = 6;

    pub fn matchConditions(&self) -> &[MatchCondition] {
        &self.matchConditions
    }

    pub fn clear_matchConditions(&mut self) {
        self.matchConditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchConditions(&mut self, v: ::std::vec::Vec<MatchCondition>) {
        self.matchConditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchConditions(&mut self) -> &mut ::std::vec::Vec<MatchCondition> {
        &mut self.matchConditions
    }

    // Take field
    pub fn take_matchConditions(&mut self) -> ::std::vec::Vec<MatchCondition> {
        ::std::mem::replace(&mut self.matchConditions, ::std::vec::Vec::new())
    }

    // repeated .api.admissionregistration.v1alpha1.Variable variables = 7;

    pub fn variables(&self) -> &[Variable] {
        &self.variables
    }

    pub fn clear_variables(&mut self) {
        self.variables.clear();
    }

    // Param is passed by value, moved
    pub fn set_variables(&mut self, v: ::std::vec::Vec<Variable>) {
        self.variables = v;
    }

    // Mutable pointer to the field.
    pub fn mut_variables(&mut self) -> &mut ::std::vec::Vec<Variable> {
        &mut self.variables
    }

    // Take field
    pub fn take_variables(&mut self) -> ::std::vec::Vec<Variable> {
        ::std::mem::replace(&mut self.variables, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ParamKind>(
            "paramKind",
            |m: &ValidatingAdmissionPolicySpec| { &m.paramKind },
            |m: &mut ValidatingAdmissionPolicySpec| { &mut m.paramKind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MatchResources>(
            "matchConstraints",
            |m: &ValidatingAdmissionPolicySpec| { &m.matchConstraints },
            |m: &mut ValidatingAdmissionPolicySpec| { &mut m.matchConstraints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "validations",
            |m: &ValidatingAdmissionPolicySpec| { &m.validations },
            |m: &mut ValidatingAdmissionPolicySpec| { &mut m.validations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "failurePolicy",
            |m: &ValidatingAdmissionPolicySpec| { &m.failurePolicy },
            |m: &mut ValidatingAdmissionPolicySpec| { &mut m.failurePolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "auditAnnotations",
            |m: &ValidatingAdmissionPolicySpec| { &m.auditAnnotations },
            |m: &mut ValidatingAdmissionPolicySpec| { &mut m.auditAnnotations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matchConditions",
            |m: &ValidatingAdmissionPolicySpec| { &m.matchConditions },
            |m: &mut ValidatingAdmissionPolicySpec| { &mut m.matchConditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "variables",
            |m: &ValidatingAdmissionPolicySpec| { &m.variables },
            |m: &mut ValidatingAdmissionPolicySpec| { &mut m.variables },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingAdmissionPolicySpec>(
            "ValidatingAdmissionPolicySpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingAdmissionPolicySpec {
    const NAME: &'static str = "ValidatingAdmissionPolicySpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.paramKind)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.matchConstraints)?;
                },
                26 => {
                    self.validations.push(is.read_message()?);
                },
                34 => {
                    self.failurePolicy = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.auditAnnotations.push(is.read_message()?);
                },
                50 => {
                    self.matchConditions.push(is.read_message()?);
                },
                58 => {
                    self.variables.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.paramKind.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.matchConstraints.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.validations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.failurePolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.auditAnnotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.matchConditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.variables {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.paramKind.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.matchConstraints.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.validations {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.failurePolicy.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.auditAnnotations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.matchConditions {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.variables {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingAdmissionPolicySpec {
        ValidatingAdmissionPolicySpec::new()
    }

    fn clear(&mut self) {
        self.paramKind.clear();
        self.matchConstraints.clear();
        self.validations.clear();
        self.failurePolicy = ::std::option::Option::None;
        self.auditAnnotations.clear();
        self.matchConditions.clear();
        self.variables.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingAdmissionPolicySpec {
        static instance: ValidatingAdmissionPolicySpec = ValidatingAdmissionPolicySpec {
            paramKind: ::protobuf::MessageField::none(),
            matchConstraints: ::protobuf::MessageField::none(),
            validations: ::std::vec::Vec::new(),
            failurePolicy: ::std::option::Option::None,
            auditAnnotations: ::std::vec::Vec::new(),
            matchConditions: ::std::vec::Vec::new(),
            variables: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingAdmissionPolicySpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingAdmissionPolicySpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingAdmissionPolicySpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingAdmissionPolicySpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingAdmissionPolicyStatus {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyStatus.observedGeneration)
    pub observedGeneration: ::std::option::Option<i64>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyStatus.typeChecking)
    pub typeChecking: ::protobuf::MessageField<TypeChecking>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyStatus.conditions)
    pub conditions: ::std::vec::Vec<crate::apimachinery::pkg::apis::meta::v1::Condition>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingAdmissionPolicyStatus {
    fn default() -> &'a ValidatingAdmissionPolicyStatus {
        <ValidatingAdmissionPolicyStatus as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingAdmissionPolicyStatus {
    pub fn new() -> ValidatingAdmissionPolicyStatus {
        ::std::default::Default::default()
    }

    // optional int64 observedGeneration = 1;

    pub fn observedGeneration(&self) -> i64 {
        self.observedGeneration.unwrap_or(0)
    }

    pub fn clear_observedGeneration(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
    }

    pub fn has_observedGeneration(&self) -> bool {
        self.observedGeneration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observedGeneration(&mut self, v: i64) {
        self.observedGeneration = ::std::option::Option::Some(v);
    }

    // optional .api.admissionregistration.v1alpha1.TypeChecking typeChecking = 2;

    pub fn typeChecking(&self) -> &TypeChecking {
        self.typeChecking.as_ref().unwrap_or_else(|| <TypeChecking as ::protobuf::Message>::default_instance())
    }

    pub fn clear_typeChecking(&mut self) {
        self.typeChecking.clear();
    }

    pub fn has_typeChecking(&self) -> bool {
        self.typeChecking.is_some()
    }

    // Param is passed by value, moved
    pub fn set_typeChecking(&mut self, v: TypeChecking) {
        self.typeChecking = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_typeChecking(&mut self) -> &mut TypeChecking {
        self.typeChecking.mut_or_insert_default()
    }

    // Take field
    pub fn take_typeChecking(&mut self) -> TypeChecking {
        self.typeChecking.take().unwrap_or_else(|| TypeChecking::new())
    }

    // repeated .apimachinery.pkg.apis.meta.v1.Condition conditions = 3;

    pub fn conditions(&self) -> &[crate::apimachinery::pkg::apis::meta::v1::Condition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<crate::apimachinery::pkg::apis::meta::v1::Condition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<crate::apimachinery::pkg::apis::meta::v1::Condition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<crate::apimachinery::pkg::apis::meta::v1::Condition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "observedGeneration",
            |m: &ValidatingAdmissionPolicyStatus| { &m.observedGeneration },
            |m: &mut ValidatingAdmissionPolicyStatus| { &mut m.observedGeneration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TypeChecking>(
            "typeChecking",
            |m: &ValidatingAdmissionPolicyStatus| { &m.typeChecking },
            |m: &mut ValidatingAdmissionPolicyStatus| { &mut m.typeChecking },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &ValidatingAdmissionPolicyStatus| { &m.conditions },
            |m: &mut ValidatingAdmissionPolicyStatus| { &mut m.conditions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingAdmissionPolicyStatus>(
            "ValidatingAdmissionPolicyStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingAdmissionPolicyStatus {
    const NAME: &'static str = "ValidatingAdmissionPolicyStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.observedGeneration = ::std::option::Option::Some(is.read_int64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.typeChecking)?;
                },
                26 => {
                    self.conditions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.observedGeneration {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.typeChecking.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.observedGeneration {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.typeChecking.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingAdmissionPolicyStatus {
        ValidatingAdmissionPolicyStatus::new()
    }

    fn clear(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
        self.typeChecking.clear();
        self.conditions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingAdmissionPolicyStatus {
        static instance: ValidatingAdmissionPolicyStatus = ValidatingAdmissionPolicyStatus {
            observedGeneration: ::std::option::Option::None,
            typeChecking: ::protobuf::MessageField::none(),
            conditions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingAdmissionPolicyStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingAdmissionPolicyStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingAdmissionPolicyStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingAdmissionPolicyStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1alpha1.Validation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Validation {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.Validation.Expression)
    pub Expression: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.Validation.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.Validation.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.Validation.messageExpression)
    pub messageExpression: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1alpha1.Validation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Validation {
    fn default() -> &'a Validation {
        <Validation as ::protobuf::Message>::default_instance()
    }
}

impl Validation {
    pub fn new() -> Validation {
        ::std::default::Default::default()
    }

    // optional string Expression = 1;

    pub fn Expression(&self) -> &str {
        match self.Expression.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_Expression(&mut self) {
        self.Expression = ::std::option::Option::None;
    }

    pub fn has_Expression(&self) -> bool {
        self.Expression.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Expression(&mut self, v: ::std::string::String) {
        self.Expression = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Expression(&mut self) -> &mut ::std::string::String {
        if self.Expression.is_none() {
            self.Expression = ::std::option::Option::Some(::std::string::String::new());
        }
        self.Expression.as_mut().unwrap()
    }

    // Take field
    pub fn take_Expression(&mut self) -> ::std::string::String {
        self.Expression.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reason = 3;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string messageExpression = 4;

    pub fn messageExpression(&self) -> &str {
        match self.messageExpression.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_messageExpression(&mut self) {
        self.messageExpression = ::std::option::Option::None;
    }

    pub fn has_messageExpression(&self) -> bool {
        self.messageExpression.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageExpression(&mut self, v: ::std::string::String) {
        self.messageExpression = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messageExpression(&mut self) -> &mut ::std::string::String {
        if self.messageExpression.is_none() {
            self.messageExpression = ::std::option::Option::Some(::std::string::String::new());
        }
        self.messageExpression.as_mut().unwrap()
    }

    // Take field
    pub fn take_messageExpression(&mut self) -> ::std::string::String {
        self.messageExpression.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "Expression",
            |m: &Validation| { &m.Expression },
            |m: &mut Validation| { &mut m.Expression },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &Validation| { &m.message },
            |m: &mut Validation| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &Validation| { &m.reason },
            |m: &mut Validation| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "messageExpression",
            |m: &Validation| { &m.messageExpression },
            |m: &mut Validation| { &mut m.messageExpression },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Validation>(
            "Validation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Validation {
    const NAME: &'static str = "Validation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Expression = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.messageExpression = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.Expression.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.messageExpression.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.Expression.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.messageExpression.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Validation {
        Validation::new()
    }

    fn clear(&mut self) {
        self.Expression = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.messageExpression = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Validation {
        static instance: Validation = Validation {
            Expression: ::std::option::Option::None,
            message: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            messageExpression: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Validation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Validation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Validation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Validation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1alpha1.Variable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Variable {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.Variable.Name)
    pub Name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1alpha1.Variable.Expression)
    pub Expression: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1alpha1.Variable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Variable {
    fn default() -> &'a Variable {
        <Variable as ::protobuf::Message>::default_instance()
    }
}

impl Variable {
    pub fn new() -> Variable {
        ::std::default::Default::default()
    }

    // optional string Name = 1;

    pub fn Name(&self) -> &str {
        match self.Name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_Name(&mut self) {
        self.Name = ::std::option::Option::None;
    }

    pub fn has_Name(&self) -> bool {
        self.Name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Name(&mut self, v: ::std::string::String) {
        self.Name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Name(&mut self) -> &mut ::std::string::String {
        if self.Name.is_none() {
            self.Name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.Name.as_mut().unwrap()
    }

    // Take field
    pub fn take_Name(&mut self) -> ::std::string::String {
        self.Name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string Expression = 2;

    pub fn Expression(&self) -> &str {
        match self.Expression.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_Expression(&mut self) {
        self.Expression = ::std::option::Option::None;
    }

    pub fn has_Expression(&self) -> bool {
        self.Expression.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Expression(&mut self, v: ::std::string::String) {
        self.Expression = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Expression(&mut self) -> &mut ::std::string::String {
        if self.Expression.is_none() {
            self.Expression = ::std::option::Option::Some(::std::string::String::new());
        }
        self.Expression.as_mut().unwrap()
    }

    // Take field
    pub fn take_Expression(&mut self) -> ::std::string::String {
        self.Expression.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "Name",
            |m: &Variable| { &m.Name },
            |m: &mut Variable| { &mut m.Name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "Expression",
            |m: &Variable| { &m.Expression },
            |m: &mut Variable| { &mut m.Expression },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Variable>(
            "Variable",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Variable {
    const NAME: &'static str = "Variable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.Expression = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.Name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.Expression.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.Name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.Expression.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Variable {
        Variable::new()
    }

    fn clear(&mut self) {
        self.Name = ::std::option::Option::None;
        self.Expression = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Variable {
        static instance: Variable = Variable {
            Name: ::std::option::Option::None,
            Expression: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Variable {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Variable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Variable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Variable {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n2api/admissionregistration/v1alpha1/generated.proto\x12\"api.admission\
    registration.v1alpha1\x1a,api/admissionregistration/v1/generated.proto\
    \x1a-apimachinery/pkg/apis/meta/v1/generated.proto\x1a(apimachinery/pkg/\
    runtime/generated.proto\x1a/apimachinery/pkg/runtime/schema/generated.pr\
    oto\"M\n\x0fAuditAnnotation\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12(\n\x0fvalueExpression\x18\x02\x20\x01(\tR\x0fvalueExpression\"I\n\
    \x11ExpressionWarning\x12\x1a\n\x08fieldRef\x18\x02\x20\x01(\tR\x08field\
    Ref\x12\x18\n\x07warning\x18\x03\x20\x01(\tR\x07warning\"D\n\x0eMatchCon\
    dition\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1e\n\nexpressi\
    on\x18\x02\x20\x01(\tR\nexpression\"\xb8\x03\n\x0eMatchResources\x12Z\n\
    \x11namespaceSelector\x18\x01\x20\x01(\x0b2,.apimachinery.pkg.apis.meta.\
    v1.LabelSelectorR\x11namespaceSelector\x12T\n\x0eobjectSelector\x18\x02\
    \x20\x01(\x0b2,.apimachinery.pkg.apis.meta.v1.LabelSelectorR\x0eobjectSe\
    lector\x12a\n\rresourceRules\x18\x03\x20\x03(\x0b2;.api.admissionregistr\
    ation.v1alpha1.NamedRuleWithOperationsR\rresourceRules\x12o\n\x14exclude\
    ResourceRules\x18\x04\x20\x03(\x0b2;.api.admissionregistration.v1alpha1.\
    NamedRuleWithOperationsR\x14excludeResourceRules\x12\x20\n\x0bmatchPolic\
    y\x18\x07\x20\x01(\tR\x0bmatchPolicy\"\xa1\x01\n\x17NamedRuleWithOperati\
    ons\x12$\n\rresourceNames\x18\x01\x20\x03(\tR\rresourceNames\x12`\n\x12r\
    uleWithOperations\x18\x02\x20\x01(\x0b20.api.admissionregistration.v1.Ru\
    leWithOperationsR\x12ruleWithOperations\"?\n\tParamKind\x12\x1e\n\napiVe\
    rsion\x18\x01\x20\x01(\tR\napiVersion\x12\x12\n\x04kind\x18\x02\x20\x01(\
    \tR\x04kind\"\xc0\x01\n\x08ParamRef\x12\x12\n\x04name\x18\x01\x20\x01(\t\
    R\x04name\x12\x1c\n\tnamespace\x18\x02\x20\x01(\tR\tnamespace\x12H\n\x08\
    selector\x18\x03\x20\x01(\x0b2,.apimachinery.pkg.apis.meta.v1.LabelSelec\
    torR\x08selector\x128\n\x17parameterNotFoundAction\x18\x04\x20\x01(\tR\
    \x17parameterNotFoundAction\"u\n\x0cTypeChecking\x12e\n\x12expressionWar\
    nings\x18\x01\x20\x03(\x0b25.api.admissionregistration.v1alpha1.Expressi\
    onWarningR\x12expressionWarnings\"\x96\x02\n\x19ValidatingAdmissionPolic\
    y\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v\
    1.ObjectMetaR\x08metadata\x12U\n\x04spec\x18\x02\x20\x01(\x0b2A.api.admi\
    ssionregistration.v1alpha1.ValidatingAdmissionPolicySpecR\x04spec\x12[\n\
    \x06status\x18\x03\x20\x01(\x0b2C.api.admissionregistration.v1alpha1.Val\
    idatingAdmissionPolicyStatusR\x06status\"\xc7\x01\n\x20ValidatingAdmissi\
    onPolicyBinding\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachinery.p\
    kg.apis.meta.v1.ObjectMetaR\x08metadata\x12\\\n\x04spec\x18\x02\x20\x01(\
    \x0b2H.api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyBindi\
    ngSpecR\x04spec\"\xc7\x01\n$ValidatingAdmissionPolicyBindingList\x12C\n\
    \x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMe\
    taR\x08metadata\x12Z\n\x05items\x18\x02\x20\x03(\x0b2D.api.admissionregi\
    stration.v1alpha1.ValidatingAdmissionPolicyBindingR\x05items\"\x9a\x02\n\
    $ValidatingAdmissionPolicyBindingSpec\x12\x1e\n\npolicyName\x18\x01\x20\
    \x01(\tR\npolicyName\x12H\n\x08paramRef\x18\x02\x20\x01(\x0b2,.api.admis\
    sionregistration.v1alpha1.ParamRefR\x08paramRef\x12Z\n\x0ematchResources\
    \x18\x03\x20\x01(\x0b22.api.admissionregistration.v1alpha1.MatchResource\
    sR\x0ematchResources\x12,\n\x11validationActions\x18\x04\x20\x03(\tR\x11\
    validationActions\"\xb9\x01\n\x1dValidatingAdmissionPolicyList\x12C\n\
    \x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMe\
    taR\x08metadata\x12S\n\x05items\x18\x02\x20\x03(\x0b2=.api.admissionregi\
    stration.v1alpha1.ValidatingAdmissionPolicyR\x05items\"\xcf\x04\n\x1dVal\
    idatingAdmissionPolicySpec\x12K\n\tparamKind\x18\x01\x20\x01(\x0b2-.api.\
    admissionregistration.v1alpha1.ParamKindR\tparamKind\x12^\n\x10matchCons\
    traints\x18\x02\x20\x01(\x0b22.api.admissionregistration.v1alpha1.MatchR\
    esourcesR\x10matchConstraints\x12P\n\x0bvalidations\x18\x03\x20\x03(\x0b\
    2..api.admissionregistration.v1alpha1.ValidationR\x0bvalidations\x12$\n\
    \rfailurePolicy\x18\x04\x20\x01(\tR\rfailurePolicy\x12_\n\x10auditAnnota\
    tions\x18\x05\x20\x03(\x0b23.api.admissionregistration.v1alpha1.AuditAnn\
    otationR\x10auditAnnotations\x12\\\n\x0fmatchConditions\x18\x06\x20\x03(\
    \x0b22.api.admissionregistration.v1alpha1.MatchConditionR\x0fmatchCondit\
    ions\x12J\n\tvariables\x18\x07\x20\x03(\x0b2,.api.admissionregistration.\
    v1alpha1.VariableR\tvariables\"\xf1\x01\n\x1fValidatingAdmissionPolicySt\
    atus\x12.\n\x12observedGeneration\x18\x01\x20\x01(\x03R\x12observedGener\
    ation\x12T\n\x0ctypeChecking\x18\x02\x20\x01(\x0b20.api.admissionregistr\
    ation.v1alpha1.TypeCheckingR\x0ctypeChecking\x12H\n\nconditions\x18\x03\
    \x20\x03(\x0b2(.apimachinery.pkg.apis.meta.v1.ConditionR\nconditions\"\
    \x8c\x01\n\nValidation\x12\x1e\n\nExpression\x18\x01\x20\x01(\tR\nExpres\
    sion\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\x12\x16\n\x06re\
    ason\x18\x03\x20\x01(\tR\x06reason\x12,\n\x11messageExpression\x18\x04\
    \x20\x01(\tR\x11messageExpression\">\n\x08Variable\x12\x12\n\x04Name\x18\
    \x01\x20\x01(\tR\x04Name\x12\x1e\n\nExpression\x18\x02\x20\x01(\tR\nExpr\
    essionB+Z)k8s.io/api/admissionregistration/v1alpha1\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(4);
            deps.push(super::v1alpha1::file_descriptor().clone());
            deps.push(super::v1alpha1::file_descriptor().clone());
            deps.push(super::v1alpha1::file_descriptor().clone());
            deps.push(super::v1alpha1::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(17);
            messages.push(AuditAnnotation::generated_message_descriptor_data());
            messages.push(ExpressionWarning::generated_message_descriptor_data());
            messages.push(MatchCondition::generated_message_descriptor_data());
            messages.push(MatchResources::generated_message_descriptor_data());
            messages.push(NamedRuleWithOperations::generated_message_descriptor_data());
            messages.push(ParamKind::generated_message_descriptor_data());
            messages.push(ParamRef::generated_message_descriptor_data());
            messages.push(TypeChecking::generated_message_descriptor_data());
            messages.push(ValidatingAdmissionPolicy::generated_message_descriptor_data());
            messages.push(ValidatingAdmissionPolicyBinding::generated_message_descriptor_data());
            messages.push(ValidatingAdmissionPolicyBindingList::generated_message_descriptor_data());
            messages.push(ValidatingAdmissionPolicyBindingSpec::generated_message_descriptor_data());
            messages.push(ValidatingAdmissionPolicyList::generated_message_descriptor_data());
            messages.push(ValidatingAdmissionPolicySpec::generated_message_descriptor_data());
            messages.push(ValidatingAdmissionPolicyStatus::generated_message_descriptor_data());
            messages.push(Validation::generated_message_descriptor_data());
            messages.push(Variable::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
