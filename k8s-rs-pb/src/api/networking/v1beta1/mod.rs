// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc 3.21.12
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `api/networking/v1beta1/generated.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1beta1.HTTPIngressPath)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HTTPIngressPath {
    // message fields
    // @@protoc_insertion_point(field:api.networking.v1beta1.HTTPIngressPath.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.networking.v1beta1.HTTPIngressPath.pathType)
    pub pathType: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1beta1.HTTPIngressPath.backend)
    pub backend: ::protobuf::MessageField<IngressBackend>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1beta1.HTTPIngressPath.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HTTPIngressPath {
    fn default() -> &'a HTTPIngressPath {
        <HTTPIngressPath as ::protobuf::Message>::default_instance()
    }
}

impl HTTPIngressPath {
    pub fn new() -> HTTPIngressPath {
        ::std::default::Default::default()
    }

    // optional string path = 1;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pathType = 3;

    pub fn pathType(&self) -> &str {
        match self.pathType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pathType(&mut self) {
        self.pathType = ::std::option::Option::None;
    }

    pub fn has_pathType(&self) -> bool {
        self.pathType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pathType(&mut self, v: ::std::string::String) {
        self.pathType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pathType(&mut self) -> &mut ::std::string::String {
        if self.pathType.is_none() {
            self.pathType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pathType.as_mut().unwrap()
    }

    // Take field
    pub fn take_pathType(&mut self) -> ::std::string::String {
        self.pathType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.networking.v1beta1.IngressBackend backend = 2;

    pub fn backend(&self) -> &IngressBackend {
        self.backend.as_ref().unwrap_or_else(|| <IngressBackend as ::protobuf::Message>::default_instance())
    }

    pub fn clear_backend(&mut self) {
        self.backend.clear();
    }

    pub fn has_backend(&self) -> bool {
        self.backend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backend(&mut self, v: IngressBackend) {
        self.backend = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backend(&mut self) -> &mut IngressBackend {
        self.backend.mut_or_insert_default()
    }

    // Take field
    pub fn take_backend(&mut self) -> IngressBackend {
        self.backend.take().unwrap_or_else(|| IngressBackend::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &HTTPIngressPath| { &m.path },
            |m: &mut HTTPIngressPath| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pathType",
            |m: &HTTPIngressPath| { &m.pathType },
            |m: &mut HTTPIngressPath| { &mut m.pathType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IngressBackend>(
            "backend",
            |m: &HTTPIngressPath| { &m.backend },
            |m: &mut HTTPIngressPath| { &mut m.backend },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HTTPIngressPath>(
            "HTTPIngressPath",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HTTPIngressPath {
    const NAME: &'static str = "HTTPIngressPath";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.pathType = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.backend)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.pathType.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.backend.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.path.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.pathType.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.backend.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HTTPIngressPath {
        HTTPIngressPath::new()
    }

    fn clear(&mut self) {
        self.path = ::std::option::Option::None;
        self.pathType = ::std::option::Option::None;
        self.backend.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HTTPIngressPath {
        static instance: HTTPIngressPath = HTTPIngressPath {
            path: ::std::option::Option::None,
            pathType: ::std::option::Option::None,
            backend: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HTTPIngressPath {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HTTPIngressPath").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HTTPIngressPath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPIngressPath {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1beta1.HTTPIngressRuleValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HTTPIngressRuleValue {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1beta1.HTTPIngressRuleValue.paths)
    pub paths: ::std::vec::Vec<HTTPIngressPath>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1beta1.HTTPIngressRuleValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HTTPIngressRuleValue {
    fn default() -> &'a HTTPIngressRuleValue {
        <HTTPIngressRuleValue as ::protobuf::Message>::default_instance()
    }
}

impl HTTPIngressRuleValue {
    pub fn new() -> HTTPIngressRuleValue {
        ::std::default::Default::default()
    }

    // repeated .api.networking.v1beta1.HTTPIngressPath paths = 1;

    pub fn paths(&self) -> &[HTTPIngressPath] {
        &self.paths
    }

    pub fn clear_paths(&mut self) {
        self.paths.clear();
    }

    // Param is passed by value, moved
    pub fn set_paths(&mut self, v: ::std::vec::Vec<HTTPIngressPath>) {
        self.paths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_paths(&mut self) -> &mut ::std::vec::Vec<HTTPIngressPath> {
        &mut self.paths
    }

    // Take field
    pub fn take_paths(&mut self) -> ::std::vec::Vec<HTTPIngressPath> {
        ::std::mem::replace(&mut self.paths, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "paths",
            |m: &HTTPIngressRuleValue| { &m.paths },
            |m: &mut HTTPIngressRuleValue| { &mut m.paths },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HTTPIngressRuleValue>(
            "HTTPIngressRuleValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HTTPIngressRuleValue {
    const NAME: &'static str = "HTTPIngressRuleValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.paths.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.paths {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.paths {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HTTPIngressRuleValue {
        HTTPIngressRuleValue::new()
    }

    fn clear(&mut self) {
        self.paths.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HTTPIngressRuleValue {
        static instance: HTTPIngressRuleValue = HTTPIngressRuleValue {
            paths: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HTTPIngressRuleValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HTTPIngressRuleValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HTTPIngressRuleValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPIngressRuleValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1beta1.Ingress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Ingress {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1beta1.Ingress.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1beta1.Ingress.spec)
    pub spec: ::protobuf::MessageField<IngressSpec>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1beta1.Ingress.status)
    pub status: ::protobuf::MessageField<IngressStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1beta1.Ingress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Ingress {
    fn default() -> &'a Ingress {
        <Ingress as ::protobuf::Message>::default_instance()
    }
}

impl Ingress {
    pub fn new() -> Ingress {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.networking.v1beta1.IngressSpec spec = 2;

    pub fn spec(&self) -> &IngressSpec {
        self.spec.as_ref().unwrap_or_else(|| <IngressSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: IngressSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut IngressSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> IngressSpec {
        self.spec.take().unwrap_or_else(|| IngressSpec::new())
    }

    // optional .api.networking.v1beta1.IngressStatus status = 3;

    pub fn status(&self) -> &IngressStatus {
        self.status.as_ref().unwrap_or_else(|| <IngressStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: IngressStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut IngressStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> IngressStatus {
        self.status.take().unwrap_or_else(|| IngressStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &Ingress| { &m.metadata },
            |m: &mut Ingress| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IngressSpec>(
            "spec",
            |m: &Ingress| { &m.spec },
            |m: &mut Ingress| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IngressStatus>(
            "status",
            |m: &Ingress| { &m.status },
            |m: &mut Ingress| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Ingress>(
            "Ingress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Ingress {
    const NAME: &'static str = "Ingress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Ingress {
        Ingress::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Ingress {
        static instance: Ingress = Ingress {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Ingress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Ingress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Ingress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ingress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1beta1.IngressBackend)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressBackend {
    // message fields
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressBackend.serviceName)
    pub serviceName: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::intorstr")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressBackend.servicePort)
    pub servicePort: ::protobuf::MessageField<crate::apimachinery::pkg::util::intstr::IntOrString>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressBackend.resource)
    pub resource: ::protobuf::MessageField<crate::api::core::v1::TypedLocalObjectReference>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1beta1.IngressBackend.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressBackend {
    fn default() -> &'a IngressBackend {
        <IngressBackend as ::protobuf::Message>::default_instance()
    }
}

impl IngressBackend {
    pub fn new() -> IngressBackend {
        ::std::default::Default::default()
    }

    // optional string serviceName = 1;

    pub fn serviceName(&self) -> &str {
        match self.serviceName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_serviceName(&mut self) {
        self.serviceName = ::std::option::Option::None;
    }

    pub fn has_serviceName(&self) -> bool {
        self.serviceName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serviceName(&mut self, v: ::std::string::String) {
        self.serviceName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serviceName(&mut self) -> &mut ::std::string::String {
        if self.serviceName.is_none() {
            self.serviceName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.serviceName.as_mut().unwrap()
    }

    // Take field
    pub fn take_serviceName(&mut self) -> ::std::string::String {
        self.serviceName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.util.intstr.IntOrString servicePort = 2;

    pub fn servicePort(&self) -> &crate::apimachinery::pkg::util::intstr::IntOrString {
        self.servicePort.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::util::intstr::IntOrString as ::protobuf::Message>::default_instance())
    }

    pub fn clear_servicePort(&mut self) {
        self.servicePort.clear();
    }

    pub fn has_servicePort(&self) -> bool {
        self.servicePort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_servicePort(&mut self, v: crate::apimachinery::pkg::util::intstr::IntOrString) {
        self.servicePort = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_servicePort(&mut self) -> &mut crate::apimachinery::pkg::util::intstr::IntOrString {
        self.servicePort.mut_or_insert_default()
    }

    // Take field
    pub fn take_servicePort(&mut self) -> crate::apimachinery::pkg::util::intstr::IntOrString {
        self.servicePort.take().unwrap_or_else(|| crate::apimachinery::pkg::util::intstr::IntOrString::new())
    }

    // optional .api.core.v1.TypedLocalObjectReference resource = 3;

    pub fn resource(&self) -> &crate::api::core::v1::TypedLocalObjectReference {
        self.resource.as_ref().unwrap_or_else(|| <crate::api::core::v1::TypedLocalObjectReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_resource(&mut self) {
        self.resource.clear();
    }

    pub fn has_resource(&self) -> bool {
        self.resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: crate::api::core::v1::TypedLocalObjectReference) {
        self.resource = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut crate::api::core::v1::TypedLocalObjectReference {
        self.resource.mut_or_insert_default()
    }

    // Take field
    pub fn take_resource(&mut self) -> crate::api::core::v1::TypedLocalObjectReference {
        self.resource.take().unwrap_or_else(|| crate::api::core::v1::TypedLocalObjectReference::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serviceName",
            |m: &IngressBackend| { &m.serviceName },
            |m: &mut IngressBackend| { &mut m.serviceName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::util::intstr::IntOrString>(
            "servicePort",
            |m: &IngressBackend| { &m.servicePort },
            |m: &mut IngressBackend| { &mut m.servicePort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::api::core::v1::TypedLocalObjectReference>(
            "resource",
            |m: &IngressBackend| { &m.resource },
            |m: &mut IngressBackend| { &mut m.resource },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressBackend>(
            "IngressBackend",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressBackend {
    const NAME: &'static str = "IngressBackend";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.serviceName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.servicePort)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resource)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.serviceName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.servicePort.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.resource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.serviceName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.servicePort.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.resource.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressBackend {
        IngressBackend::new()
    }

    fn clear(&mut self) {
        self.serviceName = ::std::option::Option::None;
        self.servicePort.clear();
        self.resource.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressBackend {
        static instance: IngressBackend = IngressBackend {
            serviceName: ::std::option::Option::None,
            servicePort: ::protobuf::MessageField::none(),
            resource: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressBackend {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressBackend").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressBackend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressBackend {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1beta1.IngressClass)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressClass {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressClass.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressClass.spec)
    pub spec: ::protobuf::MessageField<IngressClassSpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1beta1.IngressClass.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressClass {
    fn default() -> &'a IngressClass {
        <IngressClass as ::protobuf::Message>::default_instance()
    }
}

impl IngressClass {
    pub fn new() -> IngressClass {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.networking.v1beta1.IngressClassSpec spec = 2;

    pub fn spec(&self) -> &IngressClassSpec {
        self.spec.as_ref().unwrap_or_else(|| <IngressClassSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: IngressClassSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut IngressClassSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> IngressClassSpec {
        self.spec.take().unwrap_or_else(|| IngressClassSpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &IngressClass| { &m.metadata },
            |m: &mut IngressClass| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IngressClassSpec>(
            "spec",
            |m: &IngressClass| { &m.spec },
            |m: &mut IngressClass| { &mut m.spec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressClass>(
            "IngressClass",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressClass {
    const NAME: &'static str = "IngressClass";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressClass {
        IngressClass::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressClass {
        static instance: IngressClass = IngressClass {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressClass {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressClass").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressClass {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1beta1.IngressClassList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressClassList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressClassList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressClassList.items)
    pub items: ::std::vec::Vec<IngressClass>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1beta1.IngressClassList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressClassList {
    fn default() -> &'a IngressClassList {
        <IngressClassList as ::protobuf::Message>::default_instance()
    }
}

impl IngressClassList {
    pub fn new() -> IngressClassList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.networking.v1beta1.IngressClass items = 2;

    pub fn items(&self) -> &[IngressClass] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<IngressClass>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<IngressClass> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<IngressClass> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &IngressClassList| { &m.metadata },
            |m: &mut IngressClassList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &IngressClassList| { &m.items },
            |m: &mut IngressClassList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressClassList>(
            "IngressClassList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressClassList {
    const NAME: &'static str = "IngressClassList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressClassList {
        IngressClassList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressClassList {
        static instance: IngressClassList = IngressClassList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressClassList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressClassList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressClassList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressClassList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1beta1.IngressClassParametersReference)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressClassParametersReference {
    // message fields
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressClassParametersReference.aPIGroup)
    pub aPIGroup: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressClassParametersReference.kind)
    pub kind: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressClassParametersReference.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressClassParametersReference.scope)
    pub scope: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressClassParametersReference.namespace)
    pub namespace: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1beta1.IngressClassParametersReference.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressClassParametersReference {
    fn default() -> &'a IngressClassParametersReference {
        <IngressClassParametersReference as ::protobuf::Message>::default_instance()
    }
}

impl IngressClassParametersReference {
    pub fn new() -> IngressClassParametersReference {
        ::std::default::Default::default()
    }

    // optional string aPIGroup = 1;

    pub fn aPIGroup(&self) -> &str {
        match self.aPIGroup.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_aPIGroup(&mut self) {
        self.aPIGroup = ::std::option::Option::None;
    }

    pub fn has_aPIGroup(&self) -> bool {
        self.aPIGroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aPIGroup(&mut self, v: ::std::string::String) {
        self.aPIGroup = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aPIGroup(&mut self) -> &mut ::std::string::String {
        if self.aPIGroup.is_none() {
            self.aPIGroup = ::std::option::Option::Some(::std::string::String::new());
        }
        self.aPIGroup.as_mut().unwrap()
    }

    // Take field
    pub fn take_aPIGroup(&mut self) -> ::std::string::String {
        self.aPIGroup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kind = 2;

    pub fn kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string scope = 4;

    pub fn scope(&self) -> &str {
        match self.scope.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_scope(&mut self) {
        self.scope = ::std::option::Option::None;
    }

    pub fn has_scope(&self) -> bool {
        self.scope.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: ::std::string::String) {
        self.scope = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scope(&mut self) -> &mut ::std::string::String {
        if self.scope.is_none() {
            self.scope = ::std::option::Option::Some(::std::string::String::new());
        }
        self.scope.as_mut().unwrap()
    }

    // Take field
    pub fn take_scope(&mut self) -> ::std::string::String {
        self.scope.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string namespace = 5;

    pub fn namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_namespace(&mut self) {
        self.namespace = ::std::option::Option::None;
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "aPIGroup",
            |m: &IngressClassParametersReference| { &m.aPIGroup },
            |m: &mut IngressClassParametersReference| { &mut m.aPIGroup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &IngressClassParametersReference| { &m.kind },
            |m: &mut IngressClassParametersReference| { &mut m.kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &IngressClassParametersReference| { &m.name },
            |m: &mut IngressClassParametersReference| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scope",
            |m: &IngressClassParametersReference| { &m.scope },
            |m: &mut IngressClassParametersReference| { &mut m.scope },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "namespace",
            |m: &IngressClassParametersReference| { &m.namespace },
            |m: &mut IngressClassParametersReference| { &mut m.namespace },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressClassParametersReference>(
            "IngressClassParametersReference",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressClassParametersReference {
    const NAME: &'static str = "IngressClassParametersReference";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.aPIGroup = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.kind = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.scope = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.namespace = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.aPIGroup.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.scope.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.aPIGroup.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.kind.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.scope.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.namespace.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressClassParametersReference {
        IngressClassParametersReference::new()
    }

    fn clear(&mut self) {
        self.aPIGroup = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.scope = ::std::option::Option::None;
        self.namespace = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressClassParametersReference {
        static instance: IngressClassParametersReference = IngressClassParametersReference {
            aPIGroup: ::std::option::Option::None,
            kind: ::std::option::Option::None,
            name: ::std::option::Option::None,
            scope: ::std::option::Option::None,
            namespace: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressClassParametersReference {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressClassParametersReference").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressClassParametersReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressClassParametersReference {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1beta1.IngressClassSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressClassSpec {
    // message fields
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressClassSpec.controller)
    pub controller: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressClassSpec.parameters)
    pub parameters: ::protobuf::MessageField<IngressClassParametersReference>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1beta1.IngressClassSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressClassSpec {
    fn default() -> &'a IngressClassSpec {
        <IngressClassSpec as ::protobuf::Message>::default_instance()
    }
}

impl IngressClassSpec {
    pub fn new() -> IngressClassSpec {
        ::std::default::Default::default()
    }

    // optional string controller = 1;

    pub fn controller(&self) -> &str {
        match self.controller.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_controller(&mut self) {
        self.controller = ::std::option::Option::None;
    }

    pub fn has_controller(&self) -> bool {
        self.controller.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller(&mut self, v: ::std::string::String) {
        self.controller = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controller(&mut self) -> &mut ::std::string::String {
        if self.controller.is_none() {
            self.controller = ::std::option::Option::Some(::std::string::String::new());
        }
        self.controller.as_mut().unwrap()
    }

    // Take field
    pub fn take_controller(&mut self) -> ::std::string::String {
        self.controller.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.networking.v1beta1.IngressClassParametersReference parameters = 2;

    pub fn parameters(&self) -> &IngressClassParametersReference {
        self.parameters.as_ref().unwrap_or_else(|| <IngressClassParametersReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_parameters(&mut self) {
        self.parameters.clear();
    }

    pub fn has_parameters(&self) -> bool {
        self.parameters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameters(&mut self, v: IngressClassParametersReference) {
        self.parameters = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parameters(&mut self) -> &mut IngressClassParametersReference {
        self.parameters.mut_or_insert_default()
    }

    // Take field
    pub fn take_parameters(&mut self) -> IngressClassParametersReference {
        self.parameters.take().unwrap_or_else(|| IngressClassParametersReference::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "controller",
            |m: &IngressClassSpec| { &m.controller },
            |m: &mut IngressClassSpec| { &mut m.controller },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IngressClassParametersReference>(
            "parameters",
            |m: &IngressClassSpec| { &m.parameters },
            |m: &mut IngressClassSpec| { &mut m.parameters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressClassSpec>(
            "IngressClassSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressClassSpec {
    const NAME: &'static str = "IngressClassSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.controller = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.parameters)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.controller.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.parameters.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.controller.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.parameters.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressClassSpec {
        IngressClassSpec::new()
    }

    fn clear(&mut self) {
        self.controller = ::std::option::Option::None;
        self.parameters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressClassSpec {
        static instance: IngressClassSpec = IngressClassSpec {
            controller: ::std::option::Option::None,
            parameters: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressClassSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressClassSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressClassSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressClassSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1beta1.IngressList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressList.items)
    pub items: ::std::vec::Vec<Ingress>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1beta1.IngressList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressList {
    fn default() -> &'a IngressList {
        <IngressList as ::protobuf::Message>::default_instance()
    }
}

impl IngressList {
    pub fn new() -> IngressList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.networking.v1beta1.Ingress items = 2;

    pub fn items(&self) -> &[Ingress] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<Ingress>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<Ingress> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<Ingress> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &IngressList| { &m.metadata },
            |m: &mut IngressList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &IngressList| { &m.items },
            |m: &mut IngressList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressList>(
            "IngressList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressList {
    const NAME: &'static str = "IngressList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressList {
        IngressList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressList {
        static instance: IngressList = IngressList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1beta1.IngressLoadBalancerIngress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressLoadBalancerIngress {
    // message fields
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressLoadBalancerIngress.ip)
    pub ip: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressLoadBalancerIngress.hostname)
    pub hostname: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressLoadBalancerIngress.ports)
    pub ports: ::std::vec::Vec<IngressPortStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1beta1.IngressLoadBalancerIngress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressLoadBalancerIngress {
    fn default() -> &'a IngressLoadBalancerIngress {
        <IngressLoadBalancerIngress as ::protobuf::Message>::default_instance()
    }
}

impl IngressLoadBalancerIngress {
    pub fn new() -> IngressLoadBalancerIngress {
        ::std::default::Default::default()
    }

    // optional string ip = 1;

    pub fn ip(&self) -> &str {
        match self.ip.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        if self.ip.is_none() {
            self.ip = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        self.ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string hostname = 2;

    pub fn hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hostname(&mut self) {
        self.hostname = ::std::option::Option::None;
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.networking.v1beta1.IngressPortStatus ports = 4;

    pub fn ports(&self) -> &[IngressPortStatus] {
        &self.ports
    }

    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::std::vec::Vec<IngressPortStatus>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::std::vec::Vec<IngressPortStatus> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::std::vec::Vec<IngressPortStatus> {
        ::std::mem::replace(&mut self.ports, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip",
            |m: &IngressLoadBalancerIngress| { &m.ip },
            |m: &mut IngressLoadBalancerIngress| { &mut m.ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hostname",
            |m: &IngressLoadBalancerIngress| { &m.hostname },
            |m: &mut IngressLoadBalancerIngress| { &mut m.hostname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ports",
            |m: &IngressLoadBalancerIngress| { &m.ports },
            |m: &mut IngressLoadBalancerIngress| { &mut m.ports },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressLoadBalancerIngress>(
            "IngressLoadBalancerIngress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressLoadBalancerIngress {
    const NAME: &'static str = "IngressLoadBalancerIngress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ip = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.hostname = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.ports.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ip.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ip.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.hostname.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.ports {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressLoadBalancerIngress {
        IngressLoadBalancerIngress::new()
    }

    fn clear(&mut self) {
        self.ip = ::std::option::Option::None;
        self.hostname = ::std::option::Option::None;
        self.ports.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressLoadBalancerIngress {
        static instance: IngressLoadBalancerIngress = IngressLoadBalancerIngress {
            ip: ::std::option::Option::None,
            hostname: ::std::option::Option::None,
            ports: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressLoadBalancerIngress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressLoadBalancerIngress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressLoadBalancerIngress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressLoadBalancerIngress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1beta1.IngressLoadBalancerStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressLoadBalancerStatus {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressLoadBalancerStatus.ingress)
    pub ingress: ::std::vec::Vec<IngressLoadBalancerIngress>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1beta1.IngressLoadBalancerStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressLoadBalancerStatus {
    fn default() -> &'a IngressLoadBalancerStatus {
        <IngressLoadBalancerStatus as ::protobuf::Message>::default_instance()
    }
}

impl IngressLoadBalancerStatus {
    pub fn new() -> IngressLoadBalancerStatus {
        ::std::default::Default::default()
    }

    // repeated .api.networking.v1beta1.IngressLoadBalancerIngress ingress = 1;

    pub fn ingress(&self) -> &[IngressLoadBalancerIngress] {
        &self.ingress
    }

    pub fn clear_ingress(&mut self) {
        self.ingress.clear();
    }

    // Param is passed by value, moved
    pub fn set_ingress(&mut self, v: ::std::vec::Vec<IngressLoadBalancerIngress>) {
        self.ingress = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ingress(&mut self) -> &mut ::std::vec::Vec<IngressLoadBalancerIngress> {
        &mut self.ingress
    }

    // Take field
    pub fn take_ingress(&mut self) -> ::std::vec::Vec<IngressLoadBalancerIngress> {
        ::std::mem::replace(&mut self.ingress, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ingress",
            |m: &IngressLoadBalancerStatus| { &m.ingress },
            |m: &mut IngressLoadBalancerStatus| { &mut m.ingress },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressLoadBalancerStatus>(
            "IngressLoadBalancerStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressLoadBalancerStatus {
    const NAME: &'static str = "IngressLoadBalancerStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ingress.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ingress {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ingress {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressLoadBalancerStatus {
        IngressLoadBalancerStatus::new()
    }

    fn clear(&mut self) {
        self.ingress.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressLoadBalancerStatus {
        static instance: IngressLoadBalancerStatus = IngressLoadBalancerStatus {
            ingress: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressLoadBalancerStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressLoadBalancerStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressLoadBalancerStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressLoadBalancerStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1beta1.IngressPortStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressPortStatus {
    // message fields
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressPortStatus.port)
    pub port: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressPortStatus.protocol)
    pub protocol: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressPortStatus.error)
    pub error: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1beta1.IngressPortStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressPortStatus {
    fn default() -> &'a IngressPortStatus {
        <IngressPortStatus as ::protobuf::Message>::default_instance()
    }
}

impl IngressPortStatus {
    pub fn new() -> IngressPortStatus {
        ::std::default::Default::default()
    }

    // optional int32 port = 1;

    pub fn port(&self) -> i32 {
        self.port.unwrap_or(0)
    }

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Option::Some(v);
    }

    // optional string protocol = 2;

    pub fn protocol(&self) -> &str {
        match self.protocol.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_protocol(&mut self) {
        self.protocol = ::std::option::Option::None;
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol = ::std::option::Option::Some(::std::string::String::new());
        }
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string error = 3;

    pub fn error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "port",
            |m: &IngressPortStatus| { &m.port },
            |m: &mut IngressPortStatus| { &mut m.port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol",
            |m: &IngressPortStatus| { &m.protocol },
            |m: &mut IngressPortStatus| { &mut m.protocol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error",
            |m: &IngressPortStatus| { &m.error },
            |m: &mut IngressPortStatus| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressPortStatus>(
            "IngressPortStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressPortStatus {
    const NAME: &'static str = "IngressPortStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.port = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.protocol = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.error = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.protocol.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.port {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.protocol.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.error.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressPortStatus {
        IngressPortStatus::new()
    }

    fn clear(&mut self) {
        self.port = ::std::option::Option::None;
        self.protocol = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressPortStatus {
        static instance: IngressPortStatus = IngressPortStatus {
            port: ::std::option::Option::None,
            protocol: ::std::option::Option::None,
            error: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressPortStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressPortStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressPortStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressPortStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1beta1.IngressRule)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressRule {
    // message fields
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressRule.host)
    pub host: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressRule.ingressRuleValue)
    pub ingressRuleValue: ::protobuf::MessageField<IngressRuleValue>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1beta1.IngressRule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressRule {
    fn default() -> &'a IngressRule {
        <IngressRule as ::protobuf::Message>::default_instance()
    }
}

impl IngressRule {
    pub fn new() -> IngressRule {
        ::std::default::Default::default()
    }

    // optional string host = 1;

    pub fn host(&self) -> &str {
        match self.host.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_host(&mut self) {
        self.host = ::std::option::Option::None;
    }

    pub fn has_host(&self) -> bool {
        self.host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        if self.host.is_none() {
            self.host = ::std::option::Option::Some(::std::string::String::new());
        }
        self.host.as_mut().unwrap()
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        self.host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.networking.v1beta1.IngressRuleValue ingressRuleValue = 2;

    pub fn ingressRuleValue(&self) -> &IngressRuleValue {
        self.ingressRuleValue.as_ref().unwrap_or_else(|| <IngressRuleValue as ::protobuf::Message>::default_instance())
    }

    pub fn clear_ingressRuleValue(&mut self) {
        self.ingressRuleValue.clear();
    }

    pub fn has_ingressRuleValue(&self) -> bool {
        self.ingressRuleValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ingressRuleValue(&mut self, v: IngressRuleValue) {
        self.ingressRuleValue = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ingressRuleValue(&mut self) -> &mut IngressRuleValue {
        self.ingressRuleValue.mut_or_insert_default()
    }

    // Take field
    pub fn take_ingressRuleValue(&mut self) -> IngressRuleValue {
        self.ingressRuleValue.take().unwrap_or_else(|| IngressRuleValue::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "host",
            |m: &IngressRule| { &m.host },
            |m: &mut IngressRule| { &mut m.host },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IngressRuleValue>(
            "ingressRuleValue",
            |m: &IngressRule| { &m.ingressRuleValue },
            |m: &mut IngressRule| { &mut m.ingressRuleValue },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressRule>(
            "IngressRule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressRule {
    const NAME: &'static str = "IngressRule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.host = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ingressRuleValue)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.host.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.ingressRuleValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.host.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.ingressRuleValue.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressRule {
        IngressRule::new()
    }

    fn clear(&mut self) {
        self.host = ::std::option::Option::None;
        self.ingressRuleValue.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressRule {
        static instance: IngressRule = IngressRule {
            host: ::std::option::Option::None,
            ingressRuleValue: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressRule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressRule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressRule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1beta1.IngressRuleValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressRuleValue {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressRuleValue.http)
    pub http: ::protobuf::MessageField<HTTPIngressRuleValue>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1beta1.IngressRuleValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressRuleValue {
    fn default() -> &'a IngressRuleValue {
        <IngressRuleValue as ::protobuf::Message>::default_instance()
    }
}

impl IngressRuleValue {
    pub fn new() -> IngressRuleValue {
        ::std::default::Default::default()
    }

    // optional .api.networking.v1beta1.HTTPIngressRuleValue http = 1;

    pub fn http(&self) -> &HTTPIngressRuleValue {
        self.http.as_ref().unwrap_or_else(|| <HTTPIngressRuleValue as ::protobuf::Message>::default_instance())
    }

    pub fn clear_http(&mut self) {
        self.http.clear();
    }

    pub fn has_http(&self) -> bool {
        self.http.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http(&mut self, v: HTTPIngressRuleValue) {
        self.http = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http(&mut self) -> &mut HTTPIngressRuleValue {
        self.http.mut_or_insert_default()
    }

    // Take field
    pub fn take_http(&mut self) -> HTTPIngressRuleValue {
        self.http.take().unwrap_or_else(|| HTTPIngressRuleValue::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HTTPIngressRuleValue>(
            "http",
            |m: &IngressRuleValue| { &m.http },
            |m: &mut IngressRuleValue| { &mut m.http },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressRuleValue>(
            "IngressRuleValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressRuleValue {
    const NAME: &'static str = "IngressRuleValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.http)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.http.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.http.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressRuleValue {
        IngressRuleValue::new()
    }

    fn clear(&mut self) {
        self.http.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressRuleValue {
        static instance: IngressRuleValue = IngressRuleValue {
            http: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressRuleValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressRuleValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressRuleValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressRuleValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1beta1.IngressSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressSpec {
    // message fields
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressSpec.ingressClassName)
    pub ingressClassName: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressSpec.backend)
    pub backend: ::protobuf::MessageField<IngressBackend>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressSpec.tls)
    pub tls: ::std::vec::Vec<IngressTLS>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressSpec.rules)
    pub rules: ::std::vec::Vec<IngressRule>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1beta1.IngressSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressSpec {
    fn default() -> &'a IngressSpec {
        <IngressSpec as ::protobuf::Message>::default_instance()
    }
}

impl IngressSpec {
    pub fn new() -> IngressSpec {
        ::std::default::Default::default()
    }

    // optional string ingressClassName = 4;

    pub fn ingressClassName(&self) -> &str {
        match self.ingressClassName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ingressClassName(&mut self) {
        self.ingressClassName = ::std::option::Option::None;
    }

    pub fn has_ingressClassName(&self) -> bool {
        self.ingressClassName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ingressClassName(&mut self, v: ::std::string::String) {
        self.ingressClassName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ingressClassName(&mut self) -> &mut ::std::string::String {
        if self.ingressClassName.is_none() {
            self.ingressClassName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ingressClassName.as_mut().unwrap()
    }

    // Take field
    pub fn take_ingressClassName(&mut self) -> ::std::string::String {
        self.ingressClassName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.networking.v1beta1.IngressBackend backend = 1;

    pub fn backend(&self) -> &IngressBackend {
        self.backend.as_ref().unwrap_or_else(|| <IngressBackend as ::protobuf::Message>::default_instance())
    }

    pub fn clear_backend(&mut self) {
        self.backend.clear();
    }

    pub fn has_backend(&self) -> bool {
        self.backend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backend(&mut self, v: IngressBackend) {
        self.backend = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backend(&mut self) -> &mut IngressBackend {
        self.backend.mut_or_insert_default()
    }

    // Take field
    pub fn take_backend(&mut self) -> IngressBackend {
        self.backend.take().unwrap_or_else(|| IngressBackend::new())
    }

    // repeated .api.networking.v1beta1.IngressTLS tls = 2;

    pub fn tls(&self) -> &[IngressTLS] {
        &self.tls
    }

    pub fn clear_tls(&mut self) {
        self.tls.clear();
    }

    // Param is passed by value, moved
    pub fn set_tls(&mut self, v: ::std::vec::Vec<IngressTLS>) {
        self.tls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tls(&mut self) -> &mut ::std::vec::Vec<IngressTLS> {
        &mut self.tls
    }

    // Take field
    pub fn take_tls(&mut self) -> ::std::vec::Vec<IngressTLS> {
        ::std::mem::replace(&mut self.tls, ::std::vec::Vec::new())
    }

    // repeated .api.networking.v1beta1.IngressRule rules = 3;

    pub fn rules(&self) -> &[IngressRule] {
        &self.rules
    }

    pub fn clear_rules(&mut self) {
        self.rules.clear();
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: ::std::vec::Vec<IngressRule>) {
        self.rules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rules(&mut self) -> &mut ::std::vec::Vec<IngressRule> {
        &mut self.rules
    }

    // Take field
    pub fn take_rules(&mut self) -> ::std::vec::Vec<IngressRule> {
        ::std::mem::replace(&mut self.rules, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ingressClassName",
            |m: &IngressSpec| { &m.ingressClassName },
            |m: &mut IngressSpec| { &mut m.ingressClassName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IngressBackend>(
            "backend",
            |m: &IngressSpec| { &m.backend },
            |m: &mut IngressSpec| { &mut m.backend },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tls",
            |m: &IngressSpec| { &m.tls },
            |m: &mut IngressSpec| { &mut m.tls },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rules",
            |m: &IngressSpec| { &m.rules },
            |m: &mut IngressSpec| { &mut m.rules },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressSpec>(
            "IngressSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressSpec {
    const NAME: &'static str = "IngressSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                34 => {
                    self.ingressClassName = ::std::option::Option::Some(is.read_string()?);
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.backend)?;
                },
                18 => {
                    self.tls.push(is.read_message()?);
                },
                26 => {
                    self.rules.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ingressClassName.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.backend.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.tls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ingressClassName.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.backend.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.tls {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.rules {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressSpec {
        IngressSpec::new()
    }

    fn clear(&mut self) {
        self.ingressClassName = ::std::option::Option::None;
        self.backend.clear();
        self.tls.clear();
        self.rules.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressSpec {
        static instance: IngressSpec = IngressSpec {
            ingressClassName: ::std::option::Option::None,
            backend: ::protobuf::MessageField::none(),
            tls: ::std::vec::Vec::new(),
            rules: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1beta1.IngressStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressStatus {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressStatus.loadBalancer)
    pub loadBalancer: ::protobuf::MessageField<IngressLoadBalancerStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1beta1.IngressStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressStatus {
    fn default() -> &'a IngressStatus {
        <IngressStatus as ::protobuf::Message>::default_instance()
    }
}

impl IngressStatus {
    pub fn new() -> IngressStatus {
        ::std::default::Default::default()
    }

    // optional .api.networking.v1beta1.IngressLoadBalancerStatus loadBalancer = 1;

    pub fn loadBalancer(&self) -> &IngressLoadBalancerStatus {
        self.loadBalancer.as_ref().unwrap_or_else(|| <IngressLoadBalancerStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_loadBalancer(&mut self) {
        self.loadBalancer.clear();
    }

    pub fn has_loadBalancer(&self) -> bool {
        self.loadBalancer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loadBalancer(&mut self, v: IngressLoadBalancerStatus) {
        self.loadBalancer = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loadBalancer(&mut self) -> &mut IngressLoadBalancerStatus {
        self.loadBalancer.mut_or_insert_default()
    }

    // Take field
    pub fn take_loadBalancer(&mut self) -> IngressLoadBalancerStatus {
        self.loadBalancer.take().unwrap_or_else(|| IngressLoadBalancerStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IngressLoadBalancerStatus>(
            "loadBalancer",
            |m: &IngressStatus| { &m.loadBalancer },
            |m: &mut IngressStatus| { &mut m.loadBalancer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressStatus>(
            "IngressStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressStatus {
    const NAME: &'static str = "IngressStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.loadBalancer)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.loadBalancer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.loadBalancer.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressStatus {
        IngressStatus::new()
    }

    fn clear(&mut self) {
        self.loadBalancer.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressStatus {
        static instance: IngressStatus = IngressStatus {
            loadBalancer: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.networking.v1beta1.IngressTLS)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IngressTLS {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressTLS.hosts)
    pub hosts: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.networking.v1beta1.IngressTLS.secretName)
    pub secretName: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.networking.v1beta1.IngressTLS.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IngressTLS {
    fn default() -> &'a IngressTLS {
        <IngressTLS as ::protobuf::Message>::default_instance()
    }
}

impl IngressTLS {
    pub fn new() -> IngressTLS {
        ::std::default::Default::default()
    }

    // repeated string hosts = 1;

    pub fn hosts(&self) -> &[::std::string::String] {
        &self.hosts
    }

    pub fn clear_hosts(&mut self) {
        self.hosts.clear();
    }

    // Param is passed by value, moved
    pub fn set_hosts(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.hosts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hosts(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.hosts
    }

    // Take field
    pub fn take_hosts(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.hosts, ::std::vec::Vec::new())
    }

    // optional string secretName = 2;

    pub fn secretName(&self) -> &str {
        match self.secretName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_secretName(&mut self) {
        self.secretName = ::std::option::Option::None;
    }

    pub fn has_secretName(&self) -> bool {
        self.secretName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretName(&mut self, v: ::std::string::String) {
        self.secretName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretName(&mut self) -> &mut ::std::string::String {
        if self.secretName.is_none() {
            self.secretName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.secretName.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretName(&mut self) -> ::std::string::String {
        self.secretName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hosts",
            |m: &IngressTLS| { &m.hosts },
            |m: &mut IngressTLS| { &mut m.hosts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "secretName",
            |m: &IngressTLS| { &m.secretName },
            |m: &mut IngressTLS| { &mut m.secretName },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IngressTLS>(
            "IngressTLS",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IngressTLS {
    const NAME: &'static str = "IngressTLS";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hosts.push(is.read_string()?);
                },
                18 => {
                    self.secretName = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.hosts {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.secretName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.hosts {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.secretName.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IngressTLS {
        IngressTLS::new()
    }

    fn clear(&mut self) {
        self.hosts.clear();
        self.secretName = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IngressTLS {
        static instance: IngressTLS = IngressTLS {
            hosts: ::std::vec::Vec::new(),
            secretName: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IngressTLS {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IngressTLS").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IngressTLS {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngressTLS {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n&api/networking/v1beta1/generated.proto\x12\x16api.networking.v1beta1\
    \x1a\x1bapi/core/v1/generated.proto\x1a-apimachinery/pkg/apis/meta/v1/ge\
    nerated.proto\x1a(apimachinery/pkg/runtime/generated.proto\x1a/apimachin\
    ery/pkg/runtime/schema/generated.proto\x1a,apimachinery/pkg/util/intstr/\
    generated.proto\"\x83\x01\n\x0fHTTPIngressPath\x12\x12\n\x04path\x18\x01\
    \x20\x01(\tR\x04path\x12\x1a\n\x08pathType\x18\x03\x20\x01(\tR\x08pathTy\
    pe\x12@\n\x07backend\x18\x02\x20\x01(\x0b2&.api.networking.v1beta1.Ingre\
    ssBackendR\x07backend\"U\n\x14HTTPIngressRuleValue\x12=\n\x05paths\x18\
    \x01\x20\x03(\x0b2'.api.networking.v1beta1.HTTPIngressPathR\x05paths\"\
    \xc8\x01\n\x07Ingress\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachi\
    nery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x127\n\x04spec\x18\x02\x20\
    \x01(\x0b2#.api.networking.v1beta1.IngressSpecR\x04spec\x12=\n\x06status\
    \x18\x03\x20\x01(\x0b2%.api.networking.v1beta1.IngressStatusR\x06status\
    \"\xc3\x01\n\x0eIngressBackend\x12\x20\n\x0bserviceName\x18\x01\x20\x01(\
    \tR\x0bserviceName\x12K\n\x0bservicePort\x18\x02\x20\x01(\x0b2).apimachi\
    nery.pkg.util.intstr.IntOrStringR\x0bservicePort\x12B\n\x08resource\x18\
    \x03\x20\x01(\x0b2&.api.core.v1.TypedLocalObjectReferenceR\x08resource\"\
    \x93\x01\n\x0cIngressClass\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).api\
    machinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12<\n\x04spec\x18\
    \x02\x20\x01(\x0b2(.api.networking.v1beta1.IngressClassSpecR\x04spec\"\
    \x93\x01\n\x10IngressClassList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'\
    .apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12:\n\x05items\x18\
    \x02\x20\x03(\x0b2$.api.networking.v1beta1.IngressClassR\x05items\"\x99\
    \x01\n\x1fIngressClassParametersReference\x12\x1a\n\x08aPIGroup\x18\x01\
    \x20\x01(\tR\x08aPIGroup\x12\x12\n\x04kind\x18\x02\x20\x01(\tR\x04kind\
    \x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x14\n\x05scope\x18\
    \x04\x20\x01(\tR\x05scope\x12\x1c\n\tnamespace\x18\x05\x20\x01(\tR\tname\
    space\"\x8b\x01\n\x10IngressClassSpec\x12\x1e\n\ncontroller\x18\x01\x20\
    \x01(\tR\ncontroller\x12W\n\nparameters\x18\x02\x20\x01(\x0b27.api.netwo\
    rking.v1beta1.IngressClassParametersReferenceR\nparameters\"\x89\x01\n\
    \x0bIngressList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.p\
    kg.apis.meta.v1.ListMetaR\x08metadata\x125\n\x05items\x18\x02\x20\x03(\
    \x0b2\x1f.api.networking.v1beta1.IngressR\x05items\"\x89\x01\n\x1aIngres\
    sLoadBalancerIngress\x12\x0e\n\x02ip\x18\x01\x20\x01(\tR\x02ip\x12\x1a\n\
    \x08hostname\x18\x02\x20\x01(\tR\x08hostname\x12?\n\x05ports\x18\x04\x20\
    \x03(\x0b2).api.networking.v1beta1.IngressPortStatusR\x05ports\"i\n\x19I\
    ngressLoadBalancerStatus\x12L\n\x07ingress\x18\x01\x20\x03(\x0b22.api.ne\
    tworking.v1beta1.IngressLoadBalancerIngressR\x07ingress\"Y\n\x11IngressP\
    ortStatus\x12\x12\n\x04port\x18\x01\x20\x01(\x05R\x04port\x12\x1a\n\x08p\
    rotocol\x18\x02\x20\x01(\tR\x08protocol\x12\x14\n\x05error\x18\x03\x20\
    \x01(\tR\x05error\"w\n\x0bIngressRule\x12\x12\n\x04host\x18\x01\x20\x01(\
    \tR\x04host\x12T\n\x10ingressRuleValue\x18\x02\x20\x01(\x0b2(.api.networ\
    king.v1beta1.IngressRuleValueR\x10ingressRuleValue\"T\n\x10IngressRuleVa\
    lue\x12@\n\x04http\x18\x01\x20\x01(\x0b2,.api.networking.v1beta1.HTTPIng\
    ressRuleValueR\x04http\"\xec\x01\n\x0bIngressSpec\x12*\n\x10ingressClass\
    Name\x18\x04\x20\x01(\tR\x10ingressClassName\x12@\n\x07backend\x18\x01\
    \x20\x01(\x0b2&.api.networking.v1beta1.IngressBackendR\x07backend\x124\n\
    \x03tls\x18\x02\x20\x03(\x0b2\".api.networking.v1beta1.IngressTLSR\x03tl\
    s\x129\n\x05rules\x18\x03\x20\x03(\x0b2#.api.networking.v1beta1.IngressR\
    uleR\x05rules\"f\n\rIngressStatus\x12U\n\x0cloadBalancer\x18\x01\x20\x01\
    (\x0b21.api.networking.v1beta1.IngressLoadBalancerStatusR\x0cloadBalance\
    r\"B\n\nIngressTLS\x12\x14\n\x05hosts\x18\x01\x20\x03(\tR\x05hosts\x12\
    \x1e\n\nsecretName\x18\x02\x20\x01(\tR\nsecretNameB\x1fZ\x1dk8s.io/api/n\
    etworking/v1beta1\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(5);
            deps.push(super::v1beta1::file_descriptor().clone());
            deps.push(super::v1beta1::file_descriptor().clone());
            deps.push(super::v1beta1::file_descriptor().clone());
            deps.push(super::v1beta1::file_descriptor().clone());
            deps.push(super::v1beta1::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(17);
            messages.push(HTTPIngressPath::generated_message_descriptor_data());
            messages.push(HTTPIngressRuleValue::generated_message_descriptor_data());
            messages.push(Ingress::generated_message_descriptor_data());
            messages.push(IngressBackend::generated_message_descriptor_data());
            messages.push(IngressClass::generated_message_descriptor_data());
            messages.push(IngressClassList::generated_message_descriptor_data());
            messages.push(IngressClassParametersReference::generated_message_descriptor_data());
            messages.push(IngressClassSpec::generated_message_descriptor_data());
            messages.push(IngressList::generated_message_descriptor_data());
            messages.push(IngressLoadBalancerIngress::generated_message_descriptor_data());
            messages.push(IngressLoadBalancerStatus::generated_message_descriptor_data());
            messages.push(IngressPortStatus::generated_message_descriptor_data());
            messages.push(IngressRule::generated_message_descriptor_data());
            messages.push(IngressRuleValue::generated_message_descriptor_data());
            messages.push(IngressSpec::generated_message_descriptor_data());
            messages.push(IngressStatus::generated_message_descriptor_data());
            messages.push(IngressTLS::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
