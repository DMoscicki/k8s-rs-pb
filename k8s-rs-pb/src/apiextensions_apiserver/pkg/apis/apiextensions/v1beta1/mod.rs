// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by protoc 3.21.12
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `apiextensions-apiserver/pkg/apis/apiextensions/v1beta1/generated.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ConversionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConversionRequest {
    // message fields
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ConversionRequest.uid)
    pub uid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ConversionRequest.desiredAPIVersion)
    pub desiredAPIVersion: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ConversionRequest.objects)
    pub objects: ::std::vec::Vec<crate::apimachinery::pkg::runtime::RawExtension>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ConversionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConversionRequest {
    fn default() -> &'a ConversionRequest {
        <ConversionRequest as ::protobuf::Message>::default_instance()
    }
}

impl ConversionRequest {
    pub fn new() -> ConversionRequest {
        ::std::default::Default::default()
    }

    // optional string uid = 1;

    pub fn uid(&self) -> &str {
        match self.uid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_uid(&mut self) {
        self.uid = ::std::option::Option::None;
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if self.uid.is_none() {
            self.uid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        self.uid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string desiredAPIVersion = 2;

    pub fn desiredAPIVersion(&self) -> &str {
        match self.desiredAPIVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_desiredAPIVersion(&mut self) {
        self.desiredAPIVersion = ::std::option::Option::None;
    }

    pub fn has_desiredAPIVersion(&self) -> bool {
        self.desiredAPIVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desiredAPIVersion(&mut self, v: ::std::string::String) {
        self.desiredAPIVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desiredAPIVersion(&mut self) -> &mut ::std::string::String {
        if self.desiredAPIVersion.is_none() {
            self.desiredAPIVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.desiredAPIVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_desiredAPIVersion(&mut self) -> ::std::string::String {
        self.desiredAPIVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .apimachinery.pkg.runtime.RawExtension objects = 3;

    pub fn objects(&self) -> &[crate::apimachinery::pkg::runtime::RawExtension] {
        &self.objects
    }

    pub fn clear_objects(&mut self) {
        self.objects.clear();
    }

    // Param is passed by value, moved
    pub fn set_objects(&mut self, v: ::std::vec::Vec<crate::apimachinery::pkg::runtime::RawExtension>) {
        self.objects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_objects(&mut self) -> &mut ::std::vec::Vec<crate::apimachinery::pkg::runtime::RawExtension> {
        &mut self.objects
    }

    // Take field
    pub fn take_objects(&mut self) -> ::std::vec::Vec<crate::apimachinery::pkg::runtime::RawExtension> {
        ::std::mem::replace(&mut self.objects, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uid",
            |m: &ConversionRequest| { &m.uid },
            |m: &mut ConversionRequest| { &mut m.uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desiredAPIVersion",
            |m: &ConversionRequest| { &m.desiredAPIVersion },
            |m: &mut ConversionRequest| { &mut m.desiredAPIVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "objects",
            |m: &ConversionRequest| { &m.objects },
            |m: &mut ConversionRequest| { &mut m.objects },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConversionRequest>(
            "ConversionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConversionRequest {
    const NAME: &'static str = "ConversionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uid = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.desiredAPIVersion = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.objects.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.uid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.desiredAPIVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.objects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.uid.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.desiredAPIVersion.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.objects {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConversionRequest {
        ConversionRequest::new()
    }

    fn clear(&mut self) {
        self.uid = ::std::option::Option::None;
        self.desiredAPIVersion = ::std::option::Option::None;
        self.objects.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConversionRequest {
        static instance: ConversionRequest = ConversionRequest {
            uid: ::std::option::Option::None,
            desiredAPIVersion: ::std::option::Option::None,
            objects: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConversionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConversionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConversionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConversionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ConversionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConversionResponse {
    // message fields
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ConversionResponse.uid)
    pub uid: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ConversionResponse.convertedObjects)
    pub convertedObjects: ::std::vec::Vec<crate::apimachinery::pkg::runtime::RawExtension>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ConversionResponse.result)
    pub result: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::Status>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ConversionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConversionResponse {
    fn default() -> &'a ConversionResponse {
        <ConversionResponse as ::protobuf::Message>::default_instance()
    }
}

impl ConversionResponse {
    pub fn new() -> ConversionResponse {
        ::std::default::Default::default()
    }

    // optional string uid = 1;

    pub fn uid(&self) -> &str {
        match self.uid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_uid(&mut self) {
        self.uid = ::std::option::Option::None;
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if self.uid.is_none() {
            self.uid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        self.uid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .apimachinery.pkg.runtime.RawExtension convertedObjects = 2;

    pub fn convertedObjects(&self) -> &[crate::apimachinery::pkg::runtime::RawExtension] {
        &self.convertedObjects
    }

    pub fn clear_convertedObjects(&mut self) {
        self.convertedObjects.clear();
    }

    // Param is passed by value, moved
    pub fn set_convertedObjects(&mut self, v: ::std::vec::Vec<crate::apimachinery::pkg::runtime::RawExtension>) {
        self.convertedObjects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_convertedObjects(&mut self) -> &mut ::std::vec::Vec<crate::apimachinery::pkg::runtime::RawExtension> {
        &mut self.convertedObjects
    }

    // Take field
    pub fn take_convertedObjects(&mut self) -> ::std::vec::Vec<crate::apimachinery::pkg::runtime::RawExtension> {
        ::std::mem::replace(&mut self.convertedObjects, ::std::vec::Vec::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Status result = 3;

    pub fn result(&self) -> &crate::apimachinery::pkg::apis::meta::v1::Status {
        self.result.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::Status as ::protobuf::Message>::default_instance())
    }

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::Status) {
        self.result = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::Status {
        self.result.mut_or_insert_default()
    }

    // Take field
    pub fn take_result(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::Status {
        self.result.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::Status::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uid",
            |m: &ConversionResponse| { &m.uid },
            |m: &mut ConversionResponse| { &mut m.uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "convertedObjects",
            |m: &ConversionResponse| { &m.convertedObjects },
            |m: &mut ConversionResponse| { &mut m.convertedObjects },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::Status>(
            "result",
            |m: &ConversionResponse| { &m.result },
            |m: &mut ConversionResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConversionResponse>(
            "ConversionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConversionResponse {
    const NAME: &'static str = "ConversionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uid = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.convertedObjects.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.result)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.uid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.convertedObjects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.uid.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.convertedObjects {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.result.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConversionResponse {
        ConversionResponse::new()
    }

    fn clear(&mut self) {
        self.uid = ::std::option::Option::None;
        self.convertedObjects.clear();
        self.result.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConversionResponse {
        static instance: ConversionResponse = ConversionResponse {
            uid: ::std::option::Option::None,
            convertedObjects: ::std::vec::Vec::new(),
            result: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConversionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConversionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConversionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConversionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ConversionReview)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConversionReview {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ConversionReview.request)
    pub request: ::protobuf::MessageField<ConversionRequest>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ConversionReview.response)
    pub response: ::protobuf::MessageField<ConversionResponse>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ConversionReview.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConversionReview {
    fn default() -> &'a ConversionReview {
        <ConversionReview as ::protobuf::Message>::default_instance()
    }
}

impl ConversionReview {
    pub fn new() -> ConversionReview {
        ::std::default::Default::default()
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ConversionRequest request = 1;

    pub fn request(&self) -> &ConversionRequest {
        self.request.as_ref().unwrap_or_else(|| <ConversionRequest as ::protobuf::Message>::default_instance())
    }

    pub fn clear_request(&mut self) {
        self.request.clear();
    }

    pub fn has_request(&self) -> bool {
        self.request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request(&mut self, v: ConversionRequest) {
        self.request = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request(&mut self) -> &mut ConversionRequest {
        self.request.mut_or_insert_default()
    }

    // Take field
    pub fn take_request(&mut self) -> ConversionRequest {
        self.request.take().unwrap_or_else(|| ConversionRequest::new())
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ConversionResponse response = 2;

    pub fn response(&self) -> &ConversionResponse {
        self.response.as_ref().unwrap_or_else(|| <ConversionResponse as ::protobuf::Message>::default_instance())
    }

    pub fn clear_response(&mut self) {
        self.response.clear();
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: ConversionResponse) {
        self.response = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response(&mut self) -> &mut ConversionResponse {
        self.response.mut_or_insert_default()
    }

    // Take field
    pub fn take_response(&mut self) -> ConversionResponse {
        self.response.take().unwrap_or_else(|| ConversionResponse::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConversionRequest>(
            "request",
            |m: &ConversionReview| { &m.request },
            |m: &mut ConversionReview| { &mut m.request },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConversionResponse>(
            "response",
            |m: &ConversionReview| { &m.response },
            |m: &mut ConversionReview| { &mut m.response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConversionReview>(
            "ConversionReview",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConversionReview {
    const NAME: &'static str = "ConversionReview";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.request)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.response)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConversionReview {
        ConversionReview::new()
    }

    fn clear(&mut self) {
        self.request.clear();
        self.response.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConversionReview {
        static instance: ConversionReview = ConversionReview {
            request: ::protobuf::MessageField::none(),
            response: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConversionReview {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConversionReview").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConversionReview {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConversionReview {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceColumnDefinition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CustomResourceColumnDefinition {
    // message fields
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceColumnDefinition.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceColumnDefinition.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceColumnDefinition.format)
    pub format: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceColumnDefinition.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceColumnDefinition.priority)
    pub priority: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceColumnDefinition.JSONPath)
    pub JSONPath: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceColumnDefinition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CustomResourceColumnDefinition {
    fn default() -> &'a CustomResourceColumnDefinition {
        <CustomResourceColumnDefinition as ::protobuf::Message>::default_instance()
    }
}

impl CustomResourceColumnDefinition {
    pub fn new() -> CustomResourceColumnDefinition {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string type = 2;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string format = 3;

    pub fn format(&self) -> &str {
        match self.format.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_format(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: ::std::string::String) {
        self.format = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_format(&mut self) -> &mut ::std::string::String {
        if self.format.is_none() {
            self.format = ::std::option::Option::Some(::std::string::String::new());
        }
        self.format.as_mut().unwrap()
    }

    // Take field
    pub fn take_format(&mut self) -> ::std::string::String {
        self.format.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 4;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 priority = 5;

    pub fn priority(&self) -> i32 {
        self.priority.unwrap_or(0)
    }

    pub fn clear_priority(&mut self) {
        self.priority = ::std::option::Option::None;
    }

    pub fn has_priority(&self) -> bool {
        self.priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: i32) {
        self.priority = ::std::option::Option::Some(v);
    }

    // optional string JSONPath = 6;

    pub fn JSONPath(&self) -> &str {
        match self.JSONPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_JSONPath(&mut self) {
        self.JSONPath = ::std::option::Option::None;
    }

    pub fn has_JSONPath(&self) -> bool {
        self.JSONPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_JSONPath(&mut self, v: ::std::string::String) {
        self.JSONPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_JSONPath(&mut self) -> &mut ::std::string::String {
        if self.JSONPath.is_none() {
            self.JSONPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.JSONPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_JSONPath(&mut self) -> ::std::string::String {
        self.JSONPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CustomResourceColumnDefinition| { &m.name },
            |m: &mut CustomResourceColumnDefinition| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CustomResourceColumnDefinition| { &m.type_ },
            |m: &mut CustomResourceColumnDefinition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "format",
            |m: &CustomResourceColumnDefinition| { &m.format },
            |m: &mut CustomResourceColumnDefinition| { &mut m.format },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &CustomResourceColumnDefinition| { &m.description },
            |m: &mut CustomResourceColumnDefinition| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "priority",
            |m: &CustomResourceColumnDefinition| { &m.priority },
            |m: &mut CustomResourceColumnDefinition| { &mut m.priority },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "JSONPath",
            |m: &CustomResourceColumnDefinition| { &m.JSONPath },
            |m: &mut CustomResourceColumnDefinition| { &mut m.JSONPath },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CustomResourceColumnDefinition>(
            "CustomResourceColumnDefinition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CustomResourceColumnDefinition {
    const NAME: &'static str = "CustomResourceColumnDefinition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.format = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.priority = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    self.JSONPath = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.format.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.priority {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.JSONPath.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.type_.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.format.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.priority {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.JSONPath.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CustomResourceColumnDefinition {
        CustomResourceColumnDefinition::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.format = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.priority = ::std::option::Option::None;
        self.JSONPath = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CustomResourceColumnDefinition {
        static instance: CustomResourceColumnDefinition = CustomResourceColumnDefinition {
            name: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            format: ::std::option::Option::None,
            description: ::std::option::Option::None,
            priority: ::std::option::Option::None,
            JSONPath: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CustomResourceColumnDefinition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CustomResourceColumnDefinition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CustomResourceColumnDefinition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CustomResourceColumnDefinition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceConversion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CustomResourceConversion {
    // message fields
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceConversion.strategy)
    pub strategy: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceConversion.webhookClientConfig)
    pub webhookClientConfig: ::protobuf::MessageField<WebhookClientConfig>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceConversion.conversionReviewVersions)
    pub conversionReviewVersions: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceConversion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CustomResourceConversion {
    fn default() -> &'a CustomResourceConversion {
        <CustomResourceConversion as ::protobuf::Message>::default_instance()
    }
}

impl CustomResourceConversion {
    pub fn new() -> CustomResourceConversion {
        ::std::default::Default::default()
    }

    // optional string strategy = 1;

    pub fn strategy(&self) -> &str {
        match self.strategy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_strategy(&mut self) {
        self.strategy = ::std::option::Option::None;
    }

    pub fn has_strategy(&self) -> bool {
        self.strategy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strategy(&mut self, v: ::std::string::String) {
        self.strategy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_strategy(&mut self) -> &mut ::std::string::String {
        if self.strategy.is_none() {
            self.strategy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.strategy.as_mut().unwrap()
    }

    // Take field
    pub fn take_strategy(&mut self) -> ::std::string::String {
        self.strategy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.WebhookClientConfig webhookClientConfig = 2;

    pub fn webhookClientConfig(&self) -> &WebhookClientConfig {
        self.webhookClientConfig.as_ref().unwrap_or_else(|| <WebhookClientConfig as ::protobuf::Message>::default_instance())
    }

    pub fn clear_webhookClientConfig(&mut self) {
        self.webhookClientConfig.clear();
    }

    pub fn has_webhookClientConfig(&self) -> bool {
        self.webhookClientConfig.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webhookClientConfig(&mut self, v: WebhookClientConfig) {
        self.webhookClientConfig = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_webhookClientConfig(&mut self) -> &mut WebhookClientConfig {
        self.webhookClientConfig.mut_or_insert_default()
    }

    // Take field
    pub fn take_webhookClientConfig(&mut self) -> WebhookClientConfig {
        self.webhookClientConfig.take().unwrap_or_else(|| WebhookClientConfig::new())
    }

    // repeated string conversionReviewVersions = 3;

    pub fn conversionReviewVersions(&self) -> &[::std::string::String] {
        &self.conversionReviewVersions
    }

    pub fn clear_conversionReviewVersions(&mut self) {
        self.conversionReviewVersions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conversionReviewVersions(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.conversionReviewVersions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conversionReviewVersions(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.conversionReviewVersions
    }

    // Take field
    pub fn take_conversionReviewVersions(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.conversionReviewVersions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "strategy",
            |m: &CustomResourceConversion| { &m.strategy },
            |m: &mut CustomResourceConversion| { &mut m.strategy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WebhookClientConfig>(
            "webhookClientConfig",
            |m: &CustomResourceConversion| { &m.webhookClientConfig },
            |m: &mut CustomResourceConversion| { &mut m.webhookClientConfig },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conversionReviewVersions",
            |m: &CustomResourceConversion| { &m.conversionReviewVersions },
            |m: &mut CustomResourceConversion| { &mut m.conversionReviewVersions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CustomResourceConversion>(
            "CustomResourceConversion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CustomResourceConversion {
    const NAME: &'static str = "CustomResourceConversion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.strategy = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.webhookClientConfig)?;
                },
                26 => {
                    self.conversionReviewVersions.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.strategy.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.webhookClientConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.conversionReviewVersions {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.strategy.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.webhookClientConfig.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.conversionReviewVersions {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CustomResourceConversion {
        CustomResourceConversion::new()
    }

    fn clear(&mut self) {
        self.strategy = ::std::option::Option::None;
        self.webhookClientConfig.clear();
        self.conversionReviewVersions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CustomResourceConversion {
        static instance: CustomResourceConversion = CustomResourceConversion {
            strategy: ::std::option::Option::None,
            webhookClientConfig: ::protobuf::MessageField::none(),
            conversionReviewVersions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CustomResourceConversion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CustomResourceConversion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CustomResourceConversion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CustomResourceConversion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CustomResourceDefinition {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinition.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinition.spec)
    pub spec: ::protobuf::MessageField<CustomResourceDefinitionSpec>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinition.status)
    pub status: ::protobuf::MessageField<CustomResourceDefinitionStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CustomResourceDefinition {
    fn default() -> &'a CustomResourceDefinition {
        <CustomResourceDefinition as ::protobuf::Message>::default_instance()
    }
}

impl CustomResourceDefinition {
    pub fn new() -> CustomResourceDefinition {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionSpec spec = 2;

    pub fn spec(&self) -> &CustomResourceDefinitionSpec {
        self.spec.as_ref().unwrap_or_else(|| <CustomResourceDefinitionSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: CustomResourceDefinitionSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut CustomResourceDefinitionSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> CustomResourceDefinitionSpec {
        self.spec.take().unwrap_or_else(|| CustomResourceDefinitionSpec::new())
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionStatus status = 3;

    pub fn status(&self) -> &CustomResourceDefinitionStatus {
        self.status.as_ref().unwrap_or_else(|| <CustomResourceDefinitionStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: CustomResourceDefinitionStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut CustomResourceDefinitionStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> CustomResourceDefinitionStatus {
        self.status.take().unwrap_or_else(|| CustomResourceDefinitionStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &CustomResourceDefinition| { &m.metadata },
            |m: &mut CustomResourceDefinition| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CustomResourceDefinitionSpec>(
            "spec",
            |m: &CustomResourceDefinition| { &m.spec },
            |m: &mut CustomResourceDefinition| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CustomResourceDefinitionStatus>(
            "status",
            |m: &CustomResourceDefinition| { &m.status },
            |m: &mut CustomResourceDefinition| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CustomResourceDefinition>(
            "CustomResourceDefinition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CustomResourceDefinition {
    const NAME: &'static str = "CustomResourceDefinition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CustomResourceDefinition {
        CustomResourceDefinition::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CustomResourceDefinition {
        static instance: CustomResourceDefinition = CustomResourceDefinition {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CustomResourceDefinition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CustomResourceDefinition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CustomResourceDefinition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CustomResourceDefinition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CustomResourceDefinitionCondition {
    // message fields
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionCondition.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionCondition.status)
    pub status: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::custom_date")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionCondition.lastTransitionTime)
    pub lastTransitionTime: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionCondition.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionCondition.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CustomResourceDefinitionCondition {
    fn default() -> &'a CustomResourceDefinitionCondition {
        <CustomResourceDefinitionCondition as ::protobuf::Message>::default_instance()
    }
}

impl CustomResourceDefinitionCondition {
    pub fn new() -> CustomResourceDefinitionCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

    pub fn lastTransitionTime(&self) -> &crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastTransitionTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional string reason = 4;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 5;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CustomResourceDefinitionCondition| { &m.type_ },
            |m: &mut CustomResourceDefinitionCondition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &CustomResourceDefinitionCondition| { &m.status },
            |m: &mut CustomResourceDefinitionCondition| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::Time>(
            "lastTransitionTime",
            |m: &CustomResourceDefinitionCondition| { &m.lastTransitionTime },
            |m: &mut CustomResourceDefinitionCondition| { &mut m.lastTransitionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &CustomResourceDefinitionCondition| { &m.reason },
            |m: &mut CustomResourceDefinitionCondition| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CustomResourceDefinitionCondition| { &m.message },
            |m: &mut CustomResourceDefinitionCondition| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CustomResourceDefinitionCondition>(
            "CustomResourceDefinitionCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CustomResourceDefinitionCondition {
    const NAME: &'static str = "CustomResourceDefinitionCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTransitionTime)?;
                },
                34 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CustomResourceDefinitionCondition {
        CustomResourceDefinitionCondition::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.lastTransitionTime.clear();
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CustomResourceDefinitionCondition {
        static instance: CustomResourceDefinitionCondition = CustomResourceDefinitionCondition {
            type_: ::std::option::Option::None,
            status: ::std::option::Option::None,
            lastTransitionTime: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CustomResourceDefinitionCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CustomResourceDefinitionCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CustomResourceDefinitionCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CustomResourceDefinitionCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CustomResourceDefinitionList {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionList.metadata)
    pub metadata: ::protobuf::MessageField<crate::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionList.items)
    pub items: ::std::vec::Vec<CustomResourceDefinition>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CustomResourceDefinitionList {
    fn default() -> &'a CustomResourceDefinitionList {
        <CustomResourceDefinitionList as ::protobuf::Message>::default_instance()
    }
}

impl CustomResourceDefinitionList {
    pub fn new() -> CustomResourceDefinitionList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinition items = 2;

    pub fn items(&self) -> &[CustomResourceDefinition] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<CustomResourceDefinition>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<CustomResourceDefinition> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<CustomResourceDefinition> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &CustomResourceDefinitionList| { &m.metadata },
            |m: &mut CustomResourceDefinitionList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &CustomResourceDefinitionList| { &m.items },
            |m: &mut CustomResourceDefinitionList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CustomResourceDefinitionList>(
            "CustomResourceDefinitionList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CustomResourceDefinitionList {
    const NAME: &'static str = "CustomResourceDefinitionList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CustomResourceDefinitionList {
        CustomResourceDefinitionList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CustomResourceDefinitionList {
        static instance: CustomResourceDefinitionList = CustomResourceDefinitionList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CustomResourceDefinitionList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CustomResourceDefinitionList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CustomResourceDefinitionList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CustomResourceDefinitionList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionNames)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CustomResourceDefinitionNames {
    // message fields
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionNames.plural)
    pub plural: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionNames.singular)
    pub singular: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionNames.shortNames)
    pub shortNames: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionNames.kind)
    pub kind: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionNames.listKind)
    pub listKind: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionNames.categories)
    pub categories: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionNames.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CustomResourceDefinitionNames {
    fn default() -> &'a CustomResourceDefinitionNames {
        <CustomResourceDefinitionNames as ::protobuf::Message>::default_instance()
    }
}

impl CustomResourceDefinitionNames {
    pub fn new() -> CustomResourceDefinitionNames {
        ::std::default::Default::default()
    }

    // optional string plural = 1;

    pub fn plural(&self) -> &str {
        match self.plural.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_plural(&mut self) {
        self.plural = ::std::option::Option::None;
    }

    pub fn has_plural(&self) -> bool {
        self.plural.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plural(&mut self, v: ::std::string::String) {
        self.plural = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_plural(&mut self) -> &mut ::std::string::String {
        if self.plural.is_none() {
            self.plural = ::std::option::Option::Some(::std::string::String::new());
        }
        self.plural.as_mut().unwrap()
    }

    // Take field
    pub fn take_plural(&mut self) -> ::std::string::String {
        self.plural.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string singular = 2;

    pub fn singular(&self) -> &str {
        match self.singular.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_singular(&mut self) {
        self.singular = ::std::option::Option::None;
    }

    pub fn has_singular(&self) -> bool {
        self.singular.is_some()
    }

    // Param is passed by value, moved
    pub fn set_singular(&mut self, v: ::std::string::String) {
        self.singular = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_singular(&mut self) -> &mut ::std::string::String {
        if self.singular.is_none() {
            self.singular = ::std::option::Option::Some(::std::string::String::new());
        }
        self.singular.as_mut().unwrap()
    }

    // Take field
    pub fn take_singular(&mut self) -> ::std::string::String {
        self.singular.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string shortNames = 3;

    pub fn shortNames(&self) -> &[::std::string::String] {
        &self.shortNames
    }

    pub fn clear_shortNames(&mut self) {
        self.shortNames.clear();
    }

    // Param is passed by value, moved
    pub fn set_shortNames(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.shortNames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_shortNames(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.shortNames
    }

    // Take field
    pub fn take_shortNames(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.shortNames, ::std::vec::Vec::new())
    }

    // optional string kind = 4;

    pub fn kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string listKind = 5;

    pub fn listKind(&self) -> &str {
        match self.listKind.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_listKind(&mut self) {
        self.listKind = ::std::option::Option::None;
    }

    pub fn has_listKind(&self) -> bool {
        self.listKind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_listKind(&mut self, v: ::std::string::String) {
        self.listKind = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_listKind(&mut self) -> &mut ::std::string::String {
        if self.listKind.is_none() {
            self.listKind = ::std::option::Option::Some(::std::string::String::new());
        }
        self.listKind.as_mut().unwrap()
    }

    // Take field
    pub fn take_listKind(&mut self) -> ::std::string::String {
        self.listKind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string categories = 6;

    pub fn categories(&self) -> &[::std::string::String] {
        &self.categories
    }

    pub fn clear_categories(&mut self) {
        self.categories.clear();
    }

    // Param is passed by value, moved
    pub fn set_categories(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.categories = v;
    }

    // Mutable pointer to the field.
    pub fn mut_categories(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.categories
    }

    // Take field
    pub fn take_categories(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.categories, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "plural",
            |m: &CustomResourceDefinitionNames| { &m.plural },
            |m: &mut CustomResourceDefinitionNames| { &mut m.plural },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "singular",
            |m: &CustomResourceDefinitionNames| { &m.singular },
            |m: &mut CustomResourceDefinitionNames| { &mut m.singular },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "shortNames",
            |m: &CustomResourceDefinitionNames| { &m.shortNames },
            |m: &mut CustomResourceDefinitionNames| { &mut m.shortNames },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &CustomResourceDefinitionNames| { &m.kind },
            |m: &mut CustomResourceDefinitionNames| { &mut m.kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "listKind",
            |m: &CustomResourceDefinitionNames| { &m.listKind },
            |m: &mut CustomResourceDefinitionNames| { &mut m.listKind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "categories",
            |m: &CustomResourceDefinitionNames| { &m.categories },
            |m: &mut CustomResourceDefinitionNames| { &mut m.categories },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CustomResourceDefinitionNames>(
            "CustomResourceDefinitionNames",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CustomResourceDefinitionNames {
    const NAME: &'static str = "CustomResourceDefinitionNames";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.plural = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.singular = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.shortNames.push(is.read_string()?);
                },
                34 => {
                    self.kind = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.listKind = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.categories.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.plural.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.singular.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.shortNames {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.listKind.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.categories {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.plural.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.singular.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.shortNames {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.kind.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.listKind.as_ref() {
            os.write_string(5, v)?;
        }
        for v in &self.categories {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CustomResourceDefinitionNames {
        CustomResourceDefinitionNames::new()
    }

    fn clear(&mut self) {
        self.plural = ::std::option::Option::None;
        self.singular = ::std::option::Option::None;
        self.shortNames.clear();
        self.kind = ::std::option::Option::None;
        self.listKind = ::std::option::Option::None;
        self.categories.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CustomResourceDefinitionNames {
        static instance: CustomResourceDefinitionNames = CustomResourceDefinitionNames {
            plural: ::std::option::Option::None,
            singular: ::std::option::Option::None,
            shortNames: ::std::vec::Vec::new(),
            kind: ::std::option::Option::None,
            listKind: ::std::option::Option::None,
            categories: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CustomResourceDefinitionNames {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CustomResourceDefinitionNames").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CustomResourceDefinitionNames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CustomResourceDefinitionNames {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CustomResourceDefinitionSpec {
    // message fields
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionSpec.group)
    pub group: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionSpec.version)
    pub version: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionSpec.names)
    pub names: ::protobuf::MessageField<CustomResourceDefinitionNames>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionSpec.scope)
    pub scope: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionSpec.validation)
    pub validation: ::protobuf::MessageField<CustomResourceValidation>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionSpec.subresources)
    pub subresources: ::protobuf::MessageField<CustomResourceSubresources>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionSpec.versions)
    pub versions: ::std::vec::Vec<CustomResourceDefinitionVersion>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionSpec.additionalPrinterColumns)
    pub additionalPrinterColumns: ::std::vec::Vec<CustomResourceColumnDefinition>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionSpec.selectableFields)
    pub selectableFields: ::std::vec::Vec<SelectableField>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionSpec.conversion)
    pub conversion: ::protobuf::MessageField<CustomResourceConversion>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionSpec.preserveUnknownFields)
    pub preserveUnknownFields: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CustomResourceDefinitionSpec {
    fn default() -> &'a CustomResourceDefinitionSpec {
        <CustomResourceDefinitionSpec as ::protobuf::Message>::default_instance()
    }
}

impl CustomResourceDefinitionSpec {
    pub fn new() -> CustomResourceDefinitionSpec {
        ::std::default::Default::default()
    }

    // optional string group = 1;

    pub fn group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_group(&mut self) {
        self.group = ::std::option::Option::None;
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group = ::std::option::Option::Some(::std::string::String::new());
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 2;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionNames names = 3;

    pub fn names(&self) -> &CustomResourceDefinitionNames {
        self.names.as_ref().unwrap_or_else(|| <CustomResourceDefinitionNames as ::protobuf::Message>::default_instance())
    }

    pub fn clear_names(&mut self) {
        self.names.clear();
    }

    pub fn has_names(&self) -> bool {
        self.names.is_some()
    }

    // Param is passed by value, moved
    pub fn set_names(&mut self, v: CustomResourceDefinitionNames) {
        self.names = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_names(&mut self) -> &mut CustomResourceDefinitionNames {
        self.names.mut_or_insert_default()
    }

    // Take field
    pub fn take_names(&mut self) -> CustomResourceDefinitionNames {
        self.names.take().unwrap_or_else(|| CustomResourceDefinitionNames::new())
    }

    // optional string scope = 4;

    pub fn scope(&self) -> &str {
        match self.scope.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_scope(&mut self) {
        self.scope = ::std::option::Option::None;
    }

    pub fn has_scope(&self) -> bool {
        self.scope.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: ::std::string::String) {
        self.scope = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scope(&mut self) -> &mut ::std::string::String {
        if self.scope.is_none() {
            self.scope = ::std::option::Option::Some(::std::string::String::new());
        }
        self.scope.as_mut().unwrap()
    }

    // Take field
    pub fn take_scope(&mut self) -> ::std::string::String {
        self.scope.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceValidation validation = 5;

    pub fn validation(&self) -> &CustomResourceValidation {
        self.validation.as_ref().unwrap_or_else(|| <CustomResourceValidation as ::protobuf::Message>::default_instance())
    }

    pub fn clear_validation(&mut self) {
        self.validation.clear();
    }

    pub fn has_validation(&self) -> bool {
        self.validation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_validation(&mut self, v: CustomResourceValidation) {
        self.validation = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validation(&mut self) -> &mut CustomResourceValidation {
        self.validation.mut_or_insert_default()
    }

    // Take field
    pub fn take_validation(&mut self) -> CustomResourceValidation {
        self.validation.take().unwrap_or_else(|| CustomResourceValidation::new())
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceSubresources subresources = 6;

    pub fn subresources(&self) -> &CustomResourceSubresources {
        self.subresources.as_ref().unwrap_or_else(|| <CustomResourceSubresources as ::protobuf::Message>::default_instance())
    }

    pub fn clear_subresources(&mut self) {
        self.subresources.clear();
    }

    pub fn has_subresources(&self) -> bool {
        self.subresources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subresources(&mut self, v: CustomResourceSubresources) {
        self.subresources = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subresources(&mut self) -> &mut CustomResourceSubresources {
        self.subresources.mut_or_insert_default()
    }

    // Take field
    pub fn take_subresources(&mut self) -> CustomResourceSubresources {
        self.subresources.take().unwrap_or_else(|| CustomResourceSubresources::new())
    }

    // repeated .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionVersion versions = 7;

    pub fn versions(&self) -> &[CustomResourceDefinitionVersion] {
        &self.versions
    }

    pub fn clear_versions(&mut self) {
        self.versions.clear();
    }

    // Param is passed by value, moved
    pub fn set_versions(&mut self, v: ::std::vec::Vec<CustomResourceDefinitionVersion>) {
        self.versions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_versions(&mut self) -> &mut ::std::vec::Vec<CustomResourceDefinitionVersion> {
        &mut self.versions
    }

    // Take field
    pub fn take_versions(&mut self) -> ::std::vec::Vec<CustomResourceDefinitionVersion> {
        ::std::mem::replace(&mut self.versions, ::std::vec::Vec::new())
    }

    // repeated .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceColumnDefinition additionalPrinterColumns = 8;

    pub fn additionalPrinterColumns(&self) -> &[CustomResourceColumnDefinition] {
        &self.additionalPrinterColumns
    }

    pub fn clear_additionalPrinterColumns(&mut self) {
        self.additionalPrinterColumns.clear();
    }

    // Param is passed by value, moved
    pub fn set_additionalPrinterColumns(&mut self, v: ::std::vec::Vec<CustomResourceColumnDefinition>) {
        self.additionalPrinterColumns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_additionalPrinterColumns(&mut self) -> &mut ::std::vec::Vec<CustomResourceColumnDefinition> {
        &mut self.additionalPrinterColumns
    }

    // Take field
    pub fn take_additionalPrinterColumns(&mut self) -> ::std::vec::Vec<CustomResourceColumnDefinition> {
        ::std::mem::replace(&mut self.additionalPrinterColumns, ::std::vec::Vec::new())
    }

    // repeated .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.SelectableField selectableFields = 11;

    pub fn selectableFields(&self) -> &[SelectableField] {
        &self.selectableFields
    }

    pub fn clear_selectableFields(&mut self) {
        self.selectableFields.clear();
    }

    // Param is passed by value, moved
    pub fn set_selectableFields(&mut self, v: ::std::vec::Vec<SelectableField>) {
        self.selectableFields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_selectableFields(&mut self) -> &mut ::std::vec::Vec<SelectableField> {
        &mut self.selectableFields
    }

    // Take field
    pub fn take_selectableFields(&mut self) -> ::std::vec::Vec<SelectableField> {
        ::std::mem::replace(&mut self.selectableFields, ::std::vec::Vec::new())
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceConversion conversion = 9;

    pub fn conversion(&self) -> &CustomResourceConversion {
        self.conversion.as_ref().unwrap_or_else(|| <CustomResourceConversion as ::protobuf::Message>::default_instance())
    }

    pub fn clear_conversion(&mut self) {
        self.conversion.clear();
    }

    pub fn has_conversion(&self) -> bool {
        self.conversion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conversion(&mut self, v: CustomResourceConversion) {
        self.conversion = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conversion(&mut self) -> &mut CustomResourceConversion {
        self.conversion.mut_or_insert_default()
    }

    // Take field
    pub fn take_conversion(&mut self) -> CustomResourceConversion {
        self.conversion.take().unwrap_or_else(|| CustomResourceConversion::new())
    }

    // optional bool preserveUnknownFields = 10;

    pub fn preserveUnknownFields(&self) -> bool {
        self.preserveUnknownFields.unwrap_or(false)
    }

    pub fn clear_preserveUnknownFields(&mut self) {
        self.preserveUnknownFields = ::std::option::Option::None;
    }

    pub fn has_preserveUnknownFields(&self) -> bool {
        self.preserveUnknownFields.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preserveUnknownFields(&mut self, v: bool) {
        self.preserveUnknownFields = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "group",
            |m: &CustomResourceDefinitionSpec| { &m.group },
            |m: &mut CustomResourceDefinitionSpec| { &mut m.group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CustomResourceDefinitionSpec| { &m.version },
            |m: &mut CustomResourceDefinitionSpec| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CustomResourceDefinitionNames>(
            "names",
            |m: &CustomResourceDefinitionSpec| { &m.names },
            |m: &mut CustomResourceDefinitionSpec| { &mut m.names },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scope",
            |m: &CustomResourceDefinitionSpec| { &m.scope },
            |m: &mut CustomResourceDefinitionSpec| { &mut m.scope },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CustomResourceValidation>(
            "validation",
            |m: &CustomResourceDefinitionSpec| { &m.validation },
            |m: &mut CustomResourceDefinitionSpec| { &mut m.validation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CustomResourceSubresources>(
            "subresources",
            |m: &CustomResourceDefinitionSpec| { &m.subresources },
            |m: &mut CustomResourceDefinitionSpec| { &mut m.subresources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "versions",
            |m: &CustomResourceDefinitionSpec| { &m.versions },
            |m: &mut CustomResourceDefinitionSpec| { &mut m.versions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additionalPrinterColumns",
            |m: &CustomResourceDefinitionSpec| { &m.additionalPrinterColumns },
            |m: &mut CustomResourceDefinitionSpec| { &mut m.additionalPrinterColumns },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "selectableFields",
            |m: &CustomResourceDefinitionSpec| { &m.selectableFields },
            |m: &mut CustomResourceDefinitionSpec| { &mut m.selectableFields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CustomResourceConversion>(
            "conversion",
            |m: &CustomResourceDefinitionSpec| { &m.conversion },
            |m: &mut CustomResourceDefinitionSpec| { &mut m.conversion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "preserveUnknownFields",
            |m: &CustomResourceDefinitionSpec| { &m.preserveUnknownFields },
            |m: &mut CustomResourceDefinitionSpec| { &mut m.preserveUnknownFields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CustomResourceDefinitionSpec>(
            "CustomResourceDefinitionSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CustomResourceDefinitionSpec {
    const NAME: &'static str = "CustomResourceDefinitionSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.group = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.names)?;
                },
                34 => {
                    self.scope = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.validation)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.subresources)?;
                },
                58 => {
                    self.versions.push(is.read_message()?);
                },
                66 => {
                    self.additionalPrinterColumns.push(is.read_message()?);
                },
                90 => {
                    self.selectableFields.push(is.read_message()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.conversion)?;
                },
                80 => {
                    self.preserveUnknownFields = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.names.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scope.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.validation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.subresources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.additionalPrinterColumns {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.selectableFields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.conversion.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.preserveUnknownFields {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.group.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.names.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.scope.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.validation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.subresources.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.versions {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        for v in &self.additionalPrinterColumns {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        for v in &self.selectableFields {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if let Some(v) = self.conversion.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.preserveUnknownFields {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CustomResourceDefinitionSpec {
        CustomResourceDefinitionSpec::new()
    }

    fn clear(&mut self) {
        self.group = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.names.clear();
        self.scope = ::std::option::Option::None;
        self.validation.clear();
        self.subresources.clear();
        self.versions.clear();
        self.additionalPrinterColumns.clear();
        self.selectableFields.clear();
        self.conversion.clear();
        self.preserveUnknownFields = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CustomResourceDefinitionSpec {
        static instance: CustomResourceDefinitionSpec = CustomResourceDefinitionSpec {
            group: ::std::option::Option::None,
            version: ::std::option::Option::None,
            names: ::protobuf::MessageField::none(),
            scope: ::std::option::Option::None,
            validation: ::protobuf::MessageField::none(),
            subresources: ::protobuf::MessageField::none(),
            versions: ::std::vec::Vec::new(),
            additionalPrinterColumns: ::std::vec::Vec::new(),
            selectableFields: ::std::vec::Vec::new(),
            conversion: ::protobuf::MessageField::none(),
            preserveUnknownFields: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CustomResourceDefinitionSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CustomResourceDefinitionSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CustomResourceDefinitionSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CustomResourceDefinitionSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CustomResourceDefinitionStatus {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionStatus.conditions)
    pub conditions: ::std::vec::Vec<CustomResourceDefinitionCondition>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionStatus.acceptedNames)
    pub acceptedNames: ::protobuf::MessageField<CustomResourceDefinitionNames>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionStatus.storedVersions)
    pub storedVersions: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CustomResourceDefinitionStatus {
    fn default() -> &'a CustomResourceDefinitionStatus {
        <CustomResourceDefinitionStatus as ::protobuf::Message>::default_instance()
    }
}

impl CustomResourceDefinitionStatus {
    pub fn new() -> CustomResourceDefinitionStatus {
        ::std::default::Default::default()
    }

    // repeated .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionCondition conditions = 1;

    pub fn conditions(&self) -> &[CustomResourceDefinitionCondition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<CustomResourceDefinitionCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<CustomResourceDefinitionCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<CustomResourceDefinitionCondition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionNames acceptedNames = 2;

    pub fn acceptedNames(&self) -> &CustomResourceDefinitionNames {
        self.acceptedNames.as_ref().unwrap_or_else(|| <CustomResourceDefinitionNames as ::protobuf::Message>::default_instance())
    }

    pub fn clear_acceptedNames(&mut self) {
        self.acceptedNames.clear();
    }

    pub fn has_acceptedNames(&self) -> bool {
        self.acceptedNames.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acceptedNames(&mut self, v: CustomResourceDefinitionNames) {
        self.acceptedNames = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_acceptedNames(&mut self) -> &mut CustomResourceDefinitionNames {
        self.acceptedNames.mut_or_insert_default()
    }

    // Take field
    pub fn take_acceptedNames(&mut self) -> CustomResourceDefinitionNames {
        self.acceptedNames.take().unwrap_or_else(|| CustomResourceDefinitionNames::new())
    }

    // repeated string storedVersions = 3;

    pub fn storedVersions(&self) -> &[::std::string::String] {
        &self.storedVersions
    }

    pub fn clear_storedVersions(&mut self) {
        self.storedVersions.clear();
    }

    // Param is passed by value, moved
    pub fn set_storedVersions(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.storedVersions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storedVersions(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.storedVersions
    }

    // Take field
    pub fn take_storedVersions(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.storedVersions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &CustomResourceDefinitionStatus| { &m.conditions },
            |m: &mut CustomResourceDefinitionStatus| { &mut m.conditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CustomResourceDefinitionNames>(
            "acceptedNames",
            |m: &CustomResourceDefinitionStatus| { &m.acceptedNames },
            |m: &mut CustomResourceDefinitionStatus| { &mut m.acceptedNames },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "storedVersions",
            |m: &CustomResourceDefinitionStatus| { &m.storedVersions },
            |m: &mut CustomResourceDefinitionStatus| { &mut m.storedVersions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CustomResourceDefinitionStatus>(
            "CustomResourceDefinitionStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CustomResourceDefinitionStatus {
    const NAME: &'static str = "CustomResourceDefinitionStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.conditions.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.acceptedNames)?;
                },
                26 => {
                    self.storedVersions.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.acceptedNames.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.storedVersions {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.acceptedNames.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.storedVersions {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CustomResourceDefinitionStatus {
        CustomResourceDefinitionStatus::new()
    }

    fn clear(&mut self) {
        self.conditions.clear();
        self.acceptedNames.clear();
        self.storedVersions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CustomResourceDefinitionStatus {
        static instance: CustomResourceDefinitionStatus = CustomResourceDefinitionStatus {
            conditions: ::std::vec::Vec::new(),
            acceptedNames: ::protobuf::MessageField::none(),
            storedVersions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CustomResourceDefinitionStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CustomResourceDefinitionStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CustomResourceDefinitionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CustomResourceDefinitionStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionVersion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CustomResourceDefinitionVersion {
    // message fields
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionVersion.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionVersion.served)
    pub served: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionVersion.storage)
    pub storage: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionVersion.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionVersion.deprecationWarning)
    pub deprecationWarning: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionVersion.schema)
    pub schema: ::protobuf::MessageField<CustomResourceValidation>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionVersion.subresources)
    pub subresources: ::protobuf::MessageField<CustomResourceSubresources>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionVersion.additionalPrinterColumns)
    pub additionalPrinterColumns: ::std::vec::Vec<CustomResourceColumnDefinition>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionVersion.selectableFields)
    pub selectableFields: ::std::vec::Vec<SelectableField>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionVersion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CustomResourceDefinitionVersion {
    fn default() -> &'a CustomResourceDefinitionVersion {
        <CustomResourceDefinitionVersion as ::protobuf::Message>::default_instance()
    }
}

impl CustomResourceDefinitionVersion {
    pub fn new() -> CustomResourceDefinitionVersion {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool served = 2;

    pub fn served(&self) -> bool {
        self.served.unwrap_or(false)
    }

    pub fn clear_served(&mut self) {
        self.served = ::std::option::Option::None;
    }

    pub fn has_served(&self) -> bool {
        self.served.is_some()
    }

    // Param is passed by value, moved
    pub fn set_served(&mut self, v: bool) {
        self.served = ::std::option::Option::Some(v);
    }

    // optional bool storage = 3;

    pub fn storage(&self) -> bool {
        self.storage.unwrap_or(false)
    }

    pub fn clear_storage(&mut self) {
        self.storage = ::std::option::Option::None;
    }

    pub fn has_storage(&self) -> bool {
        self.storage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storage(&mut self, v: bool) {
        self.storage = ::std::option::Option::Some(v);
    }

    // optional bool deprecated = 7;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    // optional string deprecationWarning = 8;

    pub fn deprecationWarning(&self) -> &str {
        match self.deprecationWarning.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_deprecationWarning(&mut self) {
        self.deprecationWarning = ::std::option::Option::None;
    }

    pub fn has_deprecationWarning(&self) -> bool {
        self.deprecationWarning.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecationWarning(&mut self, v: ::std::string::String) {
        self.deprecationWarning = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deprecationWarning(&mut self) -> &mut ::std::string::String {
        if self.deprecationWarning.is_none() {
            self.deprecationWarning = ::std::option::Option::Some(::std::string::String::new());
        }
        self.deprecationWarning.as_mut().unwrap()
    }

    // Take field
    pub fn take_deprecationWarning(&mut self) -> ::std::string::String {
        self.deprecationWarning.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceValidation schema = 4;

    pub fn schema(&self) -> &CustomResourceValidation {
        self.schema.as_ref().unwrap_or_else(|| <CustomResourceValidation as ::protobuf::Message>::default_instance())
    }

    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    pub fn has_schema(&self) -> bool {
        self.schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: CustomResourceValidation) {
        self.schema = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut CustomResourceValidation {
        self.schema.mut_or_insert_default()
    }

    // Take field
    pub fn take_schema(&mut self) -> CustomResourceValidation {
        self.schema.take().unwrap_or_else(|| CustomResourceValidation::new())
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceSubresources subresources = 5;

    pub fn subresources(&self) -> &CustomResourceSubresources {
        self.subresources.as_ref().unwrap_or_else(|| <CustomResourceSubresources as ::protobuf::Message>::default_instance())
    }

    pub fn clear_subresources(&mut self) {
        self.subresources.clear();
    }

    pub fn has_subresources(&self) -> bool {
        self.subresources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subresources(&mut self, v: CustomResourceSubresources) {
        self.subresources = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subresources(&mut self) -> &mut CustomResourceSubresources {
        self.subresources.mut_or_insert_default()
    }

    // Take field
    pub fn take_subresources(&mut self) -> CustomResourceSubresources {
        self.subresources.take().unwrap_or_else(|| CustomResourceSubresources::new())
    }

    // repeated .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceColumnDefinition additionalPrinterColumns = 6;

    pub fn additionalPrinterColumns(&self) -> &[CustomResourceColumnDefinition] {
        &self.additionalPrinterColumns
    }

    pub fn clear_additionalPrinterColumns(&mut self) {
        self.additionalPrinterColumns.clear();
    }

    // Param is passed by value, moved
    pub fn set_additionalPrinterColumns(&mut self, v: ::std::vec::Vec<CustomResourceColumnDefinition>) {
        self.additionalPrinterColumns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_additionalPrinterColumns(&mut self) -> &mut ::std::vec::Vec<CustomResourceColumnDefinition> {
        &mut self.additionalPrinterColumns
    }

    // Take field
    pub fn take_additionalPrinterColumns(&mut self) -> ::std::vec::Vec<CustomResourceColumnDefinition> {
        ::std::mem::replace(&mut self.additionalPrinterColumns, ::std::vec::Vec::new())
    }

    // repeated .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.SelectableField selectableFields = 9;

    pub fn selectableFields(&self) -> &[SelectableField] {
        &self.selectableFields
    }

    pub fn clear_selectableFields(&mut self) {
        self.selectableFields.clear();
    }

    // Param is passed by value, moved
    pub fn set_selectableFields(&mut self, v: ::std::vec::Vec<SelectableField>) {
        self.selectableFields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_selectableFields(&mut self) -> &mut ::std::vec::Vec<SelectableField> {
        &mut self.selectableFields
    }

    // Take field
    pub fn take_selectableFields(&mut self) -> ::std::vec::Vec<SelectableField> {
        ::std::mem::replace(&mut self.selectableFields, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CustomResourceDefinitionVersion| { &m.name },
            |m: &mut CustomResourceDefinitionVersion| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "served",
            |m: &CustomResourceDefinitionVersion| { &m.served },
            |m: &mut CustomResourceDefinitionVersion| { &mut m.served },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "storage",
            |m: &CustomResourceDefinitionVersion| { &m.storage },
            |m: &mut CustomResourceDefinitionVersion| { &mut m.storage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated",
            |m: &CustomResourceDefinitionVersion| { &m.deprecated },
            |m: &mut CustomResourceDefinitionVersion| { &mut m.deprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecationWarning",
            |m: &CustomResourceDefinitionVersion| { &m.deprecationWarning },
            |m: &mut CustomResourceDefinitionVersion| { &mut m.deprecationWarning },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CustomResourceValidation>(
            "schema",
            |m: &CustomResourceDefinitionVersion| { &m.schema },
            |m: &mut CustomResourceDefinitionVersion| { &mut m.schema },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CustomResourceSubresources>(
            "subresources",
            |m: &CustomResourceDefinitionVersion| { &m.subresources },
            |m: &mut CustomResourceDefinitionVersion| { &mut m.subresources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additionalPrinterColumns",
            |m: &CustomResourceDefinitionVersion| { &m.additionalPrinterColumns },
            |m: &mut CustomResourceDefinitionVersion| { &mut m.additionalPrinterColumns },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "selectableFields",
            |m: &CustomResourceDefinitionVersion| { &m.selectableFields },
            |m: &mut CustomResourceDefinitionVersion| { &mut m.selectableFields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CustomResourceDefinitionVersion>(
            "CustomResourceDefinitionVersion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CustomResourceDefinitionVersion {
    const NAME: &'static str = "CustomResourceDefinitionVersion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.served = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.storage = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                66 => {
                    self.deprecationWarning = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.schema)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.subresources)?;
                },
                50 => {
                    self.additionalPrinterColumns.push(is.read_message()?);
                },
                74 => {
                    self.selectableFields.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.served {
            my_size += 1 + 1;
        }
        if let Some(v) = self.storage {
            my_size += 1 + 1;
        }
        if let Some(v) = self.deprecated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.deprecationWarning.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.schema.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.subresources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.additionalPrinterColumns {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.selectableFields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.served {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.storage {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.deprecated {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.deprecationWarning.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.schema.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.subresources.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        for v in &self.additionalPrinterColumns {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.selectableFields {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CustomResourceDefinitionVersion {
        CustomResourceDefinitionVersion::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.served = ::std::option::Option::None;
        self.storage = ::std::option::Option::None;
        self.deprecated = ::std::option::Option::None;
        self.deprecationWarning = ::std::option::Option::None;
        self.schema.clear();
        self.subresources.clear();
        self.additionalPrinterColumns.clear();
        self.selectableFields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CustomResourceDefinitionVersion {
        static instance: CustomResourceDefinitionVersion = CustomResourceDefinitionVersion {
            name: ::std::option::Option::None,
            served: ::std::option::Option::None,
            storage: ::std::option::Option::None,
            deprecated: ::std::option::Option::None,
            deprecationWarning: ::std::option::Option::None,
            schema: ::protobuf::MessageField::none(),
            subresources: ::protobuf::MessageField::none(),
            additionalPrinterColumns: ::std::vec::Vec::new(),
            selectableFields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CustomResourceDefinitionVersion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CustomResourceDefinitionVersion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CustomResourceDefinitionVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CustomResourceDefinitionVersion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceSubresourceScale)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CustomResourceSubresourceScale {
    // message fields
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceSubresourceScale.specReplicasPath)
    pub specReplicasPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceSubresourceScale.statusReplicasPath)
    pub statusReplicasPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceSubresourceScale.labelSelectorPath)
    pub labelSelectorPath: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceSubresourceScale.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CustomResourceSubresourceScale {
    fn default() -> &'a CustomResourceSubresourceScale {
        <CustomResourceSubresourceScale as ::protobuf::Message>::default_instance()
    }
}

impl CustomResourceSubresourceScale {
    pub fn new() -> CustomResourceSubresourceScale {
        ::std::default::Default::default()
    }

    // optional string specReplicasPath = 1;

    pub fn specReplicasPath(&self) -> &str {
        match self.specReplicasPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_specReplicasPath(&mut self) {
        self.specReplicasPath = ::std::option::Option::None;
    }

    pub fn has_specReplicasPath(&self) -> bool {
        self.specReplicasPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_specReplicasPath(&mut self, v: ::std::string::String) {
        self.specReplicasPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_specReplicasPath(&mut self) -> &mut ::std::string::String {
        if self.specReplicasPath.is_none() {
            self.specReplicasPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.specReplicasPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_specReplicasPath(&mut self) -> ::std::string::String {
        self.specReplicasPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string statusReplicasPath = 2;

    pub fn statusReplicasPath(&self) -> &str {
        match self.statusReplicasPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_statusReplicasPath(&mut self) {
        self.statusReplicasPath = ::std::option::Option::None;
    }

    pub fn has_statusReplicasPath(&self) -> bool {
        self.statusReplicasPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statusReplicasPath(&mut self, v: ::std::string::String) {
        self.statusReplicasPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statusReplicasPath(&mut self) -> &mut ::std::string::String {
        if self.statusReplicasPath.is_none() {
            self.statusReplicasPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.statusReplicasPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_statusReplicasPath(&mut self) -> ::std::string::String {
        self.statusReplicasPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string labelSelectorPath = 3;

    pub fn labelSelectorPath(&self) -> &str {
        match self.labelSelectorPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_labelSelectorPath(&mut self) {
        self.labelSelectorPath = ::std::option::Option::None;
    }

    pub fn has_labelSelectorPath(&self) -> bool {
        self.labelSelectorPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labelSelectorPath(&mut self, v: ::std::string::String) {
        self.labelSelectorPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labelSelectorPath(&mut self) -> &mut ::std::string::String {
        if self.labelSelectorPath.is_none() {
            self.labelSelectorPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.labelSelectorPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_labelSelectorPath(&mut self) -> ::std::string::String {
        self.labelSelectorPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "specReplicasPath",
            |m: &CustomResourceSubresourceScale| { &m.specReplicasPath },
            |m: &mut CustomResourceSubresourceScale| { &mut m.specReplicasPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "statusReplicasPath",
            |m: &CustomResourceSubresourceScale| { &m.statusReplicasPath },
            |m: &mut CustomResourceSubresourceScale| { &mut m.statusReplicasPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "labelSelectorPath",
            |m: &CustomResourceSubresourceScale| { &m.labelSelectorPath },
            |m: &mut CustomResourceSubresourceScale| { &mut m.labelSelectorPath },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CustomResourceSubresourceScale>(
            "CustomResourceSubresourceScale",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CustomResourceSubresourceScale {
    const NAME: &'static str = "CustomResourceSubresourceScale";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.specReplicasPath = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.statusReplicasPath = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.labelSelectorPath = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.specReplicasPath.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.statusReplicasPath.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.labelSelectorPath.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.specReplicasPath.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.statusReplicasPath.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.labelSelectorPath.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CustomResourceSubresourceScale {
        CustomResourceSubresourceScale::new()
    }

    fn clear(&mut self) {
        self.specReplicasPath = ::std::option::Option::None;
        self.statusReplicasPath = ::std::option::Option::None;
        self.labelSelectorPath = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CustomResourceSubresourceScale {
        static instance: CustomResourceSubresourceScale = CustomResourceSubresourceScale {
            specReplicasPath: ::std::option::Option::None,
            statusReplicasPath: ::std::option::Option::None,
            labelSelectorPath: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CustomResourceSubresourceScale {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CustomResourceSubresourceScale").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CustomResourceSubresourceScale {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CustomResourceSubresourceScale {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceSubresourceStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CustomResourceSubresourceStatus {
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceSubresourceStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CustomResourceSubresourceStatus {
    fn default() -> &'a CustomResourceSubresourceStatus {
        <CustomResourceSubresourceStatus as ::protobuf::Message>::default_instance()
    }
}

impl CustomResourceSubresourceStatus {
    pub fn new() -> CustomResourceSubresourceStatus {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CustomResourceSubresourceStatus>(
            "CustomResourceSubresourceStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CustomResourceSubresourceStatus {
    const NAME: &'static str = "CustomResourceSubresourceStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CustomResourceSubresourceStatus {
        CustomResourceSubresourceStatus::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CustomResourceSubresourceStatus {
        static instance: CustomResourceSubresourceStatus = CustomResourceSubresourceStatus {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CustomResourceSubresourceStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CustomResourceSubresourceStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CustomResourceSubresourceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CustomResourceSubresourceStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceSubresources)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CustomResourceSubresources {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceSubresources.status)
    pub status: ::protobuf::MessageField<CustomResourceSubresourceStatus>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceSubresources.scale)
    pub scale: ::protobuf::MessageField<CustomResourceSubresourceScale>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceSubresources.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CustomResourceSubresources {
    fn default() -> &'a CustomResourceSubresources {
        <CustomResourceSubresources as ::protobuf::Message>::default_instance()
    }
}

impl CustomResourceSubresources {
    pub fn new() -> CustomResourceSubresources {
        ::std::default::Default::default()
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceSubresourceStatus status = 1;

    pub fn status(&self) -> &CustomResourceSubresourceStatus {
        self.status.as_ref().unwrap_or_else(|| <CustomResourceSubresourceStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: CustomResourceSubresourceStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut CustomResourceSubresourceStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> CustomResourceSubresourceStatus {
        self.status.take().unwrap_or_else(|| CustomResourceSubresourceStatus::new())
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceSubresourceScale scale = 2;

    pub fn scale(&self) -> &CustomResourceSubresourceScale {
        self.scale.as_ref().unwrap_or_else(|| <CustomResourceSubresourceScale as ::protobuf::Message>::default_instance())
    }

    pub fn clear_scale(&mut self) {
        self.scale.clear();
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: CustomResourceSubresourceScale) {
        self.scale = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scale(&mut self) -> &mut CustomResourceSubresourceScale {
        self.scale.mut_or_insert_default()
    }

    // Take field
    pub fn take_scale(&mut self) -> CustomResourceSubresourceScale {
        self.scale.take().unwrap_or_else(|| CustomResourceSubresourceScale::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CustomResourceSubresourceStatus>(
            "status",
            |m: &CustomResourceSubresources| { &m.status },
            |m: &mut CustomResourceSubresources| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CustomResourceSubresourceScale>(
            "scale",
            |m: &CustomResourceSubresources| { &m.scale },
            |m: &mut CustomResourceSubresources| { &mut m.scale },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CustomResourceSubresources>(
            "CustomResourceSubresources",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CustomResourceSubresources {
    const NAME: &'static str = "CustomResourceSubresources";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scale)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scale.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.scale.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CustomResourceSubresources {
        CustomResourceSubresources::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.scale.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CustomResourceSubresources {
        static instance: CustomResourceSubresources = CustomResourceSubresources {
            status: ::protobuf::MessageField::none(),
            scale: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CustomResourceSubresources {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CustomResourceSubresources").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CustomResourceSubresources {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CustomResourceSubresources {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceValidation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CustomResourceValidation {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceValidation.openAPIV3Schema)
    pub openAPIV3Schema: ::protobuf::MessageField<JSONSchemaProps>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceValidation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CustomResourceValidation {
    fn default() -> &'a CustomResourceValidation {
        <CustomResourceValidation as ::protobuf::Message>::default_instance()
    }
}

impl CustomResourceValidation {
    pub fn new() -> CustomResourceValidation {
        ::std::default::Default::default()
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps openAPIV3Schema = 1;

    pub fn openAPIV3Schema(&self) -> &JSONSchemaProps {
        self.openAPIV3Schema.as_ref().unwrap_or_else(|| <JSONSchemaProps as ::protobuf::Message>::default_instance())
    }

    pub fn clear_openAPIV3Schema(&mut self) {
        self.openAPIV3Schema.clear();
    }

    pub fn has_openAPIV3Schema(&self) -> bool {
        self.openAPIV3Schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_openAPIV3Schema(&mut self, v: JSONSchemaProps) {
        self.openAPIV3Schema = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_openAPIV3Schema(&mut self) -> &mut JSONSchemaProps {
        self.openAPIV3Schema.mut_or_insert_default()
    }

    // Take field
    pub fn take_openAPIV3Schema(&mut self) -> JSONSchemaProps {
        self.openAPIV3Schema.take().unwrap_or_else(|| JSONSchemaProps::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, JSONSchemaProps>(
            "openAPIV3Schema",
            |m: &CustomResourceValidation| { &m.openAPIV3Schema },
            |m: &mut CustomResourceValidation| { &mut m.openAPIV3Schema },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CustomResourceValidation>(
            "CustomResourceValidation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CustomResourceValidation {
    const NAME: &'static str = "CustomResourceValidation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.openAPIV3Schema)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.openAPIV3Schema.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.openAPIV3Schema.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CustomResourceValidation {
        CustomResourceValidation::new()
    }

    fn clear(&mut self) {
        self.openAPIV3Schema.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CustomResourceValidation {
        static instance: CustomResourceValidation = CustomResourceValidation {
            openAPIV3Schema: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CustomResourceValidation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CustomResourceValidation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CustomResourceValidation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CustomResourceValidation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ExternalDocumentation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExternalDocumentation {
    // message fields
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ExternalDocumentation.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ExternalDocumentation.url)
    pub url: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ExternalDocumentation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExternalDocumentation {
    fn default() -> &'a ExternalDocumentation {
        <ExternalDocumentation as ::protobuf::Message>::default_instance()
    }
}

impl ExternalDocumentation {
    pub fn new() -> ExternalDocumentation {
        ::std::default::Default::default()
    }

    // optional string description = 1;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &ExternalDocumentation| { &m.description },
            |m: &mut ExternalDocumentation| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &ExternalDocumentation| { &m.url },
            |m: &mut ExternalDocumentation| { &mut m.url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExternalDocumentation>(
            "ExternalDocumentation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExternalDocumentation {
    const NAME: &'static str = "ExternalDocumentation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.description.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExternalDocumentation {
        ExternalDocumentation::new()
    }

    fn clear(&mut self) {
        self.description = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExternalDocumentation {
        static instance: ExternalDocumentation = ExternalDocumentation {
            description: ::std::option::Option::None,
            url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExternalDocumentation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExternalDocumentation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExternalDocumentation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalDocumentation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSON)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct JSON {
    // message fields
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSON.raw)
    pub raw: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSON.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a JSON {
    fn default() -> &'a JSON {
        <JSON as ::protobuf::Message>::default_instance()
    }
}

impl JSON {
    pub fn new() -> JSON {
        ::std::default::Default::default()
    }

    // optional bytes raw = 1;

    pub fn raw(&self) -> &[u8] {
        match self.raw.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_raw(&mut self) {
        self.raw = ::std::option::Option::None;
    }

    pub fn has_raw(&self) -> bool {
        self.raw.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw(&mut self, v: ::std::vec::Vec<u8>) {
        self.raw = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.raw.is_none() {
            self.raw = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.raw.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw(&mut self) -> ::std::vec::Vec<u8> {
        self.raw.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "raw",
            |m: &JSON| { &m.raw },
            |m: &mut JSON| { &mut m.raw },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<JSON>(
            "JSON",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for JSON {
    const NAME: &'static str = "JSON";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.raw = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.raw.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.raw.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> JSON {
        JSON::new()
    }

    fn clear(&mut self) {
        self.raw = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static JSON {
        static instance: JSON = JSON {
            raw: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for JSON {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("JSON").unwrap()).clone()
    }
}

impl ::std::fmt::Display for JSON {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JSON {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct JSONSchemaProps {
    // message fields
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.id)
    pub id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.schema)
    pub schema: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.ref)
    pub ref_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.format)
    pub format: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.title)
    pub title: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.default)
    pub default: ::protobuf::MessageField<JSON>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.maximum)
    pub maximum: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.exclusiveMaximum)
    pub exclusiveMaximum: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.minimum)
    pub minimum: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.exclusiveMinimum)
    pub exclusiveMinimum: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.maxLength)
    pub maxLength: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.minLength)
    pub minLength: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.pattern)
    pub pattern: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.maxItems)
    pub maxItems: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.minItems)
    pub minItems: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.uniqueItems)
    pub uniqueItems: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.multipleOf)
    pub multipleOf: ::std::option::Option<f64>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.enum)
    pub enum_: ::std::vec::Vec<JSON>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.maxProperties)
    pub maxProperties: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.minProperties)
    pub minProperties: ::std::option::Option<i64>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.required)
    pub required: ::std::vec::Vec<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.items)
    pub items: ::protobuf::MessageField<JSONSchemaPropsOrArray>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.allOf)
    pub allOf: ::std::vec::Vec<JSONSchemaProps>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.oneOf)
    pub oneOf: ::std::vec::Vec<JSONSchemaProps>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.anyOf)
    pub anyOf: ::std::vec::Vec<JSONSchemaProps>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.not)
    pub not: ::protobuf::MessageField<JSONSchemaProps>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.properties)
    pub properties: ::std::collections::BTreeMap<::std::string::String, JSONSchemaProps>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.additionalProperties)
    pub additionalProperties: ::protobuf::MessageField<JSONSchemaPropsOrBool>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.patternProperties)
    pub patternProperties: ::std::collections::BTreeMap<::std::string::String, JSONSchemaProps>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.dependencies)
    pub dependencies: ::std::collections::BTreeMap<::std::string::String, JSONSchemaPropsOrStringArray>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.additionalItems)
    pub additionalItems: ::protobuf::MessageField<JSONSchemaPropsOrBool>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.definitions)
    pub definitions: ::std::collections::BTreeMap<::std::string::String, JSONSchemaProps>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.externalDocs)
    pub externalDocs: ::protobuf::MessageField<ExternalDocumentation>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.example)
    pub example: ::protobuf::MessageField<JSON>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.nullable)
    pub nullable: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.xKubernetesPreserveUnknownFields)
    pub xKubernetesPreserveUnknownFields: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.xKubernetesEmbeddedResource)
    pub xKubernetesEmbeddedResource: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.xKubernetesIntOrString)
    pub xKubernetesIntOrString: ::std::option::Option<bool>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.xKubernetesListMapKeys)
    pub xKubernetesListMapKeys: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.xKubernetesListType)
    pub xKubernetesListType: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.xKubernetesMapType)
    pub xKubernetesMapType: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.xKubernetesValidations)
    pub xKubernetesValidations: ::std::vec::Vec<ValidationRule>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a JSONSchemaProps {
    fn default() -> &'a JSONSchemaProps {
        <JSONSchemaProps as ::protobuf::Message>::default_instance()
    }
}

impl JSONSchemaProps {
    pub fn new() -> JSONSchemaProps {
        ::std::default::Default::default()
    }

    // optional string id = 1;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string schema = 2;

    pub fn schema(&self) -> &str {
        match self.schema.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_schema(&mut self) {
        self.schema = ::std::option::Option::None;
    }

    pub fn has_schema(&self) -> bool {
        self.schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: ::std::string::String) {
        self.schema = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut ::std::string::String {
        if self.schema.is_none() {
            self.schema = ::std::option::Option::Some(::std::string::String::new());
        }
        self.schema.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema(&mut self) -> ::std::string::String {
        self.schema.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string ref = 3;

    pub fn ref_(&self) -> &str {
        match self.ref_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ref_(&mut self) {
        self.ref_ = ::std::option::Option::None;
    }

    pub fn has_ref(&self) -> bool {
        self.ref_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ref(&mut self, v: ::std::string::String) {
        self.ref_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ref(&mut self) -> &mut ::std::string::String {
        if self.ref_.is_none() {
            self.ref_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ref_.as_mut().unwrap()
    }

    // Take field
    pub fn take_ref_(&mut self) -> ::std::string::String {
        self.ref_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 4;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string type = 5;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string format = 6;

    pub fn format(&self) -> &str {
        match self.format.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_format(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: ::std::string::String) {
        self.format = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_format(&mut self) -> &mut ::std::string::String {
        if self.format.is_none() {
            self.format = ::std::option::Option::Some(::std::string::String::new());
        }
        self.format.as_mut().unwrap()
    }

    // Take field
    pub fn take_format(&mut self) -> ::std::string::String {
        self.format.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 7;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSON default = 8;

    pub fn default(&self) -> &JSON {
        self.default.as_ref().unwrap_or_else(|| <JSON as ::protobuf::Message>::default_instance())
    }

    pub fn clear_default(&mut self) {
        self.default.clear();
    }

    pub fn has_default(&self) -> bool {
        self.default.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default(&mut self, v: JSON) {
        self.default = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default(&mut self) -> &mut JSON {
        self.default.mut_or_insert_default()
    }

    // Take field
    pub fn take_default(&mut self) -> JSON {
        self.default.take().unwrap_or_else(|| JSON::new())
    }

    // optional double maximum = 9;

    pub fn maximum(&self) -> f64 {
        self.maximum.unwrap_or(0.)
    }

    pub fn clear_maximum(&mut self) {
        self.maximum = ::std::option::Option::None;
    }

    pub fn has_maximum(&self) -> bool {
        self.maximum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum(&mut self, v: f64) {
        self.maximum = ::std::option::Option::Some(v);
    }

    // optional bool exclusiveMaximum = 10;

    pub fn exclusiveMaximum(&self) -> bool {
        self.exclusiveMaximum.unwrap_or(false)
    }

    pub fn clear_exclusiveMaximum(&mut self) {
        self.exclusiveMaximum = ::std::option::Option::None;
    }

    pub fn has_exclusiveMaximum(&self) -> bool {
        self.exclusiveMaximum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exclusiveMaximum(&mut self, v: bool) {
        self.exclusiveMaximum = ::std::option::Option::Some(v);
    }

    // optional double minimum = 11;

    pub fn minimum(&self) -> f64 {
        self.minimum.unwrap_or(0.)
    }

    pub fn clear_minimum(&mut self) {
        self.minimum = ::std::option::Option::None;
    }

    pub fn has_minimum(&self) -> bool {
        self.minimum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum(&mut self, v: f64) {
        self.minimum = ::std::option::Option::Some(v);
    }

    // optional bool exclusiveMinimum = 12;

    pub fn exclusiveMinimum(&self) -> bool {
        self.exclusiveMinimum.unwrap_or(false)
    }

    pub fn clear_exclusiveMinimum(&mut self) {
        self.exclusiveMinimum = ::std::option::Option::None;
    }

    pub fn has_exclusiveMinimum(&self) -> bool {
        self.exclusiveMinimum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exclusiveMinimum(&mut self, v: bool) {
        self.exclusiveMinimum = ::std::option::Option::Some(v);
    }

    // optional int64 maxLength = 13;

    pub fn maxLength(&self) -> i64 {
        self.maxLength.unwrap_or(0)
    }

    pub fn clear_maxLength(&mut self) {
        self.maxLength = ::std::option::Option::None;
    }

    pub fn has_maxLength(&self) -> bool {
        self.maxLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxLength(&mut self, v: i64) {
        self.maxLength = ::std::option::Option::Some(v);
    }

    // optional int64 minLength = 14;

    pub fn minLength(&self) -> i64 {
        self.minLength.unwrap_or(0)
    }

    pub fn clear_minLength(&mut self) {
        self.minLength = ::std::option::Option::None;
    }

    pub fn has_minLength(&self) -> bool {
        self.minLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minLength(&mut self, v: i64) {
        self.minLength = ::std::option::Option::Some(v);
    }

    // optional string pattern = 15;

    pub fn pattern(&self) -> &str {
        match self.pattern.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pattern(&mut self) {
        self.pattern = ::std::option::Option::None;
    }

    pub fn has_pattern(&self) -> bool {
        self.pattern.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pattern(&mut self, v: ::std::string::String) {
        self.pattern = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pattern(&mut self) -> &mut ::std::string::String {
        if self.pattern.is_none() {
            self.pattern = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pattern.as_mut().unwrap()
    }

    // Take field
    pub fn take_pattern(&mut self) -> ::std::string::String {
        self.pattern.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 maxItems = 16;

    pub fn maxItems(&self) -> i64 {
        self.maxItems.unwrap_or(0)
    }

    pub fn clear_maxItems(&mut self) {
        self.maxItems = ::std::option::Option::None;
    }

    pub fn has_maxItems(&self) -> bool {
        self.maxItems.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxItems(&mut self, v: i64) {
        self.maxItems = ::std::option::Option::Some(v);
    }

    // optional int64 minItems = 17;

    pub fn minItems(&self) -> i64 {
        self.minItems.unwrap_or(0)
    }

    pub fn clear_minItems(&mut self) {
        self.minItems = ::std::option::Option::None;
    }

    pub fn has_minItems(&self) -> bool {
        self.minItems.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minItems(&mut self, v: i64) {
        self.minItems = ::std::option::Option::Some(v);
    }

    // optional bool uniqueItems = 18;

    pub fn uniqueItems(&self) -> bool {
        self.uniqueItems.unwrap_or(false)
    }

    pub fn clear_uniqueItems(&mut self) {
        self.uniqueItems = ::std::option::Option::None;
    }

    pub fn has_uniqueItems(&self) -> bool {
        self.uniqueItems.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uniqueItems(&mut self, v: bool) {
        self.uniqueItems = ::std::option::Option::Some(v);
    }

    // optional double multipleOf = 19;

    pub fn multipleOf(&self) -> f64 {
        self.multipleOf.unwrap_or(0.)
    }

    pub fn clear_multipleOf(&mut self) {
        self.multipleOf = ::std::option::Option::None;
    }

    pub fn has_multipleOf(&self) -> bool {
        self.multipleOf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multipleOf(&mut self, v: f64) {
        self.multipleOf = ::std::option::Option::Some(v);
    }

    // repeated .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSON enum = 20;

    pub fn enum_(&self) -> &[JSON] {
        &self.enum_
    }

    pub fn clear_enum_(&mut self) {
        self.enum_.clear();
    }

    // Param is passed by value, moved
    pub fn set_enum(&mut self, v: ::std::vec::Vec<JSON>) {
        self.enum_ = v;
    }

    // Mutable pointer to the field.
    pub fn mut_enum(&mut self) -> &mut ::std::vec::Vec<JSON> {
        &mut self.enum_
    }

    // Take field
    pub fn take_enum_(&mut self) -> ::std::vec::Vec<JSON> {
        ::std::mem::replace(&mut self.enum_, ::std::vec::Vec::new())
    }

    // optional int64 maxProperties = 21;

    pub fn maxProperties(&self) -> i64 {
        self.maxProperties.unwrap_or(0)
    }

    pub fn clear_maxProperties(&mut self) {
        self.maxProperties = ::std::option::Option::None;
    }

    pub fn has_maxProperties(&self) -> bool {
        self.maxProperties.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxProperties(&mut self, v: i64) {
        self.maxProperties = ::std::option::Option::Some(v);
    }

    // optional int64 minProperties = 22;

    pub fn minProperties(&self) -> i64 {
        self.minProperties.unwrap_or(0)
    }

    pub fn clear_minProperties(&mut self) {
        self.minProperties = ::std::option::Option::None;
    }

    pub fn has_minProperties(&self) -> bool {
        self.minProperties.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minProperties(&mut self, v: i64) {
        self.minProperties = ::std::option::Option::Some(v);
    }

    // repeated string required = 23;

    pub fn required(&self) -> &[::std::string::String] {
        &self.required
    }

    pub fn clear_required(&mut self) {
        self.required.clear();
    }

    // Param is passed by value, moved
    pub fn set_required(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.required = v;
    }

    // Mutable pointer to the field.
    pub fn mut_required(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.required
    }

    // Take field
    pub fn take_required(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.required, ::std::vec::Vec::new())
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaPropsOrArray items = 24;

    pub fn items(&self) -> &JSONSchemaPropsOrArray {
        self.items.as_ref().unwrap_or_else(|| <JSONSchemaPropsOrArray as ::protobuf::Message>::default_instance())
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    pub fn has_items(&self) -> bool {
        self.items.is_some()
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: JSONSchemaPropsOrArray) {
        self.items = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_items(&mut self) -> &mut JSONSchemaPropsOrArray {
        self.items.mut_or_insert_default()
    }

    // Take field
    pub fn take_items(&mut self) -> JSONSchemaPropsOrArray {
        self.items.take().unwrap_or_else(|| JSONSchemaPropsOrArray::new())
    }

    // repeated .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps allOf = 25;

    pub fn allOf(&self) -> &[JSONSchemaProps] {
        &self.allOf
    }

    pub fn clear_allOf(&mut self) {
        self.allOf.clear();
    }

    // Param is passed by value, moved
    pub fn set_allOf(&mut self, v: ::std::vec::Vec<JSONSchemaProps>) {
        self.allOf = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allOf(&mut self) -> &mut ::std::vec::Vec<JSONSchemaProps> {
        &mut self.allOf
    }

    // Take field
    pub fn take_allOf(&mut self) -> ::std::vec::Vec<JSONSchemaProps> {
        ::std::mem::replace(&mut self.allOf, ::std::vec::Vec::new())
    }

    // repeated .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps oneOf = 26;

    pub fn oneOf(&self) -> &[JSONSchemaProps] {
        &self.oneOf
    }

    pub fn clear_oneOf(&mut self) {
        self.oneOf.clear();
    }

    // Param is passed by value, moved
    pub fn set_oneOf(&mut self, v: ::std::vec::Vec<JSONSchemaProps>) {
        self.oneOf = v;
    }

    // Mutable pointer to the field.
    pub fn mut_oneOf(&mut self) -> &mut ::std::vec::Vec<JSONSchemaProps> {
        &mut self.oneOf
    }

    // Take field
    pub fn take_oneOf(&mut self) -> ::std::vec::Vec<JSONSchemaProps> {
        ::std::mem::replace(&mut self.oneOf, ::std::vec::Vec::new())
    }

    // repeated .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps anyOf = 27;

    pub fn anyOf(&self) -> &[JSONSchemaProps] {
        &self.anyOf
    }

    pub fn clear_anyOf(&mut self) {
        self.anyOf.clear();
    }

    // Param is passed by value, moved
    pub fn set_anyOf(&mut self, v: ::std::vec::Vec<JSONSchemaProps>) {
        self.anyOf = v;
    }

    // Mutable pointer to the field.
    pub fn mut_anyOf(&mut self) -> &mut ::std::vec::Vec<JSONSchemaProps> {
        &mut self.anyOf
    }

    // Take field
    pub fn take_anyOf(&mut self) -> ::std::vec::Vec<JSONSchemaProps> {
        ::std::mem::replace(&mut self.anyOf, ::std::vec::Vec::new())
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps not = 28;

    pub fn not(&self) -> &JSONSchemaProps {
        self.not.as_ref().unwrap_or_else(|| <JSONSchemaProps as ::protobuf::Message>::default_instance())
    }

    pub fn clear_not(&mut self) {
        self.not.clear();
    }

    pub fn has_not(&self) -> bool {
        self.not.is_some()
    }

    // Param is passed by value, moved
    pub fn set_not(&mut self, v: JSONSchemaProps) {
        self.not = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_not(&mut self) -> &mut JSONSchemaProps {
        self.not.mut_or_insert_default()
    }

    // Take field
    pub fn take_not(&mut self) -> JSONSchemaProps {
        self.not.take().unwrap_or_else(|| JSONSchemaProps::new())
    }

    // repeated .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.PropertiesEntry properties = 29;

    pub fn properties(&self) -> &::std::collections::BTreeMap<::std::string::String, JSONSchemaProps> {
        &self.properties
    }

    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::std::collections::BTreeMap<::std::string::String, JSONSchemaProps>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, JSONSchemaProps> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::std::collections::BTreeMap<::std::string::String, JSONSchemaProps> {
        ::std::mem::replace(&mut self.properties, ::std::collections::BTreeMap::new())
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaPropsOrBool additionalProperties = 30;

    pub fn additionalProperties(&self) -> &JSONSchemaPropsOrBool {
        self.additionalProperties.as_ref().unwrap_or_else(|| <JSONSchemaPropsOrBool as ::protobuf::Message>::default_instance())
    }

    pub fn clear_additionalProperties(&mut self) {
        self.additionalProperties.clear();
    }

    pub fn has_additionalProperties(&self) -> bool {
        self.additionalProperties.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additionalProperties(&mut self, v: JSONSchemaPropsOrBool) {
        self.additionalProperties = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_additionalProperties(&mut self) -> &mut JSONSchemaPropsOrBool {
        self.additionalProperties.mut_or_insert_default()
    }

    // Take field
    pub fn take_additionalProperties(&mut self) -> JSONSchemaPropsOrBool {
        self.additionalProperties.take().unwrap_or_else(|| JSONSchemaPropsOrBool::new())
    }

    // repeated .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.PatternPropertiesEntry patternProperties = 31;

    pub fn patternProperties(&self) -> &::std::collections::BTreeMap<::std::string::String, JSONSchemaProps> {
        &self.patternProperties
    }

    pub fn clear_patternProperties(&mut self) {
        self.patternProperties.clear();
    }

    // Param is passed by value, moved
    pub fn set_patternProperties(&mut self, v: ::std::collections::BTreeMap<::std::string::String, JSONSchemaProps>) {
        self.patternProperties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_patternProperties(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, JSONSchemaProps> {
        &mut self.patternProperties
    }

    // Take field
    pub fn take_patternProperties(&mut self) -> ::std::collections::BTreeMap<::std::string::String, JSONSchemaProps> {
        ::std::mem::replace(&mut self.patternProperties, ::std::collections::BTreeMap::new())
    }

    // repeated .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.DependenciesEntry dependencies = 32;

    pub fn dependencies(&self) -> &::std::collections::BTreeMap<::std::string::String, JSONSchemaPropsOrStringArray> {
        &self.dependencies
    }

    pub fn clear_dependencies(&mut self) {
        self.dependencies.clear();
    }

    // Param is passed by value, moved
    pub fn set_dependencies(&mut self, v: ::std::collections::BTreeMap<::std::string::String, JSONSchemaPropsOrStringArray>) {
        self.dependencies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dependencies(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, JSONSchemaPropsOrStringArray> {
        &mut self.dependencies
    }

    // Take field
    pub fn take_dependencies(&mut self) -> ::std::collections::BTreeMap<::std::string::String, JSONSchemaPropsOrStringArray> {
        ::std::mem::replace(&mut self.dependencies, ::std::collections::BTreeMap::new())
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaPropsOrBool additionalItems = 33;

    pub fn additionalItems(&self) -> &JSONSchemaPropsOrBool {
        self.additionalItems.as_ref().unwrap_or_else(|| <JSONSchemaPropsOrBool as ::protobuf::Message>::default_instance())
    }

    pub fn clear_additionalItems(&mut self) {
        self.additionalItems.clear();
    }

    pub fn has_additionalItems(&self) -> bool {
        self.additionalItems.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additionalItems(&mut self, v: JSONSchemaPropsOrBool) {
        self.additionalItems = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_additionalItems(&mut self) -> &mut JSONSchemaPropsOrBool {
        self.additionalItems.mut_or_insert_default()
    }

    // Take field
    pub fn take_additionalItems(&mut self) -> JSONSchemaPropsOrBool {
        self.additionalItems.take().unwrap_or_else(|| JSONSchemaPropsOrBool::new())
    }

    // repeated .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.DefinitionsEntry definitions = 34;

    pub fn definitions(&self) -> &::std::collections::BTreeMap<::std::string::String, JSONSchemaProps> {
        &self.definitions
    }

    pub fn clear_definitions(&mut self) {
        self.definitions.clear();
    }

    // Param is passed by value, moved
    pub fn set_definitions(&mut self, v: ::std::collections::BTreeMap<::std::string::String, JSONSchemaProps>) {
        self.definitions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_definitions(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, JSONSchemaProps> {
        &mut self.definitions
    }

    // Take field
    pub fn take_definitions(&mut self) -> ::std::collections::BTreeMap<::std::string::String, JSONSchemaProps> {
        ::std::mem::replace(&mut self.definitions, ::std::collections::BTreeMap::new())
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ExternalDocumentation externalDocs = 35;

    pub fn externalDocs(&self) -> &ExternalDocumentation {
        self.externalDocs.as_ref().unwrap_or_else(|| <ExternalDocumentation as ::protobuf::Message>::default_instance())
    }

    pub fn clear_externalDocs(&mut self) {
        self.externalDocs.clear();
    }

    pub fn has_externalDocs(&self) -> bool {
        self.externalDocs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_externalDocs(&mut self, v: ExternalDocumentation) {
        self.externalDocs = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_externalDocs(&mut self) -> &mut ExternalDocumentation {
        self.externalDocs.mut_or_insert_default()
    }

    // Take field
    pub fn take_externalDocs(&mut self) -> ExternalDocumentation {
        self.externalDocs.take().unwrap_or_else(|| ExternalDocumentation::new())
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSON example = 36;

    pub fn example(&self) -> &JSON {
        self.example.as_ref().unwrap_or_else(|| <JSON as ::protobuf::Message>::default_instance())
    }

    pub fn clear_example(&mut self) {
        self.example.clear();
    }

    pub fn has_example(&self) -> bool {
        self.example.is_some()
    }

    // Param is passed by value, moved
    pub fn set_example(&mut self, v: JSON) {
        self.example = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_example(&mut self) -> &mut JSON {
        self.example.mut_or_insert_default()
    }

    // Take field
    pub fn take_example(&mut self) -> JSON {
        self.example.take().unwrap_or_else(|| JSON::new())
    }

    // optional bool nullable = 37;

    pub fn nullable(&self) -> bool {
        self.nullable.unwrap_or(false)
    }

    pub fn clear_nullable(&mut self) {
        self.nullable = ::std::option::Option::None;
    }

    pub fn has_nullable(&self) -> bool {
        self.nullable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nullable(&mut self, v: bool) {
        self.nullable = ::std::option::Option::Some(v);
    }

    // optional bool xKubernetesPreserveUnknownFields = 38;

    pub fn xKubernetesPreserveUnknownFields(&self) -> bool {
        self.xKubernetesPreserveUnknownFields.unwrap_or(false)
    }

    pub fn clear_xKubernetesPreserveUnknownFields(&mut self) {
        self.xKubernetesPreserveUnknownFields = ::std::option::Option::None;
    }

    pub fn has_xKubernetesPreserveUnknownFields(&self) -> bool {
        self.xKubernetesPreserveUnknownFields.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xKubernetesPreserveUnknownFields(&mut self, v: bool) {
        self.xKubernetesPreserveUnknownFields = ::std::option::Option::Some(v);
    }

    // optional bool xKubernetesEmbeddedResource = 39;

    pub fn xKubernetesEmbeddedResource(&self) -> bool {
        self.xKubernetesEmbeddedResource.unwrap_or(false)
    }

    pub fn clear_xKubernetesEmbeddedResource(&mut self) {
        self.xKubernetesEmbeddedResource = ::std::option::Option::None;
    }

    pub fn has_xKubernetesEmbeddedResource(&self) -> bool {
        self.xKubernetesEmbeddedResource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xKubernetesEmbeddedResource(&mut self, v: bool) {
        self.xKubernetesEmbeddedResource = ::std::option::Option::Some(v);
    }

    // optional bool xKubernetesIntOrString = 40;

    pub fn xKubernetesIntOrString(&self) -> bool {
        self.xKubernetesIntOrString.unwrap_or(false)
    }

    pub fn clear_xKubernetesIntOrString(&mut self) {
        self.xKubernetesIntOrString = ::std::option::Option::None;
    }

    pub fn has_xKubernetesIntOrString(&self) -> bool {
        self.xKubernetesIntOrString.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xKubernetesIntOrString(&mut self, v: bool) {
        self.xKubernetesIntOrString = ::std::option::Option::Some(v);
    }

    // repeated string xKubernetesListMapKeys = 41;

    pub fn xKubernetesListMapKeys(&self) -> &[::std::string::String] {
        &self.xKubernetesListMapKeys
    }

    pub fn clear_xKubernetesListMapKeys(&mut self) {
        self.xKubernetesListMapKeys.clear();
    }

    // Param is passed by value, moved
    pub fn set_xKubernetesListMapKeys(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.xKubernetesListMapKeys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_xKubernetesListMapKeys(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.xKubernetesListMapKeys
    }

    // Take field
    pub fn take_xKubernetesListMapKeys(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.xKubernetesListMapKeys, ::std::vec::Vec::new())
    }

    // optional string xKubernetesListType = 42;

    pub fn xKubernetesListType(&self) -> &str {
        match self.xKubernetesListType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_xKubernetesListType(&mut self) {
        self.xKubernetesListType = ::std::option::Option::None;
    }

    pub fn has_xKubernetesListType(&self) -> bool {
        self.xKubernetesListType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xKubernetesListType(&mut self, v: ::std::string::String) {
        self.xKubernetesListType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_xKubernetesListType(&mut self) -> &mut ::std::string::String {
        if self.xKubernetesListType.is_none() {
            self.xKubernetesListType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.xKubernetesListType.as_mut().unwrap()
    }

    // Take field
    pub fn take_xKubernetesListType(&mut self) -> ::std::string::String {
        self.xKubernetesListType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string xKubernetesMapType = 43;

    pub fn xKubernetesMapType(&self) -> &str {
        match self.xKubernetesMapType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_xKubernetesMapType(&mut self) {
        self.xKubernetesMapType = ::std::option::Option::None;
    }

    pub fn has_xKubernetesMapType(&self) -> bool {
        self.xKubernetesMapType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xKubernetesMapType(&mut self, v: ::std::string::String) {
        self.xKubernetesMapType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_xKubernetesMapType(&mut self) -> &mut ::std::string::String {
        if self.xKubernetesMapType.is_none() {
            self.xKubernetesMapType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.xKubernetesMapType.as_mut().unwrap()
    }

    // Take field
    pub fn take_xKubernetesMapType(&mut self) -> ::std::string::String {
        self.xKubernetesMapType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ValidationRule xKubernetesValidations = 44;

    pub fn xKubernetesValidations(&self) -> &[ValidationRule] {
        &self.xKubernetesValidations
    }

    pub fn clear_xKubernetesValidations(&mut self) {
        self.xKubernetesValidations.clear();
    }

    // Param is passed by value, moved
    pub fn set_xKubernetesValidations(&mut self, v: ::std::vec::Vec<ValidationRule>) {
        self.xKubernetesValidations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_xKubernetesValidations(&mut self) -> &mut ::std::vec::Vec<ValidationRule> {
        &mut self.xKubernetesValidations
    }

    // Take field
    pub fn take_xKubernetesValidations(&mut self) -> ::std::vec::Vec<ValidationRule> {
        ::std::mem::replace(&mut self.xKubernetesValidations, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(44);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &JSONSchemaProps| { &m.id },
            |m: &mut JSONSchemaProps| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "schema",
            |m: &JSONSchemaProps| { &m.schema },
            |m: &mut JSONSchemaProps| { &mut m.schema },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ref",
            |m: &JSONSchemaProps| { &m.ref_ },
            |m: &mut JSONSchemaProps| { &mut m.ref_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &JSONSchemaProps| { &m.description },
            |m: &mut JSONSchemaProps| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &JSONSchemaProps| { &m.type_ },
            |m: &mut JSONSchemaProps| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "format",
            |m: &JSONSchemaProps| { &m.format },
            |m: &mut JSONSchemaProps| { &mut m.format },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &JSONSchemaProps| { &m.title },
            |m: &mut JSONSchemaProps| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, JSON>(
            "default",
            |m: &JSONSchemaProps| { &m.default },
            |m: &mut JSONSchemaProps| { &mut m.default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maximum",
            |m: &JSONSchemaProps| { &m.maximum },
            |m: &mut JSONSchemaProps| { &mut m.maximum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "exclusiveMaximum",
            |m: &JSONSchemaProps| { &m.exclusiveMaximum },
            |m: &mut JSONSchemaProps| { &mut m.exclusiveMaximum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minimum",
            |m: &JSONSchemaProps| { &m.minimum },
            |m: &mut JSONSchemaProps| { &mut m.minimum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "exclusiveMinimum",
            |m: &JSONSchemaProps| { &m.exclusiveMinimum },
            |m: &mut JSONSchemaProps| { &mut m.exclusiveMinimum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maxLength",
            |m: &JSONSchemaProps| { &m.maxLength },
            |m: &mut JSONSchemaProps| { &mut m.maxLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minLength",
            |m: &JSONSchemaProps| { &m.minLength },
            |m: &mut JSONSchemaProps| { &mut m.minLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pattern",
            |m: &JSONSchemaProps| { &m.pattern },
            |m: &mut JSONSchemaProps| { &mut m.pattern },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maxItems",
            |m: &JSONSchemaProps| { &m.maxItems },
            |m: &mut JSONSchemaProps| { &mut m.maxItems },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minItems",
            |m: &JSONSchemaProps| { &m.minItems },
            |m: &mut JSONSchemaProps| { &mut m.minItems },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uniqueItems",
            |m: &JSONSchemaProps| { &m.uniqueItems },
            |m: &mut JSONSchemaProps| { &mut m.uniqueItems },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "multipleOf",
            |m: &JSONSchemaProps| { &m.multipleOf },
            |m: &mut JSONSchemaProps| { &mut m.multipleOf },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enum",
            |m: &JSONSchemaProps| { &m.enum_ },
            |m: &mut JSONSchemaProps| { &mut m.enum_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maxProperties",
            |m: &JSONSchemaProps| { &m.maxProperties },
            |m: &mut JSONSchemaProps| { &mut m.maxProperties },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minProperties",
            |m: &JSONSchemaProps| { &m.minProperties },
            |m: &mut JSONSchemaProps| { &mut m.minProperties },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "required",
            |m: &JSONSchemaProps| { &m.required },
            |m: &mut JSONSchemaProps| { &mut m.required },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, JSONSchemaPropsOrArray>(
            "items",
            |m: &JSONSchemaProps| { &m.items },
            |m: &mut JSONSchemaProps| { &mut m.items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "allOf",
            |m: &JSONSchemaProps| { &m.allOf },
            |m: &mut JSONSchemaProps| { &mut m.allOf },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "oneOf",
            |m: &JSONSchemaProps| { &m.oneOf },
            |m: &mut JSONSchemaProps| { &mut m.oneOf },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "anyOf",
            |m: &JSONSchemaProps| { &m.anyOf },
            |m: &mut JSONSchemaProps| { &mut m.anyOf },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, JSONSchemaProps>(
            "not",
            |m: &JSONSchemaProps| { &m.not },
            |m: &mut JSONSchemaProps| { &mut m.not },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "properties",
            |m: &JSONSchemaProps| { &m.properties },
            |m: &mut JSONSchemaProps| { &mut m.properties },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, JSONSchemaPropsOrBool>(
            "additionalProperties",
            |m: &JSONSchemaProps| { &m.additionalProperties },
            |m: &mut JSONSchemaProps| { &mut m.additionalProperties },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "patternProperties",
            |m: &JSONSchemaProps| { &m.patternProperties },
            |m: &mut JSONSchemaProps| { &mut m.patternProperties },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "dependencies",
            |m: &JSONSchemaProps| { &m.dependencies },
            |m: &mut JSONSchemaProps| { &mut m.dependencies },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, JSONSchemaPropsOrBool>(
            "additionalItems",
            |m: &JSONSchemaProps| { &m.additionalItems },
            |m: &mut JSONSchemaProps| { &mut m.additionalItems },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "definitions",
            |m: &JSONSchemaProps| { &m.definitions },
            |m: &mut JSONSchemaProps| { &mut m.definitions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExternalDocumentation>(
            "externalDocs",
            |m: &JSONSchemaProps| { &m.externalDocs },
            |m: &mut JSONSchemaProps| { &mut m.externalDocs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, JSON>(
            "example",
            |m: &JSONSchemaProps| { &m.example },
            |m: &mut JSONSchemaProps| { &mut m.example },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nullable",
            |m: &JSONSchemaProps| { &m.nullable },
            |m: &mut JSONSchemaProps| { &mut m.nullable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xKubernetesPreserveUnknownFields",
            |m: &JSONSchemaProps| { &m.xKubernetesPreserveUnknownFields },
            |m: &mut JSONSchemaProps| { &mut m.xKubernetesPreserveUnknownFields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xKubernetesEmbeddedResource",
            |m: &JSONSchemaProps| { &m.xKubernetesEmbeddedResource },
            |m: &mut JSONSchemaProps| { &mut m.xKubernetesEmbeddedResource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xKubernetesIntOrString",
            |m: &JSONSchemaProps| { &m.xKubernetesIntOrString },
            |m: &mut JSONSchemaProps| { &mut m.xKubernetesIntOrString },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "xKubernetesListMapKeys",
            |m: &JSONSchemaProps| { &m.xKubernetesListMapKeys },
            |m: &mut JSONSchemaProps| { &mut m.xKubernetesListMapKeys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xKubernetesListType",
            |m: &JSONSchemaProps| { &m.xKubernetesListType },
            |m: &mut JSONSchemaProps| { &mut m.xKubernetesListType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xKubernetesMapType",
            |m: &JSONSchemaProps| { &m.xKubernetesMapType },
            |m: &mut JSONSchemaProps| { &mut m.xKubernetesMapType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "xKubernetesValidations",
            |m: &JSONSchemaProps| { &m.xKubernetesValidations },
            |m: &mut JSONSchemaProps| { &mut m.xKubernetesValidations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<JSONSchemaProps>(
            "JSONSchemaProps",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for JSONSchemaProps {
    const NAME: &'static str = "JSONSchemaProps";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.schema = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.ref_ = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.format = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.default)?;
                },
                73 => {
                    self.maximum = ::std::option::Option::Some(is.read_double()?);
                },
                80 => {
                    self.exclusiveMaximum = ::std::option::Option::Some(is.read_bool()?);
                },
                89 => {
                    self.minimum = ::std::option::Option::Some(is.read_double()?);
                },
                96 => {
                    self.exclusiveMinimum = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.maxLength = ::std::option::Option::Some(is.read_int64()?);
                },
                112 => {
                    self.minLength = ::std::option::Option::Some(is.read_int64()?);
                },
                122 => {
                    self.pattern = ::std::option::Option::Some(is.read_string()?);
                },
                128 => {
                    self.maxItems = ::std::option::Option::Some(is.read_int64()?);
                },
                136 => {
                    self.minItems = ::std::option::Option::Some(is.read_int64()?);
                },
                144 => {
                    self.uniqueItems = ::std::option::Option::Some(is.read_bool()?);
                },
                153 => {
                    self.multipleOf = ::std::option::Option::Some(is.read_double()?);
                },
                162 => {
                    self.enum_.push(is.read_message()?);
                },
                168 => {
                    self.maxProperties = ::std::option::Option::Some(is.read_int64()?);
                },
                176 => {
                    self.minProperties = ::std::option::Option::Some(is.read_int64()?);
                },
                186 => {
                    self.required.push(is.read_string()?);
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.items)?;
                },
                202 => {
                    self.allOf.push(is.read_message()?);
                },
                210 => {
                    self.oneOf.push(is.read_message()?);
                },
                218 => {
                    self.anyOf.push(is.read_message()?);
                },
                226 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.not)?;
                },
                234 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.properties.insert(key, value);
                },
                242 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.additionalProperties)?;
                },
                250 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.patternProperties.insert(key, value);
                },
                258 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.dependencies.insert(key, value);
                },
                266 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.additionalItems)?;
                },
                274 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.definitions.insert(key, value);
                },
                282 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.externalDocs)?;
                },
                290 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.example)?;
                },
                296 => {
                    self.nullable = ::std::option::Option::Some(is.read_bool()?);
                },
                304 => {
                    self.xKubernetesPreserveUnknownFields = ::std::option::Option::Some(is.read_bool()?);
                },
                312 => {
                    self.xKubernetesEmbeddedResource = ::std::option::Option::Some(is.read_bool()?);
                },
                320 => {
                    self.xKubernetesIntOrString = ::std::option::Option::Some(is.read_bool()?);
                },
                330 => {
                    self.xKubernetesListMapKeys.push(is.read_string()?);
                },
                338 => {
                    self.xKubernetesListType = ::std::option::Option::Some(is.read_string()?);
                },
                346 => {
                    self.xKubernetesMapType = ::std::option::Option::Some(is.read_string()?);
                },
                354 => {
                    self.xKubernetesValidations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.schema.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.ref_.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.format.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.default.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.maximum {
            my_size += 1 + 8;
        }
        if let Some(v) = self.exclusiveMaximum {
            my_size += 1 + 1;
        }
        if let Some(v) = self.minimum {
            my_size += 1 + 8;
        }
        if let Some(v) = self.exclusiveMinimum {
            my_size += 1 + 1;
        }
        if let Some(v) = self.maxLength {
            my_size += ::protobuf::rt::int64_size(13, v);
        }
        if let Some(v) = self.minLength {
            my_size += ::protobuf::rt::int64_size(14, v);
        }
        if let Some(v) = self.pattern.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.maxItems {
            my_size += ::protobuf::rt::int64_size(16, v);
        }
        if let Some(v) = self.minItems {
            my_size += ::protobuf::rt::int64_size(17, v);
        }
        if let Some(v) = self.uniqueItems {
            my_size += 2 + 1;
        }
        if let Some(v) = self.multipleOf {
            my_size += 2 + 8;
        }
        for value in &self.enum_ {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.maxProperties {
            my_size += ::protobuf::rt::int64_size(21, v);
        }
        if let Some(v) = self.minProperties {
            my_size += ::protobuf::rt::int64_size(22, v);
        }
        for value in &self.required {
            my_size += ::protobuf::rt::string_size(23, &value);
        };
        if let Some(v) = self.items.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.allOf {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.oneOf {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.anyOf {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.not.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.properties {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.additionalProperties.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.patternProperties {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.dependencies {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.additionalItems.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.definitions {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.externalDocs.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.example.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.nullable {
            my_size += 2 + 1;
        }
        if let Some(v) = self.xKubernetesPreserveUnknownFields {
            my_size += 2 + 1;
        }
        if let Some(v) = self.xKubernetesEmbeddedResource {
            my_size += 2 + 1;
        }
        if let Some(v) = self.xKubernetesIntOrString {
            my_size += 2 + 1;
        }
        for value in &self.xKubernetesListMapKeys {
            my_size += ::protobuf::rt::string_size(41, &value);
        };
        if let Some(v) = self.xKubernetesListType.as_ref() {
            my_size += ::protobuf::rt::string_size(42, &v);
        }
        if let Some(v) = self.xKubernetesMapType.as_ref() {
            my_size += ::protobuf::rt::string_size(43, &v);
        }
        for value in &self.xKubernetesValidations {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.schema.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.ref_.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.type_.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.format.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.default.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.maximum {
            os.write_double(9, v)?;
        }
        if let Some(v) = self.exclusiveMaximum {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.minimum {
            os.write_double(11, v)?;
        }
        if let Some(v) = self.exclusiveMinimum {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.maxLength {
            os.write_int64(13, v)?;
        }
        if let Some(v) = self.minLength {
            os.write_int64(14, v)?;
        }
        if let Some(v) = self.pattern.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.maxItems {
            os.write_int64(16, v)?;
        }
        if let Some(v) = self.minItems {
            os.write_int64(17, v)?;
        }
        if let Some(v) = self.uniqueItems {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.multipleOf {
            os.write_double(19, v)?;
        }
        for v in &self.enum_ {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        };
        if let Some(v) = self.maxProperties {
            os.write_int64(21, v)?;
        }
        if let Some(v) = self.minProperties {
            os.write_int64(22, v)?;
        }
        for v in &self.required {
            os.write_string(23, &v)?;
        };
        if let Some(v) = self.items.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        for v in &self.allOf {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        };
        for v in &self.oneOf {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        };
        for v in &self.anyOf {
            ::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
        };
        if let Some(v) = self.not.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
        }
        for (k, v) in &self.properties {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(234)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.additionalProperties.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        for (k, v) in &self.patternProperties {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(250)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.dependencies {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(258)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.additionalItems.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
        }
        for (k, v) in &self.definitions {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(274)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.externalDocs.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(35, v, os)?;
        }
        if let Some(v) = self.example.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(36, v, os)?;
        }
        if let Some(v) = self.nullable {
            os.write_bool(37, v)?;
        }
        if let Some(v) = self.xKubernetesPreserveUnknownFields {
            os.write_bool(38, v)?;
        }
        if let Some(v) = self.xKubernetesEmbeddedResource {
            os.write_bool(39, v)?;
        }
        if let Some(v) = self.xKubernetesIntOrString {
            os.write_bool(40, v)?;
        }
        for v in &self.xKubernetesListMapKeys {
            os.write_string(41, &v)?;
        };
        if let Some(v) = self.xKubernetesListType.as_ref() {
            os.write_string(42, v)?;
        }
        if let Some(v) = self.xKubernetesMapType.as_ref() {
            os.write_string(43, v)?;
        }
        for v in &self.xKubernetesValidations {
            ::protobuf::rt::write_message_field_with_cached_size(44, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> JSONSchemaProps {
        JSONSchemaProps::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.schema = ::std::option::Option::None;
        self.ref_ = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.format = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.default.clear();
        self.maximum = ::std::option::Option::None;
        self.exclusiveMaximum = ::std::option::Option::None;
        self.minimum = ::std::option::Option::None;
        self.exclusiveMinimum = ::std::option::Option::None;
        self.maxLength = ::std::option::Option::None;
        self.minLength = ::std::option::Option::None;
        self.pattern = ::std::option::Option::None;
        self.maxItems = ::std::option::Option::None;
        self.minItems = ::std::option::Option::None;
        self.uniqueItems = ::std::option::Option::None;
        self.multipleOf = ::std::option::Option::None;
        self.enum_.clear();
        self.maxProperties = ::std::option::Option::None;
        self.minProperties = ::std::option::Option::None;
        self.required.clear();
        self.items.clear();
        self.allOf.clear();
        self.oneOf.clear();
        self.anyOf.clear();
        self.not.clear();
        self.properties.clear();
        self.additionalProperties.clear();
        self.patternProperties.clear();
        self.dependencies.clear();
        self.additionalItems.clear();
        self.definitions.clear();
        self.externalDocs.clear();
        self.example.clear();
        self.nullable = ::std::option::Option::None;
        self.xKubernetesPreserveUnknownFields = ::std::option::Option::None;
        self.xKubernetesEmbeddedResource = ::std::option::Option::None;
        self.xKubernetesIntOrString = ::std::option::Option::None;
        self.xKubernetesListMapKeys.clear();
        self.xKubernetesListType = ::std::option::Option::None;
        self.xKubernetesMapType = ::std::option::Option::None;
        self.xKubernetesValidations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static JSONSchemaProps {
        static instance: ::protobuf::rt::Lazy<JSONSchemaProps> = ::protobuf::rt::Lazy::new();
        instance.get(JSONSchemaProps::new)
    }
}

impl ::protobuf::MessageFull for JSONSchemaProps {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("JSONSchemaProps").unwrap()).clone()
    }
}

impl ::std::fmt::Display for JSONSchemaProps {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JSONSchemaProps {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaPropsOrArray)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct JSONSchemaPropsOrArray {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaPropsOrArray.schema)
    pub schema: ::protobuf::MessageField<JSONSchemaProps>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaPropsOrArray.jSONSchemas)
    pub jSONSchemas: ::std::vec::Vec<JSONSchemaProps>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaPropsOrArray.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a JSONSchemaPropsOrArray {
    fn default() -> &'a JSONSchemaPropsOrArray {
        <JSONSchemaPropsOrArray as ::protobuf::Message>::default_instance()
    }
}

impl JSONSchemaPropsOrArray {
    pub fn new() -> JSONSchemaPropsOrArray {
        ::std::default::Default::default()
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps schema = 1;

    pub fn schema(&self) -> &JSONSchemaProps {
        self.schema.as_ref().unwrap_or_else(|| <JSONSchemaProps as ::protobuf::Message>::default_instance())
    }

    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    pub fn has_schema(&self) -> bool {
        self.schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: JSONSchemaProps) {
        self.schema = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut JSONSchemaProps {
        self.schema.mut_or_insert_default()
    }

    // Take field
    pub fn take_schema(&mut self) -> JSONSchemaProps {
        self.schema.take().unwrap_or_else(|| JSONSchemaProps::new())
    }

    // repeated .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps jSONSchemas = 2;

    pub fn jSONSchemas(&self) -> &[JSONSchemaProps] {
        &self.jSONSchemas
    }

    pub fn clear_jSONSchemas(&mut self) {
        self.jSONSchemas.clear();
    }

    // Param is passed by value, moved
    pub fn set_jSONSchemas(&mut self, v: ::std::vec::Vec<JSONSchemaProps>) {
        self.jSONSchemas = v;
    }

    // Mutable pointer to the field.
    pub fn mut_jSONSchemas(&mut self) -> &mut ::std::vec::Vec<JSONSchemaProps> {
        &mut self.jSONSchemas
    }

    // Take field
    pub fn take_jSONSchemas(&mut self) -> ::std::vec::Vec<JSONSchemaProps> {
        ::std::mem::replace(&mut self.jSONSchemas, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, JSONSchemaProps>(
            "schema",
            |m: &JSONSchemaPropsOrArray| { &m.schema },
            |m: &mut JSONSchemaPropsOrArray| { &mut m.schema },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "jSONSchemas",
            |m: &JSONSchemaPropsOrArray| { &m.jSONSchemas },
            |m: &mut JSONSchemaPropsOrArray| { &mut m.jSONSchemas },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<JSONSchemaPropsOrArray>(
            "JSONSchemaPropsOrArray",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for JSONSchemaPropsOrArray {
    const NAME: &'static str = "JSONSchemaPropsOrArray";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.schema)?;
                },
                18 => {
                    self.jSONSchemas.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.schema.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.jSONSchemas {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.schema.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.jSONSchemas {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> JSONSchemaPropsOrArray {
        JSONSchemaPropsOrArray::new()
    }

    fn clear(&mut self) {
        self.schema.clear();
        self.jSONSchemas.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static JSONSchemaPropsOrArray {
        static instance: JSONSchemaPropsOrArray = JSONSchemaPropsOrArray {
            schema: ::protobuf::MessageField::none(),
            jSONSchemas: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for JSONSchemaPropsOrArray {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("JSONSchemaPropsOrArray").unwrap()).clone()
    }
}

impl ::std::fmt::Display for JSONSchemaPropsOrArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JSONSchemaPropsOrArray {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaPropsOrBool)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct JSONSchemaPropsOrBool {
    // message fields
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaPropsOrBool.allows)
    pub allows: ::std::option::Option<bool>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaPropsOrBool.schema)
    pub schema: ::protobuf::MessageField<JSONSchemaProps>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaPropsOrBool.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a JSONSchemaPropsOrBool {
    fn default() -> &'a JSONSchemaPropsOrBool {
        <JSONSchemaPropsOrBool as ::protobuf::Message>::default_instance()
    }
}

impl JSONSchemaPropsOrBool {
    pub fn new() -> JSONSchemaPropsOrBool {
        ::std::default::Default::default()
    }

    // optional bool allows = 1;

    pub fn allows(&self) -> bool {
        self.allows.unwrap_or(false)
    }

    pub fn clear_allows(&mut self) {
        self.allows = ::std::option::Option::None;
    }

    pub fn has_allows(&self) -> bool {
        self.allows.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allows(&mut self, v: bool) {
        self.allows = ::std::option::Option::Some(v);
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps schema = 2;

    pub fn schema(&self) -> &JSONSchemaProps {
        self.schema.as_ref().unwrap_or_else(|| <JSONSchemaProps as ::protobuf::Message>::default_instance())
    }

    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    pub fn has_schema(&self) -> bool {
        self.schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: JSONSchemaProps) {
        self.schema = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut JSONSchemaProps {
        self.schema.mut_or_insert_default()
    }

    // Take field
    pub fn take_schema(&mut self) -> JSONSchemaProps {
        self.schema.take().unwrap_or_else(|| JSONSchemaProps::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allows",
            |m: &JSONSchemaPropsOrBool| { &m.allows },
            |m: &mut JSONSchemaPropsOrBool| { &mut m.allows },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, JSONSchemaProps>(
            "schema",
            |m: &JSONSchemaPropsOrBool| { &m.schema },
            |m: &mut JSONSchemaPropsOrBool| { &mut m.schema },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<JSONSchemaPropsOrBool>(
            "JSONSchemaPropsOrBool",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for JSONSchemaPropsOrBool {
    const NAME: &'static str = "JSONSchemaPropsOrBool";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.allows = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.schema)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.allows {
            my_size += 1 + 1;
        }
        if let Some(v) = self.schema.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.allows {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.schema.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> JSONSchemaPropsOrBool {
        JSONSchemaPropsOrBool::new()
    }

    fn clear(&mut self) {
        self.allows = ::std::option::Option::None;
        self.schema.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static JSONSchemaPropsOrBool {
        static instance: JSONSchemaPropsOrBool = JSONSchemaPropsOrBool {
            allows: ::std::option::Option::None,
            schema: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for JSONSchemaPropsOrBool {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("JSONSchemaPropsOrBool").unwrap()).clone()
    }
}

impl ::std::fmt::Display for JSONSchemaPropsOrBool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JSONSchemaPropsOrBool {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaPropsOrStringArray)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct JSONSchemaPropsOrStringArray {
    // message fields
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaPropsOrStringArray.schema)
    pub schema: ::protobuf::MessageField<JSONSchemaProps>,
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaPropsOrStringArray.property)
    pub property: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaPropsOrStringArray.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a JSONSchemaPropsOrStringArray {
    fn default() -> &'a JSONSchemaPropsOrStringArray {
        <JSONSchemaPropsOrStringArray as ::protobuf::Message>::default_instance()
    }
}

impl JSONSchemaPropsOrStringArray {
    pub fn new() -> JSONSchemaPropsOrStringArray {
        ::std::default::Default::default()
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps schema = 1;

    pub fn schema(&self) -> &JSONSchemaProps {
        self.schema.as_ref().unwrap_or_else(|| <JSONSchemaProps as ::protobuf::Message>::default_instance())
    }

    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    pub fn has_schema(&self) -> bool {
        self.schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: JSONSchemaProps) {
        self.schema = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut JSONSchemaProps {
        self.schema.mut_or_insert_default()
    }

    // Take field
    pub fn take_schema(&mut self) -> JSONSchemaProps {
        self.schema.take().unwrap_or_else(|| JSONSchemaProps::new())
    }

    // repeated string property = 2;

    pub fn property(&self) -> &[::std::string::String] {
        &self.property
    }

    pub fn clear_property(&mut self) {
        self.property.clear();
    }

    // Param is passed by value, moved
    pub fn set_property(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.property = v;
    }

    // Mutable pointer to the field.
    pub fn mut_property(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.property
    }

    // Take field
    pub fn take_property(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.property, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, JSONSchemaProps>(
            "schema",
            |m: &JSONSchemaPropsOrStringArray| { &m.schema },
            |m: &mut JSONSchemaPropsOrStringArray| { &mut m.schema },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "property",
            |m: &JSONSchemaPropsOrStringArray| { &m.property },
            |m: &mut JSONSchemaPropsOrStringArray| { &mut m.property },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<JSONSchemaPropsOrStringArray>(
            "JSONSchemaPropsOrStringArray",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for JSONSchemaPropsOrStringArray {
    const NAME: &'static str = "JSONSchemaPropsOrStringArray";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.schema)?;
                },
                18 => {
                    self.property.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.schema.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.property {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.schema.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.property {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> JSONSchemaPropsOrStringArray {
        JSONSchemaPropsOrStringArray::new()
    }

    fn clear(&mut self) {
        self.schema.clear();
        self.property.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static JSONSchemaPropsOrStringArray {
        static instance: JSONSchemaPropsOrStringArray = JSONSchemaPropsOrStringArray {
            schema: ::protobuf::MessageField::none(),
            property: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for JSONSchemaPropsOrStringArray {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("JSONSchemaPropsOrStringArray").unwrap()).clone()
    }
}

impl ::std::fmt::Display for JSONSchemaPropsOrStringArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JSONSchemaPropsOrStringArray {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.SelectableField)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SelectableField {
    // message fields
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.SelectableField.jsonPath)
    pub jsonPath: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.SelectableField.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SelectableField {
    fn default() -> &'a SelectableField {
        <SelectableField as ::protobuf::Message>::default_instance()
    }
}

impl SelectableField {
    pub fn new() -> SelectableField {
        ::std::default::Default::default()
    }

    // optional string jsonPath = 1;

    pub fn jsonPath(&self) -> &str {
        match self.jsonPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_jsonPath(&mut self) {
        self.jsonPath = ::std::option::Option::None;
    }

    pub fn has_jsonPath(&self) -> bool {
        self.jsonPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jsonPath(&mut self, v: ::std::string::String) {
        self.jsonPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jsonPath(&mut self) -> &mut ::std::string::String {
        if self.jsonPath.is_none() {
            self.jsonPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.jsonPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_jsonPath(&mut self) -> ::std::string::String {
        self.jsonPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jsonPath",
            |m: &SelectableField| { &m.jsonPath },
            |m: &mut SelectableField| { &mut m.jsonPath },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelectableField>(
            "SelectableField",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SelectableField {
    const NAME: &'static str = "SelectableField";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.jsonPath = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.jsonPath.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.jsonPath.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SelectableField {
        SelectableField::new()
    }

    fn clear(&mut self) {
        self.jsonPath = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SelectableField {
        static instance: SelectableField = SelectableField {
            jsonPath: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SelectableField {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SelectableField").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SelectableField {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelectableField {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ServiceReference)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServiceReference {
    // message fields
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ServiceReference.namespace)
    pub namespace: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ServiceReference.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ServiceReference.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ServiceReference.port)
    pub port: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ServiceReference.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceReference {
    fn default() -> &'a ServiceReference {
        <ServiceReference as ::protobuf::Message>::default_instance()
    }
}

impl ServiceReference {
    pub fn new() -> ServiceReference {
        ::std::default::Default::default()
    }

    // optional string namespace = 1;

    pub fn namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_namespace(&mut self) {
        self.namespace = ::std::option::Option::None;
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string path = 3;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 port = 4;

    pub fn port(&self) -> i32 {
        self.port.unwrap_or(0)
    }

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "namespace",
            |m: &ServiceReference| { &m.namespace },
            |m: &mut ServiceReference| { &mut m.namespace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ServiceReference| { &m.name },
            |m: &mut ServiceReference| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &ServiceReference| { &m.path },
            |m: &mut ServiceReference| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "port",
            |m: &ServiceReference| { &m.port },
            |m: &mut ServiceReference| { &mut m.port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServiceReference>(
            "ServiceReference",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServiceReference {
    const NAME: &'static str = "ServiceReference";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.namespace = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.port = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.namespace.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.port {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceReference {
        ServiceReference::new()
    }

    fn clear(&mut self) {
        self.namespace = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.path = ::std::option::Option::None;
        self.port = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceReference {
        static instance: ServiceReference = ServiceReference {
            namespace: ::std::option::Option::None,
            name: ::std::option::Option::None,
            path: ::std::option::Option::None,
            port: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServiceReference {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceReference").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceReference {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ValidationRule)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidationRule {
    // message fields
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ValidationRule.rule)
    pub rule: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ValidationRule.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ValidationRule.messageExpression)
    pub messageExpression: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ValidationRule.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ValidationRule.fieldPath)
    pub fieldPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ValidationRule.optionalOldSelf)
    pub optionalOldSelf: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ValidationRule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidationRule {
    fn default() -> &'a ValidationRule {
        <ValidationRule as ::protobuf::Message>::default_instance()
    }
}

impl ValidationRule {
    pub fn new() -> ValidationRule {
        ::std::default::Default::default()
    }

    // optional string rule = 1;

    pub fn rule(&self) -> &str {
        match self.rule.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_rule(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_rule(&self) -> bool {
        self.rule.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rule(&mut self, v: ::std::string::String) {
        self.rule = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rule(&mut self) -> &mut ::std::string::String {
        if self.rule.is_none() {
            self.rule = ::std::option::Option::Some(::std::string::String::new());
        }
        self.rule.as_mut().unwrap()
    }

    // Take field
    pub fn take_rule(&mut self) -> ::std::string::String {
        self.rule.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string messageExpression = 3;

    pub fn messageExpression(&self) -> &str {
        match self.messageExpression.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_messageExpression(&mut self) {
        self.messageExpression = ::std::option::Option::None;
    }

    pub fn has_messageExpression(&self) -> bool {
        self.messageExpression.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageExpression(&mut self, v: ::std::string::String) {
        self.messageExpression = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messageExpression(&mut self) -> &mut ::std::string::String {
        if self.messageExpression.is_none() {
            self.messageExpression = ::std::option::Option::Some(::std::string::String::new());
        }
        self.messageExpression.as_mut().unwrap()
    }

    // Take field
    pub fn take_messageExpression(&mut self) -> ::std::string::String {
        self.messageExpression.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reason = 4;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fieldPath = 5;

    pub fn fieldPath(&self) -> &str {
        match self.fieldPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fieldPath(&mut self) {
        self.fieldPath = ::std::option::Option::None;
    }

    pub fn has_fieldPath(&self) -> bool {
        self.fieldPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldPath(&mut self, v: ::std::string::String) {
        self.fieldPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldPath(&mut self) -> &mut ::std::string::String {
        if self.fieldPath.is_none() {
            self.fieldPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fieldPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldPath(&mut self) -> ::std::string::String {
        self.fieldPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool optionalOldSelf = 6;

    pub fn optionalOldSelf(&self) -> bool {
        self.optionalOldSelf.unwrap_or(false)
    }

    pub fn clear_optionalOldSelf(&mut self) {
        self.optionalOldSelf = ::std::option::Option::None;
    }

    pub fn has_optionalOldSelf(&self) -> bool {
        self.optionalOldSelf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optionalOldSelf(&mut self, v: bool) {
        self.optionalOldSelf = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rule",
            |m: &ValidationRule| { &m.rule },
            |m: &mut ValidationRule| { &mut m.rule },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &ValidationRule| { &m.message },
            |m: &mut ValidationRule| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "messageExpression",
            |m: &ValidationRule| { &m.messageExpression },
            |m: &mut ValidationRule| { &mut m.messageExpression },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &ValidationRule| { &m.reason },
            |m: &mut ValidationRule| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fieldPath",
            |m: &ValidationRule| { &m.fieldPath },
            |m: &mut ValidationRule| { &mut m.fieldPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "optionalOldSelf",
            |m: &ValidationRule| { &m.optionalOldSelf },
            |m: &mut ValidationRule| { &mut m.optionalOldSelf },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidationRule>(
            "ValidationRule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidationRule {
    const NAME: &'static str = "ValidationRule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rule = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.messageExpression = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.fieldPath = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.optionalOldSelf = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rule.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.messageExpression.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.fieldPath.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.optionalOldSelf {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rule.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.messageExpression.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.fieldPath.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.optionalOldSelf {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidationRule {
        ValidationRule::new()
    }

    fn clear(&mut self) {
        self.rule = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.messageExpression = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.fieldPath = ::std::option::Option::None;
        self.optionalOldSelf = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidationRule {
        static instance: ValidationRule = ValidationRule {
            rule: ::std::option::Option::None,
            message: ::std::option::Option::None,
            messageExpression: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            fieldPath: ::std::option::Option::None,
            optionalOldSelf: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidationRule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidationRule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidationRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidationRule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.WebhookClientConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebhookClientConfig {
    // message fields
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.WebhookClientConfig.url)
    pub url: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.WebhookClientConfig.service)
    pub service: ::protobuf::MessageField<ServiceReference>,
    // @@protoc_insertion_point(field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.WebhookClientConfig.caBundle)
    pub caBundle: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.WebhookClientConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebhookClientConfig {
    fn default() -> &'a WebhookClientConfig {
        <WebhookClientConfig as ::protobuf::Message>::default_instance()
    }
}

impl WebhookClientConfig {
    pub fn new() -> WebhookClientConfig {
        ::std::default::Default::default()
    }

    // optional string url = 3;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.ServiceReference service = 1;

    pub fn service(&self) -> &ServiceReference {
        self.service.as_ref().unwrap_or_else(|| <ServiceReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    pub fn has_service(&self) -> bool {
        self.service.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ServiceReference) {
        self.service = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ServiceReference {
        self.service.mut_or_insert_default()
    }

    // Take field
    pub fn take_service(&mut self) -> ServiceReference {
        self.service.take().unwrap_or_else(|| ServiceReference::new())
    }

    // optional bytes caBundle = 2;

    pub fn caBundle(&self) -> &[u8] {
        match self.caBundle.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_caBundle(&mut self) {
        self.caBundle = ::std::option::Option::None;
    }

    pub fn has_caBundle(&self) -> bool {
        self.caBundle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caBundle(&mut self, v: ::std::vec::Vec<u8>) {
        self.caBundle = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caBundle(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.caBundle.is_none() {
            self.caBundle = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.caBundle.as_mut().unwrap()
    }

    // Take field
    pub fn take_caBundle(&mut self) -> ::std::vec::Vec<u8> {
        self.caBundle.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &WebhookClientConfig| { &m.url },
            |m: &mut WebhookClientConfig| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ServiceReference>(
            "service",
            |m: &WebhookClientConfig| { &m.service },
            |m: &mut WebhookClientConfig| { &mut m.service },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caBundle",
            |m: &WebhookClientConfig| { &m.caBundle },
            |m: &mut WebhookClientConfig| { &mut m.caBundle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebhookClientConfig>(
            "WebhookClientConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebhookClientConfig {
    const NAME: &'static str = "WebhookClientConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.service)?;
                },
                18 => {
                    self.caBundle = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.caBundle.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.service.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.caBundle.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebhookClientConfig {
        WebhookClientConfig::new()
    }

    fn clear(&mut self) {
        self.url = ::std::option::Option::None;
        self.service.clear();
        self.caBundle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebhookClientConfig {
        static instance: WebhookClientConfig = WebhookClientConfig {
            url: ::std::option::Option::None,
            service: ::protobuf::MessageField::none(),
            caBundle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebhookClientConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebhookClientConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebhookClientConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebhookClientConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \nFapiextensions-apiserver/pkg/apis/apiextensions/v1beta1/generated.prot\
    o\x126apiextensions_apiserver.pkg.apis.apiextensions.v1beta1\x1a-apimach\
    inery/pkg/apis/meta/v1/generated.proto\x1a(apimachinery/pkg/runtime/gene\
    rated.proto\x1a/apimachinery/pkg/runtime/schema/generated.proto\"\x95\
    \x01\n\x11ConversionRequest\x12\x10\n\x03uid\x18\x01\x20\x01(\tR\x03uid\
    \x12,\n\x11desiredAPIVersion\x18\x02\x20\x01(\tR\x11desiredAPIVersion\
    \x12@\n\x07objects\x18\x03\x20\x03(\x0b2&.apimachinery.pkg.runtime.RawEx\
    tensionR\x07objects\"\xb9\x01\n\x12ConversionResponse\x12\x10\n\x03uid\
    \x18\x01\x20\x01(\tR\x03uid\x12R\n\x10convertedObjects\x18\x02\x20\x03(\
    \x0b2&.apimachinery.pkg.runtime.RawExtensionR\x10convertedObjects\x12=\n\
    \x06result\x18\x03\x20\x01(\x0b2%.apimachinery.pkg.apis.meta.v1.StatusR\
    \x06result\"\xdf\x01\n\x10ConversionReview\x12c\n\x07request\x18\x01\x20\
    \x01(\x0b2I.apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.Conve\
    rsionRequestR\x07request\x12f\n\x08response\x18\x02\x20\x01(\x0b2J.apiex\
    tensions_apiserver.pkg.apis.apiextensions.v1beta1.ConversionResponseR\
    \x08response\"\xba\x01\n\x1eCustomResourceColumnDefinition\x12\x12\n\x04\
    name\x18\x01\x20\x01(\tR\x04name\x12\x12\n\x04type\x18\x02\x20\x01(\tR\
    \x04type\x12\x16\n\x06format\x18\x03\x20\x01(\tR\x06format\x12\x20\n\x0b\
    description\x18\x04\x20\x01(\tR\x0bdescription\x12\x1a\n\x08priority\x18\
    \x05\x20\x01(\x05R\x08priority\x12\x1a\n\x08JSONPath\x18\x06\x20\x01(\tR\
    \x08JSONPath\"\xf1\x01\n\x18CustomResourceConversion\x12\x1a\n\x08strate\
    gy\x18\x01\x20\x01(\tR\x08strategy\x12}\n\x13webhookClientConfig\x18\x02\
    \x20\x01(\x0b2K.apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.W\
    ebhookClientConfigR\x13webhookClientConfig\x12:\n\x18conversionReviewVer\
    sions\x18\x03\x20\x03(\tR\x18conversionReviewVersions\"\xbb\x02\n\x18Cus\
    tomResourceDefinition\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachi\
    nery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12h\n\x04spec\x18\x02\x20\
    \x01(\x0b2T.apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.Custo\
    mResourceDefinitionSpecR\x04spec\x12n\n\x06status\x18\x03\x20\x01(\x0b2V\
    .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDe\
    finitionStatusR\x06status\"\xd6\x01\n!CustomResourceDefinitionCondition\
    \x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12\x16\n\x06status\x18\
    \x02\x20\x01(\tR\x06status\x12S\n\x12lastTransitionTime\x18\x03\x20\x01(\
    \x0b2#.apimachinery.pkg.apis.meta.v1.TimeR\x12lastTransitionTime\x12\x16\
    \n\x06reason\x18\x04\x20\x01(\tR\x06reason\x12\x18\n\x07message\x18\x05\
    \x20\x01(\tR\x07message\"\xcb\x01\n\x1cCustomResourceDefinitionList\x12C\
    \n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.List\
    MetaR\x08metadata\x12f\n\x05items\x18\x02\x20\x03(\x0b2P.apiextensions_a\
    piserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionR\x05ite\
    ms\"\xc3\x01\n\x1dCustomResourceDefinitionNames\x12\x16\n\x06plural\x18\
    \x01\x20\x01(\tR\x06plural\x12\x1a\n\x08singular\x18\x02\x20\x01(\tR\x08\
    singular\x12\x1e\n\nshortNames\x18\x03\x20\x03(\tR\nshortNames\x12\x12\n\
    \x04kind\x18\x04\x20\x01(\tR\x04kind\x12\x1a\n\x08listKind\x18\x05\x20\
    \x01(\tR\x08listKind\x12\x1e\n\ncategories\x18\x06\x20\x03(\tR\ncategori\
    es\"\xe2\x07\n\x1cCustomResourceDefinitionSpec\x12\x14\n\x05group\x18\
    \x01\x20\x01(\tR\x05group\x12\x18\n\x07version\x18\x02\x20\x01(\tR\x07ve\
    rsion\x12k\n\x05names\x18\x03\x20\x01(\x0b2U.apiextensions_apiserver.pkg\
    .apis.apiextensions.v1beta1.CustomResourceDefinitionNamesR\x05names\x12\
    \x14\n\x05scope\x18\x04\x20\x01(\tR\x05scope\x12p\n\nvalidation\x18\x05\
    \x20\x01(\x0b2P.apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.C\
    ustomResourceValidationR\nvalidation\x12v\n\x0csubresources\x18\x06\x20\
    \x01(\x0b2R.apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.Custo\
    mResourceSubresourcesR\x0csubresources\x12s\n\x08versions\x18\x07\x20\
    \x03(\x0b2W.apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.Custo\
    mResourceDefinitionVersionR\x08versions\x12\x92\x01\n\x18additionalPrint\
    erColumns\x18\x08\x20\x03(\x0b2V.apiextensions_apiserver.pkg.apis.apiext\
    ensions.v1beta1.CustomResourceColumnDefinitionR\x18additionalPrinterColu\
    mns\x12s\n\x10selectableFields\x18\x0b\x20\x03(\x0b2G.apiextensions_apis\
    erver.pkg.apis.apiextensions.v1beta1.SelectableFieldR\x10selectableField\
    s\x12p\n\nconversion\x18\t\x20\x01(\x0b2P.apiextensions_apiserver.pkg.ap\
    is.apiextensions.v1beta1.CustomResourceConversionR\nconversion\x124\n\
    \x15preserveUnknownFields\x18\n\x20\x01(\x08R\x15preserveUnknownFields\"\
    \xc0\x02\n\x1eCustomResourceDefinitionStatus\x12y\n\nconditions\x18\x01\
    \x20\x03(\x0b2Y.apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.C\
    ustomResourceDefinitionConditionR\nconditions\x12{\n\racceptedNames\x18\
    \x02\x20\x01(\x0b2U.apiextensions_apiserver.pkg.apis.apiextensions.v1bet\
    a1.CustomResourceDefinitionNamesR\racceptedNames\x12&\n\x0estoredVersion\
    s\x18\x03\x20\x03(\tR\x0estoredVersions\"\xa3\x05\n\x1fCustomResourceDef\
    initionVersion\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x16\n\
    \x06served\x18\x02\x20\x01(\x08R\x06served\x12\x18\n\x07storage\x18\x03\
    \x20\x01(\x08R\x07storage\x12\x1e\n\ndeprecated\x18\x07\x20\x01(\x08R\nd\
    eprecated\x12.\n\x12deprecationWarning\x18\x08\x20\x01(\tR\x12deprecatio\
    nWarning\x12h\n\x06schema\x18\x04\x20\x01(\x0b2P.apiextensions_apiserver\
    .pkg.apis.apiextensions.v1beta1.CustomResourceValidationR\x06schema\x12v\
    \n\x0csubresources\x18\x05\x20\x01(\x0b2R.apiextensions_apiserver.pkg.ap\
    is.apiextensions.v1beta1.CustomResourceSubresourcesR\x0csubresources\x12\
    \x92\x01\n\x18additionalPrinterColumns\x18\x06\x20\x03(\x0b2V.apiextensi\
    ons_apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceColumnDefinit\
    ionR\x18additionalPrinterColumns\x12s\n\x10selectableFields\x18\t\x20\
    \x03(\x0b2G.apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.Selec\
    tableFieldR\x10selectableFields\"\xaa\x01\n\x1eCustomResourceSubresource\
    Scale\x12*\n\x10specReplicasPath\x18\x01\x20\x01(\tR\x10specReplicasPath\
    \x12.\n\x12statusReplicasPath\x18\x02\x20\x01(\tR\x12statusReplicasPath\
    \x12,\n\x11labelSelectorPath\x18\x03\x20\x01(\tR\x11labelSelectorPath\"!\
    \n\x1fCustomResourceSubresourceStatus\"\xfb\x01\n\x1aCustomResourceSubre\
    sources\x12o\n\x06status\x18\x01\x20\x01(\x0b2W.apiextensions_apiserver.\
    pkg.apis.apiextensions.v1beta1.CustomResourceSubresourceStatusR\x06statu\
    s\x12l\n\x05scale\x18\x02\x20\x01(\x0b2V.apiextensions_apiserver.pkg.api\
    s.apiextensions.v1beta1.CustomResourceSubresourceScaleR\x05scale\"\x8d\
    \x01\n\x18CustomResourceValidation\x12q\n\x0fopenAPIV3Schema\x18\x01\x20\
    \x01(\x0b2G.apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONS\
    chemaPropsR\x0fopenAPIV3Schema\"K\n\x15ExternalDocumentation\x12\x20\n\
    \x0bdescription\x18\x01\x20\x01(\tR\x0bdescription\x12\x10\n\x03url\x18\
    \x02\x20\x01(\tR\x03url\"\x18\n\x04JSON\x12\x10\n\x03raw\x18\x01\x20\x01\
    (\x0cR\x03raw\"\xfd\x19\n\x0fJSONSchemaProps\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\tR\x02id\x12\x16\n\x06schema\x18\x02\x20\x01(\tR\x06schema\x12\x10\
    \n\x03ref\x18\x03\x20\x01(\tR\x03ref\x12\x20\n\x0bdescription\x18\x04\
    \x20\x01(\tR\x0bdescription\x12\x12\n\x04type\x18\x05\x20\x01(\tR\x04typ\
    e\x12\x16\n\x06format\x18\x06\x20\x01(\tR\x06format\x12\x14\n\x05title\
    \x18\x07\x20\x01(\tR\x05title\x12V\n\x07default\x18\x08\x20\x01(\x0b2<.a\
    piextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONR\x07default\
    \x12\x18\n\x07maximum\x18\t\x20\x01(\x01R\x07maximum\x12*\n\x10exclusive\
    Maximum\x18\n\x20\x01(\x08R\x10exclusiveMaximum\x12\x18\n\x07minimum\x18\
    \x0b\x20\x01(\x01R\x07minimum\x12*\n\x10exclusiveMinimum\x18\x0c\x20\x01\
    (\x08R\x10exclusiveMinimum\x12\x1c\n\tmaxLength\x18\r\x20\x01(\x03R\tmax\
    Length\x12\x1c\n\tminLength\x18\x0e\x20\x01(\x03R\tminLength\x12\x18\n\
    \x07pattern\x18\x0f\x20\x01(\tR\x07pattern\x12\x1a\n\x08maxItems\x18\x10\
    \x20\x01(\x03R\x08maxItems\x12\x1a\n\x08minItems\x18\x11\x20\x01(\x03R\
    \x08minItems\x12\x20\n\x0buniqueItems\x18\x12\x20\x01(\x08R\x0buniqueIte\
    ms\x12\x1e\n\nmultipleOf\x18\x13\x20\x01(\x01R\nmultipleOf\x12P\n\x04enu\
    m\x18\x14\x20\x03(\x0b2<.apiextensions_apiserver.pkg.apis.apiextensions.\
    v1beta1.JSONR\x04enum\x12$\n\rmaxProperties\x18\x15\x20\x01(\x03R\rmaxPr\
    operties\x12$\n\rminProperties\x18\x16\x20\x01(\x03R\rminProperties\x12\
    \x1a\n\x08required\x18\x17\x20\x03(\tR\x08required\x12d\n\x05items\x18\
    \x18\x20\x01(\x0b2N.apiextensions_apiserver.pkg.apis.apiextensions.v1bet\
    a1.JSONSchemaPropsOrArrayR\x05items\x12]\n\x05allOf\x18\x19\x20\x03(\x0b\
    2G.apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProp\
    sR\x05allOf\x12]\n\x05oneOf\x18\x1a\x20\x03(\x0b2G.apiextensions_apiserv\
    er.pkg.apis.apiextensions.v1beta1.JSONSchemaPropsR\x05oneOf\x12]\n\x05an\
    yOf\x18\x1b\x20\x03(\x0b2G.apiextensions_apiserver.pkg.apis.apiextension\
    s.v1beta1.JSONSchemaPropsR\x05anyOf\x12Y\n\x03not\x18\x1c\x20\x01(\x0b2G\
    .apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaPropsR\
    \x03not\x12w\n\nproperties\x18\x1d\x20\x03(\x0b2W.apiextensions_apiserve\
    r.pkg.apis.apiextensions.v1beta1.JSONSchemaProps.PropertiesEntryR\nprope\
    rties\x12\x81\x01\n\x14additionalProperties\x18\x1e\x20\x01(\x0b2M.apiex\
    tensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaPropsOrBoolR\
    \x14additionalProperties\x12\x8c\x01\n\x11patternProperties\x18\x1f\x20\
    \x03(\x0b2^.apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONS\
    chemaProps.PatternPropertiesEntryR\x11patternProperties\x12}\n\x0cdepend\
    encies\x18\x20\x20\x03(\x0b2Y.apiextensions_apiserver.pkg.apis.apiextens\
    ions.v1beta1.JSONSchemaProps.DependenciesEntryR\x0cdependencies\x12w\n\
    \x0fadditionalItems\x18!\x20\x01(\x0b2M.apiextensions_apiserver.pkg.apis\
    .apiextensions.v1beta1.JSONSchemaPropsOrBoolR\x0fadditionalItems\x12z\n\
    \x0bdefinitions\x18\"\x20\x03(\x0b2X.apiextensions_apiserver.pkg.apis.ap\
    iextensions.v1beta1.JSONSchemaProps.DefinitionsEntryR\x0bdefinitions\x12\
    q\n\x0cexternalDocs\x18#\x20\x01(\x0b2M.apiextensions_apiserver.pkg.apis\
    .apiextensions.v1beta1.ExternalDocumentationR\x0cexternalDocs\x12V\n\x07\
    example\x18$\x20\x01(\x0b2<.apiextensions_apiserver.pkg.apis.apiextensio\
    ns.v1beta1.JSONR\x07example\x12\x1a\n\x08nullable\x18%\x20\x01(\x08R\x08\
    nullable\x12J\n\x20xKubernetesPreserveUnknownFields\x18&\x20\x01(\x08R\
    \x20xKubernetesPreserveUnknownFields\x12@\n\x1bxKubernetesEmbeddedResour\
    ce\x18'\x20\x01(\x08R\x1bxKubernetesEmbeddedResource\x126\n\x16xKubernet\
    esIntOrString\x18(\x20\x01(\x08R\x16xKubernetesIntOrString\x126\n\x16xKu\
    bernetesListMapKeys\x18)\x20\x03(\tR\x16xKubernetesListMapKeys\x120\n\
    \x13xKubernetesListType\x18*\x20\x01(\tR\x13xKubernetesListType\x12.\n\
    \x12xKubernetesMapType\x18+\x20\x01(\tR\x12xKubernetesMapType\x12~\n\x16\
    xKubernetesValidations\x18,\x20\x03(\x0b2F.apiextensions_apiserver.pkg.a\
    pis.apiextensions.v1beta1.ValidationRuleR\x16xKubernetesValidations\x1a\
    \x86\x01\n\x0fPropertiesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03ke\
    y\x12]\n\x05value\x18\x02\x20\x01(\x0b2G.apiextensions_apiserver.pkg.api\
    s.apiextensions.v1beta1.JSONSchemaPropsR\x05value:\x028\x01\x1a\x8d\x01\
    \n\x16PatternPropertiesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12]\n\x05value\x18\x02\x20\x01(\x0b2G.apiextensions_apiserver.pkg.apis\
    .apiextensions.v1beta1.JSONSchemaPropsR\x05value:\x028\x01\x1a\x95\x01\n\
    \x11DependenciesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12j\n\
    \x05value\x18\x02\x20\x01(\x0b2T.apiextensions_apiserver.pkg.apis.apiext\
    ensions.v1beta1.JSONSchemaPropsOrStringArrayR\x05value:\x028\x01\x1a\x87\
    \x01\n\x10DefinitionsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12]\n\x05value\x18\x02\x20\x01(\x0b2G.apiextensions_apiserver.pkg.apis\
    .apiextensions.v1beta1.JSONSchemaPropsR\x05value:\x028\x01\"\xe4\x01\n\
    \x16JSONSchemaPropsOrArray\x12_\n\x06schema\x18\x01\x20\x01(\x0b2G.apiex\
    tensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaPropsR\x06sc\
    hema\x12i\n\x0bjSONSchemas\x18\x02\x20\x03(\x0b2G.apiextensions_apiserve\
    r.pkg.apis.apiextensions.v1beta1.JSONSchemaPropsR\x0bjSONSchemas\"\x90\
    \x01\n\x15JSONSchemaPropsOrBool\x12\x16\n\x06allows\x18\x01\x20\x01(\x08\
    R\x06allows\x12_\n\x06schema\x18\x02\x20\x01(\x0b2G.apiextensions_apiser\
    ver.pkg.apis.apiextensions.v1beta1.JSONSchemaPropsR\x06schema\"\x9b\x01\
    \n\x1cJSONSchemaPropsOrStringArray\x12_\n\x06schema\x18\x01\x20\x01(\x0b\
    2G.apiextensions_apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProp\
    sR\x06schema\x12\x1a\n\x08property\x18\x02\x20\x03(\tR\x08property\"-\n\
    \x0fSelectableField\x12\x1a\n\x08jsonPath\x18\x01\x20\x01(\tR\x08jsonPat\
    h\"l\n\x10ServiceReference\x12\x1c\n\tnamespace\x18\x01\x20\x01(\tR\tnam\
    espace\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x12\n\x04path\
    \x18\x03\x20\x01(\tR\x04path\x12\x12\n\x04port\x18\x04\x20\x01(\x05R\x04\
    port\"\xcc\x01\n\x0eValidationRule\x12\x12\n\x04rule\x18\x01\x20\x01(\tR\
    \x04rule\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\x12,\n\x11m\
    essageExpression\x18\x03\x20\x01(\tR\x11messageExpression\x12\x16\n\x06r\
    eason\x18\x04\x20\x01(\tR\x06reason\x12\x1c\n\tfieldPath\x18\x05\x20\x01\
    (\tR\tfieldPath\x12(\n\x0foptionalOldSelf\x18\x06\x20\x01(\x08R\x0foptio\
    nalOldSelf\"\xa7\x01\n\x13WebhookClientConfig\x12\x10\n\x03url\x18\x03\
    \x20\x01(\tR\x03url\x12b\n\x07service\x18\x01\x20\x01(\x0b2H.apiextensio\
    ns_apiserver.pkg.apis.apiextensions.v1beta1.ServiceReferenceR\x07service\
    \x12\x1a\n\x08caBundle\x18\x02\x20\x01(\x0cR\x08caBundleB?Z=k8s.io/apiex\
    tensions-apiserver/pkg/apis/apiextensions/v1beta1\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::v1beta1::file_descriptor().clone());
            deps.push(super::v1beta1::file_descriptor().clone());
            deps.push(super::v1beta1::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(26);
            messages.push(ConversionRequest::generated_message_descriptor_data());
            messages.push(ConversionResponse::generated_message_descriptor_data());
            messages.push(ConversionReview::generated_message_descriptor_data());
            messages.push(CustomResourceColumnDefinition::generated_message_descriptor_data());
            messages.push(CustomResourceConversion::generated_message_descriptor_data());
            messages.push(CustomResourceDefinition::generated_message_descriptor_data());
            messages.push(CustomResourceDefinitionCondition::generated_message_descriptor_data());
            messages.push(CustomResourceDefinitionList::generated_message_descriptor_data());
            messages.push(CustomResourceDefinitionNames::generated_message_descriptor_data());
            messages.push(CustomResourceDefinitionSpec::generated_message_descriptor_data());
            messages.push(CustomResourceDefinitionStatus::generated_message_descriptor_data());
            messages.push(CustomResourceDefinitionVersion::generated_message_descriptor_data());
            messages.push(CustomResourceSubresourceScale::generated_message_descriptor_data());
            messages.push(CustomResourceSubresourceStatus::generated_message_descriptor_data());
            messages.push(CustomResourceSubresources::generated_message_descriptor_data());
            messages.push(CustomResourceValidation::generated_message_descriptor_data());
            messages.push(ExternalDocumentation::generated_message_descriptor_data());
            messages.push(JSON::generated_message_descriptor_data());
            messages.push(JSONSchemaProps::generated_message_descriptor_data());
            messages.push(JSONSchemaPropsOrArray::generated_message_descriptor_data());
            messages.push(JSONSchemaPropsOrBool::generated_message_descriptor_data());
            messages.push(JSONSchemaPropsOrStringArray::generated_message_descriptor_data());
            messages.push(SelectableField::generated_message_descriptor_data());
            messages.push(ServiceReference::generated_message_descriptor_data());
            messages.push(ValidationRule::generated_message_descriptor_data());
            messages.push(WebhookClientConfig::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
