// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc 30.2
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `api/admissionregistration/v1beta1/generated.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1beta1.AuditAnnotation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AuditAnnotation {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.AuditAnnotation.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.AuditAnnotation.valueExpression)
    pub valueExpression: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1beta1.AuditAnnotation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuditAnnotation {
    fn default() -> &'a AuditAnnotation {
        <AuditAnnotation as ::protobuf::Message>::default_instance()
    }
}

impl AuditAnnotation {
    pub fn new() -> AuditAnnotation {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string valueExpression = 2;

    pub fn valueExpression(&self) -> &str {
        match self.valueExpression.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_valueExpression(&mut self) {
        self.valueExpression = ::std::option::Option::None;
    }

    pub fn has_valueExpression(&self) -> bool {
        self.valueExpression.is_some()
    }

    // Param is passed by value, moved
    pub fn set_valueExpression(&mut self, v: ::std::string::String) {
        self.valueExpression = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_valueExpression(&mut self) -> &mut ::std::string::String {
        if self.valueExpression.is_none() {
            self.valueExpression = ::std::option::Option::Some(::std::string::String::new());
        }
        self.valueExpression.as_mut().unwrap()
    }

    // Take field
    pub fn take_valueExpression(&mut self) -> ::std::string::String {
        self.valueExpression.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &AuditAnnotation| { &m.key },
            |m: &mut AuditAnnotation| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "valueExpression",
            |m: &AuditAnnotation| { &m.valueExpression },
            |m: &mut AuditAnnotation| { &mut m.valueExpression },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AuditAnnotation>(
            "AuditAnnotation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AuditAnnotation {
    const NAME: &'static str = "AuditAnnotation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.valueExpression = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.valueExpression.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.valueExpression.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuditAnnotation {
        AuditAnnotation::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.valueExpression = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuditAnnotation {
        static instance: AuditAnnotation = AuditAnnotation {
            key: ::std::option::Option::None,
            valueExpression: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AuditAnnotation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AuditAnnotation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AuditAnnotation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuditAnnotation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1beta1.ExpressionWarning)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExpressionWarning {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ExpressionWarning.fieldRef)
    pub fieldRef: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ExpressionWarning.warning)
    pub warning: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1beta1.ExpressionWarning.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExpressionWarning {
    fn default() -> &'a ExpressionWarning {
        <ExpressionWarning as ::protobuf::Message>::default_instance()
    }
}

impl ExpressionWarning {
    pub fn new() -> ExpressionWarning {
        ::std::default::Default::default()
    }

    // optional string fieldRef = 2;

    pub fn fieldRef(&self) -> &str {
        match self.fieldRef.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fieldRef(&mut self) {
        self.fieldRef = ::std::option::Option::None;
    }

    pub fn has_fieldRef(&self) -> bool {
        self.fieldRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldRef(&mut self, v: ::std::string::String) {
        self.fieldRef = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldRef(&mut self) -> &mut ::std::string::String {
        if self.fieldRef.is_none() {
            self.fieldRef = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fieldRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldRef(&mut self) -> ::std::string::String {
        self.fieldRef.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string warning = 3;

    pub fn warning(&self) -> &str {
        match self.warning.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_warning(&mut self) {
        self.warning = ::std::option::Option::None;
    }

    pub fn has_warning(&self) -> bool {
        self.warning.is_some()
    }

    // Param is passed by value, moved
    pub fn set_warning(&mut self, v: ::std::string::String) {
        self.warning = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_warning(&mut self) -> &mut ::std::string::String {
        if self.warning.is_none() {
            self.warning = ::std::option::Option::Some(::std::string::String::new());
        }
        self.warning.as_mut().unwrap()
    }

    // Take field
    pub fn take_warning(&mut self) -> ::std::string::String {
        self.warning.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fieldRef",
            |m: &ExpressionWarning| { &m.fieldRef },
            |m: &mut ExpressionWarning| { &mut m.fieldRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "warning",
            |m: &ExpressionWarning| { &m.warning },
            |m: &mut ExpressionWarning| { &mut m.warning },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExpressionWarning>(
            "ExpressionWarning",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExpressionWarning {
    const NAME: &'static str = "ExpressionWarning";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.fieldRef = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.warning = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.fieldRef.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.warning.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.fieldRef.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.warning.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExpressionWarning {
        ExpressionWarning::new()
    }

    fn clear(&mut self) {
        self.fieldRef = ::std::option::Option::None;
        self.warning = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExpressionWarning {
        static instance: ExpressionWarning = ExpressionWarning {
            fieldRef: ::std::option::Option::None,
            warning: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExpressionWarning {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExpressionWarning").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExpressionWarning {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExpressionWarning {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1beta1.MatchCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MatchCondition {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.MatchCondition.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.MatchCondition.expression)
    pub expression: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1beta1.MatchCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MatchCondition {
    fn default() -> &'a MatchCondition {
        <MatchCondition as ::protobuf::Message>::default_instance()
    }
}

impl MatchCondition {
    pub fn new() -> MatchCondition {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string expression = 2;

    pub fn expression(&self) -> &str {
        match self.expression.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_expression(&mut self) {
        self.expression = ::std::option::Option::None;
    }

    pub fn has_expression(&self) -> bool {
        self.expression.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expression(&mut self, v: ::std::string::String) {
        self.expression = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expression(&mut self) -> &mut ::std::string::String {
        if self.expression.is_none() {
            self.expression = ::std::option::Option::Some(::std::string::String::new());
        }
        self.expression.as_mut().unwrap()
    }

    // Take field
    pub fn take_expression(&mut self) -> ::std::string::String {
        self.expression.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &MatchCondition| { &m.name },
            |m: &mut MatchCondition| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expression",
            |m: &MatchCondition| { &m.expression },
            |m: &mut MatchCondition| { &mut m.expression },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MatchCondition>(
            "MatchCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MatchCondition {
    const NAME: &'static str = "MatchCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.expression = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.expression.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.expression.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MatchCondition {
        MatchCondition::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.expression = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MatchCondition {
        static instance: MatchCondition = MatchCondition {
            name: ::std::option::Option::None,
            expression: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MatchCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MatchCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MatchCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1beta1.MatchResources)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MatchResources {
    // message fields
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.MatchResources.namespaceSelector)
    pub namespaceSelector: ::protobuf::MessageField<crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.MatchResources.objectSelector)
    pub objectSelector: ::protobuf::MessageField<crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.MatchResources.resourceRules)
    pub resourceRules: ::std::vec::Vec<NamedRuleWithOperations>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.MatchResources.excludeResourceRules)
    pub excludeResourceRules: ::std::vec::Vec<NamedRuleWithOperations>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.MatchResources.matchPolicy)
    pub matchPolicy: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1beta1.MatchResources.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MatchResources {
    fn default() -> &'a MatchResources {
        <MatchResources as ::protobuf::Message>::default_instance()
    }
}

impl MatchResources {
    pub fn new() -> MatchResources {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 1;

    pub fn namespaceSelector(&self) -> &crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.as_ref().unwrap_or_else(|| <crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_namespaceSelector(&mut self) {
        self.namespaceSelector.clear();
    }

    pub fn has_namespaceSelector(&self) -> bool {
        self.namespaceSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespaceSelector(&mut self, v: crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.namespaceSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespaceSelector(&mut self) -> &mut crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_namespaceSelector(&mut self) -> crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.take().unwrap_or_else(|| crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 2;

    pub fn objectSelector(&self) -> &crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.objectSelector.as_ref().unwrap_or_else(|| <crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_objectSelector(&mut self) {
        self.objectSelector.clear();
    }

    pub fn has_objectSelector(&self) -> bool {
        self.objectSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_objectSelector(&mut self, v: crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.objectSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_objectSelector(&mut self) -> &mut crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.objectSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_objectSelector(&mut self) -> crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.objectSelector.take().unwrap_or_else(|| crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // repeated .api.admissionregistration.v1beta1.NamedRuleWithOperations resourceRules = 3;

    pub fn resourceRules(&self) -> &[NamedRuleWithOperations] {
        &self.resourceRules
    }

    pub fn clear_resourceRules(&mut self) {
        self.resourceRules.clear();
    }

    // Param is passed by value, moved
    pub fn set_resourceRules(&mut self, v: ::std::vec::Vec<NamedRuleWithOperations>) {
        self.resourceRules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resourceRules(&mut self) -> &mut ::std::vec::Vec<NamedRuleWithOperations> {
        &mut self.resourceRules
    }

    // Take field
    pub fn take_resourceRules(&mut self) -> ::std::vec::Vec<NamedRuleWithOperations> {
        ::std::mem::replace(&mut self.resourceRules, ::std::vec::Vec::new())
    }

    // repeated .api.admissionregistration.v1beta1.NamedRuleWithOperations excludeResourceRules = 4;

    pub fn excludeResourceRules(&self) -> &[NamedRuleWithOperations] {
        &self.excludeResourceRules
    }

    pub fn clear_excludeResourceRules(&mut self) {
        self.excludeResourceRules.clear();
    }

    // Param is passed by value, moved
    pub fn set_excludeResourceRules(&mut self, v: ::std::vec::Vec<NamedRuleWithOperations>) {
        self.excludeResourceRules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excludeResourceRules(&mut self) -> &mut ::std::vec::Vec<NamedRuleWithOperations> {
        &mut self.excludeResourceRules
    }

    // Take field
    pub fn take_excludeResourceRules(&mut self) -> ::std::vec::Vec<NamedRuleWithOperations> {
        ::std::mem::replace(&mut self.excludeResourceRules, ::std::vec::Vec::new())
    }

    // optional string matchPolicy = 7;

    pub fn matchPolicy(&self) -> &str {
        match self.matchPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_matchPolicy(&mut self) {
        self.matchPolicy = ::std::option::Option::None;
    }

    pub fn has_matchPolicy(&self) -> bool {
        self.matchPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchPolicy(&mut self, v: ::std::string::String) {
        self.matchPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_matchPolicy(&mut self) -> &mut ::std::string::String {
        if self.matchPolicy.is_none() {
            self.matchPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.matchPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_matchPolicy(&mut self) -> ::std::string::String {
        self.matchPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "namespaceSelector",
            |m: &MatchResources| { &m.namespaceSelector },
            |m: &mut MatchResources| { &mut m.namespaceSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "objectSelector",
            |m: &MatchResources| { &m.objectSelector },
            |m: &mut MatchResources| { &mut m.objectSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resourceRules",
            |m: &MatchResources| { &m.resourceRules },
            |m: &mut MatchResources| { &mut m.resourceRules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "excludeResourceRules",
            |m: &MatchResources| { &m.excludeResourceRules },
            |m: &mut MatchResources| { &mut m.excludeResourceRules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchPolicy",
            |m: &MatchResources| { &m.matchPolicy },
            |m: &mut MatchResources| { &mut m.matchPolicy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MatchResources>(
            "MatchResources",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MatchResources {
    const NAME: &'static str = "MatchResources";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.namespaceSelector)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.objectSelector)?;
                },
                26 => {
                    self.resourceRules.push(is.read_message()?);
                },
                34 => {
                    self.excludeResourceRules.push(is.read_message()?);
                },
                58 => {
                    self.matchPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.namespaceSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.objectSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.resourceRules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.excludeResourceRules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.matchPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.namespaceSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.objectSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.resourceRules {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.excludeResourceRules {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.matchPolicy.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MatchResources {
        MatchResources::new()
    }

    fn clear(&mut self) {
        self.namespaceSelector.clear();
        self.objectSelector.clear();
        self.resourceRules.clear();
        self.excludeResourceRules.clear();
        self.matchPolicy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MatchResources {
        static instance: MatchResources = MatchResources {
            namespaceSelector: ::protobuf::MessageField::none(),
            objectSelector: ::protobuf::MessageField::none(),
            resourceRules: ::std::vec::Vec::new(),
            excludeResourceRules: ::std::vec::Vec::new(),
            matchPolicy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MatchResources {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MatchResources").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MatchResources {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchResources {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1beta1.MutatingWebhook)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MutatingWebhook {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.MutatingWebhook.name)
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.MutatingWebhook.clientConfig)
    pub clientConfig: ::protobuf::MessageField<WebhookClientConfig>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.MutatingWebhook.rules)
    pub rules: ::std::vec::Vec<crate::v1_31::api::admissionregistration::v1::RuleWithOperations>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.MutatingWebhook.failurePolicy)
    pub failurePolicy: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.MutatingWebhook.matchPolicy)
    pub matchPolicy: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.MutatingWebhook.namespaceSelector)
    pub namespaceSelector: ::protobuf::MessageField<crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.MutatingWebhook.objectSelector)
    pub objectSelector: ::protobuf::MessageField<crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.MutatingWebhook.sideEffects)
    pub sideEffects: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.MutatingWebhook.timeoutSeconds)
    pub timeoutSeconds: ::std::option::Option<i32>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.MutatingWebhook.admissionReviewVersions)
    pub admissionReviewVersions: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.MutatingWebhook.reinvocationPolicy)
    pub reinvocationPolicy: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.MutatingWebhook.matchConditions)
    pub matchConditions: ::std::vec::Vec<MatchCondition>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1beta1.MutatingWebhook.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MutatingWebhook {
    fn default() -> &'a MutatingWebhook {
        <MutatingWebhook as ::protobuf::Message>::default_instance()
    }
}

impl MutatingWebhook {
    pub fn new() -> MutatingWebhook {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;

    pub fn clientConfig(&self) -> &WebhookClientConfig {
        self.clientConfig.as_ref().unwrap_or_else(|| <WebhookClientConfig as ::protobuf::Message>::default_instance())
    }

    pub fn clear_clientConfig(&mut self) {
        self.clientConfig.clear();
    }

    pub fn has_clientConfig(&self) -> bool {
        self.clientConfig.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientConfig(&mut self, v: WebhookClientConfig) {
        self.clientConfig = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientConfig(&mut self) -> &mut WebhookClientConfig {
        self.clientConfig.mut_or_insert_default()
    }

    // Take field
    pub fn take_clientConfig(&mut self) -> WebhookClientConfig {
        self.clientConfig.take().unwrap_or_else(|| WebhookClientConfig::new())
    }

    // repeated .api.admissionregistration.v1.RuleWithOperations rules = 3;

    pub fn rules(&self) -> &[crate::v1_31::api::admissionregistration::v1::RuleWithOperations] {
        &self.rules
    }

    pub fn clear_rules(&mut self) {
        self.rules.clear();
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: ::std::vec::Vec<crate::v1_31::api::admissionregistration::v1::RuleWithOperations>) {
        self.rules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rules(&mut self) -> &mut ::std::vec::Vec<crate::v1_31::api::admissionregistration::v1::RuleWithOperations> {
        &mut self.rules
    }

    // Take field
    pub fn take_rules(&mut self) -> ::std::vec::Vec<crate::v1_31::api::admissionregistration::v1::RuleWithOperations> {
        ::std::mem::replace(&mut self.rules, ::std::vec::Vec::new())
    }

    // optional string failurePolicy = 4;

    pub fn failurePolicy(&self) -> &str {
        match self.failurePolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_failurePolicy(&mut self) {
        self.failurePolicy = ::std::option::Option::None;
    }

    pub fn has_failurePolicy(&self) -> bool {
        self.failurePolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failurePolicy(&mut self, v: ::std::string::String) {
        self.failurePolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_failurePolicy(&mut self) -> &mut ::std::string::String {
        if self.failurePolicy.is_none() {
            self.failurePolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.failurePolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_failurePolicy(&mut self) -> ::std::string::String {
        self.failurePolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string matchPolicy = 9;

    pub fn matchPolicy(&self) -> &str {
        match self.matchPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_matchPolicy(&mut self) {
        self.matchPolicy = ::std::option::Option::None;
    }

    pub fn has_matchPolicy(&self) -> bool {
        self.matchPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchPolicy(&mut self, v: ::std::string::String) {
        self.matchPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_matchPolicy(&mut self) -> &mut ::std::string::String {
        if self.matchPolicy.is_none() {
            self.matchPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.matchPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_matchPolicy(&mut self) -> ::std::string::String {
        self.matchPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;

    pub fn namespaceSelector(&self) -> &crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.as_ref().unwrap_or_else(|| <crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_namespaceSelector(&mut self) {
        self.namespaceSelector.clear();
    }

    pub fn has_namespaceSelector(&self) -> bool {
        self.namespaceSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespaceSelector(&mut self, v: crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.namespaceSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespaceSelector(&mut self) -> &mut crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_namespaceSelector(&mut self) -> crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.take().unwrap_or_else(|| crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 11;

    pub fn objectSelector(&self) -> &crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.objectSelector.as_ref().unwrap_or_else(|| <crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_objectSelector(&mut self) {
        self.objectSelector.clear();
    }

    pub fn has_objectSelector(&self) -> bool {
        self.objectSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_objectSelector(&mut self, v: crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.objectSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_objectSelector(&mut self) -> &mut crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.objectSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_objectSelector(&mut self) -> crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.objectSelector.take().unwrap_or_else(|| crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional string sideEffects = 6;

    pub fn sideEffects(&self) -> &str {
        match self.sideEffects.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sideEffects(&mut self) {
        self.sideEffects = ::std::option::Option::None;
    }

    pub fn has_sideEffects(&self) -> bool {
        self.sideEffects.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sideEffects(&mut self, v: ::std::string::String) {
        self.sideEffects = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sideEffects(&mut self) -> &mut ::std::string::String {
        if self.sideEffects.is_none() {
            self.sideEffects = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sideEffects.as_mut().unwrap()
    }

    // Take field
    pub fn take_sideEffects(&mut self) -> ::std::string::String {
        self.sideEffects.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 timeoutSeconds = 7;

    pub fn timeoutSeconds(&self) -> i32 {
        self.timeoutSeconds.unwrap_or(0)
    }

    pub fn clear_timeoutSeconds(&mut self) {
        self.timeoutSeconds = ::std::option::Option::None;
    }

    pub fn has_timeoutSeconds(&self) -> bool {
        self.timeoutSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeoutSeconds(&mut self, v: i32) {
        self.timeoutSeconds = ::std::option::Option::Some(v);
    }

    // repeated string admissionReviewVersions = 8;

    pub fn admissionReviewVersions(&self) -> &[::std::string::String] {
        &self.admissionReviewVersions
    }

    pub fn clear_admissionReviewVersions(&mut self) {
        self.admissionReviewVersions.clear();
    }

    // Param is passed by value, moved
    pub fn set_admissionReviewVersions(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.admissionReviewVersions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_admissionReviewVersions(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.admissionReviewVersions
    }

    // Take field
    pub fn take_admissionReviewVersions(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.admissionReviewVersions, ::std::vec::Vec::new())
    }

    // optional string reinvocationPolicy = 10;

    pub fn reinvocationPolicy(&self) -> &str {
        match self.reinvocationPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reinvocationPolicy(&mut self) {
        self.reinvocationPolicy = ::std::option::Option::None;
    }

    pub fn has_reinvocationPolicy(&self) -> bool {
        self.reinvocationPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reinvocationPolicy(&mut self, v: ::std::string::String) {
        self.reinvocationPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reinvocationPolicy(&mut self) -> &mut ::std::string::String {
        if self.reinvocationPolicy.is_none() {
            self.reinvocationPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reinvocationPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_reinvocationPolicy(&mut self) -> ::std::string::String {
        self.reinvocationPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.admissionregistration.v1beta1.MatchCondition matchConditions = 12;

    pub fn matchConditions(&self) -> &[MatchCondition] {
        &self.matchConditions
    }

    pub fn clear_matchConditions(&mut self) {
        self.matchConditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchConditions(&mut self, v: ::std::vec::Vec<MatchCondition>) {
        self.matchConditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchConditions(&mut self) -> &mut ::std::vec::Vec<MatchCondition> {
        &mut self.matchConditions
    }

    // Take field
    pub fn take_matchConditions(&mut self) -> ::std::vec::Vec<MatchCondition> {
        ::std::mem::replace(&mut self.matchConditions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &MutatingWebhook| { &m.name },
            |m: &mut MutatingWebhook| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WebhookClientConfig>(
            "clientConfig",
            |m: &MutatingWebhook| { &m.clientConfig },
            |m: &mut MutatingWebhook| { &mut m.clientConfig },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rules",
            |m: &MutatingWebhook| { &m.rules },
            |m: &mut MutatingWebhook| { &mut m.rules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "failurePolicy",
            |m: &MutatingWebhook| { &m.failurePolicy },
            |m: &mut MutatingWebhook| { &mut m.failurePolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchPolicy",
            |m: &MutatingWebhook| { &m.matchPolicy },
            |m: &mut MutatingWebhook| { &mut m.matchPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "namespaceSelector",
            |m: &MutatingWebhook| { &m.namespaceSelector },
            |m: &mut MutatingWebhook| { &mut m.namespaceSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "objectSelector",
            |m: &MutatingWebhook| { &m.objectSelector },
            |m: &mut MutatingWebhook| { &mut m.objectSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sideEffects",
            |m: &MutatingWebhook| { &m.sideEffects },
            |m: &mut MutatingWebhook| { &mut m.sideEffects },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timeoutSeconds",
            |m: &MutatingWebhook| { &m.timeoutSeconds },
            |m: &mut MutatingWebhook| { &mut m.timeoutSeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "admissionReviewVersions",
            |m: &MutatingWebhook| { &m.admissionReviewVersions },
            |m: &mut MutatingWebhook| { &mut m.admissionReviewVersions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reinvocationPolicy",
            |m: &MutatingWebhook| { &m.reinvocationPolicy },
            |m: &mut MutatingWebhook| { &mut m.reinvocationPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matchConditions",
            |m: &MutatingWebhook| { &m.matchConditions },
            |m: &mut MutatingWebhook| { &mut m.matchConditions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MutatingWebhook>(
            "MutatingWebhook",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MutatingWebhook {
    const NAME: &'static str = "MutatingWebhook";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.clientConfig)?;
                },
                26 => {
                    self.rules.push(is.read_message()?);
                },
                34 => {
                    self.failurePolicy = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.matchPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.namespaceSelector)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.objectSelector)?;
                },
                50 => {
                    self.sideEffects = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.timeoutSeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                66 => {
                    self.admissionReviewVersions.push(is.read_string()?);
                },
                82 => {
                    self.reinvocationPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.matchConditions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.clientConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.failurePolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.matchPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.namespaceSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.objectSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sideEffects.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.timeoutSeconds {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        for value in &self.admissionReviewVersions {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if let Some(v) = self.reinvocationPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        for value in &self.matchConditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.clientConfig.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.rules {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.failurePolicy.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.matchPolicy.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.namespaceSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.objectSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.sideEffects.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.timeoutSeconds {
            os.write_int32(7, v)?;
        }
        for v in &self.admissionReviewVersions {
            os.write_string(8, &v)?;
        };
        if let Some(v) = self.reinvocationPolicy.as_ref() {
            os.write_string(10, v)?;
        }
        for v in &self.matchConditions {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MutatingWebhook {
        MutatingWebhook::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.clientConfig.clear();
        self.rules.clear();
        self.failurePolicy = ::std::option::Option::None;
        self.matchPolicy = ::std::option::Option::None;
        self.namespaceSelector.clear();
        self.objectSelector.clear();
        self.sideEffects = ::std::option::Option::None;
        self.timeoutSeconds = ::std::option::Option::None;
        self.admissionReviewVersions.clear();
        self.reinvocationPolicy = ::std::option::Option::None;
        self.matchConditions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MutatingWebhook {
        static instance: MutatingWebhook = MutatingWebhook {
            name: ::std::option::Option::None,
            clientConfig: ::protobuf::MessageField::none(),
            rules: ::std::vec::Vec::new(),
            failurePolicy: ::std::option::Option::None,
            matchPolicy: ::std::option::Option::None,
            namespaceSelector: ::protobuf::MessageField::none(),
            objectSelector: ::protobuf::MessageField::none(),
            sideEffects: ::std::option::Option::None,
            timeoutSeconds: ::std::option::Option::None,
            admissionReviewVersions: ::std::vec::Vec::new(),
            reinvocationPolicy: ::std::option::Option::None,
            matchConditions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MutatingWebhook {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MutatingWebhook").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MutatingWebhook {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MutatingWebhook {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1beta1.MutatingWebhookConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MutatingWebhookConfiguration {
    // message fields
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.MutatingWebhookConfiguration.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.MutatingWebhookConfiguration.Webhooks)
    pub Webhooks: ::std::vec::Vec<MutatingWebhook>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1beta1.MutatingWebhookConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MutatingWebhookConfiguration {
    fn default() -> &'a MutatingWebhookConfiguration {
        <MutatingWebhookConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl MutatingWebhookConfiguration {
    pub fn new() -> MutatingWebhookConfiguration {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // repeated .api.admissionregistration.v1beta1.MutatingWebhook Webhooks = 2;

    pub fn Webhooks(&self) -> &[MutatingWebhook] {
        &self.Webhooks
    }

    pub fn clear_Webhooks(&mut self) {
        self.Webhooks.clear();
    }

    // Param is passed by value, moved
    pub fn set_Webhooks(&mut self, v: ::std::vec::Vec<MutatingWebhook>) {
        self.Webhooks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Webhooks(&mut self) -> &mut ::std::vec::Vec<MutatingWebhook> {
        &mut self.Webhooks
    }

    // Take field
    pub fn take_Webhooks(&mut self) -> ::std::vec::Vec<MutatingWebhook> {
        ::std::mem::replace(&mut self.Webhooks, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &MutatingWebhookConfiguration| { &m.metadata },
            |m: &mut MutatingWebhookConfiguration| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Webhooks",
            |m: &MutatingWebhookConfiguration| { &m.Webhooks },
            |m: &mut MutatingWebhookConfiguration| { &mut m.Webhooks },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MutatingWebhookConfiguration>(
            "MutatingWebhookConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MutatingWebhookConfiguration {
    const NAME: &'static str = "MutatingWebhookConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.Webhooks.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.Webhooks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.Webhooks {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MutatingWebhookConfiguration {
        MutatingWebhookConfiguration::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.Webhooks.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MutatingWebhookConfiguration {
        static instance: MutatingWebhookConfiguration = MutatingWebhookConfiguration {
            metadata: ::protobuf::MessageField::none(),
            Webhooks: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MutatingWebhookConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MutatingWebhookConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MutatingWebhookConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MutatingWebhookConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1beta1.MutatingWebhookConfigurationList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MutatingWebhookConfigurationList {
    // message fields
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.MutatingWebhookConfigurationList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.MutatingWebhookConfigurationList.items)
    pub items: ::std::vec::Vec<MutatingWebhookConfiguration>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1beta1.MutatingWebhookConfigurationList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MutatingWebhookConfigurationList {
    fn default() -> &'a MutatingWebhookConfigurationList {
        <MutatingWebhookConfigurationList as ::protobuf::Message>::default_instance()
    }
}

impl MutatingWebhookConfigurationList {
    pub fn new() -> MutatingWebhookConfigurationList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.admissionregistration.v1beta1.MutatingWebhookConfiguration items = 2;

    pub fn items(&self) -> &[MutatingWebhookConfiguration] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<MutatingWebhookConfiguration>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<MutatingWebhookConfiguration> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<MutatingWebhookConfiguration> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &MutatingWebhookConfigurationList| { &m.metadata },
            |m: &mut MutatingWebhookConfigurationList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &MutatingWebhookConfigurationList| { &m.items },
            |m: &mut MutatingWebhookConfigurationList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MutatingWebhookConfigurationList>(
            "MutatingWebhookConfigurationList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MutatingWebhookConfigurationList {
    const NAME: &'static str = "MutatingWebhookConfigurationList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MutatingWebhookConfigurationList {
        MutatingWebhookConfigurationList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MutatingWebhookConfigurationList {
        static instance: MutatingWebhookConfigurationList = MutatingWebhookConfigurationList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MutatingWebhookConfigurationList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MutatingWebhookConfigurationList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MutatingWebhookConfigurationList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MutatingWebhookConfigurationList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1beta1.NamedRuleWithOperations)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NamedRuleWithOperations {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.NamedRuleWithOperations.resourceNames)
    pub resourceNames: ::std::vec::Vec<::std::string::String>,
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.NamedRuleWithOperations.ruleWithOperations)
    pub ruleWithOperations: ::protobuf::MessageField<crate::v1_31::api::admissionregistration::v1::RuleWithOperations>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1beta1.NamedRuleWithOperations.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NamedRuleWithOperations {
    fn default() -> &'a NamedRuleWithOperations {
        <NamedRuleWithOperations as ::protobuf::Message>::default_instance()
    }
}

impl NamedRuleWithOperations {
    pub fn new() -> NamedRuleWithOperations {
        ::std::default::Default::default()
    }

    // repeated string resourceNames = 1;

    pub fn resourceNames(&self) -> &[::std::string::String] {
        &self.resourceNames
    }

    pub fn clear_resourceNames(&mut self) {
        self.resourceNames.clear();
    }

    // Param is passed by value, moved
    pub fn set_resourceNames(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.resourceNames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resourceNames(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.resourceNames
    }

    // Take field
    pub fn take_resourceNames(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.resourceNames, ::std::vec::Vec::new())
    }

    // optional .api.admissionregistration.v1.RuleWithOperations ruleWithOperations = 2;

    pub fn ruleWithOperations(&self) -> &crate::v1_31::api::admissionregistration::v1::RuleWithOperations {
        self.ruleWithOperations.as_ref().unwrap_or_else(|| <crate::v1_31::api::admissionregistration::v1::RuleWithOperations as ::protobuf::Message>::default_instance())
    }

    pub fn clear_ruleWithOperations(&mut self) {
        self.ruleWithOperations.clear();
    }

    pub fn has_ruleWithOperations(&self) -> bool {
        self.ruleWithOperations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ruleWithOperations(&mut self, v: crate::v1_31::api::admissionregistration::v1::RuleWithOperations) {
        self.ruleWithOperations = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ruleWithOperations(&mut self) -> &mut crate::v1_31::api::admissionregistration::v1::RuleWithOperations {
        self.ruleWithOperations.mut_or_insert_default()
    }

    // Take field
    pub fn take_ruleWithOperations(&mut self) -> crate::v1_31::api::admissionregistration::v1::RuleWithOperations {
        self.ruleWithOperations.take().unwrap_or_else(|| crate::v1_31::api::admissionregistration::v1::RuleWithOperations::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resourceNames",
            |m: &NamedRuleWithOperations| { &m.resourceNames },
            |m: &mut NamedRuleWithOperations| { &mut m.resourceNames },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_31::api::admissionregistration::v1::RuleWithOperations>(
            "ruleWithOperations",
            |m: &NamedRuleWithOperations| { &m.ruleWithOperations },
            |m: &mut NamedRuleWithOperations| { &mut m.ruleWithOperations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NamedRuleWithOperations>(
            "NamedRuleWithOperations",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NamedRuleWithOperations {
    const NAME: &'static str = "NamedRuleWithOperations";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.resourceNames.push(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ruleWithOperations)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.resourceNames {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.ruleWithOperations.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.resourceNames {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.ruleWithOperations.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NamedRuleWithOperations {
        NamedRuleWithOperations::new()
    }

    fn clear(&mut self) {
        self.resourceNames.clear();
        self.ruleWithOperations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NamedRuleWithOperations {
        static instance: NamedRuleWithOperations = NamedRuleWithOperations {
            resourceNames: ::std::vec::Vec::new(),
            ruleWithOperations: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NamedRuleWithOperations {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NamedRuleWithOperations").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NamedRuleWithOperations {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamedRuleWithOperations {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1beta1.ParamKind)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ParamKind {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ParamKind.apiVersion)
    pub apiVersion: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ParamKind.kind)
    pub kind: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1beta1.ParamKind.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ParamKind {
    fn default() -> &'a ParamKind {
        <ParamKind as ::protobuf::Message>::default_instance()
    }
}

impl ParamKind {
    pub fn new() -> ParamKind {
        ::std::default::Default::default()
    }

    // optional string apiVersion = 1;

    pub fn apiVersion(&self) -> &str {
        match self.apiVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_apiVersion(&mut self) {
        self.apiVersion = ::std::option::Option::None;
    }

    pub fn has_apiVersion(&self) -> bool {
        self.apiVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiVersion(&mut self, v: ::std::string::String) {
        self.apiVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiVersion(&mut self) -> &mut ::std::string::String {
        if self.apiVersion.is_none() {
            self.apiVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.apiVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiVersion(&mut self) -> ::std::string::String {
        self.apiVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kind = 2;

    pub fn kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_kind(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind = ::std::option::Option::Some(::std::string::String::new());
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "apiVersion",
            |m: &ParamKind| { &m.apiVersion },
            |m: &mut ParamKind| { &mut m.apiVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kind",
            |m: &ParamKind| { &m.kind },
            |m: &mut ParamKind| { &mut m.kind },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ParamKind>(
            "ParamKind",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ParamKind {
    const NAME: &'static str = "ParamKind";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.apiVersion = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.kind = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.apiVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.apiVersion.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.kind.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ParamKind {
        ParamKind::new()
    }

    fn clear(&mut self) {
        self.apiVersion = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ParamKind {
        static instance: ParamKind = ParamKind {
            apiVersion: ::std::option::Option::None,
            kind: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ParamKind {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ParamKind").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ParamKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParamKind {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1beta1.ParamRef)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ParamRef {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ParamRef.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ParamRef.namespace)
    pub namespace: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ParamRef.selector)
    pub selector: ::protobuf::MessageField<crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ParamRef.parameterNotFoundAction)
    pub parameterNotFoundAction: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1beta1.ParamRef.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ParamRef {
    fn default() -> &'a ParamRef {
        <ParamRef as ::protobuf::Message>::default_instance()
    }
}

impl ParamRef {
    pub fn new() -> ParamRef {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string namespace = 2;

    pub fn namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_namespace(&mut self) {
        self.namespace = ::std::option::Option::None;
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3;

    pub fn selector(&self) -> &crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.as_ref().unwrap_or_else(|| <crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    pub fn has_selector(&self) -> bool {
        self.selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.selector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selector(&mut self) -> &mut crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.mut_or_insert_default()
    }

    // Take field
    pub fn take_selector(&mut self) -> crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.take().unwrap_or_else(|| crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional string parameterNotFoundAction = 4;

    pub fn parameterNotFoundAction(&self) -> &str {
        match self.parameterNotFoundAction.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_parameterNotFoundAction(&mut self) {
        self.parameterNotFoundAction = ::std::option::Option::None;
    }

    pub fn has_parameterNotFoundAction(&self) -> bool {
        self.parameterNotFoundAction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameterNotFoundAction(&mut self, v: ::std::string::String) {
        self.parameterNotFoundAction = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parameterNotFoundAction(&mut self) -> &mut ::std::string::String {
        if self.parameterNotFoundAction.is_none() {
            self.parameterNotFoundAction = ::std::option::Option::Some(::std::string::String::new());
        }
        self.parameterNotFoundAction.as_mut().unwrap()
    }

    // Take field
    pub fn take_parameterNotFoundAction(&mut self) -> ::std::string::String {
        self.parameterNotFoundAction.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ParamRef| { &m.name },
            |m: &mut ParamRef| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "namespace",
            |m: &ParamRef| { &m.namespace },
            |m: &mut ParamRef| { &mut m.namespace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "selector",
            |m: &ParamRef| { &m.selector },
            |m: &mut ParamRef| { &mut m.selector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parameterNotFoundAction",
            |m: &ParamRef| { &m.parameterNotFoundAction },
            |m: &mut ParamRef| { &mut m.parameterNotFoundAction },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ParamRef>(
            "ParamRef",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ParamRef {
    const NAME: &'static str = "ParamRef";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.namespace = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.selector)?;
                },
                34 => {
                    self.parameterNotFoundAction = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.parameterNotFoundAction.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.namespace.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.selector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.parameterNotFoundAction.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ParamRef {
        ParamRef::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.namespace = ::std::option::Option::None;
        self.selector.clear();
        self.parameterNotFoundAction = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ParamRef {
        static instance: ParamRef = ParamRef {
            name: ::std::option::Option::None,
            namespace: ::std::option::Option::None,
            selector: ::protobuf::MessageField::none(),
            parameterNotFoundAction: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ParamRef {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ParamRef").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ParamRef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParamRef {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1beta1.ServiceReference)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServiceReference {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ServiceReference.namespace)
    pub namespace: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ServiceReference.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ServiceReference.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ServiceReference.port)
    pub port: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1beta1.ServiceReference.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceReference {
    fn default() -> &'a ServiceReference {
        <ServiceReference as ::protobuf::Message>::default_instance()
    }
}

impl ServiceReference {
    pub fn new() -> ServiceReference {
        ::std::default::Default::default()
    }

    // optional string namespace = 1;

    pub fn namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_namespace(&mut self) {
        self.namespace = ::std::option::Option::None;
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string path = 3;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 port = 4;

    pub fn port(&self) -> i32 {
        self.port.unwrap_or(0)
    }

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "namespace",
            |m: &ServiceReference| { &m.namespace },
            |m: &mut ServiceReference| { &mut m.namespace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ServiceReference| { &m.name },
            |m: &mut ServiceReference| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &ServiceReference| { &m.path },
            |m: &mut ServiceReference| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "port",
            |m: &ServiceReference| { &m.port },
            |m: &mut ServiceReference| { &mut m.port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServiceReference>(
            "ServiceReference",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServiceReference {
    const NAME: &'static str = "ServiceReference";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.namespace = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.port = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.namespace.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.port {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceReference {
        ServiceReference::new()
    }

    fn clear(&mut self) {
        self.namespace = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.path = ::std::option::Option::None;
        self.port = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceReference {
        static instance: ServiceReference = ServiceReference {
            namespace: ::std::option::Option::None,
            name: ::std::option::Option::None,
            path: ::std::option::Option::None,
            port: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServiceReference {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceReference").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceReference {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1beta1.TypeChecking)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TypeChecking {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.TypeChecking.expressionWarnings)
    pub expressionWarnings: ::std::vec::Vec<ExpressionWarning>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1beta1.TypeChecking.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TypeChecking {
    fn default() -> &'a TypeChecking {
        <TypeChecking as ::protobuf::Message>::default_instance()
    }
}

impl TypeChecking {
    pub fn new() -> TypeChecking {
        ::std::default::Default::default()
    }

    // repeated .api.admissionregistration.v1beta1.ExpressionWarning expressionWarnings = 1;

    pub fn expressionWarnings(&self) -> &[ExpressionWarning] {
        &self.expressionWarnings
    }

    pub fn clear_expressionWarnings(&mut self) {
        self.expressionWarnings.clear();
    }

    // Param is passed by value, moved
    pub fn set_expressionWarnings(&mut self, v: ::std::vec::Vec<ExpressionWarning>) {
        self.expressionWarnings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_expressionWarnings(&mut self) -> &mut ::std::vec::Vec<ExpressionWarning> {
        &mut self.expressionWarnings
    }

    // Take field
    pub fn take_expressionWarnings(&mut self) -> ::std::vec::Vec<ExpressionWarning> {
        ::std::mem::replace(&mut self.expressionWarnings, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "expressionWarnings",
            |m: &TypeChecking| { &m.expressionWarnings },
            |m: &mut TypeChecking| { &mut m.expressionWarnings },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TypeChecking>(
            "TypeChecking",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TypeChecking {
    const NAME: &'static str = "TypeChecking";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.expressionWarnings.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.expressionWarnings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.expressionWarnings {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TypeChecking {
        TypeChecking::new()
    }

    fn clear(&mut self) {
        self.expressionWarnings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TypeChecking {
        static instance: TypeChecking = TypeChecking {
            expressionWarnings: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TypeChecking {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TypeChecking").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TypeChecking {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeChecking {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1beta1.ValidatingAdmissionPolicy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingAdmissionPolicy {
    // message fields
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicy.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicy.spec)
    pub spec: ::protobuf::MessageField<ValidatingAdmissionPolicySpec>,
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicy.status)
    pub status: ::protobuf::MessageField<ValidatingAdmissionPolicyStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingAdmissionPolicy {
    fn default() -> &'a ValidatingAdmissionPolicy {
        <ValidatingAdmissionPolicy as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingAdmissionPolicy {
    pub fn new() -> ValidatingAdmissionPolicy {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec spec = 2;

    pub fn spec(&self) -> &ValidatingAdmissionPolicySpec {
        self.spec.as_ref().unwrap_or_else(|| <ValidatingAdmissionPolicySpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ValidatingAdmissionPolicySpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ValidatingAdmissionPolicySpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ValidatingAdmissionPolicySpec {
        self.spec.take().unwrap_or_else(|| ValidatingAdmissionPolicySpec::new())
    }

    // optional .api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus status = 3;

    pub fn status(&self) -> &ValidatingAdmissionPolicyStatus {
        self.status.as_ref().unwrap_or_else(|| <ValidatingAdmissionPolicyStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ValidatingAdmissionPolicyStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ValidatingAdmissionPolicyStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> ValidatingAdmissionPolicyStatus {
        self.status.take().unwrap_or_else(|| ValidatingAdmissionPolicyStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ValidatingAdmissionPolicy| { &m.metadata },
            |m: &mut ValidatingAdmissionPolicy| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ValidatingAdmissionPolicySpec>(
            "spec",
            |m: &ValidatingAdmissionPolicy| { &m.spec },
            |m: &mut ValidatingAdmissionPolicy| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ValidatingAdmissionPolicyStatus>(
            "status",
            |m: &ValidatingAdmissionPolicy| { &m.status },
            |m: &mut ValidatingAdmissionPolicy| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingAdmissionPolicy>(
            "ValidatingAdmissionPolicy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingAdmissionPolicy {
    const NAME: &'static str = "ValidatingAdmissionPolicy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingAdmissionPolicy {
        ValidatingAdmissionPolicy::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingAdmissionPolicy {
        static instance: ValidatingAdmissionPolicy = ValidatingAdmissionPolicy {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingAdmissionPolicy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingAdmissionPolicy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingAdmissionPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingAdmissionPolicy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingAdmissionPolicyBinding {
    // message fields
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding.spec)
    pub spec: ::protobuf::MessageField<ValidatingAdmissionPolicyBindingSpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingAdmissionPolicyBinding {
    fn default() -> &'a ValidatingAdmissionPolicyBinding {
        <ValidatingAdmissionPolicyBinding as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingAdmissionPolicyBinding {
    pub fn new() -> ValidatingAdmissionPolicyBinding {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec spec = 2;

    pub fn spec(&self) -> &ValidatingAdmissionPolicyBindingSpec {
        self.spec.as_ref().unwrap_or_else(|| <ValidatingAdmissionPolicyBindingSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ValidatingAdmissionPolicyBindingSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ValidatingAdmissionPolicyBindingSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ValidatingAdmissionPolicyBindingSpec {
        self.spec.take().unwrap_or_else(|| ValidatingAdmissionPolicyBindingSpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ValidatingAdmissionPolicyBinding| { &m.metadata },
            |m: &mut ValidatingAdmissionPolicyBinding| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ValidatingAdmissionPolicyBindingSpec>(
            "spec",
            |m: &ValidatingAdmissionPolicyBinding| { &m.spec },
            |m: &mut ValidatingAdmissionPolicyBinding| { &mut m.spec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingAdmissionPolicyBinding>(
            "ValidatingAdmissionPolicyBinding",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingAdmissionPolicyBinding {
    const NAME: &'static str = "ValidatingAdmissionPolicyBinding";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingAdmissionPolicyBinding {
        ValidatingAdmissionPolicyBinding::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingAdmissionPolicyBinding {
        static instance: ValidatingAdmissionPolicyBinding = ValidatingAdmissionPolicyBinding {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingAdmissionPolicyBinding {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingAdmissionPolicyBinding").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingAdmissionPolicyBinding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingAdmissionPolicyBinding {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingAdmissionPolicyBindingList {
    // message fields
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingList.items)
    pub items: ::std::vec::Vec<ValidatingAdmissionPolicyBinding>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingAdmissionPolicyBindingList {
    fn default() -> &'a ValidatingAdmissionPolicyBindingList {
        <ValidatingAdmissionPolicyBindingList as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingAdmissionPolicyBindingList {
    pub fn new() -> ValidatingAdmissionPolicyBindingList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding items = 2;

    pub fn items(&self) -> &[ValidatingAdmissionPolicyBinding] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ValidatingAdmissionPolicyBinding>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ValidatingAdmissionPolicyBinding> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ValidatingAdmissionPolicyBinding> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ValidatingAdmissionPolicyBindingList| { &m.metadata },
            |m: &mut ValidatingAdmissionPolicyBindingList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ValidatingAdmissionPolicyBindingList| { &m.items },
            |m: &mut ValidatingAdmissionPolicyBindingList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingAdmissionPolicyBindingList>(
            "ValidatingAdmissionPolicyBindingList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingAdmissionPolicyBindingList {
    const NAME: &'static str = "ValidatingAdmissionPolicyBindingList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingAdmissionPolicyBindingList {
        ValidatingAdmissionPolicyBindingList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingAdmissionPolicyBindingList {
        static instance: ValidatingAdmissionPolicyBindingList = ValidatingAdmissionPolicyBindingList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingAdmissionPolicyBindingList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingAdmissionPolicyBindingList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingAdmissionPolicyBindingList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingAdmissionPolicyBindingList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingAdmissionPolicyBindingSpec {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec.policyName)
    pub policyName: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec.paramRef)
    pub paramRef: ::protobuf::MessageField<ParamRef>,
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec.matchResources)
    pub matchResources: ::protobuf::MessageField<MatchResources>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec.validationActions)
    pub validationActions: ::std::vec::Vec<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingAdmissionPolicyBindingSpec {
    fn default() -> &'a ValidatingAdmissionPolicyBindingSpec {
        <ValidatingAdmissionPolicyBindingSpec as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingAdmissionPolicyBindingSpec {
    pub fn new() -> ValidatingAdmissionPolicyBindingSpec {
        ::std::default::Default::default()
    }

    // optional string policyName = 1;

    pub fn policyName(&self) -> &str {
        match self.policyName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_policyName(&mut self) {
        self.policyName = ::std::option::Option::None;
    }

    pub fn has_policyName(&self) -> bool {
        self.policyName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_policyName(&mut self, v: ::std::string::String) {
        self.policyName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_policyName(&mut self) -> &mut ::std::string::String {
        if self.policyName.is_none() {
            self.policyName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.policyName.as_mut().unwrap()
    }

    // Take field
    pub fn take_policyName(&mut self) -> ::std::string::String {
        self.policyName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.admissionregistration.v1beta1.ParamRef paramRef = 2;

    pub fn paramRef(&self) -> &ParamRef {
        self.paramRef.as_ref().unwrap_or_else(|| <ParamRef as ::protobuf::Message>::default_instance())
    }

    pub fn clear_paramRef(&mut self) {
        self.paramRef.clear();
    }

    pub fn has_paramRef(&self) -> bool {
        self.paramRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paramRef(&mut self, v: ParamRef) {
        self.paramRef = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paramRef(&mut self) -> &mut ParamRef {
        self.paramRef.mut_or_insert_default()
    }

    // Take field
    pub fn take_paramRef(&mut self) -> ParamRef {
        self.paramRef.take().unwrap_or_else(|| ParamRef::new())
    }

    // optional .api.admissionregistration.v1beta1.MatchResources matchResources = 3;

    pub fn matchResources(&self) -> &MatchResources {
        self.matchResources.as_ref().unwrap_or_else(|| <MatchResources as ::protobuf::Message>::default_instance())
    }

    pub fn clear_matchResources(&mut self) {
        self.matchResources.clear();
    }

    pub fn has_matchResources(&self) -> bool {
        self.matchResources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchResources(&mut self, v: MatchResources) {
        self.matchResources = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_matchResources(&mut self) -> &mut MatchResources {
        self.matchResources.mut_or_insert_default()
    }

    // Take field
    pub fn take_matchResources(&mut self) -> MatchResources {
        self.matchResources.take().unwrap_or_else(|| MatchResources::new())
    }

    // repeated string validationActions = 4;

    pub fn validationActions(&self) -> &[::std::string::String] {
        &self.validationActions
    }

    pub fn clear_validationActions(&mut self) {
        self.validationActions.clear();
    }

    // Param is passed by value, moved
    pub fn set_validationActions(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.validationActions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_validationActions(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.validationActions
    }

    // Take field
    pub fn take_validationActions(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.validationActions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "policyName",
            |m: &ValidatingAdmissionPolicyBindingSpec| { &m.policyName },
            |m: &mut ValidatingAdmissionPolicyBindingSpec| { &mut m.policyName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ParamRef>(
            "paramRef",
            |m: &ValidatingAdmissionPolicyBindingSpec| { &m.paramRef },
            |m: &mut ValidatingAdmissionPolicyBindingSpec| { &mut m.paramRef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MatchResources>(
            "matchResources",
            |m: &ValidatingAdmissionPolicyBindingSpec| { &m.matchResources },
            |m: &mut ValidatingAdmissionPolicyBindingSpec| { &mut m.matchResources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "validationActions",
            |m: &ValidatingAdmissionPolicyBindingSpec| { &m.validationActions },
            |m: &mut ValidatingAdmissionPolicyBindingSpec| { &mut m.validationActions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingAdmissionPolicyBindingSpec>(
            "ValidatingAdmissionPolicyBindingSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingAdmissionPolicyBindingSpec {
    const NAME: &'static str = "ValidatingAdmissionPolicyBindingSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.policyName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.paramRef)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.matchResources)?;
                },
                34 => {
                    self.validationActions.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.policyName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.paramRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.matchResources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.validationActions {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.policyName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.paramRef.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.matchResources.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.validationActions {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingAdmissionPolicyBindingSpec {
        ValidatingAdmissionPolicyBindingSpec::new()
    }

    fn clear(&mut self) {
        self.policyName = ::std::option::Option::None;
        self.paramRef.clear();
        self.matchResources.clear();
        self.validationActions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingAdmissionPolicyBindingSpec {
        static instance: ValidatingAdmissionPolicyBindingSpec = ValidatingAdmissionPolicyBindingSpec {
            policyName: ::std::option::Option::None,
            paramRef: ::protobuf::MessageField::none(),
            matchResources: ::protobuf::MessageField::none(),
            validationActions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingAdmissionPolicyBindingSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingAdmissionPolicyBindingSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingAdmissionPolicyBindingSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingAdmissionPolicyBindingSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1beta1.ValidatingAdmissionPolicyList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingAdmissionPolicyList {
    // message fields
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicyList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicyList.items)
    pub items: ::std::vec::Vec<ValidatingAdmissionPolicy>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicyList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingAdmissionPolicyList {
    fn default() -> &'a ValidatingAdmissionPolicyList {
        <ValidatingAdmissionPolicyList as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingAdmissionPolicyList {
    pub fn new() -> ValidatingAdmissionPolicyList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.admissionregistration.v1beta1.ValidatingAdmissionPolicy items = 2;

    pub fn items(&self) -> &[ValidatingAdmissionPolicy] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ValidatingAdmissionPolicy>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ValidatingAdmissionPolicy> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ValidatingAdmissionPolicy> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ValidatingAdmissionPolicyList| { &m.metadata },
            |m: &mut ValidatingAdmissionPolicyList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ValidatingAdmissionPolicyList| { &m.items },
            |m: &mut ValidatingAdmissionPolicyList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingAdmissionPolicyList>(
            "ValidatingAdmissionPolicyList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingAdmissionPolicyList {
    const NAME: &'static str = "ValidatingAdmissionPolicyList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingAdmissionPolicyList {
        ValidatingAdmissionPolicyList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingAdmissionPolicyList {
        static instance: ValidatingAdmissionPolicyList = ValidatingAdmissionPolicyList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingAdmissionPolicyList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingAdmissionPolicyList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingAdmissionPolicyList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingAdmissionPolicyList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingAdmissionPolicySpec {
    // message fields
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec.paramKind)
    pub paramKind: ::protobuf::MessageField<ParamKind>,
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec.matchConstraints)
    pub matchConstraints: ::protobuf::MessageField<MatchResources>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec.validations)
    pub validations: ::std::vec::Vec<Validation>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec.failurePolicy)
    pub failurePolicy: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec.auditAnnotations)
    pub auditAnnotations: ::std::vec::Vec<AuditAnnotation>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec.matchConditions)
    pub matchConditions: ::std::vec::Vec<MatchCondition>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec.variables)
    pub variables: ::std::vec::Vec<Variable>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingAdmissionPolicySpec {
    fn default() -> &'a ValidatingAdmissionPolicySpec {
        <ValidatingAdmissionPolicySpec as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingAdmissionPolicySpec {
    pub fn new() -> ValidatingAdmissionPolicySpec {
        ::std::default::Default::default()
    }

    // optional .api.admissionregistration.v1beta1.ParamKind paramKind = 1;

    pub fn paramKind(&self) -> &ParamKind {
        self.paramKind.as_ref().unwrap_or_else(|| <ParamKind as ::protobuf::Message>::default_instance())
    }

    pub fn clear_paramKind(&mut self) {
        self.paramKind.clear();
    }

    pub fn has_paramKind(&self) -> bool {
        self.paramKind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paramKind(&mut self, v: ParamKind) {
        self.paramKind = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paramKind(&mut self) -> &mut ParamKind {
        self.paramKind.mut_or_insert_default()
    }

    // Take field
    pub fn take_paramKind(&mut self) -> ParamKind {
        self.paramKind.take().unwrap_or_else(|| ParamKind::new())
    }

    // optional .api.admissionregistration.v1beta1.MatchResources matchConstraints = 2;

    pub fn matchConstraints(&self) -> &MatchResources {
        self.matchConstraints.as_ref().unwrap_or_else(|| <MatchResources as ::protobuf::Message>::default_instance())
    }

    pub fn clear_matchConstraints(&mut self) {
        self.matchConstraints.clear();
    }

    pub fn has_matchConstraints(&self) -> bool {
        self.matchConstraints.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchConstraints(&mut self, v: MatchResources) {
        self.matchConstraints = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_matchConstraints(&mut self) -> &mut MatchResources {
        self.matchConstraints.mut_or_insert_default()
    }

    // Take field
    pub fn take_matchConstraints(&mut self) -> MatchResources {
        self.matchConstraints.take().unwrap_or_else(|| MatchResources::new())
    }

    // repeated .api.admissionregistration.v1beta1.Validation validations = 3;

    pub fn validations(&self) -> &[Validation] {
        &self.validations
    }

    pub fn clear_validations(&mut self) {
        self.validations.clear();
    }

    // Param is passed by value, moved
    pub fn set_validations(&mut self, v: ::std::vec::Vec<Validation>) {
        self.validations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_validations(&mut self) -> &mut ::std::vec::Vec<Validation> {
        &mut self.validations
    }

    // Take field
    pub fn take_validations(&mut self) -> ::std::vec::Vec<Validation> {
        ::std::mem::replace(&mut self.validations, ::std::vec::Vec::new())
    }

    // optional string failurePolicy = 4;

    pub fn failurePolicy(&self) -> &str {
        match self.failurePolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_failurePolicy(&mut self) {
        self.failurePolicy = ::std::option::Option::None;
    }

    pub fn has_failurePolicy(&self) -> bool {
        self.failurePolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failurePolicy(&mut self, v: ::std::string::String) {
        self.failurePolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_failurePolicy(&mut self) -> &mut ::std::string::String {
        if self.failurePolicy.is_none() {
            self.failurePolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.failurePolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_failurePolicy(&mut self) -> ::std::string::String {
        self.failurePolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.admissionregistration.v1beta1.AuditAnnotation auditAnnotations = 5;

    pub fn auditAnnotations(&self) -> &[AuditAnnotation] {
        &self.auditAnnotations
    }

    pub fn clear_auditAnnotations(&mut self) {
        self.auditAnnotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_auditAnnotations(&mut self, v: ::std::vec::Vec<AuditAnnotation>) {
        self.auditAnnotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_auditAnnotations(&mut self) -> &mut ::std::vec::Vec<AuditAnnotation> {
        &mut self.auditAnnotations
    }

    // Take field
    pub fn take_auditAnnotations(&mut self) -> ::std::vec::Vec<AuditAnnotation> {
        ::std::mem::replace(&mut self.auditAnnotations, ::std::vec::Vec::new())
    }

    // repeated .api.admissionregistration.v1beta1.MatchCondition matchConditions = 6;

    pub fn matchConditions(&self) -> &[MatchCondition] {
        &self.matchConditions
    }

    pub fn clear_matchConditions(&mut self) {
        self.matchConditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchConditions(&mut self, v: ::std::vec::Vec<MatchCondition>) {
        self.matchConditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchConditions(&mut self) -> &mut ::std::vec::Vec<MatchCondition> {
        &mut self.matchConditions
    }

    // Take field
    pub fn take_matchConditions(&mut self) -> ::std::vec::Vec<MatchCondition> {
        ::std::mem::replace(&mut self.matchConditions, ::std::vec::Vec::new())
    }

    // repeated .api.admissionregistration.v1beta1.Variable variables = 7;

    pub fn variables(&self) -> &[Variable] {
        &self.variables
    }

    pub fn clear_variables(&mut self) {
        self.variables.clear();
    }

    // Param is passed by value, moved
    pub fn set_variables(&mut self, v: ::std::vec::Vec<Variable>) {
        self.variables = v;
    }

    // Mutable pointer to the field.
    pub fn mut_variables(&mut self) -> &mut ::std::vec::Vec<Variable> {
        &mut self.variables
    }

    // Take field
    pub fn take_variables(&mut self) -> ::std::vec::Vec<Variable> {
        ::std::mem::replace(&mut self.variables, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ParamKind>(
            "paramKind",
            |m: &ValidatingAdmissionPolicySpec| { &m.paramKind },
            |m: &mut ValidatingAdmissionPolicySpec| { &mut m.paramKind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MatchResources>(
            "matchConstraints",
            |m: &ValidatingAdmissionPolicySpec| { &m.matchConstraints },
            |m: &mut ValidatingAdmissionPolicySpec| { &mut m.matchConstraints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "validations",
            |m: &ValidatingAdmissionPolicySpec| { &m.validations },
            |m: &mut ValidatingAdmissionPolicySpec| { &mut m.validations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "failurePolicy",
            |m: &ValidatingAdmissionPolicySpec| { &m.failurePolicy },
            |m: &mut ValidatingAdmissionPolicySpec| { &mut m.failurePolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "auditAnnotations",
            |m: &ValidatingAdmissionPolicySpec| { &m.auditAnnotations },
            |m: &mut ValidatingAdmissionPolicySpec| { &mut m.auditAnnotations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matchConditions",
            |m: &ValidatingAdmissionPolicySpec| { &m.matchConditions },
            |m: &mut ValidatingAdmissionPolicySpec| { &mut m.matchConditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "variables",
            |m: &ValidatingAdmissionPolicySpec| { &m.variables },
            |m: &mut ValidatingAdmissionPolicySpec| { &mut m.variables },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingAdmissionPolicySpec>(
            "ValidatingAdmissionPolicySpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingAdmissionPolicySpec {
    const NAME: &'static str = "ValidatingAdmissionPolicySpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.paramKind)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.matchConstraints)?;
                },
                26 => {
                    self.validations.push(is.read_message()?);
                },
                34 => {
                    self.failurePolicy = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.auditAnnotations.push(is.read_message()?);
                },
                50 => {
                    self.matchConditions.push(is.read_message()?);
                },
                58 => {
                    self.variables.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.paramKind.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.matchConstraints.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.validations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.failurePolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.auditAnnotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.matchConditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.variables {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.paramKind.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.matchConstraints.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.validations {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.failurePolicy.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.auditAnnotations {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.matchConditions {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.variables {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingAdmissionPolicySpec {
        ValidatingAdmissionPolicySpec::new()
    }

    fn clear(&mut self) {
        self.paramKind.clear();
        self.matchConstraints.clear();
        self.validations.clear();
        self.failurePolicy = ::std::option::Option::None;
        self.auditAnnotations.clear();
        self.matchConditions.clear();
        self.variables.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingAdmissionPolicySpec {
        static instance: ValidatingAdmissionPolicySpec = ValidatingAdmissionPolicySpec {
            paramKind: ::protobuf::MessageField::none(),
            matchConstraints: ::protobuf::MessageField::none(),
            validations: ::std::vec::Vec::new(),
            failurePolicy: ::std::option::Option::None,
            auditAnnotations: ::std::vec::Vec::new(),
            matchConditions: ::std::vec::Vec::new(),
            variables: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingAdmissionPolicySpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingAdmissionPolicySpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingAdmissionPolicySpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingAdmissionPolicySpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingAdmissionPolicyStatus {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus.observedGeneration)
    pub observedGeneration: ::std::option::Option<i64>,
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus.typeChecking)
    pub typeChecking: ::protobuf::MessageField<TypeChecking>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus.conditions)
    pub conditions: ::std::vec::Vec<crate::v1_31::apimachinery::pkg::apis::meta::v1::Condition>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingAdmissionPolicyStatus {
    fn default() -> &'a ValidatingAdmissionPolicyStatus {
        <ValidatingAdmissionPolicyStatus as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingAdmissionPolicyStatus {
    pub fn new() -> ValidatingAdmissionPolicyStatus {
        ::std::default::Default::default()
    }

    // optional int64 observedGeneration = 1;

    pub fn observedGeneration(&self) -> i64 {
        self.observedGeneration.unwrap_or(0)
    }

    pub fn clear_observedGeneration(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
    }

    pub fn has_observedGeneration(&self) -> bool {
        self.observedGeneration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observedGeneration(&mut self, v: i64) {
        self.observedGeneration = ::std::option::Option::Some(v);
    }

    // optional .api.admissionregistration.v1beta1.TypeChecking typeChecking = 2;

    pub fn typeChecking(&self) -> &TypeChecking {
        self.typeChecking.as_ref().unwrap_or_else(|| <TypeChecking as ::protobuf::Message>::default_instance())
    }

    pub fn clear_typeChecking(&mut self) {
        self.typeChecking.clear();
    }

    pub fn has_typeChecking(&self) -> bool {
        self.typeChecking.is_some()
    }

    // Param is passed by value, moved
    pub fn set_typeChecking(&mut self, v: TypeChecking) {
        self.typeChecking = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_typeChecking(&mut self) -> &mut TypeChecking {
        self.typeChecking.mut_or_insert_default()
    }

    // Take field
    pub fn take_typeChecking(&mut self) -> TypeChecking {
        self.typeChecking.take().unwrap_or_else(|| TypeChecking::new())
    }

    // repeated .apimachinery.pkg.apis.meta.v1.Condition conditions = 3;

    pub fn conditions(&self) -> &[crate::v1_31::apimachinery::pkg::apis::meta::v1::Condition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<crate::v1_31::apimachinery::pkg::apis::meta::v1::Condition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<crate::v1_31::apimachinery::pkg::apis::meta::v1::Condition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<crate::v1_31::apimachinery::pkg::apis::meta::v1::Condition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "observedGeneration",
            |m: &ValidatingAdmissionPolicyStatus| { &m.observedGeneration },
            |m: &mut ValidatingAdmissionPolicyStatus| { &mut m.observedGeneration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TypeChecking>(
            "typeChecking",
            |m: &ValidatingAdmissionPolicyStatus| { &m.typeChecking },
            |m: &mut ValidatingAdmissionPolicyStatus| { &mut m.typeChecking },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &ValidatingAdmissionPolicyStatus| { &m.conditions },
            |m: &mut ValidatingAdmissionPolicyStatus| { &mut m.conditions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingAdmissionPolicyStatus>(
            "ValidatingAdmissionPolicyStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingAdmissionPolicyStatus {
    const NAME: &'static str = "ValidatingAdmissionPolicyStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.observedGeneration = ::std::option::Option::Some(is.read_int64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.typeChecking)?;
                },
                26 => {
                    self.conditions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.observedGeneration {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.typeChecking.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.observedGeneration {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.typeChecking.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingAdmissionPolicyStatus {
        ValidatingAdmissionPolicyStatus::new()
    }

    fn clear(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
        self.typeChecking.clear();
        self.conditions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingAdmissionPolicyStatus {
        static instance: ValidatingAdmissionPolicyStatus = ValidatingAdmissionPolicyStatus {
            observedGeneration: ::std::option::Option::None,
            typeChecking: ::protobuf::MessageField::none(),
            conditions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingAdmissionPolicyStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingAdmissionPolicyStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingAdmissionPolicyStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingAdmissionPolicyStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1beta1.ValidatingWebhook)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingWebhook {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingWebhook.name)
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingWebhook.clientConfig)
    pub clientConfig: ::protobuf::MessageField<WebhookClientConfig>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingWebhook.rules)
    pub rules: ::std::vec::Vec<crate::v1_31::api::admissionregistration::v1::RuleWithOperations>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingWebhook.failurePolicy)
    pub failurePolicy: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingWebhook.matchPolicy)
    pub matchPolicy: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingWebhook.namespaceSelector)
    pub namespaceSelector: ::protobuf::MessageField<crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingWebhook.objectSelector)
    pub objectSelector: ::protobuf::MessageField<crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingWebhook.sideEffects)
    pub sideEffects: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingWebhook.timeoutSeconds)
    pub timeoutSeconds: ::std::option::Option<i32>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingWebhook.admissionReviewVersions)
    pub admissionReviewVersions: ::std::vec::Vec<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingWebhook.matchConditions)
    pub matchConditions: ::std::vec::Vec<MatchCondition>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1beta1.ValidatingWebhook.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingWebhook {
    fn default() -> &'a ValidatingWebhook {
        <ValidatingWebhook as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingWebhook {
    pub fn new() -> ValidatingWebhook {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.admissionregistration.v1beta1.WebhookClientConfig clientConfig = 2;

    pub fn clientConfig(&self) -> &WebhookClientConfig {
        self.clientConfig.as_ref().unwrap_or_else(|| <WebhookClientConfig as ::protobuf::Message>::default_instance())
    }

    pub fn clear_clientConfig(&mut self) {
        self.clientConfig.clear();
    }

    pub fn has_clientConfig(&self) -> bool {
        self.clientConfig.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientConfig(&mut self, v: WebhookClientConfig) {
        self.clientConfig = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientConfig(&mut self) -> &mut WebhookClientConfig {
        self.clientConfig.mut_or_insert_default()
    }

    // Take field
    pub fn take_clientConfig(&mut self) -> WebhookClientConfig {
        self.clientConfig.take().unwrap_or_else(|| WebhookClientConfig::new())
    }

    // repeated .api.admissionregistration.v1.RuleWithOperations rules = 3;

    pub fn rules(&self) -> &[crate::v1_31::api::admissionregistration::v1::RuleWithOperations] {
        &self.rules
    }

    pub fn clear_rules(&mut self) {
        self.rules.clear();
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: ::std::vec::Vec<crate::v1_31::api::admissionregistration::v1::RuleWithOperations>) {
        self.rules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rules(&mut self) -> &mut ::std::vec::Vec<crate::v1_31::api::admissionregistration::v1::RuleWithOperations> {
        &mut self.rules
    }

    // Take field
    pub fn take_rules(&mut self) -> ::std::vec::Vec<crate::v1_31::api::admissionregistration::v1::RuleWithOperations> {
        ::std::mem::replace(&mut self.rules, ::std::vec::Vec::new())
    }

    // optional string failurePolicy = 4;

    pub fn failurePolicy(&self) -> &str {
        match self.failurePolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_failurePolicy(&mut self) {
        self.failurePolicy = ::std::option::Option::None;
    }

    pub fn has_failurePolicy(&self) -> bool {
        self.failurePolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failurePolicy(&mut self, v: ::std::string::String) {
        self.failurePolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_failurePolicy(&mut self) -> &mut ::std::string::String {
        if self.failurePolicy.is_none() {
            self.failurePolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.failurePolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_failurePolicy(&mut self) -> ::std::string::String {
        self.failurePolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string matchPolicy = 9;

    pub fn matchPolicy(&self) -> &str {
        match self.matchPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_matchPolicy(&mut self) {
        self.matchPolicy = ::std::option::Option::None;
    }

    pub fn has_matchPolicy(&self) -> bool {
        self.matchPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchPolicy(&mut self, v: ::std::string::String) {
        self.matchPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_matchPolicy(&mut self) -> &mut ::std::string::String {
        if self.matchPolicy.is_none() {
            self.matchPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.matchPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_matchPolicy(&mut self) -> ::std::string::String {
        self.matchPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 5;

    pub fn namespaceSelector(&self) -> &crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.as_ref().unwrap_or_else(|| <crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_namespaceSelector(&mut self) {
        self.namespaceSelector.clear();
    }

    pub fn has_namespaceSelector(&self) -> bool {
        self.namespaceSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespaceSelector(&mut self, v: crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.namespaceSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespaceSelector(&mut self) -> &mut crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_namespaceSelector(&mut self) -> crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.namespaceSelector.take().unwrap_or_else(|| crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector objectSelector = 10;

    pub fn objectSelector(&self) -> &crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.objectSelector.as_ref().unwrap_or_else(|| <crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_objectSelector(&mut self) {
        self.objectSelector.clear();
    }

    pub fn has_objectSelector(&self) -> bool {
        self.objectSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_objectSelector(&mut self, v: crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.objectSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_objectSelector(&mut self) -> &mut crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.objectSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_objectSelector(&mut self) -> crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.objectSelector.take().unwrap_or_else(|| crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional string sideEffects = 6;

    pub fn sideEffects(&self) -> &str {
        match self.sideEffects.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sideEffects(&mut self) {
        self.sideEffects = ::std::option::Option::None;
    }

    pub fn has_sideEffects(&self) -> bool {
        self.sideEffects.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sideEffects(&mut self, v: ::std::string::String) {
        self.sideEffects = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sideEffects(&mut self) -> &mut ::std::string::String {
        if self.sideEffects.is_none() {
            self.sideEffects = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sideEffects.as_mut().unwrap()
    }

    // Take field
    pub fn take_sideEffects(&mut self) -> ::std::string::String {
        self.sideEffects.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 timeoutSeconds = 7;

    pub fn timeoutSeconds(&self) -> i32 {
        self.timeoutSeconds.unwrap_or(0)
    }

    pub fn clear_timeoutSeconds(&mut self) {
        self.timeoutSeconds = ::std::option::Option::None;
    }

    pub fn has_timeoutSeconds(&self) -> bool {
        self.timeoutSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeoutSeconds(&mut self, v: i32) {
        self.timeoutSeconds = ::std::option::Option::Some(v);
    }

    // repeated string admissionReviewVersions = 8;

    pub fn admissionReviewVersions(&self) -> &[::std::string::String] {
        &self.admissionReviewVersions
    }

    pub fn clear_admissionReviewVersions(&mut self) {
        self.admissionReviewVersions.clear();
    }

    // Param is passed by value, moved
    pub fn set_admissionReviewVersions(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.admissionReviewVersions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_admissionReviewVersions(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.admissionReviewVersions
    }

    // Take field
    pub fn take_admissionReviewVersions(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.admissionReviewVersions, ::std::vec::Vec::new())
    }

    // repeated .api.admissionregistration.v1beta1.MatchCondition matchConditions = 11;

    pub fn matchConditions(&self) -> &[MatchCondition] {
        &self.matchConditions
    }

    pub fn clear_matchConditions(&mut self) {
        self.matchConditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchConditions(&mut self, v: ::std::vec::Vec<MatchCondition>) {
        self.matchConditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchConditions(&mut self) -> &mut ::std::vec::Vec<MatchCondition> {
        &mut self.matchConditions
    }

    // Take field
    pub fn take_matchConditions(&mut self) -> ::std::vec::Vec<MatchCondition> {
        ::std::mem::replace(&mut self.matchConditions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ValidatingWebhook| { &m.name },
            |m: &mut ValidatingWebhook| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WebhookClientConfig>(
            "clientConfig",
            |m: &ValidatingWebhook| { &m.clientConfig },
            |m: &mut ValidatingWebhook| { &mut m.clientConfig },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rules",
            |m: &ValidatingWebhook| { &m.rules },
            |m: &mut ValidatingWebhook| { &mut m.rules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "failurePolicy",
            |m: &ValidatingWebhook| { &m.failurePolicy },
            |m: &mut ValidatingWebhook| { &mut m.failurePolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchPolicy",
            |m: &ValidatingWebhook| { &m.matchPolicy },
            |m: &mut ValidatingWebhook| { &mut m.matchPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "namespaceSelector",
            |m: &ValidatingWebhook| { &m.namespaceSelector },
            |m: &mut ValidatingWebhook| { &mut m.namespaceSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_31::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "objectSelector",
            |m: &ValidatingWebhook| { &m.objectSelector },
            |m: &mut ValidatingWebhook| { &mut m.objectSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sideEffects",
            |m: &ValidatingWebhook| { &m.sideEffects },
            |m: &mut ValidatingWebhook| { &mut m.sideEffects },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timeoutSeconds",
            |m: &ValidatingWebhook| { &m.timeoutSeconds },
            |m: &mut ValidatingWebhook| { &mut m.timeoutSeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "admissionReviewVersions",
            |m: &ValidatingWebhook| { &m.admissionReviewVersions },
            |m: &mut ValidatingWebhook| { &mut m.admissionReviewVersions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matchConditions",
            |m: &ValidatingWebhook| { &m.matchConditions },
            |m: &mut ValidatingWebhook| { &mut m.matchConditions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingWebhook>(
            "ValidatingWebhook",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingWebhook {
    const NAME: &'static str = "ValidatingWebhook";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.clientConfig)?;
                },
                26 => {
                    self.rules.push(is.read_message()?);
                },
                34 => {
                    self.failurePolicy = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.matchPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.namespaceSelector)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.objectSelector)?;
                },
                50 => {
                    self.sideEffects = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.timeoutSeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                66 => {
                    self.admissionReviewVersions.push(is.read_string()?);
                },
                90 => {
                    self.matchConditions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.clientConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.failurePolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.matchPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.namespaceSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.objectSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sideEffects.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.timeoutSeconds {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        for value in &self.admissionReviewVersions {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in &self.matchConditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.clientConfig.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.rules {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.failurePolicy.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.matchPolicy.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.namespaceSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.objectSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.sideEffects.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.timeoutSeconds {
            os.write_int32(7, v)?;
        }
        for v in &self.admissionReviewVersions {
            os.write_string(8, &v)?;
        };
        for v in &self.matchConditions {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingWebhook {
        ValidatingWebhook::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.clientConfig.clear();
        self.rules.clear();
        self.failurePolicy = ::std::option::Option::None;
        self.matchPolicy = ::std::option::Option::None;
        self.namespaceSelector.clear();
        self.objectSelector.clear();
        self.sideEffects = ::std::option::Option::None;
        self.timeoutSeconds = ::std::option::Option::None;
        self.admissionReviewVersions.clear();
        self.matchConditions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingWebhook {
        static instance: ValidatingWebhook = ValidatingWebhook {
            name: ::std::option::Option::None,
            clientConfig: ::protobuf::MessageField::none(),
            rules: ::std::vec::Vec::new(),
            failurePolicy: ::std::option::Option::None,
            matchPolicy: ::std::option::Option::None,
            namespaceSelector: ::protobuf::MessageField::none(),
            objectSelector: ::protobuf::MessageField::none(),
            sideEffects: ::std::option::Option::None,
            timeoutSeconds: ::std::option::Option::None,
            admissionReviewVersions: ::std::vec::Vec::new(),
            matchConditions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingWebhook {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingWebhook").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingWebhook {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingWebhook {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1beta1.ValidatingWebhookConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingWebhookConfiguration {
    // message fields
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingWebhookConfiguration.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingWebhookConfiguration.Webhooks)
    pub Webhooks: ::std::vec::Vec<ValidatingWebhook>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1beta1.ValidatingWebhookConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingWebhookConfiguration {
    fn default() -> &'a ValidatingWebhookConfiguration {
        <ValidatingWebhookConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingWebhookConfiguration {
    pub fn new() -> ValidatingWebhookConfiguration {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // repeated .api.admissionregistration.v1beta1.ValidatingWebhook Webhooks = 2;

    pub fn Webhooks(&self) -> &[ValidatingWebhook] {
        &self.Webhooks
    }

    pub fn clear_Webhooks(&mut self) {
        self.Webhooks.clear();
    }

    // Param is passed by value, moved
    pub fn set_Webhooks(&mut self, v: ::std::vec::Vec<ValidatingWebhook>) {
        self.Webhooks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Webhooks(&mut self) -> &mut ::std::vec::Vec<ValidatingWebhook> {
        &mut self.Webhooks
    }

    // Take field
    pub fn take_Webhooks(&mut self) -> ::std::vec::Vec<ValidatingWebhook> {
        ::std::mem::replace(&mut self.Webhooks, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_31::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ValidatingWebhookConfiguration| { &m.metadata },
            |m: &mut ValidatingWebhookConfiguration| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Webhooks",
            |m: &ValidatingWebhookConfiguration| { &m.Webhooks },
            |m: &mut ValidatingWebhookConfiguration| { &mut m.Webhooks },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingWebhookConfiguration>(
            "ValidatingWebhookConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingWebhookConfiguration {
    const NAME: &'static str = "ValidatingWebhookConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.Webhooks.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.Webhooks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.Webhooks {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingWebhookConfiguration {
        ValidatingWebhookConfiguration::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.Webhooks.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingWebhookConfiguration {
        static instance: ValidatingWebhookConfiguration = ValidatingWebhookConfiguration {
            metadata: ::protobuf::MessageField::none(),
            Webhooks: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingWebhookConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingWebhookConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingWebhookConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingWebhookConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1beta1.ValidatingWebhookConfigurationList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatingWebhookConfigurationList {
    // message fields
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingWebhookConfigurationList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.ValidatingWebhookConfigurationList.items)
    pub items: ::std::vec::Vec<ValidatingWebhookConfiguration>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1beta1.ValidatingWebhookConfigurationList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidatingWebhookConfigurationList {
    fn default() -> &'a ValidatingWebhookConfigurationList {
        <ValidatingWebhookConfigurationList as ::protobuf::Message>::default_instance()
    }
}

impl ValidatingWebhookConfigurationList {
    pub fn new() -> ValidatingWebhookConfigurationList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.admissionregistration.v1beta1.ValidatingWebhookConfiguration items = 2;

    pub fn items(&self) -> &[ValidatingWebhookConfiguration] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ValidatingWebhookConfiguration>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ValidatingWebhookConfiguration> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ValidatingWebhookConfiguration> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_31::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ValidatingWebhookConfigurationList| { &m.metadata },
            |m: &mut ValidatingWebhookConfigurationList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ValidatingWebhookConfigurationList| { &m.items },
            |m: &mut ValidatingWebhookConfigurationList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidatingWebhookConfigurationList>(
            "ValidatingWebhookConfigurationList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidatingWebhookConfigurationList {
    const NAME: &'static str = "ValidatingWebhookConfigurationList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidatingWebhookConfigurationList {
        ValidatingWebhookConfigurationList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidatingWebhookConfigurationList {
        static instance: ValidatingWebhookConfigurationList = ValidatingWebhookConfigurationList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidatingWebhookConfigurationList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidatingWebhookConfigurationList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidatingWebhookConfigurationList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatingWebhookConfigurationList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1beta1.Validation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Validation {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.Validation.Expression)
    pub Expression: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.Validation.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.Validation.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.Validation.messageExpression)
    pub messageExpression: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1beta1.Validation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Validation {
    fn default() -> &'a Validation {
        <Validation as ::protobuf::Message>::default_instance()
    }
}

impl Validation {
    pub fn new() -> Validation {
        ::std::default::Default::default()
    }

    // optional string Expression = 1;

    pub fn Expression(&self) -> &str {
        match self.Expression.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_Expression(&mut self) {
        self.Expression = ::std::option::Option::None;
    }

    pub fn has_Expression(&self) -> bool {
        self.Expression.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Expression(&mut self, v: ::std::string::String) {
        self.Expression = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Expression(&mut self) -> &mut ::std::string::String {
        if self.Expression.is_none() {
            self.Expression = ::std::option::Option::Some(::std::string::String::new());
        }
        self.Expression.as_mut().unwrap()
    }

    // Take field
    pub fn take_Expression(&mut self) -> ::std::string::String {
        self.Expression.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reason = 3;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string messageExpression = 4;

    pub fn messageExpression(&self) -> &str {
        match self.messageExpression.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_messageExpression(&mut self) {
        self.messageExpression = ::std::option::Option::None;
    }

    pub fn has_messageExpression(&self) -> bool {
        self.messageExpression.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageExpression(&mut self, v: ::std::string::String) {
        self.messageExpression = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messageExpression(&mut self) -> &mut ::std::string::String {
        if self.messageExpression.is_none() {
            self.messageExpression = ::std::option::Option::Some(::std::string::String::new());
        }
        self.messageExpression.as_mut().unwrap()
    }

    // Take field
    pub fn take_messageExpression(&mut self) -> ::std::string::String {
        self.messageExpression.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "Expression",
            |m: &Validation| { &m.Expression },
            |m: &mut Validation| { &mut m.Expression },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &Validation| { &m.message },
            |m: &mut Validation| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &Validation| { &m.reason },
            |m: &mut Validation| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "messageExpression",
            |m: &Validation| { &m.messageExpression },
            |m: &mut Validation| { &mut m.messageExpression },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Validation>(
            "Validation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Validation {
    const NAME: &'static str = "Validation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Expression = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.messageExpression = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.Expression.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.messageExpression.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.Expression.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.messageExpression.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Validation {
        Validation::new()
    }

    fn clear(&mut self) {
        self.Expression = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.messageExpression = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Validation {
        static instance: Validation = Validation {
            Expression: ::std::option::Option::None,
            message: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            messageExpression: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Validation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Validation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Validation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Validation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1beta1.Variable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Variable {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.Variable.Name)
    pub Name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.Variable.Expression)
    pub Expression: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1beta1.Variable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Variable {
    fn default() -> &'a Variable {
        <Variable as ::protobuf::Message>::default_instance()
    }
}

impl Variable {
    pub fn new() -> Variable {
        ::std::default::Default::default()
    }

    // optional string Name = 1;

    pub fn Name(&self) -> &str {
        match self.Name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_Name(&mut self) {
        self.Name = ::std::option::Option::None;
    }

    pub fn has_Name(&self) -> bool {
        self.Name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Name(&mut self, v: ::std::string::String) {
        self.Name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Name(&mut self) -> &mut ::std::string::String {
        if self.Name.is_none() {
            self.Name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.Name.as_mut().unwrap()
    }

    // Take field
    pub fn take_Name(&mut self) -> ::std::string::String {
        self.Name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string Expression = 2;

    pub fn Expression(&self) -> &str {
        match self.Expression.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_Expression(&mut self) {
        self.Expression = ::std::option::Option::None;
    }

    pub fn has_Expression(&self) -> bool {
        self.Expression.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Expression(&mut self, v: ::std::string::String) {
        self.Expression = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Expression(&mut self) -> &mut ::std::string::String {
        if self.Expression.is_none() {
            self.Expression = ::std::option::Option::Some(::std::string::String::new());
        }
        self.Expression.as_mut().unwrap()
    }

    // Take field
    pub fn take_Expression(&mut self) -> ::std::string::String {
        self.Expression.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "Name",
            |m: &Variable| { &m.Name },
            |m: &mut Variable| { &mut m.Name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "Expression",
            |m: &Variable| { &m.Expression },
            |m: &mut Variable| { &mut m.Expression },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Variable>(
            "Variable",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Variable {
    const NAME: &'static str = "Variable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.Expression = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.Name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.Expression.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.Name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.Expression.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Variable {
        Variable::new()
    }

    fn clear(&mut self) {
        self.Name = ::std::option::Option::None;
        self.Expression = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Variable {
        static instance: Variable = Variable {
            Name: ::std::option::Option::None,
            Expression: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Variable {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Variable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Variable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Variable {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.admissionregistration.v1beta1.WebhookClientConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebhookClientConfig {
    // message fields
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.WebhookClientConfig.url)
    pub url: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_31::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.WebhookClientConfig.service)
    pub service: ::protobuf::MessageField<ServiceReference>,
    // @@protoc_insertion_point(field:api.admissionregistration.v1beta1.WebhookClientConfig.caBundle)
    pub caBundle: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.admissionregistration.v1beta1.WebhookClientConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebhookClientConfig {
    fn default() -> &'a WebhookClientConfig {
        <WebhookClientConfig as ::protobuf::Message>::default_instance()
    }
}

impl WebhookClientConfig {
    pub fn new() -> WebhookClientConfig {
        ::std::default::Default::default()
    }

    // optional string url = 3;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.admissionregistration.v1beta1.ServiceReference service = 1;

    pub fn service(&self) -> &ServiceReference {
        self.service.as_ref().unwrap_or_else(|| <ServiceReference as ::protobuf::Message>::default_instance())
    }

    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    pub fn has_service(&self) -> bool {
        self.service.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ServiceReference) {
        self.service = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ServiceReference {
        self.service.mut_or_insert_default()
    }

    // Take field
    pub fn take_service(&mut self) -> ServiceReference {
        self.service.take().unwrap_or_else(|| ServiceReference::new())
    }

    // optional bytes caBundle = 2;

    pub fn caBundle(&self) -> &[u8] {
        match self.caBundle.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_caBundle(&mut self) {
        self.caBundle = ::std::option::Option::None;
    }

    pub fn has_caBundle(&self) -> bool {
        self.caBundle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caBundle(&mut self, v: ::std::vec::Vec<u8>) {
        self.caBundle = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caBundle(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.caBundle.is_none() {
            self.caBundle = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.caBundle.as_mut().unwrap()
    }

    // Take field
    pub fn take_caBundle(&mut self) -> ::std::vec::Vec<u8> {
        self.caBundle.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &WebhookClientConfig| { &m.url },
            |m: &mut WebhookClientConfig| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ServiceReference>(
            "service",
            |m: &WebhookClientConfig| { &m.service },
            |m: &mut WebhookClientConfig| { &mut m.service },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caBundle",
            |m: &WebhookClientConfig| { &m.caBundle },
            |m: &mut WebhookClientConfig| { &mut m.caBundle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebhookClientConfig>(
            "WebhookClientConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebhookClientConfig {
    const NAME: &'static str = "WebhookClientConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.service)?;
                },
                18 => {
                    self.caBundle = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.caBundle.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.service.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.caBundle.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebhookClientConfig {
        WebhookClientConfig::new()
    }

    fn clear(&mut self) {
        self.url = ::std::option::Option::None;
        self.service.clear();
        self.caBundle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebhookClientConfig {
        static instance: WebhookClientConfig = WebhookClientConfig {
            url: ::std::option::Option::None,
            service: ::protobuf::MessageField::none(),
            caBundle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebhookClientConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebhookClientConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebhookClientConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebhookClientConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n1api/admissionregistration/v1beta1/generated.proto\x12!api.admissionre\
    gistration.v1beta1\x1a,api/admissionregistration/v1/generated.proto\x1a-\
    apimachinery/pkg/apis/meta/v1/generated.proto\x1a(apimachinery/pkg/runti\
    me/generated.proto\x1a/apimachinery/pkg/runtime/schema/generated.proto\"\
    M\n\x0fAuditAnnotation\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12(\
    \n\x0fvalueExpression\x18\x02\x20\x01(\tR\x0fvalueExpression\"I\n\x11Exp\
    ressionWarning\x12\x1a\n\x08fieldRef\x18\x02\x20\x01(\tR\x08fieldRef\x12\
    \x18\n\x07warning\x18\x03\x20\x01(\tR\x07warning\"D\n\x0eMatchCondition\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1e\n\nexpression\x18\
    \x02\x20\x01(\tR\nexpression\"\xb6\x03\n\x0eMatchResources\x12Z\n\x11nam\
    espaceSelector\x18\x01\x20\x01(\x0b2,.apimachinery.pkg.apis.meta.v1.Labe\
    lSelectorR\x11namespaceSelector\x12T\n\x0eobjectSelector\x18\x02\x20\x01\
    (\x0b2,.apimachinery.pkg.apis.meta.v1.LabelSelectorR\x0eobjectSelector\
    \x12`\n\rresourceRules\x18\x03\x20\x03(\x0b2:.api.admissionregistration.\
    v1beta1.NamedRuleWithOperationsR\rresourceRules\x12n\n\x14excludeResourc\
    eRules\x18\x04\x20\x03(\x0b2:.api.admissionregistration.v1beta1.NamedRul\
    eWithOperationsR\x14excludeResourceRules\x12\x20\n\x0bmatchPolicy\x18\
    \x07\x20\x01(\tR\x0bmatchPolicy\"\xd4\x05\n\x0fMutatingWebhook\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x12Z\n\x0cclientConfig\x18\x02\x20\
    \x01(\x0b26.api.admissionregistration.v1beta1.WebhookClientConfigR\x0ccl\
    ientConfig\x12F\n\x05rules\x18\x03\x20\x03(\x0b20.api.admissionregistrat\
    ion.v1.RuleWithOperationsR\x05rules\x12$\n\rfailurePolicy\x18\x04\x20\
    \x01(\tR\rfailurePolicy\x12\x20\n\x0bmatchPolicy\x18\t\x20\x01(\tR\x0bma\
    tchPolicy\x12Z\n\x11namespaceSelector\x18\x05\x20\x01(\x0b2,.apimachiner\
    y.pkg.apis.meta.v1.LabelSelectorR\x11namespaceSelector\x12T\n\x0eobjectS\
    elector\x18\x0b\x20\x01(\x0b2,.apimachinery.pkg.apis.meta.v1.LabelSelect\
    orR\x0eobjectSelector\x12\x20\n\x0bsideEffects\x18\x06\x20\x01(\tR\x0bsi\
    deEffects\x12&\n\x0etimeoutSeconds\x18\x07\x20\x01(\x05R\x0etimeoutSecon\
    ds\x128\n\x17admissionReviewVersions\x18\x08\x20\x03(\tR\x17admissionRev\
    iewVersions\x12.\n\x12reinvocationPolicy\x18\n\x20\x01(\tR\x12reinvocati\
    onPolicy\x12[\n\x0fmatchConditions\x18\x0c\x20\x03(\x0b21.api.admissionr\
    egistration.v1beta1.MatchConditionR\x0fmatchConditions\"\xb5\x01\n\x1cMu\
    tatingWebhookConfiguration\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).api\
    machinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12N\n\x08Webhooks\
    \x18\x02\x20\x03(\x0b22.api.admissionregistration.v1beta1.MutatingWebhoo\
    kR\x08Webhooks\"\xbe\x01\n\x20MutatingWebhookConfigurationList\x12C\n\
    \x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMe\
    taR\x08metadata\x12U\n\x05items\x18\x02\x20\x03(\x0b2?.api.admissionregi\
    stration.v1beta1.MutatingWebhookConfigurationR\x05items\"\xa1\x01\n\x17N\
    amedRuleWithOperations\x12$\n\rresourceNames\x18\x01\x20\x03(\tR\rresour\
    ceNames\x12`\n\x12ruleWithOperations\x18\x02\x20\x01(\x0b20.api.admissio\
    nregistration.v1.RuleWithOperationsR\x12ruleWithOperations\"?\n\tParamKi\
    nd\x12\x1e\n\napiVersion\x18\x01\x20\x01(\tR\napiVersion\x12\x12\n\x04ki\
    nd\x18\x02\x20\x01(\tR\x04kind\"\xc0\x01\n\x08ParamRef\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12\x1c\n\tnamespace\x18\x02\x20\x01(\tR\tn\
    amespace\x12H\n\x08selector\x18\x03\x20\x01(\x0b2,.apimachinery.pkg.apis\
    .meta.v1.LabelSelectorR\x08selector\x128\n\x17parameterNotFoundAction\
    \x18\x04\x20\x01(\tR\x17parameterNotFoundAction\"l\n\x10ServiceReference\
    \x12\x1c\n\tnamespace\x18\x01\x20\x01(\tR\tnamespace\x12\x12\n\x04name\
    \x18\x02\x20\x01(\tR\x04name\x12\x12\n\x04path\x18\x03\x20\x01(\tR\x04pa\
    th\x12\x12\n\x04port\x18\x04\x20\x01(\x05R\x04port\"t\n\x0cTypeChecking\
    \x12d\n\x12expressionWarnings\x18\x01\x20\x03(\x0b24.api.admissionregist\
    ration.v1beta1.ExpressionWarningR\x12expressionWarnings\"\x94\x02\n\x19V\
    alidatingAdmissionPolicy\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apima\
    chinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12T\n\x04spec\x18\x02\
    \x20\x01(\x0b2@.api.admissionregistration.v1beta1.ValidatingAdmissionPol\
    icySpecR\x04spec\x12Z\n\x06status\x18\x03\x20\x01(\x0b2B.api.admissionre\
    gistration.v1beta1.ValidatingAdmissionPolicyStatusR\x06status\"\xc6\x01\
    \n\x20ValidatingAdmissionPolicyBinding\x12E\n\x08metadata\x18\x01\x20\
    \x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12[\n\
    \x04spec\x18\x02\x20\x01(\x0b2G.api.admissionregistration.v1beta1.Valida\
    tingAdmissionPolicyBindingSpecR\x04spec\"\xc6\x01\n$ValidatingAdmissionP\
    olicyBindingList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.\
    pkg.apis.meta.v1.ListMetaR\x08metadata\x12Y\n\x05items\x18\x02\x20\x03(\
    \x0b2C.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindin\
    gR\x05items\"\x98\x02\n$ValidatingAdmissionPolicyBindingSpec\x12\x1e\n\n\
    policyName\x18\x01\x20\x01(\tR\npolicyName\x12G\n\x08paramRef\x18\x02\
    \x20\x01(\x0b2+.api.admissionregistration.v1beta1.ParamRefR\x08paramRef\
    \x12Y\n\x0ematchResources\x18\x03\x20\x01(\x0b21.api.admissionregistrati\
    on.v1beta1.MatchResourcesR\x0ematchResources\x12,\n\x11validationActions\
    \x18\x04\x20\x03(\tR\x11validationActions\"\xb8\x01\n\x1dValidatingAdmis\
    sionPolicyList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pk\
    g.apis.meta.v1.ListMetaR\x08metadata\x12R\n\x05items\x18\x02\x20\x03(\
    \x0b2<.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyR\x05i\
    tems\"\xc9\x04\n\x1dValidatingAdmissionPolicySpec\x12J\n\tparamKind\x18\
    \x01\x20\x01(\x0b2,.api.admissionregistration.v1beta1.ParamKindR\tparamK\
    ind\x12]\n\x10matchConstraints\x18\x02\x20\x01(\x0b21.api.admissionregis\
    tration.v1beta1.MatchResourcesR\x10matchConstraints\x12O\n\x0bvalidation\
    s\x18\x03\x20\x03(\x0b2-.api.admissionregistration.v1beta1.ValidationR\
    \x0bvalidations\x12$\n\rfailurePolicy\x18\x04\x20\x01(\tR\rfailurePolicy\
    \x12^\n\x10auditAnnotations\x18\x05\x20\x03(\x0b22.api.admissionregistra\
    tion.v1beta1.AuditAnnotationR\x10auditAnnotations\x12[\n\x0fmatchConditi\
    ons\x18\x06\x20\x03(\x0b21.api.admissionregistration.v1beta1.MatchCondit\
    ionR\x0fmatchConditions\x12I\n\tvariables\x18\x07\x20\x03(\x0b2+.api.adm\
    issionregistration.v1beta1.VariableR\tvariables\"\xf0\x01\n\x1fValidatin\
    gAdmissionPolicyStatus\x12.\n\x12observedGeneration\x18\x01\x20\x01(\x03\
    R\x12observedGeneration\x12S\n\x0ctypeChecking\x18\x02\x20\x01(\x0b2/.ap\
    i.admissionregistration.v1beta1.TypeCheckingR\x0ctypeChecking\x12H\n\nco\
    nditions\x18\x03\x20\x03(\x0b2(.apimachinery.pkg.apis.meta.v1.ConditionR\
    \nconditions\"\xa6\x05\n\x11ValidatingWebhook\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x12Z\n\x0cclientConfig\x18\x02\x20\x01(\x0b26.api.a\
    dmissionregistration.v1beta1.WebhookClientConfigR\x0cclientConfig\x12F\n\
    \x05rules\x18\x03\x20\x03(\x0b20.api.admissionregistration.v1.RuleWithOp\
    erationsR\x05rules\x12$\n\rfailurePolicy\x18\x04\x20\x01(\tR\rfailurePol\
    icy\x12\x20\n\x0bmatchPolicy\x18\t\x20\x01(\tR\x0bmatchPolicy\x12Z\n\x11\
    namespaceSelector\x18\x05\x20\x01(\x0b2,.apimachinery.pkg.apis.meta.v1.L\
    abelSelectorR\x11namespaceSelector\x12T\n\x0eobjectSelector\x18\n\x20\
    \x01(\x0b2,.apimachinery.pkg.apis.meta.v1.LabelSelectorR\x0eobjectSelect\
    or\x12\x20\n\x0bsideEffects\x18\x06\x20\x01(\tR\x0bsideEffects\x12&\n\
    \x0etimeoutSeconds\x18\x07\x20\x01(\x05R\x0etimeoutSeconds\x128\n\x17adm\
    issionReviewVersions\x18\x08\x20\x03(\tR\x17admissionReviewVersions\x12[\
    \n\x0fmatchConditions\x18\x0b\x20\x03(\x0b21.api.admissionregistration.v\
    1beta1.MatchConditionR\x0fmatchConditions\"\xb9\x01\n\x1eValidatingWebho\
    okConfiguration\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachinery.p\
    kg.apis.meta.v1.ObjectMetaR\x08metadata\x12P\n\x08Webhooks\x18\x02\x20\
    \x03(\x0b24.api.admissionregistration.v1beta1.ValidatingWebhookR\x08Webh\
    ooks\"\xc2\x01\n\"ValidatingWebhookConfigurationList\x12C\n\x08metadata\
    \x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metad\
    ata\x12W\n\x05items\x18\x02\x20\x03(\x0b2A.api.admissionregistration.v1b\
    eta1.ValidatingWebhookConfigurationR\x05items\"\x8c\x01\n\nValidation\
    \x12\x1e\n\nExpression\x18\x01\x20\x01(\tR\nExpression\x12\x18\n\x07mess\
    age\x18\x02\x20\x01(\tR\x07message\x12\x16\n\x06reason\x18\x03\x20\x01(\
    \tR\x06reason\x12,\n\x11messageExpression\x18\x04\x20\x01(\tR\x11message\
    Expression\">\n\x08Variable\x12\x12\n\x04Name\x18\x01\x20\x01(\tR\x04Nam\
    e\x12\x1e\n\nExpression\x18\x02\x20\x01(\tR\nExpression\"\x92\x01\n\x13W\
    ebhookClientConfig\x12\x10\n\x03url\x18\x03\x20\x01(\tR\x03url\x12M\n\
    \x07service\x18\x01\x20\x01(\x0b23.api.admissionregistration.v1beta1.Ser\
    viceReferenceR\x07service\x12\x1a\n\x08caBundle\x18\x02\x20\x01(\x0cR\
    \x08caBundleB*Z(k8s.io/api/admissionregistration/v1beta1\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(4);
            deps.push(super::v1beta1::file_descriptor().clone());
            deps.push(super::v1beta1::file_descriptor().clone());
            deps.push(super::v1beta1::file_descriptor().clone());
            deps.push(super::v1beta1::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(25);
            messages.push(AuditAnnotation::generated_message_descriptor_data());
            messages.push(ExpressionWarning::generated_message_descriptor_data());
            messages.push(MatchCondition::generated_message_descriptor_data());
            messages.push(MatchResources::generated_message_descriptor_data());
            messages.push(MutatingWebhook::generated_message_descriptor_data());
            messages.push(MutatingWebhookConfiguration::generated_message_descriptor_data());
            messages.push(MutatingWebhookConfigurationList::generated_message_descriptor_data());
            messages.push(NamedRuleWithOperations::generated_message_descriptor_data());
            messages.push(ParamKind::generated_message_descriptor_data());
            messages.push(ParamRef::generated_message_descriptor_data());
            messages.push(ServiceReference::generated_message_descriptor_data());
            messages.push(TypeChecking::generated_message_descriptor_data());
            messages.push(ValidatingAdmissionPolicy::generated_message_descriptor_data());
            messages.push(ValidatingAdmissionPolicyBinding::generated_message_descriptor_data());
            messages.push(ValidatingAdmissionPolicyBindingList::generated_message_descriptor_data());
            messages.push(ValidatingAdmissionPolicyBindingSpec::generated_message_descriptor_data());
            messages.push(ValidatingAdmissionPolicyList::generated_message_descriptor_data());
            messages.push(ValidatingAdmissionPolicySpec::generated_message_descriptor_data());
            messages.push(ValidatingAdmissionPolicyStatus::generated_message_descriptor_data());
            messages.push(ValidatingWebhook::generated_message_descriptor_data());
            messages.push(ValidatingWebhookConfiguration::generated_message_descriptor_data());
            messages.push(ValidatingWebhookConfigurationList::generated_message_descriptor_data());
            messages.push(Validation::generated_message_descriptor_data());
            messages.push(Variable::generated_message_descriptor_data());
            messages.push(WebhookClientConfig::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
