// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc 30.2
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `api/apps/v1beta1/generated.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta1.ControllerRevision)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ControllerRevision {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.ControllerRevision.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.ControllerRevision.data)
    pub data: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::runtime::RawExtension>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.ControllerRevision.revision)
    pub revision: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta1.ControllerRevision.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ControllerRevision {
    fn default() -> &'a ControllerRevision {
        <ControllerRevision as ::protobuf::Message>::default_instance()
    }
}

impl ControllerRevision {
    pub fn new() -> ControllerRevision {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .apimachinery.pkg.runtime.RawExtension data = 2;

    pub fn data(&self) -> &crate::v1_32::apimachinery::pkg::runtime::RawExtension {
        self.data.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::runtime::RawExtension as ::protobuf::Message>::default_instance())
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: crate::v1_32::apimachinery::pkg::runtime::RawExtension) {
        self.data = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut crate::v1_32::apimachinery::pkg::runtime::RawExtension {
        self.data.mut_or_insert_default()
    }

    // Take field
    pub fn take_data(&mut self) -> crate::v1_32::apimachinery::pkg::runtime::RawExtension {
        self.data.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::runtime::RawExtension::new())
    }

    // optional int64 revision = 3;

    pub fn revision(&self) -> i64 {
        self.revision.unwrap_or(0)
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: i64) {
        self.revision = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ControllerRevision| { &m.metadata },
            |m: &mut ControllerRevision| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::runtime::RawExtension>(
            "data",
            |m: &ControllerRevision| { &m.data },
            |m: &mut ControllerRevision| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revision",
            |m: &ControllerRevision| { &m.revision },
            |m: &mut ControllerRevision| { &mut m.revision },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ControllerRevision>(
            "ControllerRevision",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ControllerRevision {
    const NAME: &'static str = "ControllerRevision";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                24 => {
                    self.revision = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.revision {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.revision {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ControllerRevision {
        ControllerRevision::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.data.clear();
        self.revision = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ControllerRevision {
        static instance: ControllerRevision = ControllerRevision {
            metadata: ::protobuf::MessageField::none(),
            data: ::protobuf::MessageField::none(),
            revision: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ControllerRevision {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ControllerRevision").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ControllerRevision {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControllerRevision {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta1.ControllerRevisionList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ControllerRevisionList {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.ControllerRevisionList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.ControllerRevisionList.items)
    pub items: ::std::vec::Vec<ControllerRevision>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta1.ControllerRevisionList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ControllerRevisionList {
    fn default() -> &'a ControllerRevisionList {
        <ControllerRevisionList as ::protobuf::Message>::default_instance()
    }
}

impl ControllerRevisionList {
    pub fn new() -> ControllerRevisionList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.apps.v1beta1.ControllerRevision items = 2;

    pub fn items(&self) -> &[ControllerRevision] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ControllerRevision>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ControllerRevision> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ControllerRevision> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ControllerRevisionList| { &m.metadata },
            |m: &mut ControllerRevisionList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ControllerRevisionList| { &m.items },
            |m: &mut ControllerRevisionList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ControllerRevisionList>(
            "ControllerRevisionList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ControllerRevisionList {
    const NAME: &'static str = "ControllerRevisionList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ControllerRevisionList {
        ControllerRevisionList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ControllerRevisionList {
        static instance: ControllerRevisionList = ControllerRevisionList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ControllerRevisionList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ControllerRevisionList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ControllerRevisionList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControllerRevisionList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta1.Deployment)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Deployment {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.Deployment.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.Deployment.spec)
    pub spec: ::protobuf::MessageField<DeploymentSpec>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.Deployment.status)
    pub status: ::protobuf::MessageField<DeploymentStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta1.Deployment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Deployment {
    fn default() -> &'a Deployment {
        <Deployment as ::protobuf::Message>::default_instance()
    }
}

impl Deployment {
    pub fn new() -> Deployment {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.apps.v1beta1.DeploymentSpec spec = 2;

    pub fn spec(&self) -> &DeploymentSpec {
        self.spec.as_ref().unwrap_or_else(|| <DeploymentSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: DeploymentSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut DeploymentSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> DeploymentSpec {
        self.spec.take().unwrap_or_else(|| DeploymentSpec::new())
    }

    // optional .api.apps.v1beta1.DeploymentStatus status = 3;

    pub fn status(&self) -> &DeploymentStatus {
        self.status.as_ref().unwrap_or_else(|| <DeploymentStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: DeploymentStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut DeploymentStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> DeploymentStatus {
        self.status.take().unwrap_or_else(|| DeploymentStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &Deployment| { &m.metadata },
            |m: &mut Deployment| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeploymentSpec>(
            "spec",
            |m: &Deployment| { &m.spec },
            |m: &mut Deployment| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeploymentStatus>(
            "status",
            |m: &Deployment| { &m.status },
            |m: &mut Deployment| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Deployment>(
            "Deployment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Deployment {
    const NAME: &'static str = "Deployment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Deployment {
        Deployment::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Deployment {
        static instance: Deployment = Deployment {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Deployment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Deployment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Deployment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Deployment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta1.DeploymentCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeploymentCondition {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentCondition.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentCondition.status)
    pub status: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentCondition.lastUpdateTime)
    pub lastUpdateTime: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::apis::meta::v1::Time>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentCondition.lastTransitionTime)
    pub lastTransitionTime: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentCondition.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentCondition.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta1.DeploymentCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeploymentCondition {
    fn default() -> &'a DeploymentCondition {
        <DeploymentCondition as ::protobuf::Message>::default_instance()
    }
}

impl DeploymentCondition {
    pub fn new() -> DeploymentCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;

    pub fn lastUpdateTime(&self) -> &crate::v1_32::apimachinery::pkg::apis::meta::v1::Time {
        self.lastUpdateTime.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastUpdateTime(&mut self) {
        self.lastUpdateTime.clear();
    }

    pub fn has_lastUpdateTime(&self) -> bool {
        self.lastUpdateTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastUpdateTime(&mut self, v: crate::v1_32::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastUpdateTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastUpdateTime(&mut self) -> &mut crate::v1_32::apimachinery::pkg::apis::meta::v1::Time {
        self.lastUpdateTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastUpdateTime(&mut self) -> crate::v1_32::apimachinery::pkg::apis::meta::v1::Time {
        self.lastUpdateTime.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 7;

    pub fn lastTransitionTime(&self) -> &crate::v1_32::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: crate::v1_32::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastTransitionTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut crate::v1_32::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> crate::v1_32::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional string reason = 4;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 5;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &DeploymentCondition| { &m.type_ },
            |m: &mut DeploymentCondition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &DeploymentCondition| { &m.status },
            |m: &mut DeploymentCondition| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::apis::meta::v1::Time>(
            "lastUpdateTime",
            |m: &DeploymentCondition| { &m.lastUpdateTime },
            |m: &mut DeploymentCondition| { &mut m.lastUpdateTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::apis::meta::v1::Time>(
            "lastTransitionTime",
            |m: &DeploymentCondition| { &m.lastTransitionTime },
            |m: &mut DeploymentCondition| { &mut m.lastTransitionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &DeploymentCondition| { &m.reason },
            |m: &mut DeploymentCondition| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &DeploymentCondition| { &m.message },
            |m: &mut DeploymentCondition| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeploymentCondition>(
            "DeploymentCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeploymentCondition {
    const NAME: &'static str = "DeploymentCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastUpdateTime)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTransitionTime)?;
                },
                34 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastUpdateTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lastUpdateTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeploymentCondition {
        DeploymentCondition::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.lastUpdateTime.clear();
        self.lastTransitionTime.clear();
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeploymentCondition {
        static instance: DeploymentCondition = DeploymentCondition {
            type_: ::std::option::Option::None,
            status: ::std::option::Option::None,
            lastUpdateTime: ::protobuf::MessageField::none(),
            lastTransitionTime: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeploymentCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeploymentCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeploymentCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeploymentCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta1.DeploymentList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeploymentList {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentList.items)
    pub items: ::std::vec::Vec<Deployment>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta1.DeploymentList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeploymentList {
    fn default() -> &'a DeploymentList {
        <DeploymentList as ::protobuf::Message>::default_instance()
    }
}

impl DeploymentList {
    pub fn new() -> DeploymentList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.apps.v1beta1.Deployment items = 2;

    pub fn items(&self) -> &[Deployment] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<Deployment>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<Deployment> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<Deployment> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &DeploymentList| { &m.metadata },
            |m: &mut DeploymentList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &DeploymentList| { &m.items },
            |m: &mut DeploymentList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeploymentList>(
            "DeploymentList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeploymentList {
    const NAME: &'static str = "DeploymentList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeploymentList {
        DeploymentList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeploymentList {
        static instance: DeploymentList = DeploymentList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeploymentList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeploymentList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeploymentList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeploymentList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta1.DeploymentRollback)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeploymentRollback {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentRollback.name)
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentRollback.updatedAnnotations)
    pub updatedAnnotations: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentRollback.rollbackTo)
    pub rollbackTo: ::protobuf::MessageField<RollbackConfig>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta1.DeploymentRollback.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeploymentRollback {
    fn default() -> &'a DeploymentRollback {
        <DeploymentRollback as ::protobuf::Message>::default_instance()
    }
}

impl DeploymentRollback {
    pub fn new() -> DeploymentRollback {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.apps.v1beta1.DeploymentRollback.UpdatedAnnotationsEntry updatedAnnotations = 2;

    pub fn updatedAnnotations(&self) -> &::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &self.updatedAnnotations
    }

    pub fn clear_updatedAnnotations(&mut self) {
        self.updatedAnnotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_updatedAnnotations(&mut self, v: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
        self.updatedAnnotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_updatedAnnotations(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &mut self.updatedAnnotations
    }

    // Take field
    pub fn take_updatedAnnotations(&mut self) -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.updatedAnnotations, ::std::collections::BTreeMap::new())
    }

    // optional .api.apps.v1beta1.RollbackConfig rollbackTo = 3;

    pub fn rollbackTo(&self) -> &RollbackConfig {
        self.rollbackTo.as_ref().unwrap_or_else(|| <RollbackConfig as ::protobuf::Message>::default_instance())
    }

    pub fn clear_rollbackTo(&mut self) {
        self.rollbackTo.clear();
    }

    pub fn has_rollbackTo(&self) -> bool {
        self.rollbackTo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollbackTo(&mut self, v: RollbackConfig) {
        self.rollbackTo = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollbackTo(&mut self) -> &mut RollbackConfig {
        self.rollbackTo.mut_or_insert_default()
    }

    // Take field
    pub fn take_rollbackTo(&mut self) -> RollbackConfig {
        self.rollbackTo.take().unwrap_or_else(|| RollbackConfig::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &DeploymentRollback| { &m.name },
            |m: &mut DeploymentRollback| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "updatedAnnotations",
            |m: &DeploymentRollback| { &m.updatedAnnotations },
            |m: &mut DeploymentRollback| { &mut m.updatedAnnotations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RollbackConfig>(
            "rollbackTo",
            |m: &DeploymentRollback| { &m.rollbackTo },
            |m: &mut DeploymentRollback| { &mut m.rollbackTo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeploymentRollback>(
            "DeploymentRollback",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeploymentRollback {
    const NAME: &'static str = "DeploymentRollback";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.updatedAnnotations.insert(key, value);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rollbackTo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for (k, v) in &self.updatedAnnotations {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.rollbackTo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for (k, v) in &self.updatedAnnotations {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.rollbackTo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeploymentRollback {
        DeploymentRollback::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.updatedAnnotations.clear();
        self.rollbackTo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeploymentRollback {
        static instance: ::protobuf::rt::Lazy<DeploymentRollback> = ::protobuf::rt::Lazy::new();
        instance.get(DeploymentRollback::new)
    }
}

impl ::protobuf::MessageFull for DeploymentRollback {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeploymentRollback").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeploymentRollback {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeploymentRollback {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta1.DeploymentSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeploymentSpec {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentSpec.replicas)
    pub replicas: ::std::option::Option<i32>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentSpec.selector)
    pub selector: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentSpec.template)
    pub template: ::protobuf::MessageField<crate::v1_32::api::core::v1::PodTemplateSpec>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentSpec.strategy)
    pub strategy: ::protobuf::MessageField<DeploymentStrategy>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentSpec.minReadySeconds)
    pub minReadySeconds: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentSpec.revisionHistoryLimit)
    pub revisionHistoryLimit: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentSpec.paused)
    pub paused: ::std::option::Option<bool>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentSpec.rollbackTo)
    pub rollbackTo: ::protobuf::MessageField<RollbackConfig>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentSpec.progressDeadlineSeconds)
    pub progressDeadlineSeconds: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta1.DeploymentSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeploymentSpec {
    fn default() -> &'a DeploymentSpec {
        <DeploymentSpec as ::protobuf::Message>::default_instance()
    }
}

impl DeploymentSpec {
    pub fn new() -> DeploymentSpec {
        ::std::default::Default::default()
    }

    // optional int32 replicas = 1;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;

    pub fn selector(&self) -> &crate::v1_32::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    pub fn has_selector(&self) -> bool {
        self.selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: crate::v1_32::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.selector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selector(&mut self) -> &mut crate::v1_32::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.mut_or_insert_default()
    }

    // Take field
    pub fn take_selector(&mut self) -> crate::v1_32::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional .api.core.v1.PodTemplateSpec template = 3;

    pub fn template(&self) -> &crate::v1_32::api::core::v1::PodTemplateSpec {
        self.template.as_ref().unwrap_or_else(|| <crate::v1_32::api::core::v1::PodTemplateSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_template(&mut self) {
        self.template.clear();
    }

    pub fn has_template(&self) -> bool {
        self.template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template(&mut self, v: crate::v1_32::api::core::v1::PodTemplateSpec) {
        self.template = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template(&mut self) -> &mut crate::v1_32::api::core::v1::PodTemplateSpec {
        self.template.mut_or_insert_default()
    }

    // Take field
    pub fn take_template(&mut self) -> crate::v1_32::api::core::v1::PodTemplateSpec {
        self.template.take().unwrap_or_else(|| crate::v1_32::api::core::v1::PodTemplateSpec::new())
    }

    // optional .api.apps.v1beta1.DeploymentStrategy strategy = 4;

    pub fn strategy(&self) -> &DeploymentStrategy {
        self.strategy.as_ref().unwrap_or_else(|| <DeploymentStrategy as ::protobuf::Message>::default_instance())
    }

    pub fn clear_strategy(&mut self) {
        self.strategy.clear();
    }

    pub fn has_strategy(&self) -> bool {
        self.strategy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strategy(&mut self, v: DeploymentStrategy) {
        self.strategy = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_strategy(&mut self) -> &mut DeploymentStrategy {
        self.strategy.mut_or_insert_default()
    }

    // Take field
    pub fn take_strategy(&mut self) -> DeploymentStrategy {
        self.strategy.take().unwrap_or_else(|| DeploymentStrategy::new())
    }

    // optional int32 minReadySeconds = 5;

    pub fn minReadySeconds(&self) -> i32 {
        self.minReadySeconds.unwrap_or(0)
    }

    pub fn clear_minReadySeconds(&mut self) {
        self.minReadySeconds = ::std::option::Option::None;
    }

    pub fn has_minReadySeconds(&self) -> bool {
        self.minReadySeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minReadySeconds(&mut self, v: i32) {
        self.minReadySeconds = ::std::option::Option::Some(v);
    }

    // optional int32 revisionHistoryLimit = 6;

    pub fn revisionHistoryLimit(&self) -> i32 {
        self.revisionHistoryLimit.unwrap_or(0)
    }

    pub fn clear_revisionHistoryLimit(&mut self) {
        self.revisionHistoryLimit = ::std::option::Option::None;
    }

    pub fn has_revisionHistoryLimit(&self) -> bool {
        self.revisionHistoryLimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revisionHistoryLimit(&mut self, v: i32) {
        self.revisionHistoryLimit = ::std::option::Option::Some(v);
    }

    // optional bool paused = 7;

    pub fn paused(&self) -> bool {
        self.paused.unwrap_or(false)
    }

    pub fn clear_paused(&mut self) {
        self.paused = ::std::option::Option::None;
    }

    pub fn has_paused(&self) -> bool {
        self.paused.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paused(&mut self, v: bool) {
        self.paused = ::std::option::Option::Some(v);
    }

    // optional .api.apps.v1beta1.RollbackConfig rollbackTo = 8;

    pub fn rollbackTo(&self) -> &RollbackConfig {
        self.rollbackTo.as_ref().unwrap_or_else(|| <RollbackConfig as ::protobuf::Message>::default_instance())
    }

    pub fn clear_rollbackTo(&mut self) {
        self.rollbackTo.clear();
    }

    pub fn has_rollbackTo(&self) -> bool {
        self.rollbackTo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollbackTo(&mut self, v: RollbackConfig) {
        self.rollbackTo = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollbackTo(&mut self) -> &mut RollbackConfig {
        self.rollbackTo.mut_or_insert_default()
    }

    // Take field
    pub fn take_rollbackTo(&mut self) -> RollbackConfig {
        self.rollbackTo.take().unwrap_or_else(|| RollbackConfig::new())
    }

    // optional int32 progressDeadlineSeconds = 9;

    pub fn progressDeadlineSeconds(&self) -> i32 {
        self.progressDeadlineSeconds.unwrap_or(0)
    }

    pub fn clear_progressDeadlineSeconds(&mut self) {
        self.progressDeadlineSeconds = ::std::option::Option::None;
    }

    pub fn has_progressDeadlineSeconds(&self) -> bool {
        self.progressDeadlineSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progressDeadlineSeconds(&mut self, v: i32) {
        self.progressDeadlineSeconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &DeploymentSpec| { &m.replicas },
            |m: &mut DeploymentSpec| { &mut m.replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "selector",
            |m: &DeploymentSpec| { &m.selector },
            |m: &mut DeploymentSpec| { &mut m.selector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::api::core::v1::PodTemplateSpec>(
            "template",
            |m: &DeploymentSpec| { &m.template },
            |m: &mut DeploymentSpec| { &mut m.template },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeploymentStrategy>(
            "strategy",
            |m: &DeploymentSpec| { &m.strategy },
            |m: &mut DeploymentSpec| { &mut m.strategy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minReadySeconds",
            |m: &DeploymentSpec| { &m.minReadySeconds },
            |m: &mut DeploymentSpec| { &mut m.minReadySeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revisionHistoryLimit",
            |m: &DeploymentSpec| { &m.revisionHistoryLimit },
            |m: &mut DeploymentSpec| { &mut m.revisionHistoryLimit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "paused",
            |m: &DeploymentSpec| { &m.paused },
            |m: &mut DeploymentSpec| { &mut m.paused },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RollbackConfig>(
            "rollbackTo",
            |m: &DeploymentSpec| { &m.rollbackTo },
            |m: &mut DeploymentSpec| { &mut m.rollbackTo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "progressDeadlineSeconds",
            |m: &DeploymentSpec| { &m.progressDeadlineSeconds },
            |m: &mut DeploymentSpec| { &mut m.progressDeadlineSeconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeploymentSpec>(
            "DeploymentSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeploymentSpec {
    const NAME: &'static str = "DeploymentSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.selector)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.template)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.strategy)?;
                },
                40 => {
                    self.minReadySeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.revisionHistoryLimit = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.paused = ::std::option::Option::Some(is.read_bool()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rollbackTo)?;
                },
                72 => {
                    self.progressDeadlineSeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.strategy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.minReadySeconds {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.revisionHistoryLimit {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.paused {
            my_size += 1 + 1;
        }
        if let Some(v) = self.rollbackTo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.progressDeadlineSeconds {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.replicas {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.selector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.template.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.strategy.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.minReadySeconds {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.revisionHistoryLimit {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.paused {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.rollbackTo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.progressDeadlineSeconds {
            os.write_int32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeploymentSpec {
        DeploymentSpec::new()
    }

    fn clear(&mut self) {
        self.replicas = ::std::option::Option::None;
        self.selector.clear();
        self.template.clear();
        self.strategy.clear();
        self.minReadySeconds = ::std::option::Option::None;
        self.revisionHistoryLimit = ::std::option::Option::None;
        self.paused = ::std::option::Option::None;
        self.rollbackTo.clear();
        self.progressDeadlineSeconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeploymentSpec {
        static instance: DeploymentSpec = DeploymentSpec {
            replicas: ::std::option::Option::None,
            selector: ::protobuf::MessageField::none(),
            template: ::protobuf::MessageField::none(),
            strategy: ::protobuf::MessageField::none(),
            minReadySeconds: ::std::option::Option::None,
            revisionHistoryLimit: ::std::option::Option::None,
            paused: ::std::option::Option::None,
            rollbackTo: ::protobuf::MessageField::none(),
            progressDeadlineSeconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeploymentSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeploymentSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeploymentSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeploymentSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta1.DeploymentStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeploymentStatus {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentStatus.observedGeneration)
    pub observedGeneration: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentStatus.replicas)
    pub replicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentStatus.updatedReplicas)
    pub updatedReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentStatus.readyReplicas)
    pub readyReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentStatus.availableReplicas)
    pub availableReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentStatus.unavailableReplicas)
    pub unavailableReplicas: ::std::option::Option<i32>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentStatus.conditions)
    pub conditions: ::std::vec::Vec<DeploymentCondition>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentStatus.collisionCount)
    pub collisionCount: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta1.DeploymentStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeploymentStatus {
    fn default() -> &'a DeploymentStatus {
        <DeploymentStatus as ::protobuf::Message>::default_instance()
    }
}

impl DeploymentStatus {
    pub fn new() -> DeploymentStatus {
        ::std::default::Default::default()
    }

    // optional int64 observedGeneration = 1;

    pub fn observedGeneration(&self) -> i64 {
        self.observedGeneration.unwrap_or(0)
    }

    pub fn clear_observedGeneration(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
    }

    pub fn has_observedGeneration(&self) -> bool {
        self.observedGeneration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observedGeneration(&mut self, v: i64) {
        self.observedGeneration = ::std::option::Option::Some(v);
    }

    // optional int32 replicas = 2;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // optional int32 updatedReplicas = 3;

    pub fn updatedReplicas(&self) -> i32 {
        self.updatedReplicas.unwrap_or(0)
    }

    pub fn clear_updatedReplicas(&mut self) {
        self.updatedReplicas = ::std::option::Option::None;
    }

    pub fn has_updatedReplicas(&self) -> bool {
        self.updatedReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updatedReplicas(&mut self, v: i32) {
        self.updatedReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 readyReplicas = 7;

    pub fn readyReplicas(&self) -> i32 {
        self.readyReplicas.unwrap_or(0)
    }

    pub fn clear_readyReplicas(&mut self) {
        self.readyReplicas = ::std::option::Option::None;
    }

    pub fn has_readyReplicas(&self) -> bool {
        self.readyReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readyReplicas(&mut self, v: i32) {
        self.readyReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 availableReplicas = 4;

    pub fn availableReplicas(&self) -> i32 {
        self.availableReplicas.unwrap_or(0)
    }

    pub fn clear_availableReplicas(&mut self) {
        self.availableReplicas = ::std::option::Option::None;
    }

    pub fn has_availableReplicas(&self) -> bool {
        self.availableReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_availableReplicas(&mut self, v: i32) {
        self.availableReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 unavailableReplicas = 5;

    pub fn unavailableReplicas(&self) -> i32 {
        self.unavailableReplicas.unwrap_or(0)
    }

    pub fn clear_unavailableReplicas(&mut self) {
        self.unavailableReplicas = ::std::option::Option::None;
    }

    pub fn has_unavailableReplicas(&self) -> bool {
        self.unavailableReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unavailableReplicas(&mut self, v: i32) {
        self.unavailableReplicas = ::std::option::Option::Some(v);
    }

    // repeated .api.apps.v1beta1.DeploymentCondition conditions = 6;

    pub fn conditions(&self) -> &[DeploymentCondition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<DeploymentCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<DeploymentCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<DeploymentCondition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    // optional int32 collisionCount = 8;

    pub fn collisionCount(&self) -> i32 {
        self.collisionCount.unwrap_or(0)
    }

    pub fn clear_collisionCount(&mut self) {
        self.collisionCount = ::std::option::Option::None;
    }

    pub fn has_collisionCount(&self) -> bool {
        self.collisionCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_collisionCount(&mut self, v: i32) {
        self.collisionCount = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "observedGeneration",
            |m: &DeploymentStatus| { &m.observedGeneration },
            |m: &mut DeploymentStatus| { &mut m.observedGeneration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &DeploymentStatus| { &m.replicas },
            |m: &mut DeploymentStatus| { &mut m.replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "updatedReplicas",
            |m: &DeploymentStatus| { &m.updatedReplicas },
            |m: &mut DeploymentStatus| { &mut m.updatedReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readyReplicas",
            |m: &DeploymentStatus| { &m.readyReplicas },
            |m: &mut DeploymentStatus| { &mut m.readyReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "availableReplicas",
            |m: &DeploymentStatus| { &m.availableReplicas },
            |m: &mut DeploymentStatus| { &mut m.availableReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unavailableReplicas",
            |m: &DeploymentStatus| { &m.unavailableReplicas },
            |m: &mut DeploymentStatus| { &mut m.unavailableReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &DeploymentStatus| { &m.conditions },
            |m: &mut DeploymentStatus| { &mut m.conditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "collisionCount",
            |m: &DeploymentStatus| { &m.collisionCount },
            |m: &mut DeploymentStatus| { &mut m.collisionCount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeploymentStatus>(
            "DeploymentStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeploymentStatus {
    const NAME: &'static str = "DeploymentStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.observedGeneration = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.updatedReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.readyReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.availableReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.unavailableReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    self.conditions.push(is.read_message()?);
                },
                64 => {
                    self.collisionCount = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.observedGeneration {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.updatedReplicas {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.readyReplicas {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.availableReplicas {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.unavailableReplicas {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.collisionCount {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.observedGeneration {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.replicas {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.updatedReplicas {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.readyReplicas {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.availableReplicas {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.unavailableReplicas {
            os.write_int32(5, v)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.collisionCount {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeploymentStatus {
        DeploymentStatus::new()
    }

    fn clear(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
        self.replicas = ::std::option::Option::None;
        self.updatedReplicas = ::std::option::Option::None;
        self.readyReplicas = ::std::option::Option::None;
        self.availableReplicas = ::std::option::Option::None;
        self.unavailableReplicas = ::std::option::Option::None;
        self.conditions.clear();
        self.collisionCount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeploymentStatus {
        static instance: DeploymentStatus = DeploymentStatus {
            observedGeneration: ::std::option::Option::None,
            replicas: ::std::option::Option::None,
            updatedReplicas: ::std::option::Option::None,
            readyReplicas: ::std::option::Option::None,
            availableReplicas: ::std::option::Option::None,
            unavailableReplicas: ::std::option::Option::None,
            conditions: ::std::vec::Vec::new(),
            collisionCount: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeploymentStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeploymentStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeploymentStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeploymentStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta1.DeploymentStrategy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeploymentStrategy {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentStrategy.type)
    pub type_: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.DeploymentStrategy.rollingUpdate)
    pub rollingUpdate: ::protobuf::MessageField<RollingUpdateDeployment>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta1.DeploymentStrategy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeploymentStrategy {
    fn default() -> &'a DeploymentStrategy {
        <DeploymentStrategy as ::protobuf::Message>::default_instance()
    }
}

impl DeploymentStrategy {
    pub fn new() -> DeploymentStrategy {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.apps.v1beta1.RollingUpdateDeployment rollingUpdate = 2;

    pub fn rollingUpdate(&self) -> &RollingUpdateDeployment {
        self.rollingUpdate.as_ref().unwrap_or_else(|| <RollingUpdateDeployment as ::protobuf::Message>::default_instance())
    }

    pub fn clear_rollingUpdate(&mut self) {
        self.rollingUpdate.clear();
    }

    pub fn has_rollingUpdate(&self) -> bool {
        self.rollingUpdate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollingUpdate(&mut self, v: RollingUpdateDeployment) {
        self.rollingUpdate = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollingUpdate(&mut self) -> &mut RollingUpdateDeployment {
        self.rollingUpdate.mut_or_insert_default()
    }

    // Take field
    pub fn take_rollingUpdate(&mut self) -> RollingUpdateDeployment {
        self.rollingUpdate.take().unwrap_or_else(|| RollingUpdateDeployment::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &DeploymentStrategy| { &m.type_ },
            |m: &mut DeploymentStrategy| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RollingUpdateDeployment>(
            "rollingUpdate",
            |m: &DeploymentStrategy| { &m.rollingUpdate },
            |m: &mut DeploymentStrategy| { &mut m.rollingUpdate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeploymentStrategy>(
            "DeploymentStrategy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeploymentStrategy {
    const NAME: &'static str = "DeploymentStrategy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rollingUpdate)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.rollingUpdate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.rollingUpdate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeploymentStrategy {
        DeploymentStrategy::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.rollingUpdate.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeploymentStrategy {
        static instance: DeploymentStrategy = DeploymentStrategy {
            type_: ::std::option::Option::None,
            rollingUpdate: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeploymentStrategy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeploymentStrategy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeploymentStrategy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeploymentStrategy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta1.RollbackConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RollbackConfig {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta1.RollbackConfig.revision)
    pub revision: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta1.RollbackConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RollbackConfig {
    fn default() -> &'a RollbackConfig {
        <RollbackConfig as ::protobuf::Message>::default_instance()
    }
}

impl RollbackConfig {
    pub fn new() -> RollbackConfig {
        ::std::default::Default::default()
    }

    // optional int64 revision = 1;

    pub fn revision(&self) -> i64 {
        self.revision.unwrap_or(0)
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: i64) {
        self.revision = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revision",
            |m: &RollbackConfig| { &m.revision },
            |m: &mut RollbackConfig| { &mut m.revision },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RollbackConfig>(
            "RollbackConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RollbackConfig {
    const NAME: &'static str = "RollbackConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.revision = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.revision {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.revision {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RollbackConfig {
        RollbackConfig::new()
    }

    fn clear(&mut self) {
        self.revision = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RollbackConfig {
        static instance: RollbackConfig = RollbackConfig {
            revision: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RollbackConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RollbackConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RollbackConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollbackConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta1.RollingUpdateDeployment)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RollingUpdateDeployment {
    // message fields
    #[serde(with = "crate::v1_32::intorstr")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.RollingUpdateDeployment.maxUnavailable)
    pub maxUnavailable: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::util::intstr::IntOrString>,
    #[serde(with = "crate::v1_32::intorstr")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.RollingUpdateDeployment.maxSurge)
    pub maxSurge: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::util::intstr::IntOrString>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta1.RollingUpdateDeployment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RollingUpdateDeployment {
    fn default() -> &'a RollingUpdateDeployment {
        <RollingUpdateDeployment as ::protobuf::Message>::default_instance()
    }
}

impl RollingUpdateDeployment {
    pub fn new() -> RollingUpdateDeployment {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;

    pub fn maxUnavailable(&self) -> &crate::v1_32::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::util::intstr::IntOrString as ::protobuf::Message>::default_instance())
    }

    pub fn clear_maxUnavailable(&mut self) {
        self.maxUnavailable.clear();
    }

    pub fn has_maxUnavailable(&self) -> bool {
        self.maxUnavailable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxUnavailable(&mut self, v: crate::v1_32::apimachinery::pkg::util::intstr::IntOrString) {
        self.maxUnavailable = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maxUnavailable(&mut self) -> &mut crate::v1_32::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.mut_or_insert_default()
    }

    // Take field
    pub fn take_maxUnavailable(&mut self) -> crate::v1_32::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::util::intstr::IntOrString::new())
    }

    // optional .apimachinery.pkg.util.intstr.IntOrString maxSurge = 2;

    pub fn maxSurge(&self) -> &crate::v1_32::apimachinery::pkg::util::intstr::IntOrString {
        self.maxSurge.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::util::intstr::IntOrString as ::protobuf::Message>::default_instance())
    }

    pub fn clear_maxSurge(&mut self) {
        self.maxSurge.clear();
    }

    pub fn has_maxSurge(&self) -> bool {
        self.maxSurge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxSurge(&mut self, v: crate::v1_32::apimachinery::pkg::util::intstr::IntOrString) {
        self.maxSurge = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maxSurge(&mut self) -> &mut crate::v1_32::apimachinery::pkg::util::intstr::IntOrString {
        self.maxSurge.mut_or_insert_default()
    }

    // Take field
    pub fn take_maxSurge(&mut self) -> crate::v1_32::apimachinery::pkg::util::intstr::IntOrString {
        self.maxSurge.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::util::intstr::IntOrString::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::util::intstr::IntOrString>(
            "maxUnavailable",
            |m: &RollingUpdateDeployment| { &m.maxUnavailable },
            |m: &mut RollingUpdateDeployment| { &mut m.maxUnavailable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::util::intstr::IntOrString>(
            "maxSurge",
            |m: &RollingUpdateDeployment| { &m.maxSurge },
            |m: &mut RollingUpdateDeployment| { &mut m.maxSurge },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RollingUpdateDeployment>(
            "RollingUpdateDeployment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RollingUpdateDeployment {
    const NAME: &'static str = "RollingUpdateDeployment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.maxUnavailable)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.maxSurge)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.maxUnavailable.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.maxSurge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.maxUnavailable.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.maxSurge.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RollingUpdateDeployment {
        RollingUpdateDeployment::new()
    }

    fn clear(&mut self) {
        self.maxUnavailable.clear();
        self.maxSurge.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RollingUpdateDeployment {
        static instance: RollingUpdateDeployment = RollingUpdateDeployment {
            maxUnavailable: ::protobuf::MessageField::none(),
            maxSurge: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RollingUpdateDeployment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RollingUpdateDeployment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RollingUpdateDeployment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpdateDeployment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta1.RollingUpdateStatefulSetStrategy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RollingUpdateStatefulSetStrategy {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta1.RollingUpdateStatefulSetStrategy.partition)
    pub partition: ::std::option::Option<i32>,
    #[serde(with = "crate::v1_32::intorstr")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.RollingUpdateStatefulSetStrategy.maxUnavailable)
    pub maxUnavailable: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::util::intstr::IntOrString>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta1.RollingUpdateStatefulSetStrategy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RollingUpdateStatefulSetStrategy {
    fn default() -> &'a RollingUpdateStatefulSetStrategy {
        <RollingUpdateStatefulSetStrategy as ::protobuf::Message>::default_instance()
    }
}

impl RollingUpdateStatefulSetStrategy {
    pub fn new() -> RollingUpdateStatefulSetStrategy {
        ::std::default::Default::default()
    }

    // optional int32 partition = 1;

    pub fn partition(&self) -> i32 {
        self.partition.unwrap_or(0)
    }

    pub fn clear_partition(&mut self) {
        self.partition = ::std::option::Option::None;
    }

    pub fn has_partition(&self) -> bool {
        self.partition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partition(&mut self, v: i32) {
        self.partition = ::std::option::Option::Some(v);
    }

    // optional .apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 2;

    pub fn maxUnavailable(&self) -> &crate::v1_32::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::util::intstr::IntOrString as ::protobuf::Message>::default_instance())
    }

    pub fn clear_maxUnavailable(&mut self) {
        self.maxUnavailable.clear();
    }

    pub fn has_maxUnavailable(&self) -> bool {
        self.maxUnavailable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxUnavailable(&mut self, v: crate::v1_32::apimachinery::pkg::util::intstr::IntOrString) {
        self.maxUnavailable = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maxUnavailable(&mut self) -> &mut crate::v1_32::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.mut_or_insert_default()
    }

    // Take field
    pub fn take_maxUnavailable(&mut self) -> crate::v1_32::apimachinery::pkg::util::intstr::IntOrString {
        self.maxUnavailable.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::util::intstr::IntOrString::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "partition",
            |m: &RollingUpdateStatefulSetStrategy| { &m.partition },
            |m: &mut RollingUpdateStatefulSetStrategy| { &mut m.partition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::util::intstr::IntOrString>(
            "maxUnavailable",
            |m: &RollingUpdateStatefulSetStrategy| { &m.maxUnavailable },
            |m: &mut RollingUpdateStatefulSetStrategy| { &mut m.maxUnavailable },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RollingUpdateStatefulSetStrategy>(
            "RollingUpdateStatefulSetStrategy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RollingUpdateStatefulSetStrategy {
    const NAME: &'static str = "RollingUpdateStatefulSetStrategy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.partition = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.maxUnavailable)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.partition {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.maxUnavailable.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.partition {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.maxUnavailable.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RollingUpdateStatefulSetStrategy {
        RollingUpdateStatefulSetStrategy::new()
    }

    fn clear(&mut self) {
        self.partition = ::std::option::Option::None;
        self.maxUnavailable.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RollingUpdateStatefulSetStrategy {
        static instance: RollingUpdateStatefulSetStrategy = RollingUpdateStatefulSetStrategy {
            partition: ::std::option::Option::None,
            maxUnavailable: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RollingUpdateStatefulSetStrategy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RollingUpdateStatefulSetStrategy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RollingUpdateStatefulSetStrategy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpdateStatefulSetStrategy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta1.Scale)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Scale {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.Scale.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.Scale.spec)
    pub spec: ::protobuf::MessageField<ScaleSpec>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.Scale.status)
    pub status: ::protobuf::MessageField<ScaleStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta1.Scale.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Scale {
    fn default() -> &'a Scale {
        <Scale as ::protobuf::Message>::default_instance()
    }
}

impl Scale {
    pub fn new() -> Scale {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.apps.v1beta1.ScaleSpec spec = 2;

    pub fn spec(&self) -> &ScaleSpec {
        self.spec.as_ref().unwrap_or_else(|| <ScaleSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ScaleSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ScaleSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ScaleSpec {
        self.spec.take().unwrap_or_else(|| ScaleSpec::new())
    }

    // optional .api.apps.v1beta1.ScaleStatus status = 3;

    pub fn status(&self) -> &ScaleStatus {
        self.status.as_ref().unwrap_or_else(|| <ScaleStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ScaleStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ScaleStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> ScaleStatus {
        self.status.take().unwrap_or_else(|| ScaleStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &Scale| { &m.metadata },
            |m: &mut Scale| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ScaleSpec>(
            "spec",
            |m: &Scale| { &m.spec },
            |m: &mut Scale| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ScaleStatus>(
            "status",
            |m: &Scale| { &m.status },
            |m: &mut Scale| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Scale>(
            "Scale",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Scale {
    const NAME: &'static str = "Scale";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Scale {
        Scale::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Scale {
        static instance: Scale = Scale {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Scale {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Scale").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Scale {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Scale {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta1.ScaleSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ScaleSpec {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta1.ScaleSpec.replicas)
    pub replicas: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta1.ScaleSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScaleSpec {
    fn default() -> &'a ScaleSpec {
        <ScaleSpec as ::protobuf::Message>::default_instance()
    }
}

impl ScaleSpec {
    pub fn new() -> ScaleSpec {
        ::std::default::Default::default()
    }

    // optional int32 replicas = 1;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &ScaleSpec| { &m.replicas },
            |m: &mut ScaleSpec| { &mut m.replicas },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScaleSpec>(
            "ScaleSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScaleSpec {
    const NAME: &'static str = "ScaleSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.replicas {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScaleSpec {
        ScaleSpec::new()
    }

    fn clear(&mut self) {
        self.replicas = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScaleSpec {
        static instance: ScaleSpec = ScaleSpec {
            replicas: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScaleSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScaleSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScaleSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScaleSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta1.ScaleStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ScaleStatus {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta1.ScaleStatus.replicas)
    pub replicas: ::std::option::Option<i32>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.ScaleStatus.selector)
    pub selector: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.ScaleStatus.targetSelector)
    pub targetSelector: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta1.ScaleStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScaleStatus {
    fn default() -> &'a ScaleStatus {
        <ScaleStatus as ::protobuf::Message>::default_instance()
    }
}

impl ScaleStatus {
    pub fn new() -> ScaleStatus {
        ::std::default::Default::default()
    }

    // optional int32 replicas = 1;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // repeated .api.apps.v1beta1.ScaleStatus.SelectorEntry selector = 2;

    pub fn selector(&self) -> &::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &self.selector
    }

    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
        self.selector = v;
    }

    // Mutable pointer to the field.
    pub fn mut_selector(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        &mut self.selector
    }

    // Take field
    pub fn take_selector(&mut self) -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.selector, ::std::collections::BTreeMap::new())
    }

    // optional string targetSelector = 3;

    pub fn targetSelector(&self) -> &str {
        match self.targetSelector.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_targetSelector(&mut self) {
        self.targetSelector = ::std::option::Option::None;
    }

    pub fn has_targetSelector(&self) -> bool {
        self.targetSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetSelector(&mut self, v: ::std::string::String) {
        self.targetSelector = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetSelector(&mut self) -> &mut ::std::string::String {
        if self.targetSelector.is_none() {
            self.targetSelector = ::std::option::Option::Some(::std::string::String::new());
        }
        self.targetSelector.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetSelector(&mut self) -> ::std::string::String {
        self.targetSelector.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &ScaleStatus| { &m.replicas },
            |m: &mut ScaleStatus| { &mut m.replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "selector",
            |m: &ScaleStatus| { &m.selector },
            |m: &mut ScaleStatus| { &mut m.selector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "targetSelector",
            |m: &ScaleStatus| { &m.targetSelector },
            |m: &mut ScaleStatus| { &mut m.targetSelector },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScaleStatus>(
            "ScaleStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScaleStatus {
    const NAME: &'static str = "ScaleStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.selector.insert(key, value);
                },
                26 => {
                    self.targetSelector = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for (k, v) in &self.selector {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.targetSelector.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.replicas {
            os.write_int32(1, v)?;
        }
        for (k, v) in &self.selector {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.targetSelector.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScaleStatus {
        ScaleStatus::new()
    }

    fn clear(&mut self) {
        self.replicas = ::std::option::Option::None;
        self.selector.clear();
        self.targetSelector = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScaleStatus {
        static instance: ::protobuf::rt::Lazy<ScaleStatus> = ::protobuf::rt::Lazy::new();
        instance.get(ScaleStatus::new)
    }
}

impl ::protobuf::MessageFull for ScaleStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScaleStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScaleStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScaleStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta1.StatefulSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatefulSet {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSet.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSet.spec)
    pub spec: ::protobuf::MessageField<StatefulSetSpec>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSet.status)
    pub status: ::protobuf::MessageField<StatefulSetStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta1.StatefulSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatefulSet {
    fn default() -> &'a StatefulSet {
        <StatefulSet as ::protobuf::Message>::default_instance()
    }
}

impl StatefulSet {
    pub fn new() -> StatefulSet {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.apps.v1beta1.StatefulSetSpec spec = 2;

    pub fn spec(&self) -> &StatefulSetSpec {
        self.spec.as_ref().unwrap_or_else(|| <StatefulSetSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: StatefulSetSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut StatefulSetSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> StatefulSetSpec {
        self.spec.take().unwrap_or_else(|| StatefulSetSpec::new())
    }

    // optional .api.apps.v1beta1.StatefulSetStatus status = 3;

    pub fn status(&self) -> &StatefulSetStatus {
        self.status.as_ref().unwrap_or_else(|| <StatefulSetStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: StatefulSetStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut StatefulSetStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> StatefulSetStatus {
        self.status.take().unwrap_or_else(|| StatefulSetStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &StatefulSet| { &m.metadata },
            |m: &mut StatefulSet| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StatefulSetSpec>(
            "spec",
            |m: &StatefulSet| { &m.spec },
            |m: &mut StatefulSet| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StatefulSetStatus>(
            "status",
            |m: &StatefulSet| { &m.status },
            |m: &mut StatefulSet| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatefulSet>(
            "StatefulSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatefulSet {
    const NAME: &'static str = "StatefulSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatefulSet {
        StatefulSet::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatefulSet {
        static instance: StatefulSet = StatefulSet {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatefulSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatefulSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatefulSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatefulSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta1.StatefulSetCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatefulSetCondition {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetCondition.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetCondition.status)
    pub status: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetCondition.lastTransitionTime)
    pub lastTransitionTime: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetCondition.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetCondition.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta1.StatefulSetCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatefulSetCondition {
    fn default() -> &'a StatefulSetCondition {
        <StatefulSetCondition as ::protobuf::Message>::default_instance()
    }
}

impl StatefulSetCondition {
    pub fn new() -> StatefulSetCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

    pub fn lastTransitionTime(&self) -> &crate::v1_32::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: crate::v1_32::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastTransitionTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut crate::v1_32::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> crate::v1_32::apimachinery::pkg::apis::meta::v1::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional string reason = 4;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 5;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &StatefulSetCondition| { &m.type_ },
            |m: &mut StatefulSetCondition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &StatefulSetCondition| { &m.status },
            |m: &mut StatefulSetCondition| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::apis::meta::v1::Time>(
            "lastTransitionTime",
            |m: &StatefulSetCondition| { &m.lastTransitionTime },
            |m: &mut StatefulSetCondition| { &mut m.lastTransitionTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &StatefulSetCondition| { &m.reason },
            |m: &mut StatefulSetCondition| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &StatefulSetCondition| { &m.message },
            |m: &mut StatefulSetCondition| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatefulSetCondition>(
            "StatefulSetCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatefulSetCondition {
    const NAME: &'static str = "StatefulSetCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastTransitionTime)?;
                },
                34 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lastTransitionTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatefulSetCondition {
        StatefulSetCondition::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.lastTransitionTime.clear();
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatefulSetCondition {
        static instance: StatefulSetCondition = StatefulSetCondition {
            type_: ::std::option::Option::None,
            status: ::std::option::Option::None,
            lastTransitionTime: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatefulSetCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatefulSetCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatefulSetCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatefulSetCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta1.StatefulSetList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatefulSetList {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetList.items)
    pub items: ::std::vec::Vec<StatefulSet>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta1.StatefulSetList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatefulSetList {
    fn default() -> &'a StatefulSetList {
        <StatefulSetList as ::protobuf::Message>::default_instance()
    }
}

impl StatefulSetList {
    pub fn new() -> StatefulSetList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.apps.v1beta1.StatefulSet items = 2;

    pub fn items(&self) -> &[StatefulSet] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<StatefulSet>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<StatefulSet> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<StatefulSet> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &StatefulSetList| { &m.metadata },
            |m: &mut StatefulSetList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &StatefulSetList| { &m.items },
            |m: &mut StatefulSetList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatefulSetList>(
            "StatefulSetList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatefulSetList {
    const NAME: &'static str = "StatefulSetList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatefulSetList {
        StatefulSetList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatefulSetList {
        static instance: StatefulSetList = StatefulSetList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatefulSetList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatefulSetList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatefulSetList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatefulSetList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta1.StatefulSetOrdinals)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatefulSetOrdinals {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetOrdinals.start)
    pub start: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta1.StatefulSetOrdinals.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatefulSetOrdinals {
    fn default() -> &'a StatefulSetOrdinals {
        <StatefulSetOrdinals as ::protobuf::Message>::default_instance()
    }
}

impl StatefulSetOrdinals {
    pub fn new() -> StatefulSetOrdinals {
        ::std::default::Default::default()
    }

    // optional int32 start = 1;

    pub fn start(&self) -> i32 {
        self.start.unwrap_or(0)
    }

    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: i32) {
        self.start = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start",
            |m: &StatefulSetOrdinals| { &m.start },
            |m: &mut StatefulSetOrdinals| { &mut m.start },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatefulSetOrdinals>(
            "StatefulSetOrdinals",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatefulSetOrdinals {
    const NAME: &'static str = "StatefulSetOrdinals";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.start = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatefulSetOrdinals {
        StatefulSetOrdinals::new()
    }

    fn clear(&mut self) {
        self.start = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatefulSetOrdinals {
        static instance: StatefulSetOrdinals = StatefulSetOrdinals {
            start: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatefulSetOrdinals {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatefulSetOrdinals").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatefulSetOrdinals {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatefulSetOrdinals {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta1.StatefulSetPersistentVolumeClaimRetentionPolicy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatefulSetPersistentVolumeClaimRetentionPolicy {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetPersistentVolumeClaimRetentionPolicy.whenDeleted)
    pub whenDeleted: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetPersistentVolumeClaimRetentionPolicy.whenScaled)
    pub whenScaled: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta1.StatefulSetPersistentVolumeClaimRetentionPolicy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatefulSetPersistentVolumeClaimRetentionPolicy {
    fn default() -> &'a StatefulSetPersistentVolumeClaimRetentionPolicy {
        <StatefulSetPersistentVolumeClaimRetentionPolicy as ::protobuf::Message>::default_instance()
    }
}

impl StatefulSetPersistentVolumeClaimRetentionPolicy {
    pub fn new() -> StatefulSetPersistentVolumeClaimRetentionPolicy {
        ::std::default::Default::default()
    }

    // optional string whenDeleted = 1;

    pub fn whenDeleted(&self) -> &str {
        match self.whenDeleted.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_whenDeleted(&mut self) {
        self.whenDeleted = ::std::option::Option::None;
    }

    pub fn has_whenDeleted(&self) -> bool {
        self.whenDeleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_whenDeleted(&mut self, v: ::std::string::String) {
        self.whenDeleted = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_whenDeleted(&mut self) -> &mut ::std::string::String {
        if self.whenDeleted.is_none() {
            self.whenDeleted = ::std::option::Option::Some(::std::string::String::new());
        }
        self.whenDeleted.as_mut().unwrap()
    }

    // Take field
    pub fn take_whenDeleted(&mut self) -> ::std::string::String {
        self.whenDeleted.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string whenScaled = 2;

    pub fn whenScaled(&self) -> &str {
        match self.whenScaled.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_whenScaled(&mut self) {
        self.whenScaled = ::std::option::Option::None;
    }

    pub fn has_whenScaled(&self) -> bool {
        self.whenScaled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_whenScaled(&mut self, v: ::std::string::String) {
        self.whenScaled = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_whenScaled(&mut self) -> &mut ::std::string::String {
        if self.whenScaled.is_none() {
            self.whenScaled = ::std::option::Option::Some(::std::string::String::new());
        }
        self.whenScaled.as_mut().unwrap()
    }

    // Take field
    pub fn take_whenScaled(&mut self) -> ::std::string::String {
        self.whenScaled.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "whenDeleted",
            |m: &StatefulSetPersistentVolumeClaimRetentionPolicy| { &m.whenDeleted },
            |m: &mut StatefulSetPersistentVolumeClaimRetentionPolicy| { &mut m.whenDeleted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "whenScaled",
            |m: &StatefulSetPersistentVolumeClaimRetentionPolicy| { &m.whenScaled },
            |m: &mut StatefulSetPersistentVolumeClaimRetentionPolicy| { &mut m.whenScaled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatefulSetPersistentVolumeClaimRetentionPolicy>(
            "StatefulSetPersistentVolumeClaimRetentionPolicy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatefulSetPersistentVolumeClaimRetentionPolicy {
    const NAME: &'static str = "StatefulSetPersistentVolumeClaimRetentionPolicy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.whenDeleted = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.whenScaled = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.whenDeleted.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.whenScaled.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.whenDeleted.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.whenScaled.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatefulSetPersistentVolumeClaimRetentionPolicy {
        StatefulSetPersistentVolumeClaimRetentionPolicy::new()
    }

    fn clear(&mut self) {
        self.whenDeleted = ::std::option::Option::None;
        self.whenScaled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatefulSetPersistentVolumeClaimRetentionPolicy {
        static instance: StatefulSetPersistentVolumeClaimRetentionPolicy = StatefulSetPersistentVolumeClaimRetentionPolicy {
            whenDeleted: ::std::option::Option::None,
            whenScaled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatefulSetPersistentVolumeClaimRetentionPolicy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatefulSetPersistentVolumeClaimRetentionPolicy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatefulSetPersistentVolumeClaimRetentionPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatefulSetPersistentVolumeClaimRetentionPolicy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta1.StatefulSetSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatefulSetSpec {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetSpec.replicas)
    pub replicas: ::std::option::Option<i32>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetSpec.selector)
    pub selector: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::apis::meta::v1::LabelSelector>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetSpec.template)
    pub template: ::protobuf::MessageField<crate::v1_32::api::core::v1::PodTemplateSpec>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetSpec.volumeClaimTemplates)
    pub volumeClaimTemplates: ::std::vec::Vec<crate::v1_32::api::core::v1::PersistentVolumeClaim>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetSpec.serviceName)
    pub serviceName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetSpec.podManagementPolicy)
    pub podManagementPolicy: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetSpec.updateStrategy)
    pub updateStrategy: ::protobuf::MessageField<StatefulSetUpdateStrategy>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetSpec.revisionHistoryLimit)
    pub revisionHistoryLimit: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetSpec.minReadySeconds)
    pub minReadySeconds: ::std::option::Option<i32>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetSpec.persistentVolumeClaimRetentionPolicy)
    pub persistentVolumeClaimRetentionPolicy: ::protobuf::MessageField<StatefulSetPersistentVolumeClaimRetentionPolicy>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetSpec.ordinals)
    pub ordinals: ::protobuf::MessageField<StatefulSetOrdinals>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta1.StatefulSetSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatefulSetSpec {
    fn default() -> &'a StatefulSetSpec {
        <StatefulSetSpec as ::protobuf::Message>::default_instance()
    }
}

impl StatefulSetSpec {
    pub fn new() -> StatefulSetSpec {
        ::std::default::Default::default()
    }

    // optional int32 replicas = 1;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // optional .apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;

    pub fn selector(&self) -> &crate::v1_32::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::apis::meta::v1::LabelSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    pub fn has_selector(&self) -> bool {
        self.selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: crate::v1_32::apimachinery::pkg::apis::meta::v1::LabelSelector) {
        self.selector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selector(&mut self) -> &mut crate::v1_32::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.mut_or_insert_default()
    }

    // Take field
    pub fn take_selector(&mut self) -> crate::v1_32::apimachinery::pkg::apis::meta::v1::LabelSelector {
        self.selector.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::apis::meta::v1::LabelSelector::new())
    }

    // optional .api.core.v1.PodTemplateSpec template = 3;

    pub fn template(&self) -> &crate::v1_32::api::core::v1::PodTemplateSpec {
        self.template.as_ref().unwrap_or_else(|| <crate::v1_32::api::core::v1::PodTemplateSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_template(&mut self) {
        self.template.clear();
    }

    pub fn has_template(&self) -> bool {
        self.template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template(&mut self, v: crate::v1_32::api::core::v1::PodTemplateSpec) {
        self.template = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template(&mut self) -> &mut crate::v1_32::api::core::v1::PodTemplateSpec {
        self.template.mut_or_insert_default()
    }

    // Take field
    pub fn take_template(&mut self) -> crate::v1_32::api::core::v1::PodTemplateSpec {
        self.template.take().unwrap_or_else(|| crate::v1_32::api::core::v1::PodTemplateSpec::new())
    }

    // repeated .api.core.v1.PersistentVolumeClaim volumeClaimTemplates = 4;

    pub fn volumeClaimTemplates(&self) -> &[crate::v1_32::api::core::v1::PersistentVolumeClaim] {
        &self.volumeClaimTemplates
    }

    pub fn clear_volumeClaimTemplates(&mut self) {
        self.volumeClaimTemplates.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumeClaimTemplates(&mut self, v: ::std::vec::Vec<crate::v1_32::api::core::v1::PersistentVolumeClaim>) {
        self.volumeClaimTemplates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumeClaimTemplates(&mut self) -> &mut ::std::vec::Vec<crate::v1_32::api::core::v1::PersistentVolumeClaim> {
        &mut self.volumeClaimTemplates
    }

    // Take field
    pub fn take_volumeClaimTemplates(&mut self) -> ::std::vec::Vec<crate::v1_32::api::core::v1::PersistentVolumeClaim> {
        ::std::mem::replace(&mut self.volumeClaimTemplates, ::std::vec::Vec::new())
    }

    // optional string serviceName = 5;

    pub fn serviceName(&self) -> &str {
        match self.serviceName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_serviceName(&mut self) {
        self.serviceName = ::std::option::Option::None;
    }

    pub fn has_serviceName(&self) -> bool {
        self.serviceName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serviceName(&mut self, v: ::std::string::String) {
        self.serviceName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serviceName(&mut self) -> &mut ::std::string::String {
        if self.serviceName.is_none() {
            self.serviceName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.serviceName.as_mut().unwrap()
    }

    // Take field
    pub fn take_serviceName(&mut self) -> ::std::string::String {
        self.serviceName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string podManagementPolicy = 6;

    pub fn podManagementPolicy(&self) -> &str {
        match self.podManagementPolicy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_podManagementPolicy(&mut self) {
        self.podManagementPolicy = ::std::option::Option::None;
    }

    pub fn has_podManagementPolicy(&self) -> bool {
        self.podManagementPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podManagementPolicy(&mut self, v: ::std::string::String) {
        self.podManagementPolicy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podManagementPolicy(&mut self) -> &mut ::std::string::String {
        if self.podManagementPolicy.is_none() {
            self.podManagementPolicy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.podManagementPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_podManagementPolicy(&mut self) -> ::std::string::String {
        self.podManagementPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.apps.v1beta1.StatefulSetUpdateStrategy updateStrategy = 7;

    pub fn updateStrategy(&self) -> &StatefulSetUpdateStrategy {
        self.updateStrategy.as_ref().unwrap_or_else(|| <StatefulSetUpdateStrategy as ::protobuf::Message>::default_instance())
    }

    pub fn clear_updateStrategy(&mut self) {
        self.updateStrategy.clear();
    }

    pub fn has_updateStrategy(&self) -> bool {
        self.updateStrategy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updateStrategy(&mut self, v: StatefulSetUpdateStrategy) {
        self.updateStrategy = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updateStrategy(&mut self) -> &mut StatefulSetUpdateStrategy {
        self.updateStrategy.mut_or_insert_default()
    }

    // Take field
    pub fn take_updateStrategy(&mut self) -> StatefulSetUpdateStrategy {
        self.updateStrategy.take().unwrap_or_else(|| StatefulSetUpdateStrategy::new())
    }

    // optional int32 revisionHistoryLimit = 8;

    pub fn revisionHistoryLimit(&self) -> i32 {
        self.revisionHistoryLimit.unwrap_or(0)
    }

    pub fn clear_revisionHistoryLimit(&mut self) {
        self.revisionHistoryLimit = ::std::option::Option::None;
    }

    pub fn has_revisionHistoryLimit(&self) -> bool {
        self.revisionHistoryLimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revisionHistoryLimit(&mut self, v: i32) {
        self.revisionHistoryLimit = ::std::option::Option::Some(v);
    }

    // optional int32 minReadySeconds = 9;

    pub fn minReadySeconds(&self) -> i32 {
        self.minReadySeconds.unwrap_or(0)
    }

    pub fn clear_minReadySeconds(&mut self) {
        self.minReadySeconds = ::std::option::Option::None;
    }

    pub fn has_minReadySeconds(&self) -> bool {
        self.minReadySeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minReadySeconds(&mut self, v: i32) {
        self.minReadySeconds = ::std::option::Option::Some(v);
    }

    // optional .api.apps.v1beta1.StatefulSetPersistentVolumeClaimRetentionPolicy persistentVolumeClaimRetentionPolicy = 10;

    pub fn persistentVolumeClaimRetentionPolicy(&self) -> &StatefulSetPersistentVolumeClaimRetentionPolicy {
        self.persistentVolumeClaimRetentionPolicy.as_ref().unwrap_or_else(|| <StatefulSetPersistentVolumeClaimRetentionPolicy as ::protobuf::Message>::default_instance())
    }

    pub fn clear_persistentVolumeClaimRetentionPolicy(&mut self) {
        self.persistentVolumeClaimRetentionPolicy.clear();
    }

    pub fn has_persistentVolumeClaimRetentionPolicy(&self) -> bool {
        self.persistentVolumeClaimRetentionPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persistentVolumeClaimRetentionPolicy(&mut self, v: StatefulSetPersistentVolumeClaimRetentionPolicy) {
        self.persistentVolumeClaimRetentionPolicy = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persistentVolumeClaimRetentionPolicy(&mut self) -> &mut StatefulSetPersistentVolumeClaimRetentionPolicy {
        self.persistentVolumeClaimRetentionPolicy.mut_or_insert_default()
    }

    // Take field
    pub fn take_persistentVolumeClaimRetentionPolicy(&mut self) -> StatefulSetPersistentVolumeClaimRetentionPolicy {
        self.persistentVolumeClaimRetentionPolicy.take().unwrap_or_else(|| StatefulSetPersistentVolumeClaimRetentionPolicy::new())
    }

    // optional .api.apps.v1beta1.StatefulSetOrdinals ordinals = 11;

    pub fn ordinals(&self) -> &StatefulSetOrdinals {
        self.ordinals.as_ref().unwrap_or_else(|| <StatefulSetOrdinals as ::protobuf::Message>::default_instance())
    }

    pub fn clear_ordinals(&mut self) {
        self.ordinals.clear();
    }

    pub fn has_ordinals(&self) -> bool {
        self.ordinals.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinals(&mut self, v: StatefulSetOrdinals) {
        self.ordinals = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ordinals(&mut self) -> &mut StatefulSetOrdinals {
        self.ordinals.mut_or_insert_default()
    }

    // Take field
    pub fn take_ordinals(&mut self) -> StatefulSetOrdinals {
        self.ordinals.take().unwrap_or_else(|| StatefulSetOrdinals::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &StatefulSetSpec| { &m.replicas },
            |m: &mut StatefulSetSpec| { &mut m.replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::apis::meta::v1::LabelSelector>(
            "selector",
            |m: &StatefulSetSpec| { &m.selector },
            |m: &mut StatefulSetSpec| { &mut m.selector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::api::core::v1::PodTemplateSpec>(
            "template",
            |m: &StatefulSetSpec| { &m.template },
            |m: &mut StatefulSetSpec| { &mut m.template },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "volumeClaimTemplates",
            |m: &StatefulSetSpec| { &m.volumeClaimTemplates },
            |m: &mut StatefulSetSpec| { &mut m.volumeClaimTemplates },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serviceName",
            |m: &StatefulSetSpec| { &m.serviceName },
            |m: &mut StatefulSetSpec| { &mut m.serviceName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "podManagementPolicy",
            |m: &StatefulSetSpec| { &m.podManagementPolicy },
            |m: &mut StatefulSetSpec| { &mut m.podManagementPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StatefulSetUpdateStrategy>(
            "updateStrategy",
            |m: &StatefulSetSpec| { &m.updateStrategy },
            |m: &mut StatefulSetSpec| { &mut m.updateStrategy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revisionHistoryLimit",
            |m: &StatefulSetSpec| { &m.revisionHistoryLimit },
            |m: &mut StatefulSetSpec| { &mut m.revisionHistoryLimit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minReadySeconds",
            |m: &StatefulSetSpec| { &m.minReadySeconds },
            |m: &mut StatefulSetSpec| { &mut m.minReadySeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StatefulSetPersistentVolumeClaimRetentionPolicy>(
            "persistentVolumeClaimRetentionPolicy",
            |m: &StatefulSetSpec| { &m.persistentVolumeClaimRetentionPolicy },
            |m: &mut StatefulSetSpec| { &mut m.persistentVolumeClaimRetentionPolicy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StatefulSetOrdinals>(
            "ordinals",
            |m: &StatefulSetSpec| { &m.ordinals },
            |m: &mut StatefulSetSpec| { &mut m.ordinals },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatefulSetSpec>(
            "StatefulSetSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatefulSetSpec {
    const NAME: &'static str = "StatefulSetSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.selector)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.template)?;
                },
                34 => {
                    self.volumeClaimTemplates.push(is.read_message()?);
                },
                42 => {
                    self.serviceName = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.podManagementPolicy = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.updateStrategy)?;
                },
                64 => {
                    self.revisionHistoryLimit = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.minReadySeconds = ::std::option::Option::Some(is.read_int32()?);
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.persistentVolumeClaimRetentionPolicy)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ordinals)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.volumeClaimTemplates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.serviceName.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.podManagementPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.updateStrategy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.revisionHistoryLimit {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.minReadySeconds {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.persistentVolumeClaimRetentionPolicy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ordinals.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.replicas {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.selector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.template.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.volumeClaimTemplates {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.serviceName.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.podManagementPolicy.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.updateStrategy.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.revisionHistoryLimit {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.minReadySeconds {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.persistentVolumeClaimRetentionPolicy.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.ordinals.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatefulSetSpec {
        StatefulSetSpec::new()
    }

    fn clear(&mut self) {
        self.replicas = ::std::option::Option::None;
        self.selector.clear();
        self.template.clear();
        self.volumeClaimTemplates.clear();
        self.serviceName = ::std::option::Option::None;
        self.podManagementPolicy = ::std::option::Option::None;
        self.updateStrategy.clear();
        self.revisionHistoryLimit = ::std::option::Option::None;
        self.minReadySeconds = ::std::option::Option::None;
        self.persistentVolumeClaimRetentionPolicy.clear();
        self.ordinals.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatefulSetSpec {
        static instance: StatefulSetSpec = StatefulSetSpec {
            replicas: ::std::option::Option::None,
            selector: ::protobuf::MessageField::none(),
            template: ::protobuf::MessageField::none(),
            volumeClaimTemplates: ::std::vec::Vec::new(),
            serviceName: ::std::option::Option::None,
            podManagementPolicy: ::std::option::Option::None,
            updateStrategy: ::protobuf::MessageField::none(),
            revisionHistoryLimit: ::std::option::Option::None,
            minReadySeconds: ::std::option::Option::None,
            persistentVolumeClaimRetentionPolicy: ::protobuf::MessageField::none(),
            ordinals: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatefulSetSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatefulSetSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatefulSetSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatefulSetSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta1.StatefulSetStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatefulSetStatus {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetStatus.observedGeneration)
    pub observedGeneration: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetStatus.replicas)
    pub replicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetStatus.readyReplicas)
    pub readyReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetStatus.currentReplicas)
    pub currentReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetStatus.updatedReplicas)
    pub updatedReplicas: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetStatus.currentRevision)
    pub currentRevision: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetStatus.updateRevision)
    pub updateRevision: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetStatus.collisionCount)
    pub collisionCount: ::std::option::Option<i32>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetStatus.conditions)
    pub conditions: ::std::vec::Vec<StatefulSetCondition>,
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetStatus.availableReplicas)
    pub availableReplicas: ::std::option::Option<i32>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta1.StatefulSetStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatefulSetStatus {
    fn default() -> &'a StatefulSetStatus {
        <StatefulSetStatus as ::protobuf::Message>::default_instance()
    }
}

impl StatefulSetStatus {
    pub fn new() -> StatefulSetStatus {
        ::std::default::Default::default()
    }

    // optional int64 observedGeneration = 1;

    pub fn observedGeneration(&self) -> i64 {
        self.observedGeneration.unwrap_or(0)
    }

    pub fn clear_observedGeneration(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
    }

    pub fn has_observedGeneration(&self) -> bool {
        self.observedGeneration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observedGeneration(&mut self, v: i64) {
        self.observedGeneration = ::std::option::Option::Some(v);
    }

    // optional int32 replicas = 2;

    pub fn replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // optional int32 readyReplicas = 3;

    pub fn readyReplicas(&self) -> i32 {
        self.readyReplicas.unwrap_or(0)
    }

    pub fn clear_readyReplicas(&mut self) {
        self.readyReplicas = ::std::option::Option::None;
    }

    pub fn has_readyReplicas(&self) -> bool {
        self.readyReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readyReplicas(&mut self, v: i32) {
        self.readyReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 currentReplicas = 4;

    pub fn currentReplicas(&self) -> i32 {
        self.currentReplicas.unwrap_or(0)
    }

    pub fn clear_currentReplicas(&mut self) {
        self.currentReplicas = ::std::option::Option::None;
    }

    pub fn has_currentReplicas(&self) -> bool {
        self.currentReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currentReplicas(&mut self, v: i32) {
        self.currentReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 updatedReplicas = 5;

    pub fn updatedReplicas(&self) -> i32 {
        self.updatedReplicas.unwrap_or(0)
    }

    pub fn clear_updatedReplicas(&mut self) {
        self.updatedReplicas = ::std::option::Option::None;
    }

    pub fn has_updatedReplicas(&self) -> bool {
        self.updatedReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updatedReplicas(&mut self, v: i32) {
        self.updatedReplicas = ::std::option::Option::Some(v);
    }

    // optional string currentRevision = 6;

    pub fn currentRevision(&self) -> &str {
        match self.currentRevision.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_currentRevision(&mut self) {
        self.currentRevision = ::std::option::Option::None;
    }

    pub fn has_currentRevision(&self) -> bool {
        self.currentRevision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currentRevision(&mut self, v: ::std::string::String) {
        self.currentRevision = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_currentRevision(&mut self) -> &mut ::std::string::String {
        if self.currentRevision.is_none() {
            self.currentRevision = ::std::option::Option::Some(::std::string::String::new());
        }
        self.currentRevision.as_mut().unwrap()
    }

    // Take field
    pub fn take_currentRevision(&mut self) -> ::std::string::String {
        self.currentRevision.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string updateRevision = 7;

    pub fn updateRevision(&self) -> &str {
        match self.updateRevision.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_updateRevision(&mut self) {
        self.updateRevision = ::std::option::Option::None;
    }

    pub fn has_updateRevision(&self) -> bool {
        self.updateRevision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updateRevision(&mut self, v: ::std::string::String) {
        self.updateRevision = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updateRevision(&mut self) -> &mut ::std::string::String {
        if self.updateRevision.is_none() {
            self.updateRevision = ::std::option::Option::Some(::std::string::String::new());
        }
        self.updateRevision.as_mut().unwrap()
    }

    // Take field
    pub fn take_updateRevision(&mut self) -> ::std::string::String {
        self.updateRevision.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 collisionCount = 9;

    pub fn collisionCount(&self) -> i32 {
        self.collisionCount.unwrap_or(0)
    }

    pub fn clear_collisionCount(&mut self) {
        self.collisionCount = ::std::option::Option::None;
    }

    pub fn has_collisionCount(&self) -> bool {
        self.collisionCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_collisionCount(&mut self, v: i32) {
        self.collisionCount = ::std::option::Option::Some(v);
    }

    // repeated .api.apps.v1beta1.StatefulSetCondition conditions = 10;

    pub fn conditions(&self) -> &[StatefulSetCondition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<StatefulSetCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<StatefulSetCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<StatefulSetCondition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    // optional int32 availableReplicas = 11;

    pub fn availableReplicas(&self) -> i32 {
        self.availableReplicas.unwrap_or(0)
    }

    pub fn clear_availableReplicas(&mut self) {
        self.availableReplicas = ::std::option::Option::None;
    }

    pub fn has_availableReplicas(&self) -> bool {
        self.availableReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_availableReplicas(&mut self, v: i32) {
        self.availableReplicas = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "observedGeneration",
            |m: &StatefulSetStatus| { &m.observedGeneration },
            |m: &mut StatefulSetStatus| { &mut m.observedGeneration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replicas",
            |m: &StatefulSetStatus| { &m.replicas },
            |m: &mut StatefulSetStatus| { &mut m.replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readyReplicas",
            |m: &StatefulSetStatus| { &m.readyReplicas },
            |m: &mut StatefulSetStatus| { &mut m.readyReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currentReplicas",
            |m: &StatefulSetStatus| { &m.currentReplicas },
            |m: &mut StatefulSetStatus| { &mut m.currentReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "updatedReplicas",
            |m: &StatefulSetStatus| { &m.updatedReplicas },
            |m: &mut StatefulSetStatus| { &mut m.updatedReplicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currentRevision",
            |m: &StatefulSetStatus| { &m.currentRevision },
            |m: &mut StatefulSetStatus| { &mut m.currentRevision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "updateRevision",
            |m: &StatefulSetStatus| { &m.updateRevision },
            |m: &mut StatefulSetStatus| { &mut m.updateRevision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "collisionCount",
            |m: &StatefulSetStatus| { &m.collisionCount },
            |m: &mut StatefulSetStatus| { &mut m.collisionCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &StatefulSetStatus| { &m.conditions },
            |m: &mut StatefulSetStatus| { &mut m.conditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "availableReplicas",
            |m: &StatefulSetStatus| { &m.availableReplicas },
            |m: &mut StatefulSetStatus| { &mut m.availableReplicas },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatefulSetStatus>(
            "StatefulSetStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatefulSetStatus {
    const NAME: &'static str = "StatefulSetStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.observedGeneration = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.replicas = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.readyReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.currentReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.updatedReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    self.currentRevision = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.updateRevision = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.collisionCount = ::std::option::Option::Some(is.read_int32()?);
                },
                82 => {
                    self.conditions.push(is.read_message()?);
                },
                88 => {
                    self.availableReplicas = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.observedGeneration {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.readyReplicas {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.currentReplicas {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.updatedReplicas {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.currentRevision.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.updateRevision.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.collisionCount {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.availableReplicas {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.observedGeneration {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.replicas {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.readyReplicas {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.currentReplicas {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.updatedReplicas {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.currentRevision.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.updateRevision.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.collisionCount {
            os.write_int32(9, v)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        if let Some(v) = self.availableReplicas {
            os.write_int32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatefulSetStatus {
        StatefulSetStatus::new()
    }

    fn clear(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
        self.replicas = ::std::option::Option::None;
        self.readyReplicas = ::std::option::Option::None;
        self.currentReplicas = ::std::option::Option::None;
        self.updatedReplicas = ::std::option::Option::None;
        self.currentRevision = ::std::option::Option::None;
        self.updateRevision = ::std::option::Option::None;
        self.collisionCount = ::std::option::Option::None;
        self.conditions.clear();
        self.availableReplicas = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatefulSetStatus {
        static instance: StatefulSetStatus = StatefulSetStatus {
            observedGeneration: ::std::option::Option::None,
            replicas: ::std::option::Option::None,
            readyReplicas: ::std::option::Option::None,
            currentReplicas: ::std::option::Option::None,
            updatedReplicas: ::std::option::Option::None,
            currentRevision: ::std::option::Option::None,
            updateRevision: ::std::option::Option::None,
            collisionCount: ::std::option::Option::None,
            conditions: ::std::vec::Vec::new(),
            availableReplicas: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatefulSetStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatefulSetStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatefulSetStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatefulSetStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.apps.v1beta1.StatefulSetUpdateStrategy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatefulSetUpdateStrategy {
    // message fields
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetUpdateStrategy.type)
    pub type_: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.apps.v1beta1.StatefulSetUpdateStrategy.rollingUpdate)
    pub rollingUpdate: ::protobuf::MessageField<RollingUpdateStatefulSetStrategy>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.apps.v1beta1.StatefulSetUpdateStrategy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatefulSetUpdateStrategy {
    fn default() -> &'a StatefulSetUpdateStrategy {
        <StatefulSetUpdateStrategy as ::protobuf::Message>::default_instance()
    }
}

impl StatefulSetUpdateStrategy {
    pub fn new() -> StatefulSetUpdateStrategy {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.apps.v1beta1.RollingUpdateStatefulSetStrategy rollingUpdate = 2;

    pub fn rollingUpdate(&self) -> &RollingUpdateStatefulSetStrategy {
        self.rollingUpdate.as_ref().unwrap_or_else(|| <RollingUpdateStatefulSetStrategy as ::protobuf::Message>::default_instance())
    }

    pub fn clear_rollingUpdate(&mut self) {
        self.rollingUpdate.clear();
    }

    pub fn has_rollingUpdate(&self) -> bool {
        self.rollingUpdate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollingUpdate(&mut self, v: RollingUpdateStatefulSetStrategy) {
        self.rollingUpdate = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollingUpdate(&mut self) -> &mut RollingUpdateStatefulSetStrategy {
        self.rollingUpdate.mut_or_insert_default()
    }

    // Take field
    pub fn take_rollingUpdate(&mut self) -> RollingUpdateStatefulSetStrategy {
        self.rollingUpdate.take().unwrap_or_else(|| RollingUpdateStatefulSetStrategy::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &StatefulSetUpdateStrategy| { &m.type_ },
            |m: &mut StatefulSetUpdateStrategy| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RollingUpdateStatefulSetStrategy>(
            "rollingUpdate",
            |m: &StatefulSetUpdateStrategy| { &m.rollingUpdate },
            |m: &mut StatefulSetUpdateStrategy| { &mut m.rollingUpdate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatefulSetUpdateStrategy>(
            "StatefulSetUpdateStrategy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatefulSetUpdateStrategy {
    const NAME: &'static str = "StatefulSetUpdateStrategy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rollingUpdate)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.rollingUpdate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.rollingUpdate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatefulSetUpdateStrategy {
        StatefulSetUpdateStrategy::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.rollingUpdate.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatefulSetUpdateStrategy {
        static instance: StatefulSetUpdateStrategy = StatefulSetUpdateStrategy {
            type_: ::std::option::Option::None,
            rollingUpdate: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatefulSetUpdateStrategy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatefulSetUpdateStrategy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatefulSetUpdateStrategy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatefulSetUpdateStrategy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20api/apps/v1beta1/generated.proto\x12\x10api.apps.v1beta1\x1a\x1bap\
    i/core/v1/generated.proto\x1a-apimachinery/pkg/apis/meta/v1/generated.pr\
    oto\x1a(apimachinery/pkg/runtime/generated.proto\x1a/apimachinery/pkg/ru\
    ntime/schema/generated.proto\x1a,apimachinery/pkg/util/intstr/generated.\
    proto\"\xb3\x01\n\x12ControllerRevision\x12E\n\x08metadata\x18\x01\x20\
    \x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12:\n\
    \x04data\x18\x02\x20\x01(\x0b2&.apimachinery.pkg.runtime.RawExtensionR\
    \x04data\x12\x1a\n\x08revision\x18\x03\x20\x01(\x03R\x08revision\"\x99\
    \x01\n\x16ControllerRevisionList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b\
    2'.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12:\n\x05items\
    \x18\x02\x20\x03(\x0b2$.api.apps.v1beta1.ControllerRevisionR\x05items\"\
    \xc5\x01\n\nDeployment\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimach\
    inery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x124\n\x04spec\x18\x02\
    \x20\x01(\x0b2\x20.api.apps.v1beta1.DeploymentSpecR\x04spec\x12:\n\x06st\
    atus\x18\x03\x20\x01(\x0b2\".api.apps.v1beta1.DeploymentStatusR\x06statu\
    s\"\x95\x02\n\x13DeploymentCondition\x12\x12\n\x04type\x18\x01\x20\x01(\
    \tR\x04type\x12\x16\n\x06status\x18\x02\x20\x01(\tR\x06status\x12K\n\x0e\
    lastUpdateTime\x18\x06\x20\x01(\x0b2#.apimachinery.pkg.apis.meta.v1.Time\
    R\x0elastUpdateTime\x12S\n\x12lastTransitionTime\x18\x07\x20\x01(\x0b2#.\
    apimachinery.pkg.apis.meta.v1.TimeR\x12lastTransitionTime\x12\x16\n\x06r\
    eason\x18\x04\x20\x01(\tR\x06reason\x12\x18\n\x07message\x18\x05\x20\x01\
    (\tR\x07message\"\x89\x01\n\x0eDeploymentList\x12C\n\x08metadata\x18\x01\
    \x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x122\
    \n\x05items\x18\x02\x20\x03(\x0b2\x1c.api.apps.v1beta1.DeploymentR\x05it\
    ems\"\x9f\x02\n\x12DeploymentRollback\x12\x12\n\x04name\x18\x01\x20\x01(\
    \tR\x04name\x12l\n\x12updatedAnnotations\x18\x02\x20\x03(\x0b2<.api.apps\
    .v1beta1.DeploymentRollback.UpdatedAnnotationsEntryR\x12updatedAnnotatio\
    ns\x12@\n\nrollbackTo\x18\x03\x20\x01(\x0b2\x20.api.apps.v1beta1.Rollbac\
    kConfigR\nrollbackTo\x1aE\n\x17UpdatedAnnotationsEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\"\xe4\x03\n\x0eDeploymentSpec\x12\x1a\n\x08replicas\x18\
    \x01\x20\x01(\x05R\x08replicas\x12H\n\x08selector\x18\x02\x20\x01(\x0b2,\
    .apimachinery.pkg.apis.meta.v1.LabelSelectorR\x08selector\x128\n\x08temp\
    late\x18\x03\x20\x01(\x0b2\x1c.api.core.v1.PodTemplateSpecR\x08template\
    \x12@\n\x08strategy\x18\x04\x20\x01(\x0b2$.api.apps.v1beta1.DeploymentSt\
    rategyR\x08strategy\x12(\n\x0fminReadySeconds\x18\x05\x20\x01(\x05R\x0fm\
    inReadySeconds\x122\n\x14revisionHistoryLimit\x18\x06\x20\x01(\x05R\x14r\
    evisionHistoryLimit\x12\x16\n\x06paused\x18\x07\x20\x01(\x08R\x06paused\
    \x12@\n\nrollbackTo\x18\x08\x20\x01(\x0b2\x20.api.apps.v1beta1.RollbackC\
    onfigR\nrollbackTo\x128\n\x17progressDeadlineSeconds\x18\t\x20\x01(\x05R\
    \x17progressDeadlineSeconds\"\xfd\x02\n\x10DeploymentStatus\x12.\n\x12ob\
    servedGeneration\x18\x01\x20\x01(\x03R\x12observedGeneration\x12\x1a\n\
    \x08replicas\x18\x02\x20\x01(\x05R\x08replicas\x12(\n\x0fupdatedReplicas\
    \x18\x03\x20\x01(\x05R\x0fupdatedReplicas\x12$\n\rreadyReplicas\x18\x07\
    \x20\x01(\x05R\rreadyReplicas\x12,\n\x11availableReplicas\x18\x04\x20\
    \x01(\x05R\x11availableReplicas\x120\n\x13unavailableReplicas\x18\x05\
    \x20\x01(\x05R\x13unavailableReplicas\x12E\n\nconditions\x18\x06\x20\x03\
    (\x0b2%.api.apps.v1beta1.DeploymentConditionR\nconditions\x12&\n\x0ecoll\
    isionCount\x18\x08\x20\x01(\x05R\x0ecollisionCount\"y\n\x12DeploymentStr\
    ategy\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12O\n\rrollingUpdat\
    e\x18\x02\x20\x01(\x0b2).api.apps.v1beta1.RollingUpdateDeploymentR\rroll\
    ingUpdate\",\n\x0eRollbackConfig\x12\x1a\n\x08revision\x18\x01\x20\x01(\
    \x03R\x08revision\"\xb3\x01\n\x17RollingUpdateDeployment\x12Q\n\x0emaxUn\
    available\x18\x01\x20\x01(\x0b2).apimachinery.pkg.util.intstr.IntOrStrin\
    gR\x0emaxUnavailable\x12E\n\x08maxSurge\x18\x02\x20\x01(\x0b2).apimachin\
    ery.pkg.util.intstr.IntOrStringR\x08maxSurge\"\x93\x01\n\x20RollingUpdat\
    eStatefulSetStrategy\x12\x1c\n\tpartition\x18\x01\x20\x01(\x05R\tpartiti\
    on\x12Q\n\x0emaxUnavailable\x18\x02\x20\x01(\x0b2).apimachinery.pkg.util\
    .intstr.IntOrStringR\x0emaxUnavailable\"\xb6\x01\n\x05Scale\x12E\n\x08me\
    tadata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\
    \x08metadata\x12/\n\x04spec\x18\x02\x20\x01(\x0b2\x1b.api.apps.v1beta1.S\
    caleSpecR\x04spec\x125\n\x06status\x18\x03\x20\x01(\x0b2\x1d.api.apps.v1\
    beta1.ScaleStatusR\x06status\"'\n\tScaleSpec\x12\x1a\n\x08replicas\x18\
    \x01\x20\x01(\x05R\x08replicas\"\xd7\x01\n\x0bScaleStatus\x12\x1a\n\x08r\
    eplicas\x18\x01\x20\x01(\x05R\x08replicas\x12G\n\x08selector\x18\x02\x20\
    \x03(\x0b2+.api.apps.v1beta1.ScaleStatus.SelectorEntryR\x08selector\x12&\
    \n\x0etargetSelector\x18\x03\x20\x01(\tR\x0etargetSelector\x1a;\n\rSelec\
    torEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xc8\x01\n\x0bStatefulSet\x12E\
    \n\x08metadata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.Obje\
    ctMetaR\x08metadata\x125\n\x04spec\x18\x02\x20\x01(\x0b2!.api.apps.v1bet\
    a1.StatefulSetSpecR\x04spec\x12;\n\x06status\x18\x03\x20\x01(\x0b2#.api.\
    apps.v1beta1.StatefulSetStatusR\x06status\"\xc9\x01\n\x14StatefulSetCond\
    ition\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12\x16\n\x06status\
    \x18\x02\x20\x01(\tR\x06status\x12S\n\x12lastTransitionTime\x18\x03\x20\
    \x01(\x0b2#.apimachinery.pkg.apis.meta.v1.TimeR\x12lastTransitionTime\
    \x12\x16\n\x06reason\x18\x04\x20\x01(\tR\x06reason\x12\x18\n\x07message\
    \x18\x05\x20\x01(\tR\x07message\"\x8b\x01\n\x0fStatefulSetList\x12C\n\
    \x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMe\
    taR\x08metadata\x123\n\x05items\x18\x02\x20\x03(\x0b2\x1d.api.apps.v1bet\
    a1.StatefulSetR\x05items\"+\n\x13StatefulSetOrdinals\x12\x14\n\x05start\
    \x18\x01\x20\x01(\x05R\x05start\"s\n/StatefulSetPersistentVolumeClaimRet\
    entionPolicy\x12\x20\n\x0bwhenDeleted\x18\x01\x20\x01(\tR\x0bwhenDeleted\
    \x12\x1e\n\nwhenScaled\x18\x02\x20\x01(\tR\nwhenScaled\"\xeb\x05\n\x0fSt\
    atefulSetSpec\x12\x1a\n\x08replicas\x18\x01\x20\x01(\x05R\x08replicas\
    \x12H\n\x08selector\x18\x02\x20\x01(\x0b2,.apimachinery.pkg.apis.meta.v1\
    .LabelSelectorR\x08selector\x128\n\x08template\x18\x03\x20\x01(\x0b2\x1c\
    .api.core.v1.PodTemplateSpecR\x08template\x12V\n\x14volumeClaimTemplates\
    \x18\x04\x20\x03(\x0b2\".api.core.v1.PersistentVolumeClaimR\x14volumeCla\
    imTemplates\x12\x20\n\x0bserviceName\x18\x05\x20\x01(\tR\x0bserviceName\
    \x120\n\x13podManagementPolicy\x18\x06\x20\x01(\tR\x13podManagementPolic\
    y\x12S\n\x0eupdateStrategy\x18\x07\x20\x01(\x0b2+.api.apps.v1beta1.State\
    fulSetUpdateStrategyR\x0eupdateStrategy\x122\n\x14revisionHistoryLimit\
    \x18\x08\x20\x01(\x05R\x14revisionHistoryLimit\x12(\n\x0fminReadySeconds\
    \x18\t\x20\x01(\x05R\x0fminReadySeconds\x12\x95\x01\n$persistentVolumeCl\
    aimRetentionPolicy\x18\n\x20\x01(\x0b2A.api.apps.v1beta1.StatefulSetPers\
    istentVolumeClaimRetentionPolicyR$persistentVolumeClaimRetentionPolicy\
    \x12A\n\x08ordinals\x18\x0b\x20\x01(\x0b2%.api.apps.v1beta1.StatefulSetO\
    rdinalsR\x08ordinals\"\xc9\x03\n\x11StatefulSetStatus\x12.\n\x12observed\
    Generation\x18\x01\x20\x01(\x03R\x12observedGeneration\x12\x1a\n\x08repl\
    icas\x18\x02\x20\x01(\x05R\x08replicas\x12$\n\rreadyReplicas\x18\x03\x20\
    \x01(\x05R\rreadyReplicas\x12(\n\x0fcurrentReplicas\x18\x04\x20\x01(\x05\
    R\x0fcurrentReplicas\x12(\n\x0fupdatedReplicas\x18\x05\x20\x01(\x05R\x0f\
    updatedReplicas\x12(\n\x0fcurrentRevision\x18\x06\x20\x01(\tR\x0fcurrent\
    Revision\x12&\n\x0eupdateRevision\x18\x07\x20\x01(\tR\x0eupdateRevision\
    \x12&\n\x0ecollisionCount\x18\t\x20\x01(\x05R\x0ecollisionCount\x12F\n\n\
    conditions\x18\n\x20\x03(\x0b2&.api.apps.v1beta1.StatefulSetConditionR\n\
    conditions\x12,\n\x11availableReplicas\x18\x0b\x20\x01(\x05R\x11availabl\
    eReplicas\"\x89\x01\n\x19StatefulSetUpdateStrategy\x12\x12\n\x04type\x18\
    \x01\x20\x01(\tR\x04type\x12X\n\rrollingUpdate\x18\x02\x20\x01(\x0b22.ap\
    i.apps.v1beta1.RollingUpdateStatefulSetStrategyR\rrollingUpdateB\x19Z\
    \x17k8s.io/api/apps/v1beta1\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(5);
            deps.push(super::v1beta1::file_descriptor().clone());
            deps.push(super::v1beta1::file_descriptor().clone());
            deps.push(super::v1beta1::file_descriptor().clone());
            deps.push(super::v1beta1::file_descriptor().clone());
            deps.push(super::v1beta1::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(23);
            messages.push(ControllerRevision::generated_message_descriptor_data());
            messages.push(ControllerRevisionList::generated_message_descriptor_data());
            messages.push(Deployment::generated_message_descriptor_data());
            messages.push(DeploymentCondition::generated_message_descriptor_data());
            messages.push(DeploymentList::generated_message_descriptor_data());
            messages.push(DeploymentRollback::generated_message_descriptor_data());
            messages.push(DeploymentSpec::generated_message_descriptor_data());
            messages.push(DeploymentStatus::generated_message_descriptor_data());
            messages.push(DeploymentStrategy::generated_message_descriptor_data());
            messages.push(RollbackConfig::generated_message_descriptor_data());
            messages.push(RollingUpdateDeployment::generated_message_descriptor_data());
            messages.push(RollingUpdateStatefulSetStrategy::generated_message_descriptor_data());
            messages.push(Scale::generated_message_descriptor_data());
            messages.push(ScaleSpec::generated_message_descriptor_data());
            messages.push(ScaleStatus::generated_message_descriptor_data());
            messages.push(StatefulSet::generated_message_descriptor_data());
            messages.push(StatefulSetCondition::generated_message_descriptor_data());
            messages.push(StatefulSetList::generated_message_descriptor_data());
            messages.push(StatefulSetOrdinals::generated_message_descriptor_data());
            messages.push(StatefulSetPersistentVolumeClaimRetentionPolicy::generated_message_descriptor_data());
            messages.push(StatefulSetSpec::generated_message_descriptor_data());
            messages.push(StatefulSetStatus::generated_message_descriptor_data());
            messages.push(StatefulSetUpdateStrategy::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
