// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc 30.2
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `api/resource/v1beta1/generated.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.AllocatedDeviceStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AllocatedDeviceStatus {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta1.AllocatedDeviceStatus.driver)
    pub driver: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta1.AllocatedDeviceStatus.pool)
    pub pool: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta1.AllocatedDeviceStatus.device)
    pub device: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.AllocatedDeviceStatus.conditions)
    pub conditions: ::std::vec::Vec<crate::v1_32::apimachinery::pkg::apis::meta::v1::Condition>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.AllocatedDeviceStatus.data)
    pub data: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::runtime::RawExtension>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.AllocatedDeviceStatus.networkData)
    pub networkData: ::protobuf::MessageField<NetworkDeviceData>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.AllocatedDeviceStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AllocatedDeviceStatus {
    fn default() -> &'a AllocatedDeviceStatus {
        <AllocatedDeviceStatus as ::protobuf::Message>::default_instance()
    }
}

impl AllocatedDeviceStatus {
    pub fn new() -> AllocatedDeviceStatus {
        ::std::default::Default::default()
    }

    // optional string driver = 1;

    pub fn driver(&self) -> &str {
        match self.driver.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_driver(&mut self) {
        self.driver = ::std::option::Option::None;
    }

    pub fn has_driver(&self) -> bool {
        self.driver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driver(&mut self, v: ::std::string::String) {
        self.driver = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver(&mut self) -> &mut ::std::string::String {
        if self.driver.is_none() {
            self.driver = ::std::option::Option::Some(::std::string::String::new());
        }
        self.driver.as_mut().unwrap()
    }

    // Take field
    pub fn take_driver(&mut self) -> ::std::string::String {
        self.driver.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pool = 2;

    pub fn pool(&self) -> &str {
        match self.pool.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pool(&mut self) {
        self.pool = ::std::option::Option::None;
    }

    pub fn has_pool(&self) -> bool {
        self.pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pool(&mut self, v: ::std::string::String) {
        self.pool = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pool(&mut self) -> &mut ::std::string::String {
        if self.pool.is_none() {
            self.pool = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pool.as_mut().unwrap()
    }

    // Take field
    pub fn take_pool(&mut self) -> ::std::string::String {
        self.pool.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string device = 3;

    pub fn device(&self) -> &str {
        match self.device.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device(&mut self) {
        self.device = ::std::option::Option::None;
    }

    pub fn has_device(&self) -> bool {
        self.device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: ::std::string::String) {
        self.device = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut ::std::string::String {
        if self.device.is_none() {
            self.device = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device.as_mut().unwrap()
    }

    // Take field
    pub fn take_device(&mut self) -> ::std::string::String {
        self.device.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .apimachinery.pkg.apis.meta.v1.Condition conditions = 4;

    pub fn conditions(&self) -> &[crate::v1_32::apimachinery::pkg::apis::meta::v1::Condition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<crate::v1_32::apimachinery::pkg::apis::meta::v1::Condition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<crate::v1_32::apimachinery::pkg::apis::meta::v1::Condition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<crate::v1_32::apimachinery::pkg::apis::meta::v1::Condition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    // optional .apimachinery.pkg.runtime.RawExtension data = 5;

    pub fn data(&self) -> &crate::v1_32::apimachinery::pkg::runtime::RawExtension {
        self.data.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::runtime::RawExtension as ::protobuf::Message>::default_instance())
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: crate::v1_32::apimachinery::pkg::runtime::RawExtension) {
        self.data = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut crate::v1_32::apimachinery::pkg::runtime::RawExtension {
        self.data.mut_or_insert_default()
    }

    // Take field
    pub fn take_data(&mut self) -> crate::v1_32::apimachinery::pkg::runtime::RawExtension {
        self.data.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::runtime::RawExtension::new())
    }

    // optional .api.resource.v1beta1.NetworkDeviceData networkData = 6;

    pub fn networkData(&self) -> &NetworkDeviceData {
        self.networkData.as_ref().unwrap_or_else(|| <NetworkDeviceData as ::protobuf::Message>::default_instance())
    }

    pub fn clear_networkData(&mut self) {
        self.networkData.clear();
    }

    pub fn has_networkData(&self) -> bool {
        self.networkData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_networkData(&mut self, v: NetworkDeviceData) {
        self.networkData = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_networkData(&mut self) -> &mut NetworkDeviceData {
        self.networkData.mut_or_insert_default()
    }

    // Take field
    pub fn take_networkData(&mut self) -> NetworkDeviceData {
        self.networkData.take().unwrap_or_else(|| NetworkDeviceData::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "driver",
            |m: &AllocatedDeviceStatus| { &m.driver },
            |m: &mut AllocatedDeviceStatus| { &mut m.driver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pool",
            |m: &AllocatedDeviceStatus| { &m.pool },
            |m: &mut AllocatedDeviceStatus| { &mut m.pool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "device",
            |m: &AllocatedDeviceStatus| { &m.device },
            |m: &mut AllocatedDeviceStatus| { &mut m.device },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &AllocatedDeviceStatus| { &m.conditions },
            |m: &mut AllocatedDeviceStatus| { &mut m.conditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::runtime::RawExtension>(
            "data",
            |m: &AllocatedDeviceStatus| { &m.data },
            |m: &mut AllocatedDeviceStatus| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NetworkDeviceData>(
            "networkData",
            |m: &AllocatedDeviceStatus| { &m.networkData },
            |m: &mut AllocatedDeviceStatus| { &mut m.networkData },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AllocatedDeviceStatus>(
            "AllocatedDeviceStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AllocatedDeviceStatus {
    const NAME: &'static str = "AllocatedDeviceStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.driver = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.pool = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.device = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.conditions.push(is.read_message()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.networkData)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.driver.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.pool.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.device.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.networkData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.driver.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.pool.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.device.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.networkData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AllocatedDeviceStatus {
        AllocatedDeviceStatus::new()
    }

    fn clear(&mut self) {
        self.driver = ::std::option::Option::None;
        self.pool = ::std::option::Option::None;
        self.device = ::std::option::Option::None;
        self.conditions.clear();
        self.data.clear();
        self.networkData.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AllocatedDeviceStatus {
        static instance: AllocatedDeviceStatus = AllocatedDeviceStatus {
            driver: ::std::option::Option::None,
            pool: ::std::option::Option::None,
            device: ::std::option::Option::None,
            conditions: ::std::vec::Vec::new(),
            data: ::protobuf::MessageField::none(),
            networkData: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AllocatedDeviceStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AllocatedDeviceStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AllocatedDeviceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllocatedDeviceStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.AllocationResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AllocationResult {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.AllocationResult.devices)
    pub devices: ::protobuf::MessageField<DeviceAllocationResult>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.AllocationResult.nodeSelector)
    pub nodeSelector: ::protobuf::MessageField<crate::v1_32::api::core::v1::NodeSelector>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.AllocationResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AllocationResult {
    fn default() -> &'a AllocationResult {
        <AllocationResult as ::protobuf::Message>::default_instance()
    }
}

impl AllocationResult {
    pub fn new() -> AllocationResult {
        ::std::default::Default::default()
    }

    // optional .api.resource.v1beta1.DeviceAllocationResult devices = 1;

    pub fn devices(&self) -> &DeviceAllocationResult {
        self.devices.as_ref().unwrap_or_else(|| <DeviceAllocationResult as ::protobuf::Message>::default_instance())
    }

    pub fn clear_devices(&mut self) {
        self.devices.clear();
    }

    pub fn has_devices(&self) -> bool {
        self.devices.is_some()
    }

    // Param is passed by value, moved
    pub fn set_devices(&mut self, v: DeviceAllocationResult) {
        self.devices = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_devices(&mut self) -> &mut DeviceAllocationResult {
        self.devices.mut_or_insert_default()
    }

    // Take field
    pub fn take_devices(&mut self) -> DeviceAllocationResult {
        self.devices.take().unwrap_or_else(|| DeviceAllocationResult::new())
    }

    // optional .api.core.v1.NodeSelector nodeSelector = 3;

    pub fn nodeSelector(&self) -> &crate::v1_32::api::core::v1::NodeSelector {
        self.nodeSelector.as_ref().unwrap_or_else(|| <crate::v1_32::api::core::v1::NodeSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_nodeSelector(&mut self) {
        self.nodeSelector.clear();
    }

    pub fn has_nodeSelector(&self) -> bool {
        self.nodeSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeSelector(&mut self, v: crate::v1_32::api::core::v1::NodeSelector) {
        self.nodeSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeSelector(&mut self) -> &mut crate::v1_32::api::core::v1::NodeSelector {
        self.nodeSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_nodeSelector(&mut self) -> crate::v1_32::api::core::v1::NodeSelector {
        self.nodeSelector.take().unwrap_or_else(|| crate::v1_32::api::core::v1::NodeSelector::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeviceAllocationResult>(
            "devices",
            |m: &AllocationResult| { &m.devices },
            |m: &mut AllocationResult| { &mut m.devices },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::api::core::v1::NodeSelector>(
            "nodeSelector",
            |m: &AllocationResult| { &m.nodeSelector },
            |m: &mut AllocationResult| { &mut m.nodeSelector },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AllocationResult>(
            "AllocationResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AllocationResult {
    const NAME: &'static str = "AllocationResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.devices)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.nodeSelector)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.devices.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.nodeSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.devices.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.nodeSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AllocationResult {
        AllocationResult::new()
    }

    fn clear(&mut self) {
        self.devices.clear();
        self.nodeSelector.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AllocationResult {
        static instance: AllocationResult = AllocationResult {
            devices: ::protobuf::MessageField::none(),
            nodeSelector: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AllocationResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AllocationResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AllocationResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllocationResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.BasicDevice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BasicDevice {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.BasicDevice.attributes)
    pub attributes: ::std::collections::BTreeMap<::std::string::String, DeviceAttribute>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.BasicDevice.capacity)
    pub capacity: ::std::collections::BTreeMap<::std::string::String, DeviceCapacity>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.BasicDevice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BasicDevice {
    fn default() -> &'a BasicDevice {
        <BasicDevice as ::protobuf::Message>::default_instance()
    }
}

impl BasicDevice {
    pub fn new() -> BasicDevice {
        ::std::default::Default::default()
    }

    // repeated .api.resource.v1beta1.BasicDevice.AttributesEntry attributes = 1;

    pub fn attributes(&self) -> &::std::collections::BTreeMap<::std::string::String, DeviceAttribute> {
        &self.attributes
    }

    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::std::collections::BTreeMap<::std::string::String, DeviceAttribute>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, DeviceAttribute> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::std::collections::BTreeMap<::std::string::String, DeviceAttribute> {
        ::std::mem::replace(&mut self.attributes, ::std::collections::BTreeMap::new())
    }

    // repeated .api.resource.v1beta1.BasicDevice.CapacityEntry capacity = 2;

    pub fn capacity(&self) -> &::std::collections::BTreeMap<::std::string::String, DeviceCapacity> {
        &self.capacity
    }

    pub fn clear_capacity(&mut self) {
        self.capacity.clear();
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: ::std::collections::BTreeMap<::std::string::String, DeviceCapacity>) {
        self.capacity = v;
    }

    // Mutable pointer to the field.
    pub fn mut_capacity(&mut self) -> &mut ::std::collections::BTreeMap<::std::string::String, DeviceCapacity> {
        &mut self.capacity
    }

    // Take field
    pub fn take_capacity(&mut self) -> ::std::collections::BTreeMap<::std::string::String, DeviceCapacity> {
        ::std::mem::replace(&mut self.capacity, ::std::collections::BTreeMap::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "attributes",
            |m: &BasicDevice| { &m.attributes },
            |m: &mut BasicDevice| { &mut m.attributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "capacity",
            |m: &BasicDevice| { &m.capacity },
            |m: &mut BasicDevice| { &mut m.capacity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BasicDevice>(
            "BasicDevice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BasicDevice {
    const NAME: &'static str = "BasicDevice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.attributes.insert(key, value);
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.capacity.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.attributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.capacity {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.attributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.capacity {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BasicDevice {
        BasicDevice::new()
    }

    fn clear(&mut self) {
        self.attributes.clear();
        self.capacity.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BasicDevice {
        static instance: ::protobuf::rt::Lazy<BasicDevice> = ::protobuf::rt::Lazy::new();
        instance.get(BasicDevice::new)
    }
}

impl ::protobuf::MessageFull for BasicDevice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BasicDevice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BasicDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BasicDevice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.CELDeviceSelector)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CELDeviceSelector {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta1.CELDeviceSelector.expression)
    pub expression: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.CELDeviceSelector.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CELDeviceSelector {
    fn default() -> &'a CELDeviceSelector {
        <CELDeviceSelector as ::protobuf::Message>::default_instance()
    }
}

impl CELDeviceSelector {
    pub fn new() -> CELDeviceSelector {
        ::std::default::Default::default()
    }

    // optional string expression = 1;

    pub fn expression(&self) -> &str {
        match self.expression.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_expression(&mut self) {
        self.expression = ::std::option::Option::None;
    }

    pub fn has_expression(&self) -> bool {
        self.expression.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expression(&mut self, v: ::std::string::String) {
        self.expression = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expression(&mut self) -> &mut ::std::string::String {
        if self.expression.is_none() {
            self.expression = ::std::option::Option::Some(::std::string::String::new());
        }
        self.expression.as_mut().unwrap()
    }

    // Take field
    pub fn take_expression(&mut self) -> ::std::string::String {
        self.expression.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expression",
            |m: &CELDeviceSelector| { &m.expression },
            |m: &mut CELDeviceSelector| { &mut m.expression },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CELDeviceSelector>(
            "CELDeviceSelector",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CELDeviceSelector {
    const NAME: &'static str = "CELDeviceSelector";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.expression = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.expression.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.expression.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CELDeviceSelector {
        CELDeviceSelector::new()
    }

    fn clear(&mut self) {
        self.expression = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CELDeviceSelector {
        static instance: CELDeviceSelector = CELDeviceSelector {
            expression: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CELDeviceSelector {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CELDeviceSelector").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CELDeviceSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CELDeviceSelector {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.Device)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Device {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta1.Device.name)
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.Device.basic)
    pub basic: ::protobuf::MessageField<BasicDevice>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.Device.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Device {
    fn default() -> &'a Device {
        <Device as ::protobuf::Message>::default_instance()
    }
}

impl Device {
    pub fn new() -> Device {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.resource.v1beta1.BasicDevice basic = 2;

    pub fn basic(&self) -> &BasicDevice {
        self.basic.as_ref().unwrap_or_else(|| <BasicDevice as ::protobuf::Message>::default_instance())
    }

    pub fn clear_basic(&mut self) {
        self.basic.clear();
    }

    pub fn has_basic(&self) -> bool {
        self.basic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_basic(&mut self, v: BasicDevice) {
        self.basic = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_basic(&mut self) -> &mut BasicDevice {
        self.basic.mut_or_insert_default()
    }

    // Take field
    pub fn take_basic(&mut self) -> BasicDevice {
        self.basic.take().unwrap_or_else(|| BasicDevice::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Device| { &m.name },
            |m: &mut Device| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BasicDevice>(
            "basic",
            |m: &Device| { &m.basic },
            |m: &mut Device| { &mut m.basic },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Device>(
            "Device",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Device {
    const NAME: &'static str = "Device";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.basic)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.basic.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.basic.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Device {
        Device::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.basic.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Device {
        static instance: Device = Device {
            name: ::std::option::Option::None,
            basic: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Device {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Device").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Device {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Device {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.DeviceAllocationConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceAllocationConfiguration {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceAllocationConfiguration.source)
    pub source: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceAllocationConfiguration.requests)
    pub requests: ::std::vec::Vec<::std::string::String>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceAllocationConfiguration.deviceConfiguration)
    pub deviceConfiguration: ::protobuf::MessageField<DeviceConfiguration>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.DeviceAllocationConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceAllocationConfiguration {
    fn default() -> &'a DeviceAllocationConfiguration {
        <DeviceAllocationConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl DeviceAllocationConfiguration {
    pub fn new() -> DeviceAllocationConfiguration {
        ::std::default::Default::default()
    }

    // optional string source = 1;

    pub fn source(&self) -> &str {
        match self.source.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_source(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::string::String {
        if self.source.is_none() {
            self.source = ::std::option::Option::Some(::std::string::String::new());
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        self.source.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string requests = 2;

    pub fn requests(&self) -> &[::std::string::String] {
        &self.requests
    }

    pub fn clear_requests(&mut self) {
        self.requests.clear();
    }

    // Param is passed by value, moved
    pub fn set_requests(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.requests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requests(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.requests
    }

    // Take field
    pub fn take_requests(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.requests, ::std::vec::Vec::new())
    }

    // optional .api.resource.v1beta1.DeviceConfiguration deviceConfiguration = 3;

    pub fn deviceConfiguration(&self) -> &DeviceConfiguration {
        self.deviceConfiguration.as_ref().unwrap_or_else(|| <DeviceConfiguration as ::protobuf::Message>::default_instance())
    }

    pub fn clear_deviceConfiguration(&mut self) {
        self.deviceConfiguration.clear();
    }

    pub fn has_deviceConfiguration(&self) -> bool {
        self.deviceConfiguration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deviceConfiguration(&mut self, v: DeviceConfiguration) {
        self.deviceConfiguration = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deviceConfiguration(&mut self) -> &mut DeviceConfiguration {
        self.deviceConfiguration.mut_or_insert_default()
    }

    // Take field
    pub fn take_deviceConfiguration(&mut self) -> DeviceConfiguration {
        self.deviceConfiguration.take().unwrap_or_else(|| DeviceConfiguration::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source",
            |m: &DeviceAllocationConfiguration| { &m.source },
            |m: &mut DeviceAllocationConfiguration| { &mut m.source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "requests",
            |m: &DeviceAllocationConfiguration| { &m.requests },
            |m: &mut DeviceAllocationConfiguration| { &mut m.requests },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeviceConfiguration>(
            "deviceConfiguration",
            |m: &DeviceAllocationConfiguration| { &m.deviceConfiguration },
            |m: &mut DeviceAllocationConfiguration| { &mut m.deviceConfiguration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceAllocationConfiguration>(
            "DeviceAllocationConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceAllocationConfiguration {
    const NAME: &'static str = "DeviceAllocationConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.source = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.requests.push(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.deviceConfiguration)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.requests {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(v) = self.deviceConfiguration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.source.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.requests {
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.deviceConfiguration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceAllocationConfiguration {
        DeviceAllocationConfiguration::new()
    }

    fn clear(&mut self) {
        self.source = ::std::option::Option::None;
        self.requests.clear();
        self.deviceConfiguration.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceAllocationConfiguration {
        static instance: DeviceAllocationConfiguration = DeviceAllocationConfiguration {
            source: ::std::option::Option::None,
            requests: ::std::vec::Vec::new(),
            deviceConfiguration: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceAllocationConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceAllocationConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceAllocationConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceAllocationConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.DeviceAllocationResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceAllocationResult {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceAllocationResult.results)
    pub results: ::std::vec::Vec<DeviceRequestAllocationResult>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceAllocationResult.config)
    pub config: ::std::vec::Vec<DeviceAllocationConfiguration>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.DeviceAllocationResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceAllocationResult {
    fn default() -> &'a DeviceAllocationResult {
        <DeviceAllocationResult as ::protobuf::Message>::default_instance()
    }
}

impl DeviceAllocationResult {
    pub fn new() -> DeviceAllocationResult {
        ::std::default::Default::default()
    }

    // repeated .api.resource.v1beta1.DeviceRequestAllocationResult results = 1;

    pub fn results(&self) -> &[DeviceRequestAllocationResult] {
        &self.results
    }

    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::std::vec::Vec<DeviceRequestAllocationResult>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::std::vec::Vec<DeviceRequestAllocationResult> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::std::vec::Vec<DeviceRequestAllocationResult> {
        ::std::mem::replace(&mut self.results, ::std::vec::Vec::new())
    }

    // repeated .api.resource.v1beta1.DeviceAllocationConfiguration config = 2;

    pub fn config(&self) -> &[DeviceAllocationConfiguration] {
        &self.config
    }

    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: ::std::vec::Vec<DeviceAllocationConfiguration>) {
        self.config = v;
    }

    // Mutable pointer to the field.
    pub fn mut_config(&mut self) -> &mut ::std::vec::Vec<DeviceAllocationConfiguration> {
        &mut self.config
    }

    // Take field
    pub fn take_config(&mut self) -> ::std::vec::Vec<DeviceAllocationConfiguration> {
        ::std::mem::replace(&mut self.config, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &DeviceAllocationResult| { &m.results },
            |m: &mut DeviceAllocationResult| { &mut m.results },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "config",
            |m: &DeviceAllocationResult| { &m.config },
            |m: &mut DeviceAllocationResult| { &mut m.config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceAllocationResult>(
            "DeviceAllocationResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceAllocationResult {
    const NAME: &'static str = "DeviceAllocationResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                18 => {
                    self.config.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.config {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.config {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceAllocationResult {
        DeviceAllocationResult::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceAllocationResult {
        static instance: DeviceAllocationResult = DeviceAllocationResult {
            results: ::std::vec::Vec::new(),
            config: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceAllocationResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceAllocationResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceAllocationResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceAllocationResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.DeviceAttribute)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceAttribute {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceAttribute.int)
    pub int: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceAttribute.bool)
    pub bool: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceAttribute.string)
    pub string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceAttribute.version)
    pub version: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.DeviceAttribute.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceAttribute {
    fn default() -> &'a DeviceAttribute {
        <DeviceAttribute as ::protobuf::Message>::default_instance()
    }
}

impl DeviceAttribute {
    pub fn new() -> DeviceAttribute {
        ::std::default::Default::default()
    }

    // optional int64 int = 2;

    pub fn int(&self) -> i64 {
        self.int.unwrap_or(0)
    }

    pub fn clear_int(&mut self) {
        self.int = ::std::option::Option::None;
    }

    pub fn has_int(&self) -> bool {
        self.int.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int(&mut self, v: i64) {
        self.int = ::std::option::Option::Some(v);
    }

    // optional bool bool = 3;

    pub fn bool(&self) -> bool {
        self.bool.unwrap_or(false)
    }

    pub fn clear_bool(&mut self) {
        self.bool = ::std::option::Option::None;
    }

    pub fn has_bool(&self) -> bool {
        self.bool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bool(&mut self, v: bool) {
        self.bool = ::std::option::Option::Some(v);
    }

    // optional string string = 4;

    pub fn string(&self) -> &str {
        match self.string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string(&mut self) {
        self.string = ::std::option::Option::None;
    }

    pub fn has_string(&self) -> bool {
        self.string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string(&mut self, v: ::std::string::String) {
        self.string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string(&mut self) -> &mut ::std::string::String {
        if self.string.is_none() {
            self.string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string.as_mut().unwrap()
    }

    // Take field
    pub fn take_string(&mut self) -> ::std::string::String {
        self.string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 5;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "int",
            |m: &DeviceAttribute| { &m.int },
            |m: &mut DeviceAttribute| { &mut m.int },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bool",
            |m: &DeviceAttribute| { &m.bool },
            |m: &mut DeviceAttribute| { &mut m.bool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "string",
            |m: &DeviceAttribute| { &m.string },
            |m: &mut DeviceAttribute| { &mut m.string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &DeviceAttribute| { &m.version },
            |m: &mut DeviceAttribute| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceAttribute>(
            "DeviceAttribute",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceAttribute {
    const NAME: &'static str = "DeviceAttribute";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.int = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.bool = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.string = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.int {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.bool {
            my_size += 1 + 1;
        }
        if let Some(v) = self.string.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.int {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.bool {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.string.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceAttribute {
        DeviceAttribute::new()
    }

    fn clear(&mut self) {
        self.int = ::std::option::Option::None;
        self.bool = ::std::option::Option::None;
        self.string = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceAttribute {
        static instance: DeviceAttribute = DeviceAttribute {
            int: ::std::option::Option::None,
            bool: ::std::option::Option::None,
            string: ::std::option::Option::None,
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceAttribute {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceAttribute").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceAttribute {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.DeviceCapacity)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceCapacity {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceCapacity.value)
    pub value: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::api::resource::Quantity>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.DeviceCapacity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceCapacity {
    fn default() -> &'a DeviceCapacity {
        <DeviceCapacity as ::protobuf::Message>::default_instance()
    }
}

impl DeviceCapacity {
    pub fn new() -> DeviceCapacity {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.api.resource.Quantity value = 1;

    pub fn value(&self) -> &crate::v1_32::apimachinery::pkg::api::resource::Quantity {
        self.value.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::api::resource::Quantity as ::protobuf::Message>::default_instance())
    }

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: crate::v1_32::apimachinery::pkg::api::resource::Quantity) {
        self.value = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut crate::v1_32::apimachinery::pkg::api::resource::Quantity {
        self.value.mut_or_insert_default()
    }

    // Take field
    pub fn take_value(&mut self) -> crate::v1_32::apimachinery::pkg::api::resource::Quantity {
        self.value.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::api::resource::Quantity::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::api::resource::Quantity>(
            "value",
            |m: &DeviceCapacity| { &m.value },
            |m: &mut DeviceCapacity| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceCapacity>(
            "DeviceCapacity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceCapacity {
    const NAME: &'static str = "DeviceCapacity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceCapacity {
        DeviceCapacity::new()
    }

    fn clear(&mut self) {
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceCapacity {
        static instance: DeviceCapacity = DeviceCapacity {
            value: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceCapacity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceCapacity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceCapacity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceCapacity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.DeviceClaim)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceClaim {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceClaim.requests)
    pub requests: ::std::vec::Vec<DeviceRequest>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceClaim.constraints)
    pub constraints: ::std::vec::Vec<DeviceConstraint>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceClaim.config)
    pub config: ::std::vec::Vec<DeviceClaimConfiguration>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.DeviceClaim.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceClaim {
    fn default() -> &'a DeviceClaim {
        <DeviceClaim as ::protobuf::Message>::default_instance()
    }
}

impl DeviceClaim {
    pub fn new() -> DeviceClaim {
        ::std::default::Default::default()
    }

    // repeated .api.resource.v1beta1.DeviceRequest requests = 1;

    pub fn requests(&self) -> &[DeviceRequest] {
        &self.requests
    }

    pub fn clear_requests(&mut self) {
        self.requests.clear();
    }

    // Param is passed by value, moved
    pub fn set_requests(&mut self, v: ::std::vec::Vec<DeviceRequest>) {
        self.requests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requests(&mut self) -> &mut ::std::vec::Vec<DeviceRequest> {
        &mut self.requests
    }

    // Take field
    pub fn take_requests(&mut self) -> ::std::vec::Vec<DeviceRequest> {
        ::std::mem::replace(&mut self.requests, ::std::vec::Vec::new())
    }

    // repeated .api.resource.v1beta1.DeviceConstraint constraints = 2;

    pub fn constraints(&self) -> &[DeviceConstraint] {
        &self.constraints
    }

    pub fn clear_constraints(&mut self) {
        self.constraints.clear();
    }

    // Param is passed by value, moved
    pub fn set_constraints(&mut self, v: ::std::vec::Vec<DeviceConstraint>) {
        self.constraints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_constraints(&mut self) -> &mut ::std::vec::Vec<DeviceConstraint> {
        &mut self.constraints
    }

    // Take field
    pub fn take_constraints(&mut self) -> ::std::vec::Vec<DeviceConstraint> {
        ::std::mem::replace(&mut self.constraints, ::std::vec::Vec::new())
    }

    // repeated .api.resource.v1beta1.DeviceClaimConfiguration config = 3;

    pub fn config(&self) -> &[DeviceClaimConfiguration] {
        &self.config
    }

    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: ::std::vec::Vec<DeviceClaimConfiguration>) {
        self.config = v;
    }

    // Mutable pointer to the field.
    pub fn mut_config(&mut self) -> &mut ::std::vec::Vec<DeviceClaimConfiguration> {
        &mut self.config
    }

    // Take field
    pub fn take_config(&mut self) -> ::std::vec::Vec<DeviceClaimConfiguration> {
        ::std::mem::replace(&mut self.config, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "requests",
            |m: &DeviceClaim| { &m.requests },
            |m: &mut DeviceClaim| { &mut m.requests },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "constraints",
            |m: &DeviceClaim| { &m.constraints },
            |m: &mut DeviceClaim| { &mut m.constraints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "config",
            |m: &DeviceClaim| { &m.config },
            |m: &mut DeviceClaim| { &mut m.config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceClaim>(
            "DeviceClaim",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceClaim {
    const NAME: &'static str = "DeviceClaim";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.requests.push(is.read_message()?);
                },
                18 => {
                    self.constraints.push(is.read_message()?);
                },
                26 => {
                    self.config.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.requests {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.constraints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.config {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.requests {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.constraints {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.config {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceClaim {
        DeviceClaim::new()
    }

    fn clear(&mut self) {
        self.requests.clear();
        self.constraints.clear();
        self.config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceClaim {
        static instance: DeviceClaim = DeviceClaim {
            requests: ::std::vec::Vec::new(),
            constraints: ::std::vec::Vec::new(),
            config: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceClaim {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceClaim").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceClaim {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceClaim {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.DeviceClaimConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceClaimConfiguration {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceClaimConfiguration.requests)
    pub requests: ::std::vec::Vec<::std::string::String>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceClaimConfiguration.deviceConfiguration)
    pub deviceConfiguration: ::protobuf::MessageField<DeviceConfiguration>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.DeviceClaimConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceClaimConfiguration {
    fn default() -> &'a DeviceClaimConfiguration {
        <DeviceClaimConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl DeviceClaimConfiguration {
    pub fn new() -> DeviceClaimConfiguration {
        ::std::default::Default::default()
    }

    // repeated string requests = 1;

    pub fn requests(&self) -> &[::std::string::String] {
        &self.requests
    }

    pub fn clear_requests(&mut self) {
        self.requests.clear();
    }

    // Param is passed by value, moved
    pub fn set_requests(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.requests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requests(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.requests
    }

    // Take field
    pub fn take_requests(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.requests, ::std::vec::Vec::new())
    }

    // optional .api.resource.v1beta1.DeviceConfiguration deviceConfiguration = 2;

    pub fn deviceConfiguration(&self) -> &DeviceConfiguration {
        self.deviceConfiguration.as_ref().unwrap_or_else(|| <DeviceConfiguration as ::protobuf::Message>::default_instance())
    }

    pub fn clear_deviceConfiguration(&mut self) {
        self.deviceConfiguration.clear();
    }

    pub fn has_deviceConfiguration(&self) -> bool {
        self.deviceConfiguration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deviceConfiguration(&mut self, v: DeviceConfiguration) {
        self.deviceConfiguration = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deviceConfiguration(&mut self) -> &mut DeviceConfiguration {
        self.deviceConfiguration.mut_or_insert_default()
    }

    // Take field
    pub fn take_deviceConfiguration(&mut self) -> DeviceConfiguration {
        self.deviceConfiguration.take().unwrap_or_else(|| DeviceConfiguration::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "requests",
            |m: &DeviceClaimConfiguration| { &m.requests },
            |m: &mut DeviceClaimConfiguration| { &mut m.requests },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeviceConfiguration>(
            "deviceConfiguration",
            |m: &DeviceClaimConfiguration| { &m.deviceConfiguration },
            |m: &mut DeviceClaimConfiguration| { &mut m.deviceConfiguration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceClaimConfiguration>(
            "DeviceClaimConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceClaimConfiguration {
    const NAME: &'static str = "DeviceClaimConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.requests.push(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.deviceConfiguration)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.requests {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.deviceConfiguration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.requests {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.deviceConfiguration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceClaimConfiguration {
        DeviceClaimConfiguration::new()
    }

    fn clear(&mut self) {
        self.requests.clear();
        self.deviceConfiguration.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceClaimConfiguration {
        static instance: DeviceClaimConfiguration = DeviceClaimConfiguration {
            requests: ::std::vec::Vec::new(),
            deviceConfiguration: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceClaimConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceClaimConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceClaimConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceClaimConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.DeviceClass)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceClass {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceClass.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceClass.spec)
    pub spec: ::protobuf::MessageField<DeviceClassSpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.DeviceClass.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceClass {
    fn default() -> &'a DeviceClass {
        <DeviceClass as ::protobuf::Message>::default_instance()
    }
}

impl DeviceClass {
    pub fn new() -> DeviceClass {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.resource.v1beta1.DeviceClassSpec spec = 2;

    pub fn spec(&self) -> &DeviceClassSpec {
        self.spec.as_ref().unwrap_or_else(|| <DeviceClassSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: DeviceClassSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut DeviceClassSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> DeviceClassSpec {
        self.spec.take().unwrap_or_else(|| DeviceClassSpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &DeviceClass| { &m.metadata },
            |m: &mut DeviceClass| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeviceClassSpec>(
            "spec",
            |m: &DeviceClass| { &m.spec },
            |m: &mut DeviceClass| { &mut m.spec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceClass>(
            "DeviceClass",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceClass {
    const NAME: &'static str = "DeviceClass";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceClass {
        DeviceClass::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceClass {
        static instance: DeviceClass = DeviceClass {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceClass {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceClass").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceClass {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.DeviceClassConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceClassConfiguration {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceClassConfiguration.deviceConfiguration)
    pub deviceConfiguration: ::protobuf::MessageField<DeviceConfiguration>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.DeviceClassConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceClassConfiguration {
    fn default() -> &'a DeviceClassConfiguration {
        <DeviceClassConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl DeviceClassConfiguration {
    pub fn new() -> DeviceClassConfiguration {
        ::std::default::Default::default()
    }

    // optional .api.resource.v1beta1.DeviceConfiguration deviceConfiguration = 1;

    pub fn deviceConfiguration(&self) -> &DeviceConfiguration {
        self.deviceConfiguration.as_ref().unwrap_or_else(|| <DeviceConfiguration as ::protobuf::Message>::default_instance())
    }

    pub fn clear_deviceConfiguration(&mut self) {
        self.deviceConfiguration.clear();
    }

    pub fn has_deviceConfiguration(&self) -> bool {
        self.deviceConfiguration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deviceConfiguration(&mut self, v: DeviceConfiguration) {
        self.deviceConfiguration = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deviceConfiguration(&mut self) -> &mut DeviceConfiguration {
        self.deviceConfiguration.mut_or_insert_default()
    }

    // Take field
    pub fn take_deviceConfiguration(&mut self) -> DeviceConfiguration {
        self.deviceConfiguration.take().unwrap_or_else(|| DeviceConfiguration::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeviceConfiguration>(
            "deviceConfiguration",
            |m: &DeviceClassConfiguration| { &m.deviceConfiguration },
            |m: &mut DeviceClassConfiguration| { &mut m.deviceConfiguration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceClassConfiguration>(
            "DeviceClassConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceClassConfiguration {
    const NAME: &'static str = "DeviceClassConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.deviceConfiguration)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.deviceConfiguration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.deviceConfiguration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceClassConfiguration {
        DeviceClassConfiguration::new()
    }

    fn clear(&mut self) {
        self.deviceConfiguration.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceClassConfiguration {
        static instance: DeviceClassConfiguration = DeviceClassConfiguration {
            deviceConfiguration: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceClassConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceClassConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceClassConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceClassConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.DeviceClassList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceClassList {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceClassList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceClassList.items)
    pub items: ::std::vec::Vec<DeviceClass>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.DeviceClassList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceClassList {
    fn default() -> &'a DeviceClassList {
        <DeviceClassList as ::protobuf::Message>::default_instance()
    }
}

impl DeviceClassList {
    pub fn new() -> DeviceClassList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.resource.v1beta1.DeviceClass items = 2;

    pub fn items(&self) -> &[DeviceClass] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<DeviceClass>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<DeviceClass> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<DeviceClass> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &DeviceClassList| { &m.metadata },
            |m: &mut DeviceClassList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &DeviceClassList| { &m.items },
            |m: &mut DeviceClassList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceClassList>(
            "DeviceClassList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceClassList {
    const NAME: &'static str = "DeviceClassList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceClassList {
        DeviceClassList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceClassList {
        static instance: DeviceClassList = DeviceClassList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceClassList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceClassList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceClassList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceClassList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.DeviceClassSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceClassSpec {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceClassSpec.selectors)
    pub selectors: ::std::vec::Vec<DeviceSelector>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceClassSpec.config)
    pub config: ::std::vec::Vec<DeviceClassConfiguration>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.DeviceClassSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceClassSpec {
    fn default() -> &'a DeviceClassSpec {
        <DeviceClassSpec as ::protobuf::Message>::default_instance()
    }
}

impl DeviceClassSpec {
    pub fn new() -> DeviceClassSpec {
        ::std::default::Default::default()
    }

    // repeated .api.resource.v1beta1.DeviceSelector selectors = 1;

    pub fn selectors(&self) -> &[DeviceSelector] {
        &self.selectors
    }

    pub fn clear_selectors(&mut self) {
        self.selectors.clear();
    }

    // Param is passed by value, moved
    pub fn set_selectors(&mut self, v: ::std::vec::Vec<DeviceSelector>) {
        self.selectors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_selectors(&mut self) -> &mut ::std::vec::Vec<DeviceSelector> {
        &mut self.selectors
    }

    // Take field
    pub fn take_selectors(&mut self) -> ::std::vec::Vec<DeviceSelector> {
        ::std::mem::replace(&mut self.selectors, ::std::vec::Vec::new())
    }

    // repeated .api.resource.v1beta1.DeviceClassConfiguration config = 2;

    pub fn config(&self) -> &[DeviceClassConfiguration] {
        &self.config
    }

    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: ::std::vec::Vec<DeviceClassConfiguration>) {
        self.config = v;
    }

    // Mutable pointer to the field.
    pub fn mut_config(&mut self) -> &mut ::std::vec::Vec<DeviceClassConfiguration> {
        &mut self.config
    }

    // Take field
    pub fn take_config(&mut self) -> ::std::vec::Vec<DeviceClassConfiguration> {
        ::std::mem::replace(&mut self.config, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "selectors",
            |m: &DeviceClassSpec| { &m.selectors },
            |m: &mut DeviceClassSpec| { &mut m.selectors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "config",
            |m: &DeviceClassSpec| { &m.config },
            |m: &mut DeviceClassSpec| { &mut m.config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceClassSpec>(
            "DeviceClassSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceClassSpec {
    const NAME: &'static str = "DeviceClassSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.selectors.push(is.read_message()?);
                },
                18 => {
                    self.config.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.selectors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.config {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.selectors {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.config {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceClassSpec {
        DeviceClassSpec::new()
    }

    fn clear(&mut self) {
        self.selectors.clear();
        self.config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceClassSpec {
        static instance: DeviceClassSpec = DeviceClassSpec {
            selectors: ::std::vec::Vec::new(),
            config: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceClassSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceClassSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceClassSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceClassSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.DeviceConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceConfiguration {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceConfiguration.opaque)
    pub opaque: ::protobuf::MessageField<OpaqueDeviceConfiguration>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.DeviceConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceConfiguration {
    fn default() -> &'a DeviceConfiguration {
        <DeviceConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl DeviceConfiguration {
    pub fn new() -> DeviceConfiguration {
        ::std::default::Default::default()
    }

    // optional .api.resource.v1beta1.OpaqueDeviceConfiguration opaque = 1;

    pub fn opaque(&self) -> &OpaqueDeviceConfiguration {
        self.opaque.as_ref().unwrap_or_else(|| <OpaqueDeviceConfiguration as ::protobuf::Message>::default_instance())
    }

    pub fn clear_opaque(&mut self) {
        self.opaque.clear();
    }

    pub fn has_opaque(&self) -> bool {
        self.opaque.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opaque(&mut self, v: OpaqueDeviceConfiguration) {
        self.opaque = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_opaque(&mut self) -> &mut OpaqueDeviceConfiguration {
        self.opaque.mut_or_insert_default()
    }

    // Take field
    pub fn take_opaque(&mut self) -> OpaqueDeviceConfiguration {
        self.opaque.take().unwrap_or_else(|| OpaqueDeviceConfiguration::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, OpaqueDeviceConfiguration>(
            "opaque",
            |m: &DeviceConfiguration| { &m.opaque },
            |m: &mut DeviceConfiguration| { &mut m.opaque },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceConfiguration>(
            "DeviceConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceConfiguration {
    const NAME: &'static str = "DeviceConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.opaque)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.opaque.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.opaque.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceConfiguration {
        DeviceConfiguration::new()
    }

    fn clear(&mut self) {
        self.opaque.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceConfiguration {
        static instance: DeviceConfiguration = DeviceConfiguration {
            opaque: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.DeviceConstraint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceConstraint {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceConstraint.requests)
    pub requests: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceConstraint.matchAttribute)
    pub matchAttribute: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.DeviceConstraint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceConstraint {
    fn default() -> &'a DeviceConstraint {
        <DeviceConstraint as ::protobuf::Message>::default_instance()
    }
}

impl DeviceConstraint {
    pub fn new() -> DeviceConstraint {
        ::std::default::Default::default()
    }

    // repeated string requests = 1;

    pub fn requests(&self) -> &[::std::string::String] {
        &self.requests
    }

    pub fn clear_requests(&mut self) {
        self.requests.clear();
    }

    // Param is passed by value, moved
    pub fn set_requests(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.requests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requests(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.requests
    }

    // Take field
    pub fn take_requests(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.requests, ::std::vec::Vec::new())
    }

    // optional string matchAttribute = 2;

    pub fn matchAttribute(&self) -> &str {
        match self.matchAttribute.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_matchAttribute(&mut self) {
        self.matchAttribute = ::std::option::Option::None;
    }

    pub fn has_matchAttribute(&self) -> bool {
        self.matchAttribute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchAttribute(&mut self, v: ::std::string::String) {
        self.matchAttribute = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_matchAttribute(&mut self) -> &mut ::std::string::String {
        if self.matchAttribute.is_none() {
            self.matchAttribute = ::std::option::Option::Some(::std::string::String::new());
        }
        self.matchAttribute.as_mut().unwrap()
    }

    // Take field
    pub fn take_matchAttribute(&mut self) -> ::std::string::String {
        self.matchAttribute.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "requests",
            |m: &DeviceConstraint| { &m.requests },
            |m: &mut DeviceConstraint| { &mut m.requests },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchAttribute",
            |m: &DeviceConstraint| { &m.matchAttribute },
            |m: &mut DeviceConstraint| { &mut m.matchAttribute },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceConstraint>(
            "DeviceConstraint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceConstraint {
    const NAME: &'static str = "DeviceConstraint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.requests.push(is.read_string()?);
                },
                18 => {
                    self.matchAttribute = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.requests {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.matchAttribute.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.requests {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.matchAttribute.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceConstraint {
        DeviceConstraint::new()
    }

    fn clear(&mut self) {
        self.requests.clear();
        self.matchAttribute = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceConstraint {
        static instance: DeviceConstraint = DeviceConstraint {
            requests: ::std::vec::Vec::new(),
            matchAttribute: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceConstraint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceConstraint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceConstraint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceConstraint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.DeviceRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceRequest {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceRequest.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceRequest.deviceClassName)
    pub deviceClassName: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceRequest.selectors)
    pub selectors: ::std::vec::Vec<DeviceSelector>,
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceRequest.allocationMode)
    pub allocationMode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceRequest.count)
    pub count: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceRequest.adminAccess)
    pub adminAccess: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.DeviceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceRequest {
    fn default() -> &'a DeviceRequest {
        <DeviceRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeviceRequest {
    pub fn new() -> DeviceRequest {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string deviceClassName = 2;

    pub fn deviceClassName(&self) -> &str {
        match self.deviceClassName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_deviceClassName(&mut self) {
        self.deviceClassName = ::std::option::Option::None;
    }

    pub fn has_deviceClassName(&self) -> bool {
        self.deviceClassName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deviceClassName(&mut self, v: ::std::string::String) {
        self.deviceClassName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deviceClassName(&mut self) -> &mut ::std::string::String {
        if self.deviceClassName.is_none() {
            self.deviceClassName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.deviceClassName.as_mut().unwrap()
    }

    // Take field
    pub fn take_deviceClassName(&mut self) -> ::std::string::String {
        self.deviceClassName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .api.resource.v1beta1.DeviceSelector selectors = 3;

    pub fn selectors(&self) -> &[DeviceSelector] {
        &self.selectors
    }

    pub fn clear_selectors(&mut self) {
        self.selectors.clear();
    }

    // Param is passed by value, moved
    pub fn set_selectors(&mut self, v: ::std::vec::Vec<DeviceSelector>) {
        self.selectors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_selectors(&mut self) -> &mut ::std::vec::Vec<DeviceSelector> {
        &mut self.selectors
    }

    // Take field
    pub fn take_selectors(&mut self) -> ::std::vec::Vec<DeviceSelector> {
        ::std::mem::replace(&mut self.selectors, ::std::vec::Vec::new())
    }

    // optional string allocationMode = 4;

    pub fn allocationMode(&self) -> &str {
        match self.allocationMode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_allocationMode(&mut self) {
        self.allocationMode = ::std::option::Option::None;
    }

    pub fn has_allocationMode(&self) -> bool {
        self.allocationMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allocationMode(&mut self, v: ::std::string::String) {
        self.allocationMode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allocationMode(&mut self) -> &mut ::std::string::String {
        if self.allocationMode.is_none() {
            self.allocationMode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.allocationMode.as_mut().unwrap()
    }

    // Take field
    pub fn take_allocationMode(&mut self) -> ::std::string::String {
        self.allocationMode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 count = 5;

    pub fn count(&self) -> i64 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i64) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional bool adminAccess = 6;

    pub fn adminAccess(&self) -> bool {
        self.adminAccess.unwrap_or(false)
    }

    pub fn clear_adminAccess(&mut self) {
        self.adminAccess = ::std::option::Option::None;
    }

    pub fn has_adminAccess(&self) -> bool {
        self.adminAccess.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adminAccess(&mut self, v: bool) {
        self.adminAccess = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &DeviceRequest| { &m.name },
            |m: &mut DeviceRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deviceClassName",
            |m: &DeviceRequest| { &m.deviceClassName },
            |m: &mut DeviceRequest| { &mut m.deviceClassName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "selectors",
            |m: &DeviceRequest| { &m.selectors },
            |m: &mut DeviceRequest| { &mut m.selectors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allocationMode",
            |m: &DeviceRequest| { &m.allocationMode },
            |m: &mut DeviceRequest| { &mut m.allocationMode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &DeviceRequest| { &m.count },
            |m: &mut DeviceRequest| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "adminAccess",
            |m: &DeviceRequest| { &m.adminAccess },
            |m: &mut DeviceRequest| { &mut m.adminAccess },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceRequest>(
            "DeviceRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceRequest {
    const NAME: &'static str = "DeviceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.deviceClassName = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.selectors.push(is.read_message()?);
                },
                34 => {
                    self.allocationMode = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.count = ::std::option::Option::Some(is.read_int64()?);
                },
                48 => {
                    self.adminAccess = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.deviceClassName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.selectors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.allocationMode.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.adminAccess {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.deviceClassName.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.selectors {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.allocationMode.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.count {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.adminAccess {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceRequest {
        DeviceRequest::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.deviceClassName = ::std::option::Option::None;
        self.selectors.clear();
        self.allocationMode = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.adminAccess = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceRequest {
        static instance: DeviceRequest = DeviceRequest {
            name: ::std::option::Option::None,
            deviceClassName: ::std::option::Option::None,
            selectors: ::std::vec::Vec::new(),
            allocationMode: ::std::option::Option::None,
            count: ::std::option::Option::None,
            adminAccess: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.DeviceRequestAllocationResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceRequestAllocationResult {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceRequestAllocationResult.request)
    pub request: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceRequestAllocationResult.driver)
    pub driver: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceRequestAllocationResult.pool)
    pub pool: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceRequestAllocationResult.device)
    pub device: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceRequestAllocationResult.adminAccess)
    pub adminAccess: ::std::option::Option<bool>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.DeviceRequestAllocationResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceRequestAllocationResult {
    fn default() -> &'a DeviceRequestAllocationResult {
        <DeviceRequestAllocationResult as ::protobuf::Message>::default_instance()
    }
}

impl DeviceRequestAllocationResult {
    pub fn new() -> DeviceRequestAllocationResult {
        ::std::default::Default::default()
    }

    // optional string request = 1;

    pub fn request(&self) -> &str {
        match self.request.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_request(&self) -> bool {
        self.request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request(&mut self, v: ::std::string::String) {
        self.request = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request(&mut self) -> &mut ::std::string::String {
        if self.request.is_none() {
            self.request = ::std::option::Option::Some(::std::string::String::new());
        }
        self.request.as_mut().unwrap()
    }

    // Take field
    pub fn take_request(&mut self) -> ::std::string::String {
        self.request.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string driver = 2;

    pub fn driver(&self) -> &str {
        match self.driver.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_driver(&mut self) {
        self.driver = ::std::option::Option::None;
    }

    pub fn has_driver(&self) -> bool {
        self.driver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driver(&mut self, v: ::std::string::String) {
        self.driver = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver(&mut self) -> &mut ::std::string::String {
        if self.driver.is_none() {
            self.driver = ::std::option::Option::Some(::std::string::String::new());
        }
        self.driver.as_mut().unwrap()
    }

    // Take field
    pub fn take_driver(&mut self) -> ::std::string::String {
        self.driver.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pool = 3;

    pub fn pool(&self) -> &str {
        match self.pool.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pool(&mut self) {
        self.pool = ::std::option::Option::None;
    }

    pub fn has_pool(&self) -> bool {
        self.pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pool(&mut self, v: ::std::string::String) {
        self.pool = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pool(&mut self) -> &mut ::std::string::String {
        if self.pool.is_none() {
            self.pool = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pool.as_mut().unwrap()
    }

    // Take field
    pub fn take_pool(&mut self) -> ::std::string::String {
        self.pool.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string device = 4;

    pub fn device(&self) -> &str {
        match self.device.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device(&mut self) {
        self.device = ::std::option::Option::None;
    }

    pub fn has_device(&self) -> bool {
        self.device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: ::std::string::String) {
        self.device = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut ::std::string::String {
        if self.device.is_none() {
            self.device = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device.as_mut().unwrap()
    }

    // Take field
    pub fn take_device(&mut self) -> ::std::string::String {
        self.device.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool adminAccess = 5;

    pub fn adminAccess(&self) -> bool {
        self.adminAccess.unwrap_or(false)
    }

    pub fn clear_adminAccess(&mut self) {
        self.adminAccess = ::std::option::Option::None;
    }

    pub fn has_adminAccess(&self) -> bool {
        self.adminAccess.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adminAccess(&mut self, v: bool) {
        self.adminAccess = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request",
            |m: &DeviceRequestAllocationResult| { &m.request },
            |m: &mut DeviceRequestAllocationResult| { &mut m.request },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "driver",
            |m: &DeviceRequestAllocationResult| { &m.driver },
            |m: &mut DeviceRequestAllocationResult| { &mut m.driver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pool",
            |m: &DeviceRequestAllocationResult| { &m.pool },
            |m: &mut DeviceRequestAllocationResult| { &mut m.pool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "device",
            |m: &DeviceRequestAllocationResult| { &m.device },
            |m: &mut DeviceRequestAllocationResult| { &mut m.device },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "adminAccess",
            |m: &DeviceRequestAllocationResult| { &m.adminAccess },
            |m: &mut DeviceRequestAllocationResult| { &mut m.adminAccess },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceRequestAllocationResult>(
            "DeviceRequestAllocationResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceRequestAllocationResult {
    const NAME: &'static str = "DeviceRequestAllocationResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.request = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.driver = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.pool = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.device = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.adminAccess = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.driver.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.pool.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.device.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.adminAccess {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.driver.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.pool.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.device.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.adminAccess {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceRequestAllocationResult {
        DeviceRequestAllocationResult::new()
    }

    fn clear(&mut self) {
        self.request = ::std::option::Option::None;
        self.driver = ::std::option::Option::None;
        self.pool = ::std::option::Option::None;
        self.device = ::std::option::Option::None;
        self.adminAccess = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceRequestAllocationResult {
        static instance: DeviceRequestAllocationResult = DeviceRequestAllocationResult {
            request: ::std::option::Option::None,
            driver: ::std::option::Option::None,
            pool: ::std::option::Option::None,
            device: ::std::option::Option::None,
            adminAccess: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceRequestAllocationResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceRequestAllocationResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceRequestAllocationResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceRequestAllocationResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.DeviceSelector)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceSelector {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.DeviceSelector.cel)
    pub cel: ::protobuf::MessageField<CELDeviceSelector>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.DeviceSelector.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceSelector {
    fn default() -> &'a DeviceSelector {
        <DeviceSelector as ::protobuf::Message>::default_instance()
    }
}

impl DeviceSelector {
    pub fn new() -> DeviceSelector {
        ::std::default::Default::default()
    }

    // optional .api.resource.v1beta1.CELDeviceSelector cel = 1;

    pub fn cel(&self) -> &CELDeviceSelector {
        self.cel.as_ref().unwrap_or_else(|| <CELDeviceSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_cel(&mut self) {
        self.cel.clear();
    }

    pub fn has_cel(&self) -> bool {
        self.cel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cel(&mut self, v: CELDeviceSelector) {
        self.cel = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cel(&mut self) -> &mut CELDeviceSelector {
        self.cel.mut_or_insert_default()
    }

    // Take field
    pub fn take_cel(&mut self) -> CELDeviceSelector {
        self.cel.take().unwrap_or_else(|| CELDeviceSelector::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CELDeviceSelector>(
            "cel",
            |m: &DeviceSelector| { &m.cel },
            |m: &mut DeviceSelector| { &mut m.cel },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceSelector>(
            "DeviceSelector",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceSelector {
    const NAME: &'static str = "DeviceSelector";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cel)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cel.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceSelector {
        DeviceSelector::new()
    }

    fn clear(&mut self) {
        self.cel.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceSelector {
        static instance: DeviceSelector = DeviceSelector {
            cel: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceSelector {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceSelector").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceSelector {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.NetworkDeviceData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NetworkDeviceData {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta1.NetworkDeviceData.interfaceName)
    pub interfaceName: ::std::option::Option<::std::string::String>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.NetworkDeviceData.ips)
    pub ips: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta1.NetworkDeviceData.hardwareAddress)
    pub hardwareAddress: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.NetworkDeviceData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NetworkDeviceData {
    fn default() -> &'a NetworkDeviceData {
        <NetworkDeviceData as ::protobuf::Message>::default_instance()
    }
}

impl NetworkDeviceData {
    pub fn new() -> NetworkDeviceData {
        ::std::default::Default::default()
    }

    // optional string interfaceName = 1;

    pub fn interfaceName(&self) -> &str {
        match self.interfaceName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_interfaceName(&mut self) {
        self.interfaceName = ::std::option::Option::None;
    }

    pub fn has_interfaceName(&self) -> bool {
        self.interfaceName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interfaceName(&mut self, v: ::std::string::String) {
        self.interfaceName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interfaceName(&mut self) -> &mut ::std::string::String {
        if self.interfaceName.is_none() {
            self.interfaceName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.interfaceName.as_mut().unwrap()
    }

    // Take field
    pub fn take_interfaceName(&mut self) -> ::std::string::String {
        self.interfaceName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string ips = 2;

    pub fn ips(&self) -> &[::std::string::String] {
        &self.ips
    }

    pub fn clear_ips(&mut self) {
        self.ips.clear();
    }

    // Param is passed by value, moved
    pub fn set_ips(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.ips = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ips(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.ips
    }

    // Take field
    pub fn take_ips(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.ips, ::std::vec::Vec::new())
    }

    // optional string hardwareAddress = 3;

    pub fn hardwareAddress(&self) -> &str {
        match self.hardwareAddress.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hardwareAddress(&mut self) {
        self.hardwareAddress = ::std::option::Option::None;
    }

    pub fn has_hardwareAddress(&self) -> bool {
        self.hardwareAddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hardwareAddress(&mut self, v: ::std::string::String) {
        self.hardwareAddress = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hardwareAddress(&mut self) -> &mut ::std::string::String {
        if self.hardwareAddress.is_none() {
            self.hardwareAddress = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hardwareAddress.as_mut().unwrap()
    }

    // Take field
    pub fn take_hardwareAddress(&mut self) -> ::std::string::String {
        self.hardwareAddress.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "interfaceName",
            |m: &NetworkDeviceData| { &m.interfaceName },
            |m: &mut NetworkDeviceData| { &mut m.interfaceName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ips",
            |m: &NetworkDeviceData| { &m.ips },
            |m: &mut NetworkDeviceData| { &mut m.ips },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hardwareAddress",
            |m: &NetworkDeviceData| { &m.hardwareAddress },
            |m: &mut NetworkDeviceData| { &mut m.hardwareAddress },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NetworkDeviceData>(
            "NetworkDeviceData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NetworkDeviceData {
    const NAME: &'static str = "NetworkDeviceData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.interfaceName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.ips.push(is.read_string()?);
                },
                26 => {
                    self.hardwareAddress = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.interfaceName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.ips {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(v) = self.hardwareAddress.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.interfaceName.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.ips {
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.hardwareAddress.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NetworkDeviceData {
        NetworkDeviceData::new()
    }

    fn clear(&mut self) {
        self.interfaceName = ::std::option::Option::None;
        self.ips.clear();
        self.hardwareAddress = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NetworkDeviceData {
        static instance: NetworkDeviceData = NetworkDeviceData {
            interfaceName: ::std::option::Option::None,
            ips: ::std::vec::Vec::new(),
            hardwareAddress: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NetworkDeviceData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NetworkDeviceData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NetworkDeviceData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkDeviceData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.OpaqueDeviceConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OpaqueDeviceConfiguration {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta1.OpaqueDeviceConfiguration.driver)
    pub driver: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.OpaqueDeviceConfiguration.parameters)
    pub parameters: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::runtime::RawExtension>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.OpaqueDeviceConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OpaqueDeviceConfiguration {
    fn default() -> &'a OpaqueDeviceConfiguration {
        <OpaqueDeviceConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl OpaqueDeviceConfiguration {
    pub fn new() -> OpaqueDeviceConfiguration {
        ::std::default::Default::default()
    }

    // optional string driver = 1;

    pub fn driver(&self) -> &str {
        match self.driver.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_driver(&mut self) {
        self.driver = ::std::option::Option::None;
    }

    pub fn has_driver(&self) -> bool {
        self.driver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driver(&mut self, v: ::std::string::String) {
        self.driver = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver(&mut self) -> &mut ::std::string::String {
        if self.driver.is_none() {
            self.driver = ::std::option::Option::Some(::std::string::String::new());
        }
        self.driver.as_mut().unwrap()
    }

    // Take field
    pub fn take_driver(&mut self) -> ::std::string::String {
        self.driver.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.runtime.RawExtension parameters = 2;

    pub fn parameters(&self) -> &crate::v1_32::apimachinery::pkg::runtime::RawExtension {
        self.parameters.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::runtime::RawExtension as ::protobuf::Message>::default_instance())
    }

    pub fn clear_parameters(&mut self) {
        self.parameters.clear();
    }

    pub fn has_parameters(&self) -> bool {
        self.parameters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameters(&mut self, v: crate::v1_32::apimachinery::pkg::runtime::RawExtension) {
        self.parameters = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parameters(&mut self) -> &mut crate::v1_32::apimachinery::pkg::runtime::RawExtension {
        self.parameters.mut_or_insert_default()
    }

    // Take field
    pub fn take_parameters(&mut self) -> crate::v1_32::apimachinery::pkg::runtime::RawExtension {
        self.parameters.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::runtime::RawExtension::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "driver",
            |m: &OpaqueDeviceConfiguration| { &m.driver },
            |m: &mut OpaqueDeviceConfiguration| { &mut m.driver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::runtime::RawExtension>(
            "parameters",
            |m: &OpaqueDeviceConfiguration| { &m.parameters },
            |m: &mut OpaqueDeviceConfiguration| { &mut m.parameters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OpaqueDeviceConfiguration>(
            "OpaqueDeviceConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OpaqueDeviceConfiguration {
    const NAME: &'static str = "OpaqueDeviceConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.driver = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.parameters)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.driver.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.parameters.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.driver.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.parameters.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OpaqueDeviceConfiguration {
        OpaqueDeviceConfiguration::new()
    }

    fn clear(&mut self) {
        self.driver = ::std::option::Option::None;
        self.parameters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OpaqueDeviceConfiguration {
        static instance: OpaqueDeviceConfiguration = OpaqueDeviceConfiguration {
            driver: ::std::option::Option::None,
            parameters: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OpaqueDeviceConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OpaqueDeviceConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OpaqueDeviceConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpaqueDeviceConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.ResourceClaim)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaim {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceClaim.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceClaim.spec)
    pub spec: ::protobuf::MessageField<ResourceClaimSpec>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceClaim.status)
    pub status: ::protobuf::MessageField<ResourceClaimStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.ResourceClaim.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaim {
    fn default() -> &'a ResourceClaim {
        <ResourceClaim as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaim {
    pub fn new() -> ResourceClaim {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.resource.v1beta1.ResourceClaimSpec spec = 2;

    pub fn spec(&self) -> &ResourceClaimSpec {
        self.spec.as_ref().unwrap_or_else(|| <ResourceClaimSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ResourceClaimSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ResourceClaimSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ResourceClaimSpec {
        self.spec.take().unwrap_or_else(|| ResourceClaimSpec::new())
    }

    // optional .api.resource.v1beta1.ResourceClaimStatus status = 3;

    pub fn status(&self) -> &ResourceClaimStatus {
        self.status.as_ref().unwrap_or_else(|| <ResourceClaimStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ResourceClaimStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ResourceClaimStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> ResourceClaimStatus {
        self.status.take().unwrap_or_else(|| ResourceClaimStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ResourceClaim| { &m.metadata },
            |m: &mut ResourceClaim| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceClaimSpec>(
            "spec",
            |m: &ResourceClaim| { &m.spec },
            |m: &mut ResourceClaim| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceClaimStatus>(
            "status",
            |m: &ResourceClaim| { &m.status },
            |m: &mut ResourceClaim| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaim>(
            "ResourceClaim",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaim {
    const NAME: &'static str = "ResourceClaim";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaim {
        ResourceClaim::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaim {
        static instance: ResourceClaim = ResourceClaim {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaim {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaim").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaim {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaim {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.ResourceClaimConsumerReference)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaimConsumerReference {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceClaimConsumerReference.apiGroup)
    pub apiGroup: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceClaimConsumerReference.resource)
    pub resource: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceClaimConsumerReference.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceClaimConsumerReference.uid)
    pub uid: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.ResourceClaimConsumerReference.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaimConsumerReference {
    fn default() -> &'a ResourceClaimConsumerReference {
        <ResourceClaimConsumerReference as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaimConsumerReference {
    pub fn new() -> ResourceClaimConsumerReference {
        ::std::default::Default::default()
    }

    // optional string apiGroup = 1;

    pub fn apiGroup(&self) -> &str {
        match self.apiGroup.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_apiGroup(&mut self) {
        self.apiGroup = ::std::option::Option::None;
    }

    pub fn has_apiGroup(&self) -> bool {
        self.apiGroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiGroup(&mut self, v: ::std::string::String) {
        self.apiGroup = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiGroup(&mut self) -> &mut ::std::string::String {
        if self.apiGroup.is_none() {
            self.apiGroup = ::std::option::Option::Some(::std::string::String::new());
        }
        self.apiGroup.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiGroup(&mut self) -> ::std::string::String {
        self.apiGroup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resource = 3;

    pub fn resource(&self) -> &str {
        match self.resource.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resource(&mut self) {
        self.resource = ::std::option::Option::None;
    }

    pub fn has_resource(&self) -> bool {
        self.resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: ::std::string::String) {
        self.resource = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut ::std::string::String {
        if self.resource.is_none() {
            self.resource = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resource.as_mut().unwrap()
    }

    // Take field
    pub fn take_resource(&mut self) -> ::std::string::String {
        self.resource.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 4;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string uid = 5;

    pub fn uid(&self) -> &str {
        match self.uid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_uid(&mut self) {
        self.uid = ::std::option::Option::None;
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if self.uid.is_none() {
            self.uid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        self.uid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "apiGroup",
            |m: &ResourceClaimConsumerReference| { &m.apiGroup },
            |m: &mut ResourceClaimConsumerReference| { &mut m.apiGroup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resource",
            |m: &ResourceClaimConsumerReference| { &m.resource },
            |m: &mut ResourceClaimConsumerReference| { &mut m.resource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ResourceClaimConsumerReference| { &m.name },
            |m: &mut ResourceClaimConsumerReference| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uid",
            |m: &ResourceClaimConsumerReference| { &m.uid },
            |m: &mut ResourceClaimConsumerReference| { &mut m.uid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaimConsumerReference>(
            "ResourceClaimConsumerReference",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaimConsumerReference {
    const NAME: &'static str = "ResourceClaimConsumerReference";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.apiGroup = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.resource = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.uid = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.apiGroup.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.resource.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.uid.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.apiGroup.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.resource.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.uid.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaimConsumerReference {
        ResourceClaimConsumerReference::new()
    }

    fn clear(&mut self) {
        self.apiGroup = ::std::option::Option::None;
        self.resource = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.uid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaimConsumerReference {
        static instance: ResourceClaimConsumerReference = ResourceClaimConsumerReference {
            apiGroup: ::std::option::Option::None,
            resource: ::std::option::Option::None,
            name: ::std::option::Option::None,
            uid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaimConsumerReference {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaimConsumerReference").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaimConsumerReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaimConsumerReference {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.ResourceClaimList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaimList {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceClaimList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceClaimList.items)
    pub items: ::std::vec::Vec<ResourceClaim>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.ResourceClaimList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaimList {
    fn default() -> &'a ResourceClaimList {
        <ResourceClaimList as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaimList {
    pub fn new() -> ResourceClaimList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.resource.v1beta1.ResourceClaim items = 2;

    pub fn items(&self) -> &[ResourceClaim] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ResourceClaim>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ResourceClaim> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ResourceClaim> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ResourceClaimList| { &m.metadata },
            |m: &mut ResourceClaimList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ResourceClaimList| { &m.items },
            |m: &mut ResourceClaimList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaimList>(
            "ResourceClaimList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaimList {
    const NAME: &'static str = "ResourceClaimList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaimList {
        ResourceClaimList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaimList {
        static instance: ResourceClaimList = ResourceClaimList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaimList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaimList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaimList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaimList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.ResourceClaimSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaimSpec {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceClaimSpec.devices)
    pub devices: ::protobuf::MessageField<DeviceClaim>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.ResourceClaimSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaimSpec {
    fn default() -> &'a ResourceClaimSpec {
        <ResourceClaimSpec as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaimSpec {
    pub fn new() -> ResourceClaimSpec {
        ::std::default::Default::default()
    }

    // optional .api.resource.v1beta1.DeviceClaim devices = 1;

    pub fn devices(&self) -> &DeviceClaim {
        self.devices.as_ref().unwrap_or_else(|| <DeviceClaim as ::protobuf::Message>::default_instance())
    }

    pub fn clear_devices(&mut self) {
        self.devices.clear();
    }

    pub fn has_devices(&self) -> bool {
        self.devices.is_some()
    }

    // Param is passed by value, moved
    pub fn set_devices(&mut self, v: DeviceClaim) {
        self.devices = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_devices(&mut self) -> &mut DeviceClaim {
        self.devices.mut_or_insert_default()
    }

    // Take field
    pub fn take_devices(&mut self) -> DeviceClaim {
        self.devices.take().unwrap_or_else(|| DeviceClaim::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeviceClaim>(
            "devices",
            |m: &ResourceClaimSpec| { &m.devices },
            |m: &mut ResourceClaimSpec| { &mut m.devices },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaimSpec>(
            "ResourceClaimSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaimSpec {
    const NAME: &'static str = "ResourceClaimSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.devices)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.devices.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.devices.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaimSpec {
        ResourceClaimSpec::new()
    }

    fn clear(&mut self) {
        self.devices.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaimSpec {
        static instance: ResourceClaimSpec = ResourceClaimSpec {
            devices: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaimSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaimSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaimSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaimSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.ResourceClaimStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaimStatus {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceClaimStatus.allocation)
    pub allocation: ::protobuf::MessageField<AllocationResult>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceClaimStatus.reservedFor)
    pub reservedFor: ::std::vec::Vec<ResourceClaimConsumerReference>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceClaimStatus.devices)
    pub devices: ::std::vec::Vec<AllocatedDeviceStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.ResourceClaimStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaimStatus {
    fn default() -> &'a ResourceClaimStatus {
        <ResourceClaimStatus as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaimStatus {
    pub fn new() -> ResourceClaimStatus {
        ::std::default::Default::default()
    }

    // optional .api.resource.v1beta1.AllocationResult allocation = 1;

    pub fn allocation(&self) -> &AllocationResult {
        self.allocation.as_ref().unwrap_or_else(|| <AllocationResult as ::protobuf::Message>::default_instance())
    }

    pub fn clear_allocation(&mut self) {
        self.allocation.clear();
    }

    pub fn has_allocation(&self) -> bool {
        self.allocation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allocation(&mut self, v: AllocationResult) {
        self.allocation = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allocation(&mut self) -> &mut AllocationResult {
        self.allocation.mut_or_insert_default()
    }

    // Take field
    pub fn take_allocation(&mut self) -> AllocationResult {
        self.allocation.take().unwrap_or_else(|| AllocationResult::new())
    }

    // repeated .api.resource.v1beta1.ResourceClaimConsumerReference reservedFor = 2;

    pub fn reservedFor(&self) -> &[ResourceClaimConsumerReference] {
        &self.reservedFor
    }

    pub fn clear_reservedFor(&mut self) {
        self.reservedFor.clear();
    }

    // Param is passed by value, moved
    pub fn set_reservedFor(&mut self, v: ::std::vec::Vec<ResourceClaimConsumerReference>) {
        self.reservedFor = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reservedFor(&mut self) -> &mut ::std::vec::Vec<ResourceClaimConsumerReference> {
        &mut self.reservedFor
    }

    // Take field
    pub fn take_reservedFor(&mut self) -> ::std::vec::Vec<ResourceClaimConsumerReference> {
        ::std::mem::replace(&mut self.reservedFor, ::std::vec::Vec::new())
    }

    // repeated .api.resource.v1beta1.AllocatedDeviceStatus devices = 4;

    pub fn devices(&self) -> &[AllocatedDeviceStatus] {
        &self.devices
    }

    pub fn clear_devices(&mut self) {
        self.devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_devices(&mut self, v: ::std::vec::Vec<AllocatedDeviceStatus>) {
        self.devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_devices(&mut self) -> &mut ::std::vec::Vec<AllocatedDeviceStatus> {
        &mut self.devices
    }

    // Take field
    pub fn take_devices(&mut self) -> ::std::vec::Vec<AllocatedDeviceStatus> {
        ::std::mem::replace(&mut self.devices, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AllocationResult>(
            "allocation",
            |m: &ResourceClaimStatus| { &m.allocation },
            |m: &mut ResourceClaimStatus| { &mut m.allocation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reservedFor",
            |m: &ResourceClaimStatus| { &m.reservedFor },
            |m: &mut ResourceClaimStatus| { &mut m.reservedFor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "devices",
            |m: &ResourceClaimStatus| { &m.devices },
            |m: &mut ResourceClaimStatus| { &mut m.devices },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaimStatus>(
            "ResourceClaimStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaimStatus {
    const NAME: &'static str = "ResourceClaimStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.allocation)?;
                },
                18 => {
                    self.reservedFor.push(is.read_message()?);
                },
                34 => {
                    self.devices.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.allocation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.reservedFor {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.devices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.allocation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.reservedFor {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.devices {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaimStatus {
        ResourceClaimStatus::new()
    }

    fn clear(&mut self) {
        self.allocation.clear();
        self.reservedFor.clear();
        self.devices.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaimStatus {
        static instance: ResourceClaimStatus = ResourceClaimStatus {
            allocation: ::protobuf::MessageField::none(),
            reservedFor: ::std::vec::Vec::new(),
            devices: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaimStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaimStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaimStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaimStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.ResourceClaimTemplate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaimTemplate {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceClaimTemplate.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceClaimTemplate.spec)
    pub spec: ::protobuf::MessageField<ResourceClaimTemplateSpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.ResourceClaimTemplate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaimTemplate {
    fn default() -> &'a ResourceClaimTemplate {
        <ResourceClaimTemplate as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaimTemplate {
    pub fn new() -> ResourceClaimTemplate {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.resource.v1beta1.ResourceClaimTemplateSpec spec = 2;

    pub fn spec(&self) -> &ResourceClaimTemplateSpec {
        self.spec.as_ref().unwrap_or_else(|| <ResourceClaimTemplateSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ResourceClaimTemplateSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ResourceClaimTemplateSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ResourceClaimTemplateSpec {
        self.spec.take().unwrap_or_else(|| ResourceClaimTemplateSpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ResourceClaimTemplate| { &m.metadata },
            |m: &mut ResourceClaimTemplate| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceClaimTemplateSpec>(
            "spec",
            |m: &ResourceClaimTemplate| { &m.spec },
            |m: &mut ResourceClaimTemplate| { &mut m.spec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaimTemplate>(
            "ResourceClaimTemplate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaimTemplate {
    const NAME: &'static str = "ResourceClaimTemplate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaimTemplate {
        ResourceClaimTemplate::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaimTemplate {
        static instance: ResourceClaimTemplate = ResourceClaimTemplate {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaimTemplate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaimTemplate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaimTemplate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaimTemplate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.ResourceClaimTemplateList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaimTemplateList {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceClaimTemplateList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceClaimTemplateList.items)
    pub items: ::std::vec::Vec<ResourceClaimTemplate>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.ResourceClaimTemplateList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaimTemplateList {
    fn default() -> &'a ResourceClaimTemplateList {
        <ResourceClaimTemplateList as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaimTemplateList {
    pub fn new() -> ResourceClaimTemplateList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.resource.v1beta1.ResourceClaimTemplate items = 2;

    pub fn items(&self) -> &[ResourceClaimTemplate] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ResourceClaimTemplate>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ResourceClaimTemplate> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ResourceClaimTemplate> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ResourceClaimTemplateList| { &m.metadata },
            |m: &mut ResourceClaimTemplateList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ResourceClaimTemplateList| { &m.items },
            |m: &mut ResourceClaimTemplateList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaimTemplateList>(
            "ResourceClaimTemplateList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaimTemplateList {
    const NAME: &'static str = "ResourceClaimTemplateList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaimTemplateList {
        ResourceClaimTemplateList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaimTemplateList {
        static instance: ResourceClaimTemplateList = ResourceClaimTemplateList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaimTemplateList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaimTemplateList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaimTemplateList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaimTemplateList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.ResourceClaimTemplateSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceClaimTemplateSpec {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceClaimTemplateSpec.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceClaimTemplateSpec.spec)
    pub spec: ::protobuf::MessageField<ResourceClaimSpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.ResourceClaimTemplateSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceClaimTemplateSpec {
    fn default() -> &'a ResourceClaimTemplateSpec {
        <ResourceClaimTemplateSpec as ::protobuf::Message>::default_instance()
    }
}

impl ResourceClaimTemplateSpec {
    pub fn new() -> ResourceClaimTemplateSpec {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.resource.v1beta1.ResourceClaimSpec spec = 2;

    pub fn spec(&self) -> &ResourceClaimSpec {
        self.spec.as_ref().unwrap_or_else(|| <ResourceClaimSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ResourceClaimSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ResourceClaimSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ResourceClaimSpec {
        self.spec.take().unwrap_or_else(|| ResourceClaimSpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ResourceClaimTemplateSpec| { &m.metadata },
            |m: &mut ResourceClaimTemplateSpec| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceClaimSpec>(
            "spec",
            |m: &ResourceClaimTemplateSpec| { &m.spec },
            |m: &mut ResourceClaimTemplateSpec| { &mut m.spec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceClaimTemplateSpec>(
            "ResourceClaimTemplateSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceClaimTemplateSpec {
    const NAME: &'static str = "ResourceClaimTemplateSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceClaimTemplateSpec {
        ResourceClaimTemplateSpec::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceClaimTemplateSpec {
        static instance: ResourceClaimTemplateSpec = ResourceClaimTemplateSpec {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceClaimTemplateSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceClaimTemplateSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceClaimTemplateSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceClaimTemplateSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.ResourcePool)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourcePool {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourcePool.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourcePool.generation)
    pub generation: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourcePool.resourceSliceCount)
    pub resourceSliceCount: ::std::option::Option<i64>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.ResourcePool.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourcePool {
    fn default() -> &'a ResourcePool {
        <ResourcePool as ::protobuf::Message>::default_instance()
    }
}

impl ResourcePool {
    pub fn new() -> ResourcePool {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 generation = 2;

    pub fn generation(&self) -> i64 {
        self.generation.unwrap_or(0)
    }

    pub fn clear_generation(&mut self) {
        self.generation = ::std::option::Option::None;
    }

    pub fn has_generation(&self) -> bool {
        self.generation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generation(&mut self, v: i64) {
        self.generation = ::std::option::Option::Some(v);
    }

    // optional int64 resourceSliceCount = 3;

    pub fn resourceSliceCount(&self) -> i64 {
        self.resourceSliceCount.unwrap_or(0)
    }

    pub fn clear_resourceSliceCount(&mut self) {
        self.resourceSliceCount = ::std::option::Option::None;
    }

    pub fn has_resourceSliceCount(&self) -> bool {
        self.resourceSliceCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceSliceCount(&mut self, v: i64) {
        self.resourceSliceCount = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ResourcePool| { &m.name },
            |m: &mut ResourcePool| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "generation",
            |m: &ResourcePool| { &m.generation },
            |m: &mut ResourcePool| { &mut m.generation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resourceSliceCount",
            |m: &ResourcePool| { &m.resourceSliceCount },
            |m: &mut ResourcePool| { &mut m.resourceSliceCount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourcePool>(
            "ResourcePool",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourcePool {
    const NAME: &'static str = "ResourcePool";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.generation = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.resourceSliceCount = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.generation {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.resourceSliceCount {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.generation {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.resourceSliceCount {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourcePool {
        ResourcePool::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.generation = ::std::option::Option::None;
        self.resourceSliceCount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourcePool {
        static instance: ResourcePool = ResourcePool {
            name: ::std::option::Option::None,
            generation: ::std::option::Option::None,
            resourceSliceCount: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourcePool {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourcePool").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourcePool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourcePool {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.ResourceSlice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceSlice {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceSlice.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceSlice.spec)
    pub spec: ::protobuf::MessageField<ResourceSliceSpec>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.ResourceSlice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceSlice {
    fn default() -> &'a ResourceSlice {
        <ResourceSlice as ::protobuf::Message>::default_instance()
    }
}

impl ResourceSlice {
    pub fn new() -> ResourceSlice {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.resource.v1beta1.ResourceSliceSpec spec = 2;

    pub fn spec(&self) -> &ResourceSliceSpec {
        self.spec.as_ref().unwrap_or_else(|| <ResourceSliceSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ResourceSliceSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ResourceSliceSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> ResourceSliceSpec {
        self.spec.take().unwrap_or_else(|| ResourceSliceSpec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &ResourceSlice| { &m.metadata },
            |m: &mut ResourceSlice| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceSliceSpec>(
            "spec",
            |m: &ResourceSlice| { &m.spec },
            |m: &mut ResourceSlice| { &mut m.spec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceSlice>(
            "ResourceSlice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceSlice {
    const NAME: &'static str = "ResourceSlice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceSlice {
        ResourceSlice::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceSlice {
        static instance: ResourceSlice = ResourceSlice {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceSlice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceSlice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceSlice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceSlice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.ResourceSliceList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceSliceList {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceSliceList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceSliceList.items)
    pub items: ::std::vec::Vec<ResourceSlice>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.ResourceSliceList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceSliceList {
    fn default() -> &'a ResourceSliceList {
        <ResourceSliceList as ::protobuf::Message>::default_instance()
    }
}

impl ResourceSliceList {
    pub fn new() -> ResourceSliceList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.resource.v1beta1.ResourceSlice items = 2;

    pub fn items(&self) -> &[ResourceSlice] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<ResourceSlice>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<ResourceSlice> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<ResourceSlice> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &ResourceSliceList| { &m.metadata },
            |m: &mut ResourceSliceList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ResourceSliceList| { &m.items },
            |m: &mut ResourceSliceList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceSliceList>(
            "ResourceSliceList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceSliceList {
    const NAME: &'static str = "ResourceSliceList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceSliceList {
        ResourceSliceList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceSliceList {
        static instance: ResourceSliceList = ResourceSliceList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceSliceList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceSliceList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceSliceList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceSliceList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.resource.v1beta1.ResourceSliceSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceSliceSpec {
    // message fields
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceSliceSpec.driver)
    pub driver: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceSliceSpec.pool)
    pub pool: ::protobuf::MessageField<ResourcePool>,
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceSliceSpec.nodeName)
    pub nodeName: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceSliceSpec.nodeSelector)
    pub nodeSelector: ::protobuf::MessageField<crate::v1_32::api::core::v1::NodeSelector>,
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceSliceSpec.allNodes)
    pub allNodes: ::std::option::Option<bool>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.resource.v1beta1.ResourceSliceSpec.devices)
    pub devices: ::std::vec::Vec<Device>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.resource.v1beta1.ResourceSliceSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceSliceSpec {
    fn default() -> &'a ResourceSliceSpec {
        <ResourceSliceSpec as ::protobuf::Message>::default_instance()
    }
}

impl ResourceSliceSpec {
    pub fn new() -> ResourceSliceSpec {
        ::std::default::Default::default()
    }

    // optional string driver = 1;

    pub fn driver(&self) -> &str {
        match self.driver.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_driver(&mut self) {
        self.driver = ::std::option::Option::None;
    }

    pub fn has_driver(&self) -> bool {
        self.driver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driver(&mut self, v: ::std::string::String) {
        self.driver = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver(&mut self) -> &mut ::std::string::String {
        if self.driver.is_none() {
            self.driver = ::std::option::Option::Some(::std::string::String::new());
        }
        self.driver.as_mut().unwrap()
    }

    // Take field
    pub fn take_driver(&mut self) -> ::std::string::String {
        self.driver.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.resource.v1beta1.ResourcePool pool = 2;

    pub fn pool(&self) -> &ResourcePool {
        self.pool.as_ref().unwrap_or_else(|| <ResourcePool as ::protobuf::Message>::default_instance())
    }

    pub fn clear_pool(&mut self) {
        self.pool.clear();
    }

    pub fn has_pool(&self) -> bool {
        self.pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pool(&mut self, v: ResourcePool) {
        self.pool = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pool(&mut self) -> &mut ResourcePool {
        self.pool.mut_or_insert_default()
    }

    // Take field
    pub fn take_pool(&mut self) -> ResourcePool {
        self.pool.take().unwrap_or_else(|| ResourcePool::new())
    }

    // optional string nodeName = 3;

    pub fn nodeName(&self) -> &str {
        match self.nodeName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nodeName(&mut self) {
        self.nodeName = ::std::option::Option::None;
    }

    pub fn has_nodeName(&self) -> bool {
        self.nodeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeName(&mut self, v: ::std::string::String) {
        self.nodeName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeName(&mut self) -> &mut ::std::string::String {
        if self.nodeName.is_none() {
            self.nodeName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.nodeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodeName(&mut self) -> ::std::string::String {
        self.nodeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .api.core.v1.NodeSelector nodeSelector = 4;

    pub fn nodeSelector(&self) -> &crate::v1_32::api::core::v1::NodeSelector {
        self.nodeSelector.as_ref().unwrap_or_else(|| <crate::v1_32::api::core::v1::NodeSelector as ::protobuf::Message>::default_instance())
    }

    pub fn clear_nodeSelector(&mut self) {
        self.nodeSelector.clear();
    }

    pub fn has_nodeSelector(&self) -> bool {
        self.nodeSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeSelector(&mut self, v: crate::v1_32::api::core::v1::NodeSelector) {
        self.nodeSelector = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeSelector(&mut self) -> &mut crate::v1_32::api::core::v1::NodeSelector {
        self.nodeSelector.mut_or_insert_default()
    }

    // Take field
    pub fn take_nodeSelector(&mut self) -> crate::v1_32::api::core::v1::NodeSelector {
        self.nodeSelector.take().unwrap_or_else(|| crate::v1_32::api::core::v1::NodeSelector::new())
    }

    // optional bool allNodes = 5;

    pub fn allNodes(&self) -> bool {
        self.allNodes.unwrap_or(false)
    }

    pub fn clear_allNodes(&mut self) {
        self.allNodes = ::std::option::Option::None;
    }

    pub fn has_allNodes(&self) -> bool {
        self.allNodes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allNodes(&mut self, v: bool) {
        self.allNodes = ::std::option::Option::Some(v);
    }

    // repeated .api.resource.v1beta1.Device devices = 6;

    pub fn devices(&self) -> &[Device] {
        &self.devices
    }

    pub fn clear_devices(&mut self) {
        self.devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_devices(&mut self, v: ::std::vec::Vec<Device>) {
        self.devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_devices(&mut self) -> &mut ::std::vec::Vec<Device> {
        &mut self.devices
    }

    // Take field
    pub fn take_devices(&mut self) -> ::std::vec::Vec<Device> {
        ::std::mem::replace(&mut self.devices, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "driver",
            |m: &ResourceSliceSpec| { &m.driver },
            |m: &mut ResourceSliceSpec| { &mut m.driver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourcePool>(
            "pool",
            |m: &ResourceSliceSpec| { &m.pool },
            |m: &mut ResourceSliceSpec| { &mut m.pool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nodeName",
            |m: &ResourceSliceSpec| { &m.nodeName },
            |m: &mut ResourceSliceSpec| { &mut m.nodeName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::api::core::v1::NodeSelector>(
            "nodeSelector",
            |m: &ResourceSliceSpec| { &m.nodeSelector },
            |m: &mut ResourceSliceSpec| { &mut m.nodeSelector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allNodes",
            |m: &ResourceSliceSpec| { &m.allNodes },
            |m: &mut ResourceSliceSpec| { &mut m.allNodes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "devices",
            |m: &ResourceSliceSpec| { &m.devices },
            |m: &mut ResourceSliceSpec| { &mut m.devices },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceSliceSpec>(
            "ResourceSliceSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceSliceSpec {
    const NAME: &'static str = "ResourceSliceSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.driver = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pool)?;
                },
                26 => {
                    self.nodeName = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.nodeSelector)?;
                },
                40 => {
                    self.allNodes = ::std::option::Option::Some(is.read_bool()?);
                },
                50 => {
                    self.devices.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.driver.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.pool.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.nodeName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.nodeSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.allNodes {
            my_size += 1 + 1;
        }
        for value in &self.devices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.driver.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.pool.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.nodeName.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.nodeSelector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.allNodes {
            os.write_bool(5, v)?;
        }
        for v in &self.devices {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceSliceSpec {
        ResourceSliceSpec::new()
    }

    fn clear(&mut self) {
        self.driver = ::std::option::Option::None;
        self.pool.clear();
        self.nodeName = ::std::option::Option::None;
        self.nodeSelector.clear();
        self.allNodes = ::std::option::Option::None;
        self.devices.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceSliceSpec {
        static instance: ResourceSliceSpec = ResourceSliceSpec {
            driver: ::std::option::Option::None,
            pool: ::protobuf::MessageField::none(),
            nodeName: ::std::option::Option::None,
            nodeSelector: ::protobuf::MessageField::none(),
            allNodes: ::std::option::Option::None,
            devices: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceSliceSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceSliceSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceSliceSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceSliceSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n$api/resource/v1beta1/generated.proto\x12\x14api.resource.v1beta1\x1a\
    \x1bapi/core/v1/generated.proto\x1a-apimachinery/pkg/api/resource/genera\
    ted.proto\x1a-apimachinery/pkg/apis/meta/v1/generated.proto\x1a(apimachi\
    nery/pkg/runtime/generated.proto\x1a/apimachinery/pkg/runtime/schema/gen\
    erated.proto\"\xac\x02\n\x15AllocatedDeviceStatus\x12\x16\n\x06driver\
    \x18\x01\x20\x01(\tR\x06driver\x12\x12\n\x04pool\x18\x02\x20\x01(\tR\x04\
    pool\x12\x16\n\x06device\x18\x03\x20\x01(\tR\x06device\x12H\n\ncondition\
    s\x18\x04\x20\x03(\x0b2(.apimachinery.pkg.apis.meta.v1.ConditionR\ncondi\
    tions\x12:\n\x04data\x18\x05\x20\x01(\x0b2&.apimachinery.pkg.runtime.Raw\
    ExtensionR\x04data\x12I\n\x0bnetworkData\x18\x06\x20\x01(\x0b2'.api.reso\
    urce.v1beta1.NetworkDeviceDataR\x0bnetworkData\"\x99\x01\n\x10Allocation\
    Result\x12F\n\x07devices\x18\x01\x20\x01(\x0b2,.api.resource.v1beta1.Dev\
    iceAllocationResultR\x07devices\x12=\n\x0cnodeSelector\x18\x03\x20\x01(\
    \x0b2\x19.api.core.v1.NodeSelectorR\x0cnodeSelector\"\xf6\x02\n\x0bBasic\
    Device\x12Q\n\nattributes\x18\x01\x20\x03(\x0b21.api.resource.v1beta1.Ba\
    sicDevice.AttributesEntryR\nattributes\x12K\n\x08capacity\x18\x02\x20\
    \x03(\x0b2/.api.resource.v1beta1.BasicDevice.CapacityEntryR\x08capacity\
    \x1ad\n\x0fAttributesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12;\n\x05value\x18\x02\x20\x01(\x0b2%.api.resource.v1beta1.DeviceAttri\
    buteR\x05value:\x028\x01\x1aa\n\rCapacityEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12:\n\x05value\x18\x02\x20\x01(\x0b2$.api.resource.\
    v1beta1.DeviceCapacityR\x05value:\x028\x01\"3\n\x11CELDeviceSelector\x12\
    \x1e\n\nexpression\x18\x01\x20\x01(\tR\nexpression\"U\n\x06Device\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x127\n\x05basic\x18\x02\x20\
    \x01(\x0b2!.api.resource.v1beta1.BasicDeviceR\x05basic\"\xb0\x01\n\x1dDe\
    viceAllocationConfiguration\x12\x16\n\x06source\x18\x01\x20\x01(\tR\x06s\
    ource\x12\x1a\n\x08requests\x18\x02\x20\x03(\tR\x08requests\x12[\n\x13de\
    viceConfiguration\x18\x03\x20\x01(\x0b2).api.resource.v1beta1.DeviceConf\
    igurationR\x13deviceConfiguration\"\xb4\x01\n\x16DeviceAllocationResult\
    \x12M\n\x07results\x18\x01\x20\x03(\x0b23.api.resource.v1beta1.DeviceReq\
    uestAllocationResultR\x07results\x12K\n\x06config\x18\x02\x20\x03(\x0b23\
    .api.resource.v1beta1.DeviceAllocationConfigurationR\x06config\"i\n\x0fD\
    eviceAttribute\x12\x10\n\x03int\x18\x02\x20\x01(\x03R\x03int\x12\x12\n\
    \x04bool\x18\x03\x20\x01(\x08R\x04bool\x12\x16\n\x06string\x18\x04\x20\
    \x01(\tR\x06string\x12\x18\n\x07version\x18\x05\x20\x01(\tR\x07version\"\
    O\n\x0eDeviceCapacity\x12=\n\x05value\x18\x01\x20\x01(\x0b2'.apimachiner\
    y.pkg.api.resource.QuantityR\x05value\"\xe0\x01\n\x0bDeviceClaim\x12?\n\
    \x08requests\x18\x01\x20\x03(\x0b2#.api.resource.v1beta1.DeviceRequestR\
    \x08requests\x12H\n\x0bconstraints\x18\x02\x20\x03(\x0b2&.api.resource.v\
    1beta1.DeviceConstraintR\x0bconstraints\x12F\n\x06config\x18\x03\x20\x03\
    (\x0b2..api.resource.v1beta1.DeviceClaimConfigurationR\x06config\"\x93\
    \x01\n\x18DeviceClaimConfiguration\x12\x1a\n\x08requests\x18\x01\x20\x03\
    (\tR\x08requests\x12[\n\x13deviceConfiguration\x18\x02\x20\x01(\x0b2).ap\
    i.resource.v1beta1.DeviceConfigurationR\x13deviceConfiguration\"\x8f\x01\
    \n\x0bDeviceClass\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2).apimachinery\
    .pkg.apis.meta.v1.ObjectMetaR\x08metadata\x129\n\x04spec\x18\x02\x20\x01\
    (\x0b2%.api.resource.v1beta1.DeviceClassSpecR\x04spec\"w\n\x18DeviceClas\
    sConfiguration\x12[\n\x13deviceConfiguration\x18\x01\x20\x01(\x0b2).api.\
    resource.v1beta1.DeviceConfigurationR\x13deviceConfiguration\"\x8f\x01\n\
    \x0fDeviceClassList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachine\
    ry.pkg.apis.meta.v1.ListMetaR\x08metadata\x127\n\x05items\x18\x02\x20\
    \x03(\x0b2!.api.resource.v1beta1.DeviceClassR\x05items\"\x9d\x01\n\x0fDe\
    viceClassSpec\x12B\n\tselectors\x18\x01\x20\x03(\x0b2$.api.resource.v1be\
    ta1.DeviceSelectorR\tselectors\x12F\n\x06config\x18\x02\x20\x03(\x0b2..a\
    pi.resource.v1beta1.DeviceClassConfigurationR\x06config\"^\n\x13DeviceCo\
    nfiguration\x12G\n\x06opaque\x18\x01\x20\x01(\x0b2/.api.resource.v1beta1\
    .OpaqueDeviceConfigurationR\x06opaque\"V\n\x10DeviceConstraint\x12\x1a\n\
    \x08requests\x18\x01\x20\x03(\tR\x08requests\x12&\n\x0ematchAttribute\
    \x18\x02\x20\x01(\tR\x0ematchAttribute\"\xf1\x01\n\rDeviceRequest\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12(\n\x0fdeviceClassName\x18\
    \x02\x20\x01(\tR\x0fdeviceClassName\x12B\n\tselectors\x18\x03\x20\x03(\
    \x0b2$.api.resource.v1beta1.DeviceSelectorR\tselectors\x12&\n\x0eallocat\
    ionMode\x18\x04\x20\x01(\tR\x0eallocationMode\x12\x14\n\x05count\x18\x05\
    \x20\x01(\x03R\x05count\x12\x20\n\x0badminAccess\x18\x06\x20\x01(\x08R\
    \x0badminAccess\"\x9f\x01\n\x1dDeviceRequestAllocationResult\x12\x18\n\
    \x07request\x18\x01\x20\x01(\tR\x07request\x12\x16\n\x06driver\x18\x02\
    \x20\x01(\tR\x06driver\x12\x12\n\x04pool\x18\x03\x20\x01(\tR\x04pool\x12\
    \x16\n\x06device\x18\x04\x20\x01(\tR\x06device\x12\x20\n\x0badminAccess\
    \x18\x05\x20\x01(\x08R\x0badminAccess\"K\n\x0eDeviceSelector\x129\n\x03c\
    el\x18\x01\x20\x01(\x0b2'.api.resource.v1beta1.CELDeviceSelectorR\x03cel\
    \"u\n\x11NetworkDeviceData\x12$\n\rinterfaceName\x18\x01\x20\x01(\tR\rin\
    terfaceName\x12\x10\n\x03ips\x18\x02\x20\x03(\tR\x03ips\x12(\n\x0fhardwa\
    reAddress\x18\x03\x20\x01(\tR\x0fhardwareAddress\"{\n\x19OpaqueDeviceCon\
    figuration\x12\x16\n\x06driver\x18\x01\x20\x01(\tR\x06driver\x12F\n\npar\
    ameters\x18\x02\x20\x01(\x0b2&.apimachinery.pkg.runtime.RawExtensionR\np\
    arameters\"\xd6\x01\n\rResourceClaim\x12E\n\x08metadata\x18\x01\x20\x01(\
    \x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12;\n\x04s\
    pec\x18\x02\x20\x01(\x0b2'.api.resource.v1beta1.ResourceClaimSpecR\x04sp\
    ec\x12A\n\x06status\x18\x03\x20\x01(\x0b2).api.resource.v1beta1.Resource\
    ClaimStatusR\x06status\"~\n\x1eResourceClaimConsumerReference\x12\x1a\n\
    \x08apiGroup\x18\x01\x20\x01(\tR\x08apiGroup\x12\x1a\n\x08resource\x18\
    \x03\x20\x01(\tR\x08resource\x12\x12\n\x04name\x18\x04\x20\x01(\tR\x04na\
    me\x12\x10\n\x03uid\x18\x05\x20\x01(\tR\x03uid\"\x93\x01\n\x11ResourceCl\
    aimList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2'.apimachinery.pkg.apis.\
    meta.v1.ListMetaR\x08metadata\x129\n\x05items\x18\x02\x20\x03(\x0b2#.api\
    .resource.v1beta1.ResourceClaimR\x05items\"P\n\x11ResourceClaimSpec\x12;\
    \n\x07devices\x18\x01\x20\x01(\x0b2!.api.resource.v1beta1.DeviceClaimR\
    \x07devices\"\xfc\x01\n\x13ResourceClaimStatus\x12F\n\nallocation\x18\
    \x01\x20\x01(\x0b2&.api.resource.v1beta1.AllocationResultR\nallocation\
    \x12V\n\x0breservedFor\x18\x02\x20\x03(\x0b24.api.resource.v1beta1.Resou\
    rceClaimConsumerReferenceR\x0breservedFor\x12E\n\x07devices\x18\x04\x20\
    \x03(\x0b2+.api.resource.v1beta1.AllocatedDeviceStatusR\x07devices\"\xa3\
    \x01\n\x15ResourceClaimTemplate\x12E\n\x08metadata\x18\x01\x20\x01(\x0b2\
    ).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12C\n\x04spec\
    \x18\x02\x20\x01(\x0b2/.api.resource.v1beta1.ResourceClaimTemplateSpecR\
    \x04spec\"\xa3\x01\n\x19ResourceClaimTemplateList\x12C\n\x08metadata\x18\
    \x01\x20\x01(\x0b2'.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\
    \x12A\n\x05items\x18\x02\x20\x03(\x0b2+.api.resource.v1beta1.ResourceCla\
    imTemplateR\x05items\"\x9f\x01\n\x19ResourceClaimTemplateSpec\x12E\n\x08\
    metadata\x18\x01\x20\x01(\x0b2).apimachinery.pkg.apis.meta.v1.ObjectMeta\
    R\x08metadata\x12;\n\x04spec\x18\x02\x20\x01(\x0b2'.api.resource.v1beta1\
    .ResourceClaimSpecR\x04spec\"r\n\x0cResourcePool\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12\x1e\n\ngeneration\x18\x02\x20\x01(\x03R\nge\
    neration\x12.\n\x12resourceSliceCount\x18\x03\x20\x01(\x03R\x12resourceS\
    liceCount\"\x93\x01\n\rResourceSlice\x12E\n\x08metadata\x18\x01\x20\x01(\
    \x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12;\n\x04s\
    pec\x18\x02\x20\x01(\x0b2'.api.resource.v1beta1.ResourceSliceSpecR\x04sp\
    ec\"\x93\x01\n\x11ResourceSliceList\x12C\n\x08metadata\x18\x01\x20\x01(\
    \x0b2'.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x129\n\x05ite\
    ms\x18\x02\x20\x03(\x0b2#.api.resource.v1beta1.ResourceSliceR\x05items\"\
    \x92\x02\n\x11ResourceSliceSpec\x12\x16\n\x06driver\x18\x01\x20\x01(\tR\
    \x06driver\x126\n\x04pool\x18\x02\x20\x01(\x0b2\".api.resource.v1beta1.R\
    esourcePoolR\x04pool\x12\x1a\n\x08nodeName\x18\x03\x20\x01(\tR\x08nodeNa\
    me\x12=\n\x0cnodeSelector\x18\x04\x20\x01(\x0b2\x19.api.core.v1.NodeSele\
    ctorR\x0cnodeSelector\x12\x1a\n\x08allNodes\x18\x05\x20\x01(\x08R\x08all\
    Nodes\x126\n\x07devices\x18\x06\x20\x03(\x0b2\x1c.api.resource.v1beta1.D\
    eviceR\x07devicesB\x1dZ\x1bk8s.io/api/resource/v1beta1\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(5);
            deps.push(super::v1beta1::file_descriptor().clone());
            deps.push(super::v1beta1::file_descriptor().clone());
            deps.push(super::v1beta1::file_descriptor().clone());
            deps.push(super::v1beta1::file_descriptor().clone());
            deps.push(super::v1beta1::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(34);
            messages.push(AllocatedDeviceStatus::generated_message_descriptor_data());
            messages.push(AllocationResult::generated_message_descriptor_data());
            messages.push(BasicDevice::generated_message_descriptor_data());
            messages.push(CELDeviceSelector::generated_message_descriptor_data());
            messages.push(Device::generated_message_descriptor_data());
            messages.push(DeviceAllocationConfiguration::generated_message_descriptor_data());
            messages.push(DeviceAllocationResult::generated_message_descriptor_data());
            messages.push(DeviceAttribute::generated_message_descriptor_data());
            messages.push(DeviceCapacity::generated_message_descriptor_data());
            messages.push(DeviceClaim::generated_message_descriptor_data());
            messages.push(DeviceClaimConfiguration::generated_message_descriptor_data());
            messages.push(DeviceClass::generated_message_descriptor_data());
            messages.push(DeviceClassConfiguration::generated_message_descriptor_data());
            messages.push(DeviceClassList::generated_message_descriptor_data());
            messages.push(DeviceClassSpec::generated_message_descriptor_data());
            messages.push(DeviceConfiguration::generated_message_descriptor_data());
            messages.push(DeviceConstraint::generated_message_descriptor_data());
            messages.push(DeviceRequest::generated_message_descriptor_data());
            messages.push(DeviceRequestAllocationResult::generated_message_descriptor_data());
            messages.push(DeviceSelector::generated_message_descriptor_data());
            messages.push(NetworkDeviceData::generated_message_descriptor_data());
            messages.push(OpaqueDeviceConfiguration::generated_message_descriptor_data());
            messages.push(ResourceClaim::generated_message_descriptor_data());
            messages.push(ResourceClaimConsumerReference::generated_message_descriptor_data());
            messages.push(ResourceClaimList::generated_message_descriptor_data());
            messages.push(ResourceClaimSpec::generated_message_descriptor_data());
            messages.push(ResourceClaimStatus::generated_message_descriptor_data());
            messages.push(ResourceClaimTemplate::generated_message_descriptor_data());
            messages.push(ResourceClaimTemplateList::generated_message_descriptor_data());
            messages.push(ResourceClaimTemplateSpec::generated_message_descriptor_data());
            messages.push(ResourcePool::generated_message_descriptor_data());
            messages.push(ResourceSlice::generated_message_descriptor_data());
            messages.push(ResourceSliceList::generated_message_descriptor_data());
            messages.push(ResourceSliceSpec::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
