// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc 30.2
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `api/storagemigration/v1alpha1/generated.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.storagemigration.v1alpha1.GroupVersionResource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GroupVersionResource {
    // message fields
    // @@protoc_insertion_point(field:api.storagemigration.v1alpha1.GroupVersionResource.group)
    pub group: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.storagemigration.v1alpha1.GroupVersionResource.version)
    pub version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.storagemigration.v1alpha1.GroupVersionResource.resource)
    pub resource: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.storagemigration.v1alpha1.GroupVersionResource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GroupVersionResource {
    fn default() -> &'a GroupVersionResource {
        <GroupVersionResource as ::protobuf::Message>::default_instance()
    }
}

impl GroupVersionResource {
    pub fn new() -> GroupVersionResource {
        ::std::default::Default::default()
    }

    // optional string group = 1;

    pub fn group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_group(&mut self) {
        self.group = ::std::option::Option::None;
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group = ::std::option::Option::Some(::std::string::String::new());
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 2;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resource = 3;

    pub fn resource(&self) -> &str {
        match self.resource.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resource(&mut self) {
        self.resource = ::std::option::Option::None;
    }

    pub fn has_resource(&self) -> bool {
        self.resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: ::std::string::String) {
        self.resource = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut ::std::string::String {
        if self.resource.is_none() {
            self.resource = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resource.as_mut().unwrap()
    }

    // Take field
    pub fn take_resource(&mut self) -> ::std::string::String {
        self.resource.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "group",
            |m: &GroupVersionResource| { &m.group },
            |m: &mut GroupVersionResource| { &mut m.group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &GroupVersionResource| { &m.version },
            |m: &mut GroupVersionResource| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resource",
            |m: &GroupVersionResource| { &m.resource },
            |m: &mut GroupVersionResource| { &mut m.resource },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupVersionResource>(
            "GroupVersionResource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GroupVersionResource {
    const NAME: &'static str = "GroupVersionResource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.group = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.resource = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.resource.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.group.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.resource.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GroupVersionResource {
        GroupVersionResource::new()
    }

    fn clear(&mut self) {
        self.group = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.resource = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GroupVersionResource {
        static instance: GroupVersionResource = GroupVersionResource {
            group: ::std::option::Option::None,
            version: ::std::option::Option::None,
            resource: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GroupVersionResource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GroupVersionResource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GroupVersionResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupVersionResource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.storagemigration.v1alpha1.MigrationCondition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MigrationCondition {
    // message fields
    // @@protoc_insertion_point(field:api.storagemigration.v1alpha1.MigrationCondition.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.storagemigration.v1alpha1.MigrationCondition.status)
    pub status: ::std::option::Option<::std::string::String>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.storagemigration.v1alpha1.MigrationCondition.lastUpdateTime)
    pub lastUpdateTime: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::apis::meta::v1::Time>,
    // @@protoc_insertion_point(field:api.storagemigration.v1alpha1.MigrationCondition.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:api.storagemigration.v1alpha1.MigrationCondition.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.storagemigration.v1alpha1.MigrationCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MigrationCondition {
    fn default() -> &'a MigrationCondition {
        <MigrationCondition as ::protobuf::Message>::default_instance()
    }
}

impl MigrationCondition {
    pub fn new() -> MigrationCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;

    pub fn status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 3;

    pub fn lastUpdateTime(&self) -> &crate::v1_32::apimachinery::pkg::apis::meta::v1::Time {
        self.lastUpdateTime.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::apis::meta::v1::Time as ::protobuf::Message>::default_instance())
    }

    pub fn clear_lastUpdateTime(&mut self) {
        self.lastUpdateTime.clear();
    }

    pub fn has_lastUpdateTime(&self) -> bool {
        self.lastUpdateTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastUpdateTime(&mut self, v: crate::v1_32::apimachinery::pkg::apis::meta::v1::Time) {
        self.lastUpdateTime = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastUpdateTime(&mut self) -> &mut crate::v1_32::apimachinery::pkg::apis::meta::v1::Time {
        self.lastUpdateTime.mut_or_insert_default()
    }

    // Take field
    pub fn take_lastUpdateTime(&mut self) -> crate::v1_32::apimachinery::pkg::apis::meta::v1::Time {
        self.lastUpdateTime.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::apis::meta::v1::Time::new())
    }

    // optional string reason = 4;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 5;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &MigrationCondition| { &m.type_ },
            |m: &mut MigrationCondition| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &MigrationCondition| { &m.status },
            |m: &mut MigrationCondition| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::apis::meta::v1::Time>(
            "lastUpdateTime",
            |m: &MigrationCondition| { &m.lastUpdateTime },
            |m: &mut MigrationCondition| { &mut m.lastUpdateTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &MigrationCondition| { &m.reason },
            |m: &mut MigrationCondition| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &MigrationCondition| { &m.message },
            |m: &mut MigrationCondition| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MigrationCondition>(
            "MigrationCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MigrationCondition {
    const NAME: &'static str = "MigrationCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.status = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lastUpdateTime)?;
                },
                34 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastUpdateTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.status.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lastUpdateTime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MigrationCondition {
        MigrationCondition::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.lastUpdateTime.clear();
        self.reason = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MigrationCondition {
        static instance: MigrationCondition = MigrationCondition {
            type_: ::std::option::Option::None,
            status: ::std::option::Option::None,
            lastUpdateTime: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MigrationCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MigrationCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MigrationCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MigrationCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.storagemigration.v1alpha1.StorageVersionMigration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StorageVersionMigration {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.storagemigration.v1alpha1.StorageVersionMigration.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.storagemigration.v1alpha1.StorageVersionMigration.spec)
    pub spec: ::protobuf::MessageField<StorageVersionMigrationSpec>,
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.storagemigration.v1alpha1.StorageVersionMigration.status)
    pub status: ::protobuf::MessageField<StorageVersionMigrationStatus>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.storagemigration.v1alpha1.StorageVersionMigration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StorageVersionMigration {
    fn default() -> &'a StorageVersionMigration {
        <StorageVersionMigration as ::protobuf::Message>::default_instance()
    }
}

impl StorageVersionMigration {
    pub fn new() -> StorageVersionMigration {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta::new())
    }

    // optional .api.storagemigration.v1alpha1.StorageVersionMigrationSpec spec = 2;

    pub fn spec(&self) -> &StorageVersionMigrationSpec {
        self.spec.as_ref().unwrap_or_else(|| <StorageVersionMigrationSpec as ::protobuf::Message>::default_instance())
    }

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: StorageVersionMigrationSpec) {
        self.spec = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut StorageVersionMigrationSpec {
        self.spec.mut_or_insert_default()
    }

    // Take field
    pub fn take_spec(&mut self) -> StorageVersionMigrationSpec {
        self.spec.take().unwrap_or_else(|| StorageVersionMigrationSpec::new())
    }

    // optional .api.storagemigration.v1alpha1.StorageVersionMigrationStatus status = 3;

    pub fn status(&self) -> &StorageVersionMigrationStatus {
        self.status.as_ref().unwrap_or_else(|| <StorageVersionMigrationStatus as ::protobuf::Message>::default_instance())
    }

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: StorageVersionMigrationStatus) {
        self.status = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut StorageVersionMigrationStatus {
        self.status.mut_or_insert_default()
    }

    // Take field
    pub fn take_status(&mut self) -> StorageVersionMigrationStatus {
        self.status.take().unwrap_or_else(|| StorageVersionMigrationStatus::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::apis::meta::v1::ObjectMeta>(
            "metadata",
            |m: &StorageVersionMigration| { &m.metadata },
            |m: &mut StorageVersionMigration| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StorageVersionMigrationSpec>(
            "spec",
            |m: &StorageVersionMigration| { &m.spec },
            |m: &mut StorageVersionMigration| { &mut m.spec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StorageVersionMigrationStatus>(
            "status",
            |m: &StorageVersionMigration| { &m.status },
            |m: &mut StorageVersionMigration| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StorageVersionMigration>(
            "StorageVersionMigration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StorageVersionMigration {
    const NAME: &'static str = "StorageVersionMigration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spec)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.spec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StorageVersionMigration {
        StorageVersionMigration::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StorageVersionMigration {
        static instance: StorageVersionMigration = StorageVersionMigration {
            metadata: ::protobuf::MessageField::none(),
            spec: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StorageVersionMigration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StorageVersionMigration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StorageVersionMigration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageVersionMigration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.storagemigration.v1alpha1.StorageVersionMigrationList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StorageVersionMigrationList {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.storagemigration.v1alpha1.StorageVersionMigrationList.metadata)
    pub metadata: ::protobuf::MessageField<crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta>,
    #[serde(default)]
    // @@protoc_insertion_point(field:api.storagemigration.v1alpha1.StorageVersionMigrationList.items)
    pub items: ::std::vec::Vec<StorageVersionMigration>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.storagemigration.v1alpha1.StorageVersionMigrationList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StorageVersionMigrationList {
    fn default() -> &'a StorageVersionMigrationList {
        <StorageVersionMigrationList as ::protobuf::Message>::default_instance()
    }
}

impl StorageVersionMigrationList {
    pub fn new() -> StorageVersionMigrationList {
        ::std::default::Default::default()
    }

    // optional .apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn metadata(&self) -> &crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta as ::protobuf::Message>::default_instance())
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta) {
        self.metadata = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.mut_or_insert_default()
    }

    // Take field
    pub fn take_metadata(&mut self) -> crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta {
        self.metadata.take().unwrap_or_else(|| crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta::new())
    }

    // repeated .api.storagemigration.v1alpha1.StorageVersionMigration items = 2;

    pub fn items(&self) -> &[StorageVersionMigration] {
        &self.items
    }

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<StorageVersionMigration>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<StorageVersionMigration> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<StorageVersionMigration> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, crate::v1_32::apimachinery::pkg::apis::meta::v1::ListMeta>(
            "metadata",
            |m: &StorageVersionMigrationList| { &m.metadata },
            |m: &mut StorageVersionMigrationList| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &StorageVersionMigrationList| { &m.items },
            |m: &mut StorageVersionMigrationList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StorageVersionMigrationList>(
            "StorageVersionMigrationList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StorageVersionMigrationList {
    const NAME: &'static str = "StorageVersionMigrationList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StorageVersionMigrationList {
        StorageVersionMigrationList::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StorageVersionMigrationList {
        static instance: StorageVersionMigrationList = StorageVersionMigrationList {
            metadata: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StorageVersionMigrationList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StorageVersionMigrationList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StorageVersionMigrationList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageVersionMigrationList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.storagemigration.v1alpha1.StorageVersionMigrationSpec)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StorageVersionMigrationSpec {
    // message fields
    #[serde(with = "crate::v1_32::MessageFieldDef")]
    #[serde(default)]
    // @@protoc_insertion_point(field:api.storagemigration.v1alpha1.StorageVersionMigrationSpec.resource)
    pub resource: ::protobuf::MessageField<GroupVersionResource>,
    // @@protoc_insertion_point(field:api.storagemigration.v1alpha1.StorageVersionMigrationSpec.continueToken)
    pub continueToken: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.storagemigration.v1alpha1.StorageVersionMigrationSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StorageVersionMigrationSpec {
    fn default() -> &'a StorageVersionMigrationSpec {
        <StorageVersionMigrationSpec as ::protobuf::Message>::default_instance()
    }
}

impl StorageVersionMigrationSpec {
    pub fn new() -> StorageVersionMigrationSpec {
        ::std::default::Default::default()
    }

    // optional .api.storagemigration.v1alpha1.GroupVersionResource resource = 1;

    pub fn resource(&self) -> &GroupVersionResource {
        self.resource.as_ref().unwrap_or_else(|| <GroupVersionResource as ::protobuf::Message>::default_instance())
    }

    pub fn clear_resource(&mut self) {
        self.resource.clear();
    }

    pub fn has_resource(&self) -> bool {
        self.resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: GroupVersionResource) {
        self.resource = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut GroupVersionResource {
        self.resource.mut_or_insert_default()
    }

    // Take field
    pub fn take_resource(&mut self) -> GroupVersionResource {
        self.resource.take().unwrap_or_else(|| GroupVersionResource::new())
    }

    // optional string continueToken = 2;

    pub fn continueToken(&self) -> &str {
        match self.continueToken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_continueToken(&mut self) {
        self.continueToken = ::std::option::Option::None;
    }

    pub fn has_continueToken(&self) -> bool {
        self.continueToken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_continueToken(&mut self, v: ::std::string::String) {
        self.continueToken = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_continueToken(&mut self) -> &mut ::std::string::String {
        if self.continueToken.is_none() {
            self.continueToken = ::std::option::Option::Some(::std::string::String::new());
        }
        self.continueToken.as_mut().unwrap()
    }

    // Take field
    pub fn take_continueToken(&mut self) -> ::std::string::String {
        self.continueToken.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GroupVersionResource>(
            "resource",
            |m: &StorageVersionMigrationSpec| { &m.resource },
            |m: &mut StorageVersionMigrationSpec| { &mut m.resource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "continueToken",
            |m: &StorageVersionMigrationSpec| { &m.continueToken },
            |m: &mut StorageVersionMigrationSpec| { &mut m.continueToken },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StorageVersionMigrationSpec>(
            "StorageVersionMigrationSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StorageVersionMigrationSpec {
    const NAME: &'static str = "StorageVersionMigrationSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resource)?;
                },
                18 => {
                    self.continueToken = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.resource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.continueToken.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.resource.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.continueToken.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StorageVersionMigrationSpec {
        StorageVersionMigrationSpec::new()
    }

    fn clear(&mut self) {
        self.resource.clear();
        self.continueToken = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StorageVersionMigrationSpec {
        static instance: StorageVersionMigrationSpec = StorageVersionMigrationSpec {
            resource: ::protobuf::MessageField::none(),
            continueToken: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StorageVersionMigrationSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StorageVersionMigrationSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StorageVersionMigrationSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageVersionMigrationSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(::serde::Deserialize, ::serde::Serialize)]
#[serde(rename_all = "snake_case")]
// @@protoc_insertion_point(message:api.storagemigration.v1alpha1.StorageVersionMigrationStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StorageVersionMigrationStatus {
    // message fields
    #[serde(default)]
    // @@protoc_insertion_point(field:api.storagemigration.v1alpha1.StorageVersionMigrationStatus.conditions)
    pub conditions: ::std::vec::Vec<MigrationCondition>,
    // @@protoc_insertion_point(field:api.storagemigration.v1alpha1.StorageVersionMigrationStatus.resourceVersion)
    pub resourceVersion: ::std::option::Option<::std::string::String>,
    // special fields
    #[serde(skip)]
    // @@protoc_insertion_point(special_field:api.storagemigration.v1alpha1.StorageVersionMigrationStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StorageVersionMigrationStatus {
    fn default() -> &'a StorageVersionMigrationStatus {
        <StorageVersionMigrationStatus as ::protobuf::Message>::default_instance()
    }
}

impl StorageVersionMigrationStatus {
    pub fn new() -> StorageVersionMigrationStatus {
        ::std::default::Default::default()
    }

    // repeated .api.storagemigration.v1alpha1.MigrationCondition conditions = 1;

    pub fn conditions(&self) -> &[MigrationCondition] {
        &self.conditions
    }

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<MigrationCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<MigrationCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<MigrationCondition> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    // optional string resourceVersion = 2;

    pub fn resourceVersion(&self) -> &str {
        match self.resourceVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resourceVersion(&mut self) {
        self.resourceVersion = ::std::option::Option::None;
    }

    pub fn has_resourceVersion(&self) -> bool {
        self.resourceVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceVersion(&mut self, v: ::std::string::String) {
        self.resourceVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceVersion(&mut self) -> &mut ::std::string::String {
        if self.resourceVersion.is_none() {
            self.resourceVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resourceVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceVersion(&mut self) -> ::std::string::String {
        self.resourceVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &StorageVersionMigrationStatus| { &m.conditions },
            |m: &mut StorageVersionMigrationStatus| { &mut m.conditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resourceVersion",
            |m: &StorageVersionMigrationStatus| { &m.resourceVersion },
            |m: &mut StorageVersionMigrationStatus| { &mut m.resourceVersion },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StorageVersionMigrationStatus>(
            "StorageVersionMigrationStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StorageVersionMigrationStatus {
    const NAME: &'static str = "StorageVersionMigrationStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.conditions.push(is.read_message()?);
                },
                18 => {
                    self.resourceVersion = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.resourceVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.resourceVersion.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StorageVersionMigrationStatus {
        StorageVersionMigrationStatus::new()
    }

    fn clear(&mut self) {
        self.conditions.clear();
        self.resourceVersion = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StorageVersionMigrationStatus {
        static instance: StorageVersionMigrationStatus = StorageVersionMigrationStatus {
            conditions: ::std::vec::Vec::new(),
            resourceVersion: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StorageVersionMigrationStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StorageVersionMigrationStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StorageVersionMigrationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageVersionMigrationStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n-api/storagemigration/v1alpha1/generated.proto\x12\x1dapi.storagemigra\
    tion.v1alpha1\x1a\x1bapi/core/v1/generated.proto\x1a-apimachinery/pkg/ap\
    is/meta/v1/generated.proto\x1a(apimachinery/pkg/runtime/generated.proto\
    \x1a/apimachinery/pkg/runtime/schema/generated.proto\"b\n\x14GroupVersio\
    nResource\x12\x14\n\x05group\x18\x01\x20\x01(\tR\x05group\x12\x18\n\x07v\
    ersion\x18\x02\x20\x01(\tR\x07version\x12\x1a\n\x08resource\x18\x03\x20\
    \x01(\tR\x08resource\"\xbf\x01\n\x12MigrationCondition\x12\x12\n\x04type\
    \x18\x01\x20\x01(\tR\x04type\x12\x16\n\x06status\x18\x02\x20\x01(\tR\x06\
    status\x12K\n\x0elastUpdateTime\x18\x03\x20\x01(\x0b2#.apimachinery.pkg.\
    apis.meta.v1.TimeR\x0elastUpdateTime\x12\x16\n\x06reason\x18\x04\x20\x01\
    (\tR\x06reason\x12\x18\n\x07message\x18\x05\x20\x01(\tR\x07message\"\x86\
    \x02\n\x17StorageVersionMigration\x12E\n\x08metadata\x18\x01\x20\x01(\
    \x0b2).apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12N\n\x04s\
    pec\x18\x02\x20\x01(\x0b2:.api.storagemigration.v1alpha1.StorageVersionM\
    igrationSpecR\x04spec\x12T\n\x06status\x18\x03\x20\x01(\x0b2<.api.storag\
    emigration.v1alpha1.StorageVersionMigrationStatusR\x06status\"\xb0\x01\n\
    \x1bStorageVersionMigrationList\x12C\n\x08metadata\x18\x01\x20\x01(\x0b2\
    '.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12L\n\x05items\
    \x18\x02\x20\x03(\x0b26.api.storagemigration.v1alpha1.StorageVersionMigr\
    ationR\x05items\"\x94\x01\n\x1bStorageVersionMigrationSpec\x12O\n\x08res\
    ource\x18\x01\x20\x01(\x0b23.api.storagemigration.v1alpha1.GroupVersionR\
    esourceR\x08resource\x12$\n\rcontinueToken\x18\x02\x20\x01(\tR\rcontinue\
    Token\"\x9c\x01\n\x1dStorageVersionMigrationStatus\x12Q\n\nconditions\
    \x18\x01\x20\x03(\x0b21.api.storagemigration.v1alpha1.MigrationCondition\
    R\nconditions\x12(\n\x0fresourceVersion\x18\x02\x20\x01(\tR\x0fresourceV\
    ersionB&Z$k8s.io/api/storagemigration/v1alpha1\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(4);
            deps.push(super::v1alpha1::file_descriptor().clone());
            deps.push(super::v1alpha1::file_descriptor().clone());
            deps.push(super::v1alpha1::file_descriptor().clone());
            deps.push(super::v1alpha1::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(6);
            messages.push(GroupVersionResource::generated_message_descriptor_data());
            messages.push(MigrationCondition::generated_message_descriptor_data());
            messages.push(StorageVersionMigration::generated_message_descriptor_data());
            messages.push(StorageVersionMigrationList::generated_message_descriptor_data());
            messages.push(StorageVersionMigrationSpec::generated_message_descriptor_data());
            messages.push(StorageVersionMigrationStatus::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
